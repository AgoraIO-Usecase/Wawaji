
#ifndef DHNETSDK_H
#define DHNETSDK_H


#if (defined(WIN32) || defined(WIN64))
    #include <windows.h>
    #ifdef NETSDK_EXPORTS
        #define CLIENT_NET_API  __declspec(dllexport)
    #else
        #define CLIENT_NET_API  __declspec(dllimport)
    #endif

    #define CALLBACK        __stdcall
    #define CALL_METHOD     __stdcall  //__cdecl

    #define INT64           __int64
    #define TP_U64          unsigned __int64

    #ifndef LLONG
        #ifdef WIN64
            #define LLONG   INT64
        #else 
            #define LLONG   LONG
        #endif
    #endif

    #ifndef LDWORD
        #ifdef WIN64
            #define LDWORD  INT64
        #else 
            #define LDWORD  DWORD
        #endif
    #endif
#else    //non-windows
    #define CLIENT_NET_API  extern "C"
    #define CALL_METHOD 
    #define CALLBACK

    #ifndef INTERNAL_COMPILE
        #define RELEASE_HEADER
    #endif
 
    #ifdef RELEASE_HEADER
        #define WORD        unsigned short
        #define DWORD       unsigned int
        #define LONG        int
        #define LPDWORD     DWORD*

        #ifdef __OBJC__
            #include "objc/objc.h"
        #else
            #define BOOL    int
        #endif

        #ifndef TRUE
        #define TRUE        1
        #endif

        #ifndef FALSE
        #define FALSE       0
        #endif
        #define BYTE        unsigned char
        #define UINT        unsigned int
        #define HDC         void*
        #define HWND        void*
        #define LPVOID      void*

        #ifndef NULL
        #define NULL        0
        #endif

        #define LLONG       long
        #define INT64       long long
        #define TP_U64      unsigned long long
        #define LDWORD      long 

        #ifndef MAX_PATH
        #define MAX_PATH    260
        #endif

        #ifndef DEF_RECT
        typedef struct  tagRECT
        {
            LONG left;
            LONG top;
            LONG right;
            LONG bottom;
        } RECT;
        #define DEF_RECT
        #endif
    #else	//Internal translation
        #include "../Platform/osIndependent.h"
        #define INT64       int64
        #define TP_U64      uint64
    #endif // RELEASE_HEADER
#endif // linux

#ifndef LDWORD
    #if (defined(WIN32) || defined(WIN64))
        #ifdef WIN64
            #define LDWORD  __int64
        #else //WIN32 
            #define LDWORD  DWORD
        #endif
    #else    //linux
        #define LDWORD      long 
    #endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************
 ** Constant Definition
 ***********************************************************************/
#define DH_SERIALNO_LEN             48          // Device SN string length
#define DH_MAX_DISKNUM 				256			// Max HDD number
#define DH_MAX_SDCARDNUM			32			// Max SD card number
#define DH_MAX_BURNING_DEV_NUM		32			// Max buner amount
#define DH_BURNING_DEV_NAMELEN		32			// Burner name max length 
#define DH_MAX_LINK 				6
#define DH_MAX_CHANNUM 				16			// Max channel amount
#define DH_MAX_DECODER_CHANNUM		64			// decoder device max channel number
#define DH_MAX_ALARMIN 				128			// Max alarm input amount 
#define DH_MAX_ALARMOUT 			64			// Max alarm output amount 
#define DH_MAX_RIGHT_NUM			100			// Max user right amount
#define DH_MAX_GROUP_NUM			20			// Max user group amount
#define DH_MAX_USER_NUM				200			// Max user account amount
#define DH_RIGHT_NAME_LENGTH		32			// Right name length
#define DH_USER_NAME_LENGTH			8			// User name length 
#define DH_USER_PSW_LENGTH			8			// User password length 
#define DH_CUSTOM_NAME_LENGTH       32          // Custom name length
#define DH_USER_NAME_LEN_EX			32			// User name length ,for extension
#define DH_USER_PSW_LEN_EX			32			// User password length ,for extension
#define DH_MEMO_LENGTH				32			// Note length 
#define DH_MAX_STRING_LEN			128
#define MAX_STRING_LINE_LEN			6			// Max six rows
#define MAX_PER_STRING_LEN			20			// Line max length 
#define DH_MAX_MAIL_NAME_LEN		64			// The user name length the new mail structure supported
#define DH_MAX_MAIL_PSW_LEN			64			// Password length the new mail structhre supported
#define DH_SPEEDLIMIT_TYPE_LEN      32          // speed limit string max length
#define DH_VEHICLE_TYPE_LEN         32          // vehicle info type max length
#define DH_VEHICLE_INFO_LEN         32          // vehicle info string max length
#define DH_VEHICLE_DRIVERNO_LEN     32          // Driver no string max length=
#define DH_MAX_CROSSING_NUM         128         // Max supported crossing num 
#define DH_MAX_CROSSING_ID          32          // Max crossing ID length 
#define DH_MAX_CARD_INFO_LEN		256			// max card info length
#define DH_MAX_CHANNUM_EX           32          // extended max channel number
#define DH_MAX_SAERCH_IP_NUM        256         // max number of IP for saerch
#define DH_MAX_HARDDISK_TYPE_LEN	32			// hard disk type maximum length
#define DH_MAX_HARDDISK_SERIAL_LEN	32			// hard disk serial maximum length
#define DH_MAX_SIM_LEN				16			// value of SIM maximum length
#define DH_MAX_SIM_NUM				10			// pick up SIM maximum number
#define DH_MAX_VERSION_LEN			32			// version maximum length
#define DH_MAX_MDN_LEN				36			// value of MDN maximum length
#define DH_MAX_NETINTERFACE_NUM     64          // support the card number
#define DH_EVENT_NAME_LEN			128			// length of event name
#define DH_STORAGE_NAME_LEN			128			// length of storage name
#define DH_MAX_CARPORTLIGHT_NUM     4           // carport liht maximum number
#define DH_STATION_NAME_LEN         32          // length of station name
#define	PTZ_PRESET_NAME_LEN         64			// Length of PTZ preset name
#define DH_MAX_GUARD_DETECT_ID_COUNT	  64			   // Max Station Detection ID Number
	
#define DH_MAX_VERSION_STR			64			// Max length of version string

#define DH_MAX_AUDIO_MATRIX_OUTPUT  8           // The Maximum OutPut Channels Of Each Audio Matrix

#define DH_COMMON_STRING_16			16          // Common string length 16
#define DH_COMMON_STRING_32			32          // Common string length 32
#define DH_COMMON_STRING_64			64          // Common string length 64
#define DH_COMMON_STRING_128		128         // Common string length 128
#define DH_COMMON_STRING_256		256         // Common string length 256
#define DH_COMMON_STRING_512		512         // Common string length 512
#define DH_COMMON_STRING_1024		1024        // Common string length 1024

#define DH_MAX_ACCESS_NAME_LEN		64			// Length of access name
#define DH_MAX_EXALARMCHANNEL_NAME_LEN	 128	// length of extension module alarm channel name
#define DH_MAX_ALARM_SUBSYSTEM_NUM  8           // Max Alarm Sub System Number
#define DH_MAX_BELL_NUM             4           // Max Bell Number
#define DH_MAX_KEYBOARD_NUM         256         // Max Keyboard Number
#define MAX_GOURP_NUM               128         // Face library max number
#define DH_MAX_POS_EXCHANGE_INFO    64          // Max NET_POSEXCHANGE_INFO array Number
#define NET_INTERFACE_DEFAULT_TIMEOUT     3000  // Interface default timeout
#define DH_MAX_BUSCARD_NUM          64          // The max of buscard number
#define DH_MAX_POS_MAC_NUM          8           // The max of POS Mac number
#define DH_MAX_MARK_FILE_NAME_LEN	124			// the max of video control markfile

#define NET_MAX_ATTACHMENT_NUM			   8    // the max of car attachment number
#define NET_MAX_ANNUUALINSPECTION_NUM	   8	// the max of car AnnualInspection number
// Remote configuration structure corresponding constant 
#define DH_MAX_MAIL_ADDR_LEN		128			// Mail address max length
#define DH_MAX_MAIL_SUBJECT_LEN		64			// Mail subject max length 
#define DH_MAX_IPADDR_LEN			16			// IP address string length 
#define DH_MAX_IPADDR_LEN_EX		40			// extension Ip address support IPV6
#define DH_MACADDR_LEN				40			// MACE address string length
#define DH_MAX_URL_LEN				128			// URL string length 
#define DH_MAX_DEV_ID_LEN			48			// Device serial number max length 
#define	DH_MAX_HOST_NAMELEN			64			// Host name length 
#define DH_MAX_HOST_PSWLEN			32			// Password length 
#define DH_MAX_NAME_LEN				16			// Universal name string length 
#define DH_MAX_ETHERNET_NUM			2			// Ethernet max amount 
#define DH_MAX_ETHERNET_NUM_EX	    10			// extended ethernet max amout
#define	DH_DEV_SERIALNO_LEN			48			// Serial number string length 
#define DH_DEV_CLASS_LEN            16          // Device type string (such as IPC) length 
#define DH_DEV_TYPE_LEN				32			// Device type string length 
#define DH_N_WEEKS					7			// The days in one week 
#define DH_N_TSECT					6			// Time period amount 
#define DH_N_REC_TSECT				6			// Record period amount 
#define DH_N_COL_TSECT				2			// Color period amount 
#define DH_CHAN_NAME_LEN			32			// Channel name lengh. DVR DSP capacity limit. Max 32 bytes.		
#define DH_N_ENCODE_AUX				3			// Extra stream amount 
#define DH_N_TALK					1			// Max audio talk channel amount 
#define DH_N_COVERS					1			// Privacy mask zone amount 
#define DH_N_CHANNEL				16			// Max channel amount 
#define DH_N_ALARM_TSECT			2			// Alarm prompt period amount 
#define DH_MAX_ALARMOUT_NUM			16			// Alarm output ports max amount 
#define DH_MAX_AUDIO_IN_NUM			16			// Audio input ports max amount 
#define DH_MAX_VIDEO_IN_NUM			16			// Video input ports max amount 
#define DH_MAX_ALARM_IN_NUM			16			// Alarm input ports max amount 
#define DH_MAX_DISK_NUM				16			// HDD max amount. Now the value is 16.
#define DH_MAX_DECODER_NUM			16			// Decoder(485) max amount 
#define DH_MAX_232FUNCS				10			// 232 COM function max amount 
#define DH_MAX_232_NUM				2			// 232 COM port max amount 
#define DH_MAX_232_NUM_EX           16          // extended 232 COM port max amount 
#define DH_MAX_DECPRO_LIST_SIZE		100			// Decoder protocol list max amount 
#define DH_FTP_MAXDIRLEN			240			// FTP file folder max length 
#define DH_MATRIX_MAXOUT			16			// Matrix output ports max amount
#define DH_TOUR_GROUP_NUM			6			// Matrix output ports max amount 
#define DH_MAX_DDNS_NUM				10			// ddns max amount the device supported 
#define DH_MAX_SERVER_TYPE_LEN		32			// ddns type and max string length 
#define DH_MAX_DOMAIN_NAME_LEN		256			// ddns domain name and max string length 
#define DH_MAX_DDNS_ALIAS_LEN		32			// ddns alias and max string length 
#define DH_MAX_DEFAULT_DOMAIN_LEN	60			// ddns default domain, max sring length	
#define DH_MOTION_ROW				32			// Motion detection zone row amount 
#define DH_MOTION_COL				32			// Motion detection zone column amount 
#define DH_STATIC_ROW				32			// Static detection zone row amount 
#define DH_STATIC_COL				32			// Static detection zone column amount 
#define	DH_FTP_USERNAME_LEN			64			// FTP setup:user name max lengh 
#define	DH_FTP_PASSWORD_LEN			64			// FTP setup:password max length 
#define	DH_TIME_SECTION				2			// FTP setup:time periods in each day.
#define DH_FTP_MAX_PATH				240			// FTP setup:file path max length 
#define DH_FTP_MAX_SUB_PATH			128 		// FTP setup:sub path max lenth
#define DH_INTERVIDEO_UCOM_CHANID	32			// Platform embedded setup:U China Net Communication (CNC)channel ID
#define DH_INTERVIDEO_UCOM_DEVID	32			// Platform embedded setup:UCNC device ID
#define DH_INTERVIDEO_UCOM_REGPSW	16			// Platform embedded setup:UCNC registration password 
#define DH_INTERVIDEO_UCOM_USERNAME	32			// Platform embedded setup:UCNC user name 
#define DH_INTERVIDEO_UCOM_USERPSW	32			// Platform embedded setup: UCNC password 
#define DH_INTERVIDEO_NSS_IP		32			// Platform embedded setup:ZTE Netview IP
#define DH_INTERVIDEO_NSS_SERIAL	32			// Serial Platform embedded setup:ZTE Netview  serial
#define DH_INTERVIDEO_NSS_USER		32			// User Platform embedded setup:ZTE Netview user
#define DH_INTERVIDEO_NSS_PWD		50			// Password Platform embedded setup:ZTE Netview password
#define DH_MAX_VIDEO_COVER_NUM		16			// Privacy mask zones max amount 
#define DH_MAX_WATERMAKE_DATA		4096		// Watermark data max length 
#define DH_MAX_WATERMAKE_LETTER		128			// Watermark text max length
#define DH_MAX_WLANDEVICE_NUM		10			// Max searched wireless device amount 
#define DH_MAX_WLANDEVICE_NUM_EX	32			// Max searched wireless device amount
#define DH_MAX_ALARM_NAME			64			// Address length 
#define DH_MAX_REGISTER_SERVER_NUM	10			// Auto registration server amount 
#define DH_SNIFFER_FRAMEID_NUM		6			// 6 FRAME ID options
#define DH_SNIFFER_CONTENT_NUM		4			// 4 sniffer in each FRAME
#define DH_SNIFFER_CONTENT_NUM_EX	8			// 8 sniffer in each FRAME
#define DH_SNIFFER_PROTOCOL_SIZE	20			// protocol length
#define DH_MAX_PROTOCOL_NAME_LENGTH 20
#define DH_SNIFFER_GROUP_NUM		4			// 4 group sniffer setup 
#define MAX_PATH_STOR				240			// Remote folder length 
#define DH_ALARM_OCCUR_TIME_LEN		40			// New alarm upload time length 
#define DH_VIDEO_OSD_NAME_NUM		64			// Overlay name length. Now it supports 32-digit English and 16-digit Chinese.
#define DH_VIDEO_CUSTOM_OSD_NUM		8			// The self-defined amount supported excluding time and channel.
#define DH_CONTROL_AUTO_REGISTER_NUM 100        // Targeted initiatives to support the number of registration servers
#define DH_MMS_RECEIVER_NUM          100        // Support the number of messages the recipient
#define DH_MMS_SMSACTIVATION_NUM     100        // Support the number of SMS sender
#define DH_MMS_DIALINACTIVATION_NUM  100        // Support for dial-up number of the sender
#define DH_MAX_ALARMOUT_NUM_EX		 32			// Alarm output amount max limit
#define DH_MAX_VIDEO_IN_NUM_EX		 32			// Video input amount max limit
#define DH_MAX_ALARM_IN_NUM_EX		 32			// Alarm input amount max limit
#define DH_MAX_IPADDR_OR_DOMAIN_LEN	 64			// IP or domain name length
#define DH_MAX_CALLID				 32         // Call ID
#define DH_MAX_OBJECT_LIST				 16			// the upper limit number of object id that detected by device in intelligent analysis 
#define DH_MAX_RULE_LIST				 16			// the upper limit number of device rule in intelligent analysis 
#define DH_MAX_POLYGON_NUM				 16			// the max number of polygon's culmination
#define DH_MAX_DETECT_LINE_NUM       20          // rule detect line's max point number
#define DH_MAX_DETECT_REGION_NUM     20          // rule detect region's max point number
#define DH_MAX_TRACK_LINE_NUM        20         // object moving track's max point number
#define DH_MAX_CANDIDATE_NUM         50         // max candidate number
#define DH_MAX_PERSON_IMAGE_NUM      48         // max image of ervery person
#define DH_MAX_FENCE_LINE_NUM        2          // max fance line number
#define MAX_SMART_VALUE_NUM          30         // the max number of smart disk information
#define DH_MACHINE_NAME_NUM			 64         // Device name length
#define DH_INTERVIDEO_AMP_DEVICESERIAL    48    // Platform embedded setup, AMP,Device serial num length
#define DH_INTERVIDEO_AMP_DEVICENAME      16    // Platform embedded setup, AMP,Device Name length
#define DH_INTERVIDEO_AMP_USER            32    // Platform embedded setup, AMP,User Name Length
#define DH_INTERVIDEO_AMP_PWD             32    // Platform embedded setup, AMP,password length
#define MAX_SUBMODULE_NUM            32         // Max number of submodule infomation
#define DH_MAX_CARWAY_NUM            8          // traffic snapshot,the max car way number
#define DH_MAX_SNAP_SIGNAL_NUM       3          // one car way max time for snapshot
#define DH_MAX_CARD_NUM              128        // max number of card
#define DH_MAX_CARDINFO_LEN          32         // max lenth of card infomation
#define DH_MAX_CONTROLER_NUM         64         // max supported controller number
#define DH_MAX_LIGHT_NUM             32         // max control light group number
#define DH_MAX_SNMP_COMMON_LEN       64         // max Snmp read or write buffer
#define DH_MAX_DDNS_STATE_LEN        128        // max DDNS state buffer
#define DH_MAX_PHONE_NO_LEN          16         // max phone len
#define DH_MAX_MSGTYPE_LEN           32         // max type len
#define DH_MAX_MSG_LEN               256        // max message len
#define DH_MAX_DRIVINGDIRECTION      256        // max drivingdirection len
#define DH_MAX_GRAB_INTERVAL_NUM     4	        // max snapshot count
#define DH_MAX_FLASH_NUM			 5			// max flash count
#define DH_MAX_LANE_NUM              8          // max number of road in every channel
#define DH_MAX_ISCSI_PATH_NUM		 64			// max ISCSI remote path number
#define DH_MAX_WIRELESS_CHN_NUM		 256		// max wireless channel number
#define DH_PROTOCOL3_BASE			 100		// protocol 3 base value
#define DH_PROTOCOL3_SUPPORT		 11			// prococol 3 support
#define DH_MAX_CHANMASK              64         // max channel mask
#define DH_MAX_STAFF_NUM			 20			// max of compressed video configuration staff number
#define DH_MAX_CALIBRATEBOX_NUM		 10			// max of compressed video configuration calibrate region
#define DH_MAX_EXCLUDEREGION_NUM	 10			// max of compressed video configuration exclude region
#define DH_MAX_POLYLINE_NUM			 20			// number of compressed video configuration poly line
#define	DH_MAX_COLOR_NUM			 16			// color maximum number
#define MAX_OBJFILTER_NUM			 16			// max number of  filter type 
#define DH_MAX_SYNOPSIS_STATE_NAME   64         // string state length of compressed video 
#define DH_MAX_SYNOPSIS_QUERY_FILE_COUNT	10	// the file number limit
#define DH_MAX_SSID_LEN              36         // length of SSID
#define DH_MAX_APPIN_LEN             16         // length of PIN
#define DH_NETINTERFACE_NAME_LEN     260        // length of net port
#define DH_NETINTERFACE_TYPE_LEN     260        // length of net type
#define DH_MAX_CONNECT_STATUS_LEN    260        // length of connect status
#define DH_MAX_MODE_LEN              64         // length of 3G mode support
#define DH_MAX_MODE_NUM              64         // number of 3G mode support
#define DH_MAX_COMPRESSION_TYPES_NUM  16        // max number of video compression types
#define DH_MAX_CAPTURE_SIZE_NUM      64         // number of video resolution 
#define DH_NODE_NAME_LEN			 64			// length of node name
#define MAX_CALIBPOINTS_NUM          256        // max number of point support
#define DH_MAX_ATTR_NUM				 32			// the maximum number display element attributes
#define DH_MAX_CLOUDCONNECT_STATE_LEN 128       // length of cloud connect state
#define DH_MAX_IPADDR_EX_LEN         128        // IP entended maximum length
#define DH_MAX_PLATE_NUMBER_LEN      32         // plate string length    
#define DH_MAX_AUTHORITY_LIST_NUM    16         // max in authority list   
#define DH_MAX_CITY_NAME_LEN         64         // max length of city name
#define DH_MAX_PROVINCE_NAME_LEN     64         // max length of province name
#define DH_MAX_PERSON_ID_LEN         32         // max length of person ID
#define MAX_FACE_AREA_NUM            8          // max number if face area
#define MAX_FACE_DB_NUM              8          // max number of face DB
#define MAX_EVENT_NAME				128			// max event name
#define DH_MAX_ETH_NAME			     64			// max network card name
#define DH_MAX_PERSON_NAME_LEN       64         // max length of person name
#define DH_N_SCHEDULE_TSECT			 8			// element number of schedule	
#define DH_MAX_URL_NUM				 8			// max URL number 
#define DH_MAX_LOWER_MITRIX_NUM		16			// max lower mitrix number
#define DH_MAX_BURN_CHANNEL_NUM		32			// max burn channel number
#define DH_MAX_NET_STRORAGE_BLOCK_NUM	64		// max remote storage block number 
#define DH_MAX_CASE_PERSON_NUM		32			// max number of case person
#define DH_MAX_MULTIPLAYBACK_CHANNEL_NUM 64     // max channel number of multiplayback channel
#define DH_MAX_MULTIPLAYBACK_SPLIT_NUM   32     // max split number of multipalyback channel
#define DH_MAX_AUDIO_ENCODE_TYPE          64               // Max audio encoding type quantity
#define MAX_LOG_PATH_LEN                  260              // Max log path name length
#define MAX_CARD_RECORD_FIELD_NUM         16               // Card No. Max Domain Quantity
#define DH_BATTERY_NUM_MAX			 16			// max battery number	
#define DH_POWER_NUM_MAX			 16			// max power number	
#define DH_MAX_AUDIO_PATH			 260		// max path of audio file
#define DH_MAX_DOORNAME_LEN			 128		// max length of door access name
#define DH_MAX_CARDPWD_LEN			 64			// max length of door access name
#define NET_MAX_FISHEYE_MOUNTMODE_NUM   4       // Max fish eye installation mode number
#define NET_MAX_FISHEYE_CALIBRATEMODE_NUM 16    // Max fish eye correction mode numer
#define NET_MAX_FISHEYE_EPTZCMD_NUM    64       // Max fish eye electronic PTZ operation number  
#define POINT_NUM_IN_PAIR              2        // Point Number in Pair
#define MAX_POINT_PAIR_NUM            128       // Point Max Quantity
#define CHANNEL_NUM_IN_POINT_GROUP    2         // Point Video Channel Number
#define MAX_POINT_GROUP_NUM           32        // Point Group Max Quantity. Each two channel splicing requires one group of point. 
#define MAX_LANE_INFO_NUM             32        // Max lane info number
#define MAX_LANE_DIRECTION_NUM        8         // Lane direction total
#define DH_MAX_MONITORWALL_NUM        32        // TV wall max quantity
#define DH_MAX_OPTIONAL_URL_NUM       8         // Alternate url maxquantity
#define DH_MAX_CAMERA_CHANNEL_NUM         1024             // Max channel amount
#define MAX_FILE_SUMMARY_NUM              32               // Max file summary amount  
#define MAX_AUDIO_ENCODE_NUM              64               // Max audio encode amount

#define MAX_FLASH_LIGHT_NUM               8                // Max flash light amount
#define MAX_STROBOSCOPIC_LIGHT_NUM        8                // Max stroboscopic light amount
#define	MAX_MOSAIC_NUM					  8				   // Max counts of mosaic 
#define MAX_MOSAIC_CHANNEL_NUM			  256			   // Max counts of channels which supported video mosaic

// Search type, corresponding to CLIENT_QueryDevState
#define DH_DEVSTATE_COMM_ALARM            0x0001           // Search general alarm status(including external alarm,video loss, motion detection)
#define DH_DEVSTATE_SHELTER_ALARM         0x0002           // Search camera masking alarm status
#define DH_DEVSTATE_RECORDING             0x0003           // Search record status 
#define DH_DEVSTATE_DISK                  0x0004           // Search HDD information 
#define DH_DEVSTATE_RESOURCE              0x0005           // Search system resources status 
#define DH_DEVSTATE_BITRATE	              0x0006           // Search channel bit stream 
#define DH_DEVSTATE_CONN                  0x0007           // Search device connection status 
#define DH_DEVSTATE_PROTOCAL_VER          0x0008           // Search network protocol version number , pBuf = int*
#define DH_DEVSTATE_TALK_ECTYPE	          0x0009           // Search the audio talk format the device supported. Please refer to structure DHDEV_TALKFORMAT_LIST
#define DH_DEVSTATE_SD_CARD	              0x000A           // Search SD card information(FOR IPC series)
#define DH_DEVSTATE_BURNING_DEV           0x000B           // Search burner information
#define DH_DEVSTATE_BURNING_PROGRESS      0x000C           // Search burning information
#define DH_DEVSTATE_PLATFORM              0x000D           // Search the embedded platform the device supported
#define DH_DEVSTATE_CAMERA                0x000E           // Search camera property information ( for IPC series),pBuf = DHDEV_CAMERA_INFO *,there can be several structure.
#define DH_DEVSTATE_SOFTWARE              0x000F           // Search device software version information
#define DH_DEVSTATE_LANGUAGE              0x0010           // Search the audio type the device supported 
#define DH_DEVSTATE_DSP                   0x0011           // Search DSP capacity description 
#define	DH_DEVSTATE_OEM	                  0x0012           // Search OEM information 
#define	DH_DEVSTATE_NET	                  0x0013           // Search network running status information 
#define DH_DEVSTATE_TYPE                  0x0014           // Search function attributes(for IPC serirs)
#define DH_DEVSTATE_SNAP                  0x0015           // Search snapshot function attribute(For IPC series)
#define DH_DEVSTATE_RECORD_TIME	          0x0016           // Query the first time and the recent video time
#define DH_DEVSTATE_NET_RSSI              0x0017           // Query the wireless network signal strength,Please refer to structure DHDEV_WIRELESS_RSS_INFO
#define DH_DEVSTATE_BURNING_ATTACH        0x0018           // Burning options inquiry
#define DH_DEVSTATE_BACKUP_DEV            0x0019           // Query the list of backup device
#define DH_DEVSTATE_BACKUP_DEV_INFO	      0x001a           // Query the backup device information
#define DH_DEVSTATE_BACKUP_FEEDBACK	      0x001b           // backup rate of progress
#define DH_DEVSTATE_ATM_QUERY_TRADE       0x001c           // Query ATM trade type
#define DH_DEVSTATE_SIP                   0x001d           // Query sip state
#define DH_DEVSTATE_VICHILE_STATE         0x001e           // Query wifi state of mobile DVR
#define DH_DEVSTATE_TEST_EMAIL            0x001f           // Query Email Function
#define DH_DEVSTATE_SMART_HARD_DISK       0x0020           // Query Hard Disk Information
#define DH_DEVSTATE_TEST_SNAPPICTURE      0x0021           // Query Snap Picture Function
#define DH_DEVSTATE_STATIC_ALARM          0x0022           // Query static alarm state
#define DH_DEVSTATE_SUBMODULE_INFO        0x0023           // Query submodule information
#define DH_DEVSTATE_DISKDAMAGE            0x0024           // Query harddisk damage ability     
#define DH_DEVSTATE_IPC                   0x0025           // Query device supported IPC ability,see struct DH_DEV_IPC_INFO 
#define DH_DEVSTATE_ALARM_ARM_DISARM      0x0026           // Query alarm arm disarm state
#define DH_DEVSTATE_ACC_POWEROFF_ALARM    0x0027           // Query ACC power off state(return a DWORD type value, 1 means power off,0 means power on)
#define DH_DEVSTATE_TEST_FTP_SERVER       0x0028           // FTP server connect test
#define DH_DEVSTATE_3GFLOW_EXCEED         0x0029           // Query 3G Flow exceed state info(see struct DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_DEVSTATE_3GFLOW_INFO           0x002a           // Query 3G Flow info(see struct DH_DEV_3GFLOW_INFO)
#define DH_DEVSTATE_VIHICLE_INFO_UPLOAD   0x002b           // Vihicle information uploading
#define DH_DEVSTATE_SPEED_LIMIT           0x002c           // Speed limit alarm
#define DH_DEVSTATE_DSP_EX                0x002d           // Query DSP expended cap(struct DHDEV_DSP_ENCODECAP_EX)
#define DH_DEVSTATE_3GMODULE_INFO         0x002e           // Query 3G module info(struct DH_DEV_3GMODLE_INFO)
#define DH_DEVSTATE_MULTI_DDNS            0x002f           // Query multi DDNS status(struct DH_DEV_MULTI_DDNS_INFO)
#define DH_DEVSTATE_CONFIG_URL            0x0030           // Query Device URL info(struct DH_DEV_URL_INFO)
#define DH_DEVSTATE_HARDKEY               0x0031           // Query Hard key state(struct DHDEV_HARDKEY_STATE)
#define DH_DEVSTATE_ISCSI_PATH            0x0032           // Query ISCSI path(struct DHDEV_ISCSI_PATHLIST)
#define DH_DEVSTATE_DLPREVIEW_SLIPT_CAP   0x0033           // Query local preview split capability(struct DEVICE_LOCALPREVIEW_SLIPT_CAP)
#define DH_DEVSTATE_WIFI_ROUTE_CAP        0x0034           // Query wifi capablity(struct DHDEV_WIFI_ROUTE_CAP)
#define DH_DEVSTATE_ONLINE                0x0035           // Query device online state(return a DWORD value, 1-online, 0-offline)
#define DH_DEVSTATE_PTZ_LOCATION          0x0036           // Query ptz state(struct DH_PTZ_LOCATION_INFO)
#define DH_DEVSTATE_MONITOR_INFO          0x0037           // Query monitor state(state DHDEV_MONITOR_INFO)
#define DH_DEVSTATE_SUBDEVICE             0x0300           // Query subdevcie(fan,cpu...) state(struct CFG_DEVICESTATUS_INFO)
#define DH_DEVSTATE_RAID_INFO             0x0038           // Query RAID state(struct ALARM_RAID_INFO)  
#define DH_DEVSTATE_TEST_DDNSDOMAIN       0x0039           // test DDNS domain enable
#define DH_DEVSTATE_VIRTUALCAMERA         0x003a           // query virtual camera state(struct DHDEV_VIRTUALCAMERA_STATE_INFO)
#define DH_DEVSTATE_TRAFFICWORKSTATE      0x003b           // get device's state of video/coil module(struct DHDEV_TRAFFICWORKSTATE_INFO)
#define DH_DEVSTATE_ALARM_CAMERA_MOVE     0x003c           // get camera move alarm state(struct ALARM_CAMERA_MOVE_INFO)
#define DH_DEVSTATE_ALARM                 0x003e           // get external alarm(struct NET_CLIENT_ALARM_STATE) 
#define DH_DEVSTATE_VIDEOLOST             0x003f           // get video loss alarm(struct NET_CLIENT_VIDEOLOST_STATE) 
#define DH_DEVSTATE_MOTIONDETECT          0x0040           // get motion alarm(struct NET_CLIENT_MOTIONDETECT_STATE)
#define DH_DEVSTATE_DETAILEDMOTION        0x0041           // get detailed motion alarm(struct NET_CLIENT_DETAILEDMOTION_STATE)
#define DH_DEVSTATE_VEHICLE_INFO          0x0042           // get vehicle device state(struct DHDEV_VEHICLE_INFO)
#define DH_DEVSTATE_VIDEOBLIND            0x0043           // get blind alarm(struct NET_CLIENT_VIDEOBLIND_STATE)
#define DH_DEVSTATE_3GSTATE_INFO          0x0044           // Query 3G state(struct DHDEV_VEHICLE_3GMODULE)
#define DH_DEVSTATE_NETINTERFACE          0x0045           // Query net interface(struct DHDEV_NETINTERFACE_INFO)
#define DH_DEVSTATE_PICINPIC_CHN          0x0046           // Query picinpic channel(struct DWORD)
#define DH_DEVSTATE_COMPOSITE_CHN         0x0047           // Query splice screen(struct DH_COMPOSITE_CHANNEL)
#define DH_DEVSTATE_WHOLE_RECORDING	      0x0048           // Query whole recording status(struct BOOL),as long as ther is a channel running,it indicates that the overall state
#define DH_DEVSTATE_WHOLE_ENCODING        0x0049           // Query whole encoding(struct BOOL),as long as ther is a channel running,it indicates that the overall state
#define DH_DEVSTATE_DISK_RECORDE_TIME     0x004a           // Query disk record time(pBuf = DEV_DISK_RECORD_TIME*)
#define DH_DEVSTATE_BURNER_DOOR           0x004b           // whether have pop-up optical dirve(struct NET_DEVSTATE_BURNERDOOR)
#define DH_DEVSTATE_GET_DATA_CHECK        0x004c           // get data validation process(struct NET_DEVSTATE_DATA_CHECK)
#define DH_DEVSTATE_ALARM_IN_CHANNEL      0x004f           // Query alarm input channel information(struct NET_ALARM_IN_CHANNEL)
#define DH_DEVSTATE_ALARM_CHN_COUNT	      0x0050           // Query alarm channel number(struct NET_ALARM_CHANNEL_COUNT)
#define DH_DEVSTATE_PTZ_VIEW_RANGE        0x0051           // Query PTZ view range status(struct DH_OUT_PTZ_VIEW_RANGE_STATUS)
#define DH_DEVSTATE_DEV_CHN_COUNT         0x0052           // Query device channel information(struct NET_DEV_CHN_COUNT_INFO)
#define DH_DEVSTATE_RTSP_URL              0x0053           // Query RTSP URL list supported by device, struct DEV_RTSPURL_LIST
#define DH_DEVSTATE_LIMIT_LOGIN_TIME      0x0054           // Query online overtime of device logging in and return a BTY¡ê¡§UNIT¡êoMIN¡ê? ,0 means no limite and The non-zero positive integer means restrictions on the number of minutes
#define DH_DEVSTATE_GET_COMM_COUNT        0x0055           // get com count (struct NET_GET_COMM_COUNT)
#define DH_DEVSTATE_RECORDING_DETAIL      0x0056           // Query recording status detail information(pBuf = NET_RECORD_STATE_DETAIL*)
#define DH_DEVSTATE_PTZ_PRESET_LIST       0x0057           // get state PTZ preset list (struct NET_PTZ_PRESET_LIST)
#define DH_DEVSTATE_EXTERNAL_DEVICE	      0x0058           // exteral device information (pBuf = NET_EXTERNAL_DEVICE*)
#define DH_DEVSTATE_GET_UPGRADE_STATE     0x0059           // get device upgrade state(struct DHDEV_UPGRADE_STATE_INFO)
#define DH_DEVSTATE_MULTIPLAYBACK_SPLIT_CAP 0x005a         // get mulipalyback split (struct NET_MULTIPLAYBACK_SPLIT_CAP )
#define DH_DEVSTATE_BURN_SESSION_NUM      0x005b           // get burn session number(pBuf = int*)
#define DH_DEVSTATE_PROTECTIVE_CAPSULE    0X005c           // Search protective capsule status(corresponding structure ALARM_PROTECTIVE_CAPSULE_INFO)
#define DH_DEVSTATE_GET_DOORWORK_MODE     0X005d           // get access controlmode( corresponding NET_GET_DOORWORK_MODE)

#define DH_DEVSTATE_POWER_STATE	          0x0152           // Query power state(struct DH_POWER_STATUS)
#define DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE  0x153	       // Query alarm channel state(struct NET_CLIENT_ALARM_CHANNELS_STATE)
#define DH_DEVSTATE_ALARMKEYBOARD_COUNT	  0x0154           // Query alarm keyboard count connected on com(struct NET_ALARMKEYBOARD_COUNT)
#define DH_DEVSTATE_EXALARMCHANNELS       0x0155           // Query mapping relationship of extension alarm module channel (struct NET_EXALARMCHANNELS)
#define DH_DEVSTATE_GET_BYPASS            0x0156           // Query channel bypass state(struct NET_DEVSTATE_GET_BYPASS)
#define DH_DEVSTATE_ACTIVATEDDEFENCEAREA  0x0157           // get active sector information(struct NET_ACTIVATEDDEFENCEAREA)
#define DH_DEVSTATE_DEV_RECORDSET         0x0158           // Query device recording information(struct NET_CTRL_RECORDSET_PARAM)
#define DH_DEVSTATE_DOOR_STATE            0x0159           // Query door access state(struct NET_DOOR_STATUS_INFO)
#define DH_DEVSTATE_ANALOGALARM_CHANNELS  0x1560           // analog alarm input channel mapping (struct NET_ANALOGALARM_CHANNELS)
#define DH_DEVSTATE_GET_SENSORLIST        0x1561           // Get device supported sensor list(corresponding NET_SENSOR_LIST)
#define DH_DEVSTATE_ALARM_CHANNELS        0x1562           // Search switch alarm template channel mapping relation(corresponding structure  NET_ALARM_CHANNELS)
                                                           // If device su not support search extension alarm module channel, may use this function to search extension channel logic channel no. and use as local alarm channel use
#define DH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS	0x1563	// Get current system enabling status( corresponding NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES)
#define DH_DEVSTATE_AIRCONDITION_STATE    0x1564           // Get air conditioning status(corresponding to NET_GET_AIRCONDITION_STATE)
#define DH_DEVSTATE_ALARMSUBSYSTEM_STATE  0x1565           // Get sub system status(corresponding to NET_ALARM_SUBSYSTEM_STATE)
#define DH_DEVSTATE_ALARM_FAULT_STATE     0x1566           // Get failure status(corresponding to NET_ALARM_FAULT_STATE_INFO)
#define DH_DEVSTATE_DEFENCE_STATE         0x1567           // Get zone status(corresponding to NET_DEFENCE_STATE_INFO, and bypass status change event, local alarm event, alarm signal event status description is different, cannot mix, for specific device use only)
#define DH_DEVSTATE_CLUSTER_STATE         0x1568           // Get collection status(corresponding to NET_CLUSTER_STATE_INFO)
#define DH_DEVSTATE_SCADA_POINT_LIST      0x1569           // Get spot chart path info(corresponding to NET_SCADA_POINT_LIST_INFO)
#define DH_DEVSTATE_SCADA_INFO            0x156a           // Get monitor spot info(corresponding to NET_SCADA_INFO)
#define DH_DEVSTATE_SCADA_CAPS            0X156b           // Get SCADA capacityset(corresponding to NET_SCADA_CAPS)
#define DH_DEVSTATE_GET_CODEID_COUNT      0x156c           // Get successful code item number(corresponding  NET_GET_CODEID_COUNT)
#define DH_DEVSTATE_GET_CODEID_LIST       0x156d           // Search code info(corresponding  NET_GET_CODEID_LIST)
#define DH_DEVSTATE_ANALOGALARM_DATA      0x156e           // Search analog channel data(corresponding  NET_GET_ANALOGALARM_DATA)
#define DH_DEVSTATE_VTP_CALLSTATE         0x156f           // Access the call state of the video phone (Corresponding to NET_GET_VTP_CALLSTATE)
#define DH_DEVSTATE_SCADA_INFO_BY_ID      0x1570           // query point info by device id(corresponding to NET_SCADA_INFO_BY_ID)
#define DH_DEVSTATE_SCADA_DEVICE_LIST     0x1571           // query scada device id(corresponding to NET_SCADA_DEVICE_LIST)
#define DH_DEVSTATE_DEV_RECORDSET_EX      0x1572           // Search device record set info (with binary data) (Corresponding to NET_CTRL_RECORDSET_PARAM)
#define DH_DEVSTATE_ACCESS_LOCK_VER       0x1573           // Get door locker software version (Corresponding to NET_ACCESS_LOCK_VER)
#define DH_DEVSTATE_MONITORWALL_TVINFO    0x1574           // get monitorwall TV info(Corresponding to NET_CTRL_MONITORWALL_TVINFO)
#define DH_DEVSTATE_GET_ALL_POS           0x1575           // get all configuration of users's Pos devices (Corresponding to NET_POS_ALL_INFO)
#define DH_DEVSTATE_GET_ROAD_LIST         0x1576           // get city and road code info(Corresponding to NET_ROAD_LIST_INFO)
#define DH_DEVSTATE_GET_HEAT_MAP          0x1577           // get heatmap infomation(Corresponding to NET_QUERY_HEAT_MAP)


//////////////////////////////////////////////////////////////////////////
// To set structure. The macro of dwSize
#define _setdwSize(stu) ((stu).dwSize = sizeof(stu))

//////////////////////////////////////////////////////////////////////////

// three state bool type
typedef enum tagNET_THREE_STATUS_BOOL
{
    BOOL_STATUS_FALSE  = 0 , 
    BOOL_STATUS_TRUE       ,
    BOOL_STATUS_UNKNOWN    ,  //unknown
}NET_THREE_STATUS_BOOL;

//////////////////////////////////////////////////////////////////////////

// Air Conditioning Work Mode
typedef enum __EM_AIRCONDITION_MODE
{
    AIRCONDITION_MODE_UNKNOWN = 0,
    AIRCONDITION_MODE_AUTO,             // Auto
    AIRCONDITION_MODE_HOT,              // Cool
    AIRCONDITION_MODE_COLD,             // Heat
    AIRCONDITION_MODE_WET,              // Arefaction
    AIRCONDITION_MODE_WIND,             // Vent
} EM_AIRCONDITION_MODE;

// Air Conditioning Fan Mode
typedef enum __EM_AIRCONDITION_WINDMODE
{
    AIRCONDITION_WINDMODE_UNKNOWN = 0,
    AIRCONDITION_WINDMODE_STOP,            // Stop
    AIRCONDITION_WINDMODE_AUTO,            // Auto
    AIRCONDITION_WINDMODE_HIGH,            // High Speed
    AIRCONDITION_WINDMODE_MIDDLE,          // Medium Speed
    AIRCONDITION_WINDMODE_LOW,             // Low Speed
} EM_AIRCONDITION_WINDMODE;

// Air Conditioning Working Status Info
typedef struct tagNET_AIRCONDITION_STATE_INFO
{
    DWORD				        dwSize;
    BOOL                        bIsOnline;                      // Online
    BOOL                        bIsON;                          // Enable
    int                         nTemperature;                   // Temperature
    EM_AIRCONDITION_MODE        emAirconditionMode;             // Work Mode
    EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;         // Air Fan Mode
    float                       fActualTemperature;             // Environment Temperature
}NET_AIRCONDITION_STATE_INFO;

// Get Air Working Status(corresponding to DH_DEVSTATE_AIRCONDITION_STATE command)
typedef struct tagNET_GET_AIRCONDITION_STATE
{
    DWORD				dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// Device SN
    NET_AIRCONDITION_STATE_INFO stuAirConditionState;           // Air conditioning working status info
}NET_GET_AIRCONDITION_STATE;

// Switch alarm channel info
typedef struct tagNET_ALARM_CHANNEL_INFO 
{
	DWORD			dwSize;
	int				nSlot;					// Root address, 0 means local channel, 1 means connected to 1st serial extension channel, 2, 3... and so on
	int				nChannel;				// Non local alarm channel on extension module channel no., from 0 
	char			szName[DH_COMMON_STRING_128];	// Channel name
}NET_ALARM_CHANNEL_INFO;

// Local(far or close)switch alarm channel and logic channel no. mapping relation
typedef struct tagNET_ALARM_CHANNELS 
{
	DWORD			dwSize;
	int				nMaxAlarmChannels;		// Max channel
	int				nRetAlarmChannels;		// Retuen channel no.
	NET_ALARM_CHANNEL_INFO*	pstuChannelInfo;// Channel info, user allocate memory
}NET_ALARM_CHANNELS;

// Alarm Sub System Status Type
typedef enum __EM_ALARM_SUBSYSTEM_STATE_TYPE
{
    ALARM_SUBSYSTEM_STATE_UNKNOWN = 0,
	ALARM_SUBSYSTEM_STATE_ACTIVE,               // Activated
	ALARM_SUBSYSTEM_STATE_INACTIVE,             // Not activated
	ALARM_SUBSYSTEM_STATE_UNDISTRIBUTED,        // Not distributed
}EM_ALARM_SUBSYSTEM_STATE_TYPE;

// Alarm Sub System Status, CLIENT_QueryDevStatecorresponding to command DH_DEVSTATE_ALARMSUBSYSTEM_STATE
typedef struct tagNET_ALARM_SUBSYSTEM_STATE
{
    DWORD          dwSize;
	int            nMaxAlarmSubSystem;                                  // Valid Sub System Number
	EM_ALARM_SUBSYSTEM_STATE_TYPE  emState[DH_MAX_ALARM_SUBSYSTEM_NUM]; // Sub System Status Info
}NET_ALARM_SUBSYSTEM_STATE;


// Failure Type
typedef enum __EM_ALARM_FAULT_STATE_TYPE
{
    EM_ALARM_FAULT_STATE_ALL = 0,                       // All Types
    EM_ALARM_FAULT_STATE_CONNECTFAULT,                  // Connection Failure
    EM_ALARM_FAULT_STATE_BELLFAULT,                     // Bell Failure
    EM_ALARM_FAULT_STATE_KBFAULT,                       // Keyboard Failure
    EM_ALARM_FAULT_STATE_KBTAMPER,                      // Keyboard Vandal-proof
    EM_ALARM_FAULT_STATE_SENSORSHORTOUT,                // Sensor Short circuit
    EM_ALARM_FAULT_STATE_SENSORTAMPER,                  // Sensor Vandal-proof
}EM_ALARM_FAULT_STATE_TYPE;

// Alarm Failure Status, Input Parameter
typedef struct tagNET_IN_ALARM_FAULT_STATE
{
    DWORD           dwSize;
    EM_ALARM_FAULT_STATE_TYPE   emType;                 // Type to search
}NET_IN_ALARM_FAULT_STATE;

// Alarm Failure Status, Output Parameter
typedef struct tagNET_OUT_ALARM_FAULT_STATE
{
    DWORD           dwSize;
    int             nConnectFaultState;                 // 0: Unknown, 1: Normal, 2:Failure
    int             nBell;                              // Bell valid number 
    int             anBellState[DH_MAX_BELL_NUM];       // Bell failure status info 0: Unknown, 1: Normal, 2:Failure
    int             nFaultKeyboard;                     // Keyboard failure valid number
    int             anFaultKeyboard[DH_MAX_KEYBOARD_NUM];// Keyboard failure info 0: Unknown, 1: Normal, 2:Failure
    int             nTamperKeyboard;                    // Keyboard valid vandal-proof number 
    int             anTamperKeyboard[DH_MAX_KEYBOARD_NUM];// Keyboard vandal-proof info 0: Unknown, 1: Normal, 2:Failure
    int             nShortOutSensor;                    // Sensor valid short circuit number
    int             anShortOutSensor[DH_MAX_ALARMIN];   // Sensor short circuit info 0: Unknown, 1: Normal, 2:Failure
    int             nTamperSensor;                      // Sensor valid vandal-proof number
    int             anTamperSensor[DH_MAX_ALARMIN];     // Sensor vandal-proof info 0: Unknown, 1: Normal, 2:Failure
}NET_OUT_ALARM_FAULT_STATE;

// Alarm failure status, CLIENT_QueryDevStatecorresponding to command DH_DEVSTATE_ALARM_FAULT_STATE
typedef struct tagNET_ALARM_FAULT_STATE_INFO
{
    DWORD           dwSize;
    NET_IN_ALARM_FAULT_STATE    stuIn;                  // Input parameter
    NET_OUT_ALARM_FAULT_STATE   stuOut;                 // Output parameter
}NET_ALARM_FAULT_STATE_INFO;

// Zone Status Type
typedef enum __EM_DEFENCE_STATE_TYPE
{
    EM_DEFENCE_STATE_UNKNOWN = 0,
    EM_DEFENCE_STATE_BYPASS,                                // Bypass
    EM_DEFENCE_STATE_OPEN,                                  // Open, for alarm under disarming
    EM_DEFENCE_STATE_CLOSE,                                 // Close
    EM_DEFENCE_STATE_ALARMING,                              // Alarm, for alarm under arming
}EM_DEFENCE_STATE_TYPE;

// Zone Status Info Input Parameter
typedef struct tagNET_IN_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;
    int             nDefenceNum;                            // Zone valid number, -1means search all zones
    int             anDefence[DH_MAX_ALARMIN];              // Zone number to search
}NET_IN_DEFENCE_STATE_INFO;

// Zone Status Info Output Parameter
typedef struct tagNET_OUT_DEFENCE_STATE_INFO
{
    DWORD           dwSize;
    int             nDefenceNum;                            // Zone valid number    
	EM_DEFENCE_STATE_TYPE  anDefenceState[DH_MAX_ALARMIN];  // Zone status info
}NET_OUT_DEFENCE_STATE_INFO;

// Zpne status info, CLIENT_QueryDevStatecorresponding to command DH_DEVSTATE_DEFENCE_STATE
typedef struct tagNET_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;
    NET_IN_DEFENCE_STATE_INFO   stuIn;                      // Input parameter
    NET_OUT_DEFENCE_STATE_INFO  stuOut;                     // Output parameter
}NET_DEFENCE_STATE_INFO;

// Type of video phone call
typedef enum tagEM_NET_VTP_CALL_TYPE
{
    EM_NET_VTP_CALL_TYPE_SIP = 0,                           // SIP calling
    EM_NET_VTP_CALL_TYPE_GSM,                               // GSM calling
    EM_NET_VTP_CALL_TYPE_PRIVATE,                           // private protocol calling
}EM_NET_VTP_CALL_TYPE;

// Type of video phone call
typedef enum tagEM_NET_VTP_CALL_STATE_TYPE
{
    EM_NET_VTP_CALL_STATE_UNKNOWN = 0,
    EM_NET_VTP_CALL_STATE_IDLE,                                 // Initial State
    EM_NET_VTP_CALL_STATE_CALLING,                              // State of calling(the opposite side not response)
    EM_NET_VTP_CALL_STATE_CALLED,                               // State of called
    EM_NET_VTP_CALL_STATE_RINGING,                              // State of calling back (the opposite side responsed but no answer)
    EM_NET_VTP_CALL_STATE_CONNECTING,                           // State of answering 
    EM_NET_VTP_CALL_STATE_CONNECTING2,                          // 2 states in the call (¨ª¡§?¡ã??¨¬?¡À??¨¹o¨®¦Ì?¨ª¡§?¡ã?D¡Á¡ä¨¬?)
    EM_NET_VTP_CALL_STATE_DISCONNECT,                           // State of call off
}EM_NET_VTP_CALL_STATE_TYPE;

// Obtain the calling state of video phone (Corresponding to DH_DEVSTATE_VTP_CALLSTATE)
typedef struct tagNET_GET_VTP_CALLSTATE 
{
    DWORD                       dwSize;
    EM_NET_VTP_CALL_TYPE        emCallType;                     // the call type to be queried, input parameter
    char                        szCallID[DH_COMMON_STRING_128]; // the unique identification to be queried, input parameter
    const char*                 szTargetID;                     // the device to be transmit,  ID= NULL equals to no transmitting,  input parameter
    EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // State of calling
}NET_GET_VTP_CALLSTATE;

// Configuration type,corresponding to CLIENT_QueryRemotDevState
#define DH_DEVSTATE_ALARM_REMOTE   0x1000        // get the remote device external alarm(struct ALARM_REMOTE_ALARM_INFO)
#define DH_DEVSTATE_ALARM_FRONTDISCONNECT 0x1001 // get the front IPC disconnect alarm (struct ALARM_FRONTDISCONNET_INFO)

// Configuration type,corresponding to CLIENT_GetDevConfig and CLIENT_SetDevConfig
#define DH_DEV_DEVICECFG			0x0001		// Device property setup 
#define DH_DEV_NETCFG				0x0002		// Network setup 
#define DH_DEV_CHANNELCFG			0x0003		// Video channel setup
#define DH_DEV_PREVIEWCFG 			0x0004		// Preview parameter setup
#define DH_DEV_RECORDCFG			0x0005		// Record setup
#define DH_DEV_COMMCFG				0x0006		// COM property setup 
#define DH_DEV_ALARMCFG 			0x0007		// Alarm property setup
#define DH_DEV_TIMECFG 				0x0008		// DVR time setup 
#define DH_DEV_TALKCFG				0x0009		// Audio talk parameter setup 
#define DH_DEV_AUTOMTCFG			0x000A		// Auto matrix setup
#define	DH_DEV_VEDIO_MARTIX			0x000B		// Local matrix control strategy setup
#define DH_DEV_MULTI_DDNS			0x000C		//  Multiple ddns setup 
#define DH_DEV_SNAP_CFG				0x000D		// Snapshot corresponding setup 
#define DH_DEV_WEB_URL_CFG			0x000E		// HTTP path setup 
#define DH_DEV_FTP_PROTO_CFG		0x000F		// FTP upload setup 
#define DH_DEV_INTERVIDEO_CFG		0x0010		// Plaform embedded setup. Now the channel parameter represents the platform type. 
												// channel=4:Bell alcatel;channel=10:ZTE Netview;channel=11:U CNC  channel = 51 AMP
#define DH_DEV_VIDEO_COVER			0x0011		// Privacy mask setup
#define DH_DEV_TRANS_STRATEGY		0x0012		// Transmission strategy. Video quality\Fluency
#define DH_DEV_DOWNLOAD_STRATEGY	0x0013		//  Record download strategy setup:high-speed\general download
#define DH_DEV_WATERMAKE_CFG		0x0014		// Video watermark setup
#define DH_DEV_WLAN_CFG				0x0015		// Wireless network setup 
#define DH_DEV_WLAN_DEVICE_CFG		0x0016		// Search wireless device setup 
#define DH_DEV_REGISTER_CFG			0x0017		// Auto register parameter setup 
#define DH_DEV_CAMERA_CFG			0x0018		// Camera property setup 
#define DH_DEV_INFRARED_CFG 		0x0019		// IR alarm setup 
#define DH_DEV_SNIFFER_CFG			0x001A		// Sniffer setup 
#define DH_DEV_MAIL_CFG				0x001B		// Mail setup 
#define DH_DEV_DNS_CFG				0x001C		// DNS setup 
#define DH_DEV_NTP_CFG				0x001D		// NTP setup
#define DH_DEV_AUDIO_DETECT_CFG		0x001E		// Audio detection setup 
#define DH_DEV_STORAGE_STATION_CFG  0x001F      // Storage position setup 
#define DH_DEV_PTZ_OPT_CFG			0x0020		// PTZ operation property(It is invalid now. Please use CLIENT_GetPtzOptAttr to get PTZ operation property.)
#define DH_DEV_DST_CFG				0x0021      // Daylight Saving Time (DST)setup
#define DH_DEV_ALARM_CENTER_CFG		0x0022		// Alarm centre setup
#define DH_DEV_VIDEO_OSD_CFG        0x0023		// VIdeo OSD setup
#define DH_DEV_CDMAGPRS_CFG         0x0024		// CDMA\GPRS configuration

#define DH_DEV_IPFILTER_CFG         0x0025		// IP Filter configuration
#define DH_DEV_TALK_ENCODE_CFG      0x0026      // Talk encode configuration
#define DH_DEV_RECORD_PACKET_CFG    0X0027      // The length of the video package configuration
#define DH_DEV_MMS_CFG              0X0028		// SMS MMS configuration 
#define DH_DEV_SMSACTIVATION_CFG	0X0029		// SMS to activate the wireless connection configuration
#define DH_DEV_DIALINACTIVATION_CFG	0X002A		// Dial-up activation of a wireless connection configuration
#define DH_DEV_SNIFFER_CFG_EX		0x0030		// Capture network configuration
#define DH_DEV_DOWNLOAD_RATE_CFG	0x0031		// Download speed limit
#define DH_DEV_PANORAMA_SWITCH_CFG	0x0032		// Panorama switch alarm configuration
#define DH_DEV_LOST_FOCUS_CFG		0x0033		// Lose focus alarm configuration
#define DH_DEV_ALARM_DECODE_CFG		0x0034		// Alarm decoder configuration
#define DH_DEV_VIDEOOUT_CFG         0x0035      // Video output configuration
#define DH_DEV_POINT_CFG			0x0036		// Preset enable configuration
#define DH_DEV_IP_COLLISION_CFG     0x0037      // IP conflication configurationIp
#define DH_DEV_OSD_ENABLE_CFG		0x0038		// OSD overlay enable configuration
#define DH_DEV_LOCALALARM_CFG 		0x0039		// Local alarm configuration(Structure DH_ALARMIN_CFG_EX)
#define DH_DEV_NETALARM_CFG 		0x003A		// Network alarm configuration(Structure DH_ALARMIN_CFG_EX)
#define DH_DEV_MOTIONALARM_CFG 		0x003B		// Motion detection configuration(Structure DH_MOTION_DETECT_CFG_EX)
#define DH_DEV_VIDEOLOSTALARM_CFG 	0x003C		// Video loss configuration(Structure DH_VIDEO_LOST_CFG_EX)
#define DH_DEV_BLINDALARM_CFG 		0x003D		// Camera masking configuration(Structure DH_BLIND_CFG_EX)
#define DH_DEV_DISKALARM_CFG 		0x003E		// HDD alarm configuration(Structure DH_DISK_ALARM_CFG_EX)
#define DH_DEV_NETBROKENALARM_CFG 	0x003F		// Network disconnection alarm configuration(Structure DH_NETBROKEN_ALARM_CFG_EX)
#define DH_DEV_ENCODER_CFG          0x0040      // Digital channel info of front encoders(Hybrid DVR use,Structure DEV_ENCODER_CFG)
#define DH_DEV_TV_ADJUST_CFG        0x0041      // TV adjust configuration(Now the channel parameter represents the TV numble(from 0), Structure DHDEV_TVADJUST_CFG)
#define DH_DEV_ABOUT_VEHICLE_CFG	0x0042		// about vehicle configuration
#define DH_DEV_ATM_OVERLAY_ABILITY	0x0043		// ATM ability information
#define DH_DEV_ATM_OVERLAY_CFG		0x0044		// ATM overlay configuration
#define DH_DEV_DECODER_TOUR_CFG		0x0045		// Decoder tour configuration
#define DH_DEV_SIP_CFG				0x0046		// SIP configuration
#define DH_DEV_VICHILE_WIFI_AP_CFG	0x0047		// wifi ap configuration
#define DH_DEV_STATICALARM_CFG      0x0048      // Static 
#define DH_DEV_DECODE_POLICY_CFG    0x0049      // decode policy configuration(Structure DHDEV_DECODEPOLICY_CFG,channel start with 0) 
#define DH_DEV_MACHINE_CFG			0x004A		// Device relative config (Structure DHDEV_MACHINE_CFG)
#define DH_DEV_MAC_COLLISION_CFG    0x004B      // MACconflication configuration(Structure ALARM_MAC_COLLISION_CFG)
#define DH_DEV_RTSP_CFG             0x004C      // RTSP configuration(structure DHDEV_RTSP_CFG)
#define DH_DEV_232_COM_CARD_CFG     0x004E      // 232 com card signal event configuration(structure COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_485_COM_CARD_CFG     0x004F      // 485 com card signal event configuration(structure COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_FTP_PROTO_CFG_EX		0x0050		// extend FTP upload setup(Structure DHDEV_FTP_PROTO_CFG_EX)
#define DH_DEV_SYSLOG_REMOTE_SERVER	0x0051		// SYSLOG remote server config (Structure DHDEV_SYSLOG_REMOTE_SERVER)
#define DH_DEV_COMMCFG_EX           0x0052      // Extended com configuration(structure DHDEV_COMM_CFG_EX)
#define DH_DEV_NETCARD_CFG          0x0053      // net card configuration(structure DHDEV_NETCARD_CFG)
#define DH_DEV_BACKUP_VIDEO_FORMAT  0x0054		// Video backup format(structure DHDEV_BACKUP_VIDEO_FORMAT)
#define DH_DEV_STREAM_ENCRYPT_CFG   0x0055      // stream encrypt configuration(structure DHEDV_STREAM_ENCRYPT)
#define DH_DEV_IPFILTER_CFG_EX      0x0056		// IP filter extended configuration(structure DHDEV_IPIFILTER_CFG_EX)
#define DH_DEV_CUSTOM_CFG           0x0057      // custom configuration(structure DHDEV_CUSTOM_CFG)
#define DH_DEV_WLAN_DEVICE_CFG_EX   0x0058      // Search wireless device extended setup(structure DHDEV_WLAN_DEVICE_LIST_EX)
#define DH_DEV_ACC_POWEROFF_CFG     0x0059      // ACC power off configuration(structure DHDEV_ACC_POWEROFF_CFG)
#define DH_DEV_EXPLOSION_PROOF_CFG  0x005a      // explosion proof alarm configuration(structure DHDEV_EXPLOSION_PROOF_CFG)
#define DH_DEV_NETCFG_EX			0x005b		// Network extended setup(struct DHDEV_NET_CFG_EX)
#define DH_DEV_LIGHTCONTROL_CFG     0x005c      // light control config(struct DHDEV_LIGHTCONTROL_CFG)
#define DH_DEV_3GFLOW_CFG           0x005d      // 3G flow info config(struct DHDEV_3GFLOW_INFO_CFG)
#define DH_DEV_IPV6_CFG             0x005e      // IPv6 config(struct DHDEV_IPV6_CFG)
#define DH_DEV_SNMP_CFG             0X005f      // Snmp config(struct DHDEV_NET_SNMP_CFG)
#define DH_DEV_SNAP_CONTROL_CFG     0x0060      // snap control config(struct DHDEV_SNAP_CONTROL_CFG)
#define DH_DEV_GPS_MODE_CFG         0X0061      // GPS mode config(struct DHDEV_GPS_MODE_CFG)
#define DH_DEV_SNAP_UPLOAD_CFG      0X0062      // Snap upload config(struct DHDEV_SNAP_UPLOAD_CFG)
#define DH_DEV_SPEED_LIMIT_CFG      0x0063      // Speed limit config(struct DHDEV_SPEED_LIMIT_CFG)
#define DH_DEV_ISCSI_CFG	    0x0064		// iSCSI config(struct DHDEV_ISCSI_CFG), need reboot
#define DH_DEV_WIRELESS_ROUTING_CFG  0x0065		// wifi config(struc DHDEV_WIRELESS_ROUTING_CFG)
#define DH_DEV_ENCLOSURE_CFG         0x0066      // enclosure config(stuct DHDEV_ENCLOSURE_CFG)
#define DH_DEV_ENCLOSURE_VERSION_CFG 0x0067     // enclosure version config(struct DHDEV_ENCLOSURE_VERSION_CFG)
#define DH_DEV_RIAD_EVENT_CFG        0x0068     // Raid event config(struct DHDEV_RAID_EVENT_CFG)
#define DH_DEV_FIRE_ALARM_CFG        0x0069     // fire alarm config(struct DHDEV_FIRE_ALARM_CFG)
#define DH_DEV_LOCALALARM_NAME_CFG   0x006a     // local alarm name config(string like "Name1&&name2&&name3...")
#define DH_DEV_URGENCY_RECORD_CFG    0x0070     // urgency storage config(struct DHDEV_URGENCY_RECORD_CFG)
#define DH_DEV_ELEVATOR_ATTRI_CFG    0x0071     // elevator parameter config(struct DHDEV_ELEVATOR_ATTRI_CFG)
#define DH_DEV_ATM_OVERLAY_CFG_EX   0x0072     // TM overlay function. For latest ATM series product only. 
	                                        // Support devices of 32-channel or higher.( struct DHDEV_ATM_OVERLAY_CONFIG_EX)
#define DH_DEV_MACFILTER_CFG		 0x0073		// MAC filter config(struct DHDEV_MACFILTER_CFG)
#define DH_DEV_MACIPFILTER_CFG		 0x0074		// MAC,IP filter config(need ip,mac one to one corresponding)(struct DHDEV_MACIPFILTER_CFG)
#define DH_DEV_STREAM_ENCRYPT_TIME_CFG 0x0075   // stream encrypt(encryot plan)(struct DHEDV_STREAM_ENCRYPT)
#define DH_DEV_LIMIT_BIT_RATE_CFG    0x0076     // limit bit rate config(struct DHDEV_LIMIT_BIT_RATE) 
#define DH_DEV_SNAP_CFG_EX			 0x0077		// snap extern config(struct DHDEV_SNAP_CFG_EX)
#define DH_DEV_DECODER_URL_CFG		0x0078		// decoder url config(struct DHDEV_DECODER_URL_CFG)
#define DH_DEV_TOUR_ENABLE_CFG		0x0079		// toyr enable config(struct DHDEV_TOUR_ENABLE_CFG)
#define DH_DEV_VICHILE_WIFI_AP_CFG_EX 0x007a    // wifi ap extern config(struct DHDEV_VEHICLE_WIFI_AP_CFG_EX)
#define DH_DEV_ENCODER_CFG_EX         0x007b    // encoder extern config(struct DEV_ENCODER_CFG_EX)
#define DH_DEV_USER_END_CFG			1000

// Alarm type, corresponding to CLIENT_StartListen
#define DH_COMM_ALARM				0x1100		// General alarm(Including external alarm, video loss and motion detection)
#define DH_SHELTER_ALARM			0x1101		// Camera masking alarm 
#define DH_DISK_FULL_ALARM			0x1102		// HDD full alarm 
#define DH_DISK_ERROR_ALARM			0x1103		// HDD malfunction alarm 
#define DH_SOUND_DETECT_ALARM		0x1104		// Audio detection alarm 
#define DH_ALARM_DECODER_ALARM		0x1105		// Alarm decoder alarm 

// Extensive alarm type,corresponding to CLIENT_StartListenEx
#define DH_ALARM_ALARM_EX			0x2101		// External alarm 
#define DH_MOTION_ALARM_EX			0x2102		// Motion detection alarm 
#define DH_VIDEOLOST_ALARM_EX		0x2103		// Video loss alarm 
#define DH_SHELTER_ALARM_EX			0x2104		// Camera masking alarm 
#define DH_SOUND_DETECT_ALARM_EX	0x2105		// Audio detection alarm 
#define DH_DISKFULL_ALARM_EX		0x2106		// HDD full alarm 
#define DH_DISKERROR_ALARM_EX		0x2107		// HDD malfunction alarm 
#define DH_ENCODER_ALARM_EX			0x210A		// Encoder alarm 
#define DH_URGENCY_ALARM_EX			0x210B		// Emergency alarm 
#define DH_WIRELESS_ALARM_EX		0x210C		// Wireless alarm 
#define DH_NEW_SOUND_DETECT_ALARM_EX 0x210D		// New auido detection alarm. Please refer to DH_NEW_SOUND_ALARM_STATE for alarm information structure;
#define DH_ALARM_DECODER_ALARM_EX	0x210E		// Alarm decoder alarm 
#define DH_DECODER_DECODE_ABILITY	0x210F		// NVD:Decoding capacity
#define DH_FDDI_DECODER_ABILITY		0x2110		// Fiber encoder alarm
#define DH_PANORAMA_SWITCH_ALARM_EX	0x2111		// Panorama switch alarm
#define DH_LOSTFOCUS_ALARM_EX		0x2112		// Lost focus alarm
#define DH_OEMSTATE_EX				0x2113		// oem state
#define DH_DSP_ALARM_EX				0x2114		// DSP alarm
#define DH_ATMPOS_BROKEN_EX			0x2115		// atm and pos disconnection alarm, 0:disconnection 1:connection
#define DH_RECORD_CHANGED_EX		0x2116		// Record state changed alarm
#define DH_CONFIG_CHANGED_EX		0x2117		// Device config changed alarm
#define DH_DEVICE_REBOOT_EX			0x2118		// Device rebooting alarm
#define DH_WINGDING_ALARM_EX        0x2119      // CoilFault alarm
#define DH_TRAF_CONGESTION_ALARM_EX 0x211A      // traffic congestion alarm
#define DH_TRAF_EXCEPTION_ALARM_EX  0x211B      // traffic exception alarm
#define DH_EQUIPMENT_FILL_ALARM_EX  0x211C      // FlashFault alarm
#define DH_ALARM_ARM_DISARM_STATE	0x211D		// alarm arm disarm 
#define DH_ALARM_ACC_POWEROFF       0x211E      // ACC power off alarm
#define DH_ALARM_3GFLOW_EXCEED      0x211F      // Alarm of 3G flow exceed(see struct DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_ALARM_SPEED_LIMIT        0x2120      // Speed limit alarm 
#define DH_ALARM_VEHICLE_INFO_UPLOAD  0x2121    // Vehicle information uploading 
#define DH_STATIC_ALARM_EX          0x2122      // Static detection alarm
#define DH_PTZ_LOCATION_EX          0x2123      // ptz location info
#define DH_ALARM_CARD_RECORD_UPLOAD	0x2124		// card record info(struct ALARM_CARD_RECORD_INFO_UPLOAD)
#define DH_ALARM_ATM_INFO_UPLOAD	0x2125		// ATM trade info(struct ALARM_ATM_INFO_UPLOAD)
#define DH_ALARM_ENCLOSURE          0x2126      // enclosure alarm(struct ALARM_ENCLOSURE_INFO)
#define DH_ALARM_SIP_STATE          0x2127      // SIP state alarm(struct ALARM_SIP_STATE)
#define DH_ALARM_RAID_STATE         0x2128      // RAID state alarm(struct ALARM_RAID_INFO)
#define DH_ALARM_CROSSING_SPEED_LIMIT 0x2129	// crossing speed limit alarm(struct ALARM_SPEED_LIMIT)
#define DH_ALARM_OVER_LOADING         0x212A      // over loading alarm(struct ALARM_OVER_LOADING)
#define DH_ALARM_HARD_BRAKING         0x212B      // hard brake alarm(struct ALARM_HARD_BRAKING)
#define DH_ALARM_SMOKE_SENSOR         0x212C      // smoke sensor alarm(struct ALARM_SMOKE_SENSOR)
#define DH_ALARM_TRAFFIC_LIGHT_FAULT 0x212D     // traffic light fault alarm(struct ALARM_TRAFFIC_LIGHT_FAULT) 
#define DH_ALARM_TRAFFIC_FLUX_STAT   0x212E     // traffic flux alarm(struct ALARM_TRAFFIC_FLUX_LANE_INFO)
#define DH_ALARM_CAMERA_MOVE         0x212F     // camera move alarm(struct ALARM_CAMERA_MOVE_INFO)
#define DH_ALARM_DETAILEDMOTION      0x2130     // detailed motion alarm(struct ALARM_DETAILEDMOTION_CHNL_INFO)
#define DH_ALARM_STORAGE_FAILURE     0x2131     // storage failure alarm(struct ALARM_STORAGE_FAILURE)
#define DH_ALARM_FRONTDISCONNECT     0x2132     // front IPC disconnect alarm(struct ALARM_FRONTDISCONNET_INFO)
#define DH_ALARM_ALARM_EX_REMOTE     0x2133     // remote external alarm
#define DH_ALARM_BATTERYLOWPOWER     0x2134     // battery low power alarm(struct ALARM_BATTERYLOWPOWER_INFO)
#define DH_ALARM_TEMPERATURE         0x2135     // temperature alarm(struct ALARM_TEMPERATURE_INFO)
#define DH_ALARM_TIREDDRIVE          0x2136     // tired drive alarm(struct ALARM_TIREDDRIVE_INFO)
#define DH_ALARM_LOST_RECORD         0x2137     // Alarm of record loss (corresponding structure ALARM_LOST_RECORD)
#define DH_ALARM_HIGH_CPU            0x2138     // Alarm of High CPU Occupancy rate (corresponding structure ALARM_HIGH_CPU) 
#define DH_ALARM_LOST_NETPACKET      0x2139     // Alarm of net package loss (corresponding structure ALARM_LOST_NETPACKET)
#define DH_ALARM_HIGH_MEMORY         0x213A     // Alarm of high memory occupancy rate(corresponding structure ALARM_HIGH_MEMORY)
#define DH_LONG_TIME_NO_OPERATION	 0x213B	    // WEB user have no operation for long time (no extended info)
#define DH_BLACKLIST_SNAP            0x213C     // blacklist snap(corresponding to DH_BLACKLIST_SNAP_INFO)         
#define DH_ALARM_DISK				 0x213E		// alarm of disk(corresponding to ALARM_DISK_INFO)
#define	DH_ALARM_FILE_SYSTEM		 0x213F		// alarm of file systemcorresponding to ALARM_FILE_SYSTEM_INFO)
#define DH_ALARM_IVS                 0x2140     // alarm of ivs(corresponding to ALARM_IVS_INFO)
#define DH_ALARM_GOODS_WEIGHT_UPLOAD 0x2141		// goods weight (corresponding to ALARM_GOODS_WEIGHT_UPLOAD_INFO)
#define DH_ALARM_GOODS_WEIGHT		 0x2142		// alarm of goods weight(corresponding to ALARM_GOODS_WEIGHT_INFO)
#define DH_GPS_STATUS                0x2143     // GPS orientation info(corresponding to NET_GPS_STATUS_INFO)
#define DH_ALARM_DISKBURNED_FULL     0x2144     // alarm disk burned full(corresponding to ALARM_DISKBURNED_FULL_INFO)
#define DH_ALARM_STORAGE_LOW_SPACE	 0x2145		// storage low space(corresponding to ALARM_STORAGE_LOW_SPACE_INFO)
#define DH_ALARM_DISK_FLUX			 0x2160		// disk flux abnormal(corresponding to ALARM_DISK_FLUX)
#define DH_ALARM_NET_FLUX			 0x2161		// net flux abnormal(corresponding to ALARM_NET_FLUX)
#define	DH_ALARM_FAN_SPEED			 0x2162		// fan speed abnormal(corresponding to ALARM_FAN_SPEED)
#define DH_ALARM_STORAGE_FAILURE_EX  0x2163     // storage mistake(corresponding to ALARM_STORAGE_FAILURE_EX)
#define	DH_ALARM_RECORD_FAILED		 0x2164		// record abnormal(corresponding to ALARM_RECORD_FAILED_INFO)
#define DH_ALARM_STORAGE_BREAK_DOWN	 0x2165		// storage break down(corresponding to ALARM_STORAGE_BREAK_DOWN_INFO)
#define DH_ALARM_VIDEO_ININVALID     0x2166     // ALARM_VIDEO_ININVALID_INFO
#define DH_ALARM_VEHICLE_TURNOVER	 0x2167		// vehicle turnover arm event(struct ALARM_VEHICEL_TURNOVER_EVENT_INFO)
#define DH_ALARM_VEHICLE_COLLISION	 0x2168     // vehicle collision event(struct ALARM_VEHICEL_COLLISION_EVENT_INFO)
#define DH_ALARM_VEHICLE_CONFIRM     0x2169     // vehicle confirm information event(struct ALARM_VEHICEL_CONFIRM_INFO)
#define DH_ALARM_VEHICLE_LARGE_ANGLE 0x2170     // vehicle camero large angle event(struct ALARM_VEHICEL_LARGE_ANGLE)
#define DH_ALARM_TALKING_INVITE		 0x2171		// device talking invite event (struct ALARM_TALKING_INVITE_INFO)
#define DH_ALARM_ALARM_EX2			 0x2175		// local alarm event (struct ALARM_ALARM_INFO_EX2¡ê?upgrade DH_ALARM_ALARM_EX)
#define DH_ALARM_VIDEO_TIMING        0x2176     // video timing detecting event(struct ALARM_VIDEO_TIMING)
#define DH_ALARM_COMM_PORT			 0x2177     // COM event(struct ALARM_COMM_PORT_EVENT_INFO)
#define DH_ALARM_AUDIO_ANOMALY       0x2178     // audio anomaly event(struct ALARM_AUDIO_ANOMALY)
#define DH_ALARM_AUDIO_MUTATION      0x2179     // audio mutation event(struct ALARM_AUDIO_MUTATION)
#define DH_EVENT_TYREINFO            0x2180     // Tyre information report event (struct EVENT_TYRE_INFO)
#define DH_ALARM_POWER_ABNORMAL      0X2181     // Redundant power supplies abnormal alarm(struct ALARM_POWER_ABNORMAL_INFO)
#define DH_EVENT_REGISTER_OFF		 0x2182		// On-board equipment active offline events(struct  EVENT_REGISTER_OFF_INFO)
#define DH_ALARM_NO_DISK             0x2183     // No hard disk alarm(struct ALARM_NO_DISK_INFO)
#define DH_ALARM_FALLING             0x2184     // The fall alarm(struct ALARM_FALLING_INFO)
#define DH_ALARM_PROTECTIVE_CAPSULE  0x2185     // Protective capsule event(corresponding structure ALARM_PROTECTIVE_CAPSULE_INFO)
#define DH_ALARM_NO_RESPONSE              0x2186           // Call Non-response alarm(corresponding to ALARM_NO_RESPONSE_INFO)
#define DH_ALARM_CONFIG_ENABLE_CHANGE     0x2187           // Config enable to change reported event(corresponding to structure  ALARM_CONFIG_ENABLE_CHANGE_INFO)
#define DH_EVENT_CROSSLINE_DETECTION      0x2188           // Cross warning line event( Corresponding to structure ALARM_EVENT_CROSSLINE_INFO )
#define DH_EVENT_CROSSREGION_DETECTION    0x2189           // Warning zone event(Corresponding to structure ALARM_EVENT_CROSSREGION_INFO )
#define DH_EVENT_LEFT_DETECTION           0x218a           // Abandoned object event(Corresponding to structure ALARM_EVENT_LEFT_INFO )
#define DH_EVENT_FACE_DETECTION           0x218b           // Human face detect event(Corresponding to structure ALARM_EVENT_FACE_INFO ) 
#define DH_ALARM_IPC                      0x218c           // IPC alarm,IPC upload local alarm via DVR or NVR(Corresponding to structure ALARM_IPC_INFO)
#define DH_EVENT_TAKENAWAYDETECTION       0x218d           // Missing object event(Corresponding to structure ALARM_TAKENAWAY_DETECTION_INFO)
#define DH_EVENT_VIDEOABNORMALDETECTION   0x218e           // Video abnormal event(Corresponding to structure ALARM_VIDEOABNORMAL_DETECTION_INFO)
#define DH_EVENT_MOTIONDETECT             0x218f           // Video motion detect event  (Corresponding to structure ALARM_MOTIONDETECT_INFO)
#define DH_ALARM_PIR                      0x2190           // PIR alarm (Corresponding to BYTE*, pBuf length dwBufLen)
#define DH_ALARM_STORAGE_HOT_PLUG         0x2191           // Storage hot swap event(Corresponding to structure ALARM_STORAGE_HOT_PLUG_INFO)

#define DH_ALARM_STORAGE_NOT_EXIST   0x3167		// A storage group does not exist(struct ALARM_STORAGE_NOT_EXIST_INFO)
#define DH_ALARM_NET_ABORT			 0x3169		// Network fault event(struct ALARM_NETABORT_INFO)
#define DH_ALARM_IP_CONFLICT		 0x3170		// IP conflict event(struct ALARM_IP_CONFLICT_INFO)
#define DH_ALARM_MAC_CONFLICT		 0x3171		// MAC conflict event(struct ALARM_MAC_CONFLICT_INFO)
#define DH_ALARM_POWERFAULT			 0x3172		// power fault event(struct ALARM_POWERFAULT_INFO)
#define DH_ALARM_CHASSISINTRUDED	 0x3173		// Chassis intrusion, tamper alarm events(struct ALARM_CHASSISINTRUDED_INFO)
#define DH_ALARM_ALARMEXTENDED		 0x3174		// Native extension alarm events(struct ALARM_ALARMEXTENDED_INFO)

#define DH_ALARM_ARMMODE_CHANGE_EVENT		 0x3175		// Cloth removal state change events(struct ALARM_ARMMODE_CHANGE_INFO)
#define DH_ALARM_BYPASSMODE_CHANGE_EVENT	 0x3176		// The bypass state change events(struct ALARM_BYPASSMODE_CHANGE_INFO)

#define DH_ALARM_ACCESS_CTL_NOT_CLOSE		0x3177		// Entrance guard did not close events(struct ALARM_ACCESS_CTL_NOT_CLOSE_INFO)
#define DH_ALARM_ACCESS_CTL_BREAK_IN		0x3178		// break-in event(struct ALARM_ACCESS_CTL_BREAK_IN_INFO)
#define DH_ALARM_ACCESS_CTL_REPEAT_ENTER	0x3179		//access Again and again event(struct ALARM_ACCESS_CTL_REPEAT_ENTER_INFO)
#define DH_ALARM_ACCESS_CTL_DURESS			0x3180		// Stress CARDS event(struct ALARM_ACCESS_CTL_DURESS_INFO)
#define DH_ALARM_ACCESS_CTL_EVENT			0x3181		// Access event(struct ALARM_ACCESS_CTL_EVENT_INFO)

#define DH_URGENCY_ALARM_EX2              0x3182           // Emergency ALARM EX2(upgrade DH_URGENCY_ALARM_EX,struct ALARM_URGENCY_ALARM_EX2, Artificially triggered emergency, general processing is linked external communication function requests for help
#define DH_ALARM_INPUT_SOURCE_SIGNAL      0x3183           // Alarm input source signal events (as long as there is input will generate the event, whether to play the current mode, unable to block, struct ALARM_INPUT_SOURCE_SIGNAL_INFO)
#define DH_ALARM_ANALOGALARM_EVENT        0x3184           //  analog alarm(struct ALARM_ANALOGALARM_EVENT_INFO)
#define DH_ALARM_ACCESS_CTL_STATUS        0x3185           // Access control status event(corresponding structure ALARM_ACCESS_CTL_STATUS_INFO)
#define DH_ALARM_ACCESS_SNAP              0x3186           // Access control snapshot event(corresponding to ALARM_ACCESS_SNAP_INFO)
#define DH_ALARM_ALARMCLEAR               0x3187           // Cancel alarm(corresponding to structure ALARM_ALARMCLEAR_INFO)
#define DH_ALARM_CIDEVENT                 0x3188           // CID event(corresponding to structure ALARM_CIDEVENT_INFO)
#define DH_ALARM_TALKING_HANGUP           0x3189           // Device hand up evnt(corresponding to structure ALARM_TALKING_HANGUP_INFO)
#define DH_ALARM_BANKCARDINSERT           0x318a           // Bank card evnt(corresponding to structure ALARM_BANKCARDINSERT_INFO)
#define DH_ALARM_RCEMERGENCY_CALL         0x318b           // Emergency call alarm event(corresponding to structure ALARM_RCEMERGENCY_CALL_INFO)
#define DH_ALARM_OPENDOORGROUP            0x318c           // Multi-people group unlock event(corresponding to  structure ALARM_OPEN_DOOR_GROUP_INFO)
#define DH_ALARM_FINGER_PRINT             0x318d           // get fingerprint event(corresponding to  structure ALARM_CAPTURE_FINGER_PRINT_INFO)
#define DH_ALARM_CARD_RECORD              0x318e           // card no. record event(corresponding to  structure  ALARM_CARD_RECORD_INFO)
#define DH_ALARM_SUBSYSTEM_STATE_CHANGE   0x318f           // sub system status change event(corresponding to  structure ALARM_SUBSYSTEM_STATE_CHANGE_INFO)
#define DH_ALARM_BATTERYPOWER_EVENT       0x3190           // battery scheduled warning event(corresponding to  structure ALARM_BATTERYPOWER_INFO)
#define DH_ALARM_BELLSTATUS_EVENT         0x3191           // bell status event(corresponding to  structure ALARM_BELLSTATUS_INFO)
#define DH_ALARM_DEFENCE_STATE_CHANGE_EVENT 0x3192         // zone status change event(corresponding to  structure ALARM_DEFENCE_STATUS_CHANGE_INFO), 
                                                           // customized need¡ê?and arm/disarm change event, bypass event status have different definitions,
                                                           // The status via CLIENT_QueryDevState() port DH_DEVSTATE_DEFENCE_STATE command get
#define DH_ALARM_TICKET_STATISTIC         0x3193           // ticket statistics info event(corresponding to  structure  ALARM_TICKET_STATISTIC)
#define DH_ALARM_LOGIN_FAILIUR            0x3194           // login failed event(corresponding to  structure ALARM_LOGIN_FAILIUR_INFO)
#define DH_ALARM_MODULE_LOST              0x3195           // expansion module offline event(corresponding to  structure  ALARM_MODULE_LOST_INFO)
#define DH_ALARM_PSTN_BREAK_LINE          0x3196           // PSTN offline event(corresponding to  structure ALARM_PSTN_BREAK_LINE_INFO)
#define DH_ALARM_ANALOG_PULSE             0x3197           // analog alarm evnet(instant event), specific sensor  trigger(corresponding to  structure ALARM_ANALOGPULSE_INFO)
#define DH_ALARM_MISSION_CONFIRM          0x3198           // task confirmation event(corresponding to  structure  ALARM_MISSION_CONFIRM_INFO)
#define DH_ALARM_DEVICE_MSG_NOTIFY        0x3199           // device to platform notice event?t(corresponding to  structure  ALARM_DEVICE_MSG_NOTIFY_INFO)
#define DH_ALARM_VEHICLE_STANDING_OVER_TIME 0x319A         // parking timeout event(corresponding to  structure  ALARM_VEHICLE_STANDING_OVER_TIME_INFO)
#define DH_ALARM_ENCLOSURE_ALARM          0x319B           // e-fence event(corresponding to  structure  ALARM_ENCLOSURE_ALARM_INFO)
#define DH_ALARM_GUARD_DETECT			  0x319C	       // station detection event, one in station first report the start event¡ê?and last on in station report stop event before leave (corresponding to  structure ALARM_GUARD_DETECT_INFO)
#define DH_ALARM_GUARD_INFO_UPDATE		  0x319D	       // station info update event¡ê?report if people in station(corresponding to  structure ALARM_GUARD_UPDATE_INFO)  
#define DH_ALARM_NODE_ACTIVE              0x319E           // Node activation event (corresponding to structure ALARM_NODE_ACTIVE_INFO)
#define DH_ALARM_VIDEO_STATIC             0x319F           // Video static detection event (corresponding to structure ALARM_VIDEO_STATIC_INFO)
#define DH_ALARM_REGISTER_REONLINE        0x31a0           // Active registration device re-login event (corresponding to structure ALARM_REGISTER_REONLINE_INFO)
#define DH_ALARM_ISCSI_STATUS             0x31a1           // ISCSI alarm event (corresponding to structure ALARM_ISCSI_STATUS_INFO)
#define DH_ALARM_SCADA_DEV_ALARM          0x31a2           // detection collection device alarm event (corresponding to structure ALARM_SCADA_DEV_INFO)
#define DH_ALARM_AUXILIARY_DEV_STATE      0x31a3           // Sub device status(corresponding structure ALARM_AUXILIARY_DEV_STATE)
#define DH_ALARM_PARKING_CARD             0x31a4           // Parking swipe card event(corresponding structure ALARM_PARKING_CARD)
#define DH_ALARM_PROFILE_ALARM_TRANSMIT   0x31a5           // Alarm transmit event(corresponding structure ALARM_PROFILE_ALARM_TRANSMIT_INFO)
#define DH_ALARM_VEHICLE_ACC              0x31a6           // Vehicle acc event(corresponding structure ALARM_VEHICLE_ACC_INFO)
#define DH_ALARM_TRAFFIC_SUSPICIOUSCAR    0x31a7           // suspiciouscar event(corresponding structure ALARM_TRAFFIC_SUSPICIOUSCAR_INFO)
#define DH_ALARM_ACCESS_LOCK_STATUS       0x31a8           // the event of latch state (corresponding structure  ALARM_ACCESS_LOCK_STATUS_INFO)
#define DH_ALARM_FINACE_SCHEME            0x31a9           // Finace scheme event(corresponding structure ALARM_FINACE_SCHEME_INFO)
#define DH_ALARM_HEATIMG_TEMPER           0x31aa           // Thermal temperature abnormal event alarm(Corresponding to structure ALARM_HEATIMG_TEMPER_INFO)
#define DH_ALARM_TALKING_IGNORE_INVITE    0x31ab           // Device cancel bidirectional talk query event(Corresponding to structure ALARM_TALKING_IGNORE_INVITE_INFO)
#define DH_ALARM_BUS_SHARP_TURN           0x31ac           // Vehicle Abrupt-turn event(Corresponding to structure ALARM_BUS_SHARP_TURN_INFO)
#define DH_ALARM_BUS_SCRAM                0x31ad           // vehicle abrupt stop event(Corresponding to structure ALARM_BUS_SCRAM_INFO)
#define DH_ALARM_BUS_SHARP_ACCELERATE     0x31ae           // Vehicle abrupt speed up event(Corresponding to structure ALARM_BUS_SHARP_ACCELERATE_INFO)
#define DH_ALARM_BUS_SHARP_DECELERATE     0x31af           // Vehicle abrupt slow down event (Corresponding to structure ALARM_BUS_SHARP_DECELERATE_INFO)
#define DH_ALARM_ACCESS_CARD_OPERATE      0x31b0		   // A&C data operation event (Corresponding to structure ALARM_ACCESS_CARD_OPERATE_INFO)
#define DH_ALARM_POLICE_CHECK             0x31b1           // Policeman check in event(Corresponding to structure ALARM_POLICE_CHECK_INFO)
#define DH_ALARM_NET                      0x31b2           // Network alarm event(Corresponding to structure ALARM_NET_INFO)
#define DH_ALARM_NEW_FILE                 0X31b3           // New file event(Corresponding to structure ALARM_NEW_FILE_INFO)

#define DH_ALARM_FIREWARNING              0x31b5           // Thermal fire position (Corresponding to structure ALARM_FIREWARNING_INFO)
#define DH_ALARM_RECORD_LOSS              0x31b6           // Record loss event: the HDD is OK, delete results from misoperation.  (Corresponding to structure ALARM_RECORD_LOSS_INFO)
#define DH_ALARM_VIDEO_FRAME_LOSS         0x31b7           // Frame loss event£¬it results from poor network environment or insufficient encode capability (Corresponding to structure ALARM_VIDEO_FRAME_LOSS_INFO)
#define DH_ALARM_RECORD_VOLUME_FAILURE    0x31b8           // Abnormal record results from HDD volume(Corresponding to structure ALARM_RECORD_VOLUME_FAILURE_INFO)
#define DH_EVENT_SNAP_UPLOAD              0X31b9           // Image upload completion event(Corresponding to structure EVENT_SNAP_UPLOAD_INFO)
#define DH_ALARM_AUDIO_DETECT             0x31ba           // Audio detect event(Corresponding to structure ALARM_AUDIO_DETECT )
#define DH_ALARM_UPLOADPIC_FAILCOUNT      0x31bb           // Failure data amount during the image upload process £¨Corresponding to structure ALARM_UPLOADPIC_FAILCOUNT_INFO£©
#define DH_ALARM_POS_MANAGE               0x31bc           // POS management event(Corresponding to ALARM_POS_MANAGE_INFO )
#define DH_ALARM_REMOTE_CTRL_STATUS       0x31bd           // remote control status(Corresponding to ALARM_REMOTE_CTRL_STATUS )
#define DH_ALARM_PASSENGER_CARD_CHECK     0x31be           // desuetude, passenger card check(Corresponding to structure ALARM_PASSENGER_CARD_CHECK )
#define DH_ALARM_SOUND                    0x31bf           // Sound event(Corresponding to ALARM_SOUND )
#define DH_ALARM_LOCK_BREAK               0x31c0           // Lock break event(Corresponding to ALARM_LOCK_BREAK_INFO )
#define DH_ALARM_HUMAN_INSIDE             0x31c1           // Human Inside event((Corresponding to structure ALARM_HUMAN_INSIDE_INFO)
#define DH_ALARM_HUMAN_TUMBLE_INSIDE      0x31c2           // Human tumble Inside(Corresponding to structure ALARM_HUMAN_TUMBLE_INSIDE_INFO)
#define DH_ALARM_DISABLE_LOCKIN           0x31c3           // Lock entry trigger event(Corresponding to structure ALARM_DISABLE_LOCKIN_INFO)
#define DH_ALARM_DISABLE_LOCKOUT          0x31c4           // Lock go out trigger(Corresponding to structure ALARM_DISABLE_LOCKOUT_INFO)
#define DH_ALARM_UPLOAD_PIC_FAILED        0x31c5           // break rules data upload failed (Corresponding to ALARM_UPLOAD_PIC_FAILED_INFO )
#define DH_ALARM_FLOW_METER               0x31c6           // flow meter info event (ALARM_FLOW_METER_INFO)
#define DH_ALARM_WIFI_SEARCH              0x31c7           // search around wifi device(Corresponding to ALARM_WIFI_SEARCH_INFO)
#define DH_ALARM_WIRELESSDEV_LOWPOWER     0X31C8           // lowpower of wirelessdevice(ALARM_WIRELESSDEV_LOWPOWER_INFO)
#define DH_ALARM_PTZ_DIAGNOSES			  0x31c9		   // Ptz Diagnoses event(Corresponding to ALARM_PTZ_DIAGNOSES_INFO)
#define DH_ALARM_FLASH_LIGHT_FAULT        0x31ca           // flash light fault event (Corresponding to ALARM_FLASH_LIGHT_FAULT_INFO)
#define DH_ALARM_STROBOSCOPIC_LIGTHT_FAULT 0x31cb          // stroboscopic light fault event (Corresponding to ALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO)
#define DH_ALARM_HUMAM_NUMBER_STATISTIC   0x31cc           // NumberStat event (Corresponding to ALARM_HUMAN_NUMBER_STATISTIC_INFO)
#define DH_ALARM_VIDEOUNFOCUS             0x31ce           // Video unfocus (Corresponding ALARM_VIDEOUNFOCUS_INFO)
#define DH_ALARM_BUF_DROP_FRAME           0x31cd           // Video recond buffer drop frame event(Corresponding to ALARM_BUF_DROP_FRAME_INFO)
#define DH_ALARM_DOUBLE_DEV_VERSION_ABNORMAL 0x31cf        // Abnormal event when master broad'version and slave broad'version different  (Corresponding to ALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO)
#define DH_ALARM_DCSSWITCH                0x31d0           // Switch with master and slave(Corresponding to ALARM_DCSSWITCH_INFO)
#define DH_ALARM_RADAR_CONNECT_STATE      0x31d1           // Radar connect state(Corresponding to ALARM_RADAR_CONNECT_STATE_INFO)
#define DH_ALARM_DEFENCE_ARMMODE_CHANGE    0X31d2          // Defence arming status change(Corresponding to ALARM_DEFENCE_ARMMODECHANGE_INFO)
#define DH_ALARM_SUBSYSTEM_ARMMODE_CHANGE  0X31d3          // Subsystem arming status change(Corresponding to ALARM_SUBSYSTEM_ARMMODECHANGE_INFO)
#define DH_ALARM_RFID_INFO                 0X31d4          // infrared detection information event (Corresponding ALARM_RFID_INFO)
#define DH_ALARM_SMOKE_DETECTION           0X31d5          // smoke detection(Corresponding ALARM_SMOKE_DETECTION_INFO)
#define DH_ALARM_BETWEENRULE_TEMP_DIFF     0x31d6          // TemperatureDifference Between Rule (Corresponding ALARM_BETWEENRULE_DIFFTEMPER_INFO)
#define DH_ALARM_TRAFFIC_PIC_ANALYSE	   0X31d7		   // Traffic picture analyse(Corresponding ALARM_PIC_ANALYSE_INFO)
#define DH_ALARM_HOTSPOT_WARNING           0X31d8          // Hotspot warning(Corresponding ALARM_HOTSPOT_WARNING_INFO)
#define DH_ALARM_COLDSPOT_WARNING          0X31d9          // coldspot warning(Corresponding ALARM_COLDSPOT_WARNING_INFO)

// Event type
#define DH_CONFIG_RESULT_EVENT_EX	0x3000		// Modify the return code of the setup. Please refer to DEV_SET_RESULT for returned structure.
#define DH_REBOOT_EVENT_EX			0x3001		//  Device reboot event. Current modification becomes valid unitl sending out the reboot command. 
#define DH_AUTO_TALK_START_EX		0x3002		// Device automatically invites to begin audio talk 
#define DH_AUTO_TALK_STOP_EX		0x3003		// Device actively stop audio talk 
#define DH_CONFIG_CHANGE_EX			0x3004		// Device setup changes.
#define DH_IPSEARCH_EVENT_EX        0x3005      // IP search event, the return value format is:DevName:::Manufacturer::MAC:: IP:: Port&& DevName:: Manufacturer::MAC:: IP:: Port&&?-
#define DH_AUTO_RECONNECT_FAILD     0x3006      // reconnect failed
#define DH_REALPLAY_FAILD_EVENT     0x3007      // real play failed
#define DH_PLAYBACK_FAILD_EVENT     0x3008      // playback failed
#define DH_IVS_TRAFFIC_REALFLOWINFO 0x3009      // traffic real flow info ALARM_IVS_TRAFFIC_REALFLOW_INFO
#define DH_DEVICE_ABORT_EVENT	    0x300a	    // Client end is out, corresponding to structure  DEV_CLIENT_ABORT_INFO
#define DH_TALK_FAILD_EVENT         0x300b      // failed to request talk, corresponding to  structure  DEV_TALK_RESULT
#define DH_START_LISTEN_FINISH_EVENT 0x300c     // start listen interface finish asyn notify event, info pointer is NULL

// Alarm type of alarm upload function,corresponding to CLIENT_StartService.NEW_ALARM_UPLOAD structure.
#define DH_UPLOAD_ALARM					0x4000		// External alarm 		
#define DH_UPLOAD_MOTION_ALARM			0x4001		// Motion detection alarm 
#define DH_UPLOAD_VIDEOLOST_ALARM		0x4002		// Video loss alarm 
#define DH_UPLOAD_SHELTER_ALARM			0x4003		// Camera masking alarm 
#define DH_UPLOAD_SOUND_DETECT_ALARM	0x4004		// Audio detection alarm 
#define DH_UPLOAD_DISKFULL_ALARM		0x4005		// HDD full alarm 
#define DH_UPLOAD_DISKERROR_ALARM		0x4006		// HDD malfunction alarm 
#define DH_UPLOAD_ENCODER_ALARM			0x4007		// Encoder alarm 
#define DH_UPLOAD_DECODER_ALARM			0x400B		// Alarm decoder alarm 
#define DH_UPLOAD_EVENT					0x400C		// Scheduled upload 
#define DH_UPLOAD_IVS					0x400D		// intelligent alarm,corresponding to ALARM_UPLOAD_IVS_INFO
#define DH_UPLOAD_SMOKESENSOR_ALARM     0x400E		// Smoke alarm, struct ALARM_UPLOAD_SMOKESENSOR_INFO
#define DH_UPLOAD_ALARM_EX              0x400F      // External alarm extension¡ê?corresponding structure  ALARM_UPLOAD_ALARMEX_INFO 
#define DH_UPLOAD_REMOTE_LOGIN_FAILD_ALARM  0x4010  // Remote login failed alarm, corresponding structure ALARM_UPLOAD_LOGIN_FAILED_INFO
#define DH_UPLOAD_CUSTOM                    0x4011  // Extension string is defined by the client.,pParam:extension data pointer,dwParamLen:extension data length
#define DH_UPLOAD_FRONTDISCONNECT_ALARM     0x4012  // front device disconnect alarm, corresponding structure NEW_ALARM_UPLOAD
#define DH_UPLOAD_ALARM_IPC                 0x4013  // IPC External alarm, corresponding structure NEW_ALARM_UPLOAD
#define DH_UPLOAD_NET_ALARM                 0x4014  // Net Alarm input(trigger through network,different from device's local alarm input), corresponding structure NEW_ALARM_UPLOAD

// order Bus status corresponding to event report(CLIENT_AttachBusState)
#define DH_ALARM_BUS_DRIVER_CHECK         0X0001           // driver sign up event(corresponding to  structure  ALARM_BUS_DRIVER_CHECK_INFO)
#define DH_ALARM_BUS_IMPORT_SITE          0x0002           // in station(corresponding to  structure  ALARM_BUS_IMPORT_SITE_INFO)
#define DH_ALARM_BUS_EXPORT_SITE          0x0003           // out event (corresponding to  structure  ALARM_BUS_EXPORT_SITE_INFO)
#define DH_ALARM_BUS_ABNORMAL             0x0004           // Abnormal vehicle event (corresponding to structure ALARM_BUS_ABNORMAL_INFO)
#define DH_ALARM_BUS_DOOR_OPEN            0x0005           // Unlock car door event (corresponding to structure ALARM_VEHICLE_DOOR_OPEN_INFO)
#define DH_ALARM_BUS_CUR_MILEAGE          0x0006           // Current mileage event(corresponding to structure ALARM_BUS_CUR_MILEAGE_INFO)
#define DH_ALARM_BUS_CUR_OIL              0x0007           // Current oil event(corresponding to structure ALARM_BUS_CUR_OIL_INFO)
#define DH_ALARM_BUS_LOW_OIL              0x0008           // Low oil event(corresponding to structure ALARM_BUS_LOW_OIL_INFO)
#define DH_ALARM_BUS_PASSENGER_CARD_CHECK 0x0009           // Passeger card check event(corresponding to structure ALARM_PASSENGER_CARD_CHECK )
#define DH_ALARM_BUS_VEHICLE_STANDING_OVER_TIME 0x000a     // vehicle standing over time(corresponding to structure ALARM_VEHICLE_STANDING_OVER_TIME_INFO )
#define DH_ALARM_BUS_DRIVE_AFTER_WORK     0x000b           // not work time(corresponding to structure ALARM_DVRIVE_AFTER_WORK )
#define DH_ALARM_BUS_PAD_SHUTDOWN         0x000c           // PAD shutdown event; DVR notify PadShutdown event, PAD will delay shutdown automatically by receiving this event(corresponding to structure ALARM_BUS_PAD_SHUTDOWN_INFO)
#define DH_ALARM_BUS_TIRED_DRIVE_CHECK    0x000d           // tired drive event(corresponding to ALARM_TIRED_DRIVE_CHECK_INFO )


// Asynchronous interface callback type
#define RESPONSE_DECODER_CTRL_TV	0x00000001		// refer to CLIENT_CtrlDecTVScreen interface
#define RESPONSE_DECODER_SWITCH_TV	0x00000002		// refer to CLIENT_SwitchDecTVEncoder interface
#define RESPONSE_DECODER_PLAYBACK	0x00000003		// refer to CLIENT_DecTVPlayback interface

#define RESPONSE_EXCHANGE_DATA		0X00000004	// correspoding CLIENT_ExchangeData interface
#define RESPONSE_ASYN_QUERY_RECORDFILE 0X00000005  // correspoding CLIENT_StartQueryRecordFile interface
// CLIENT_FileTransmit Interface transmission file type
#define DH_DEV_UPGRADEFILETRANS_START	0x0000		// Begin sending update file(Corresponding structure DHDEV_UPGRADE_FILE_INFO)
#define DH_DEV_UPGRADEFILETRANS_SEND	0x0001		// Send update file  
#define DH_DEV_UPGRADEFILETRANS_STOP	0x0002		// Stop sending update file
#define DH_DEV_BLACKWHITETRANS_START  	0x0003    	// begin to send blackwhite list(Corresponding structure DHDEV_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITETRANS_SEND   	0x0004    	// send blackwhite list
#define DH_DEV_BLACKWHITETRANS_STOP   	0x0005    	// stop to send blackwhite list
#define DH_DEV_BLACKWHITE_LOAD        	0x0006    	// blackwhite list load (Corresponding structure DHDEV_LOAD_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITE_LOAD_STOP   	0x0007    	// blackwhite list load stop
#define DH_DEV_FILETRANS_STOP			0x002B		// Stop file upload
#define DH_DEV_FILETRANS_BURN			0x002C		// Burn File Upload

// Resolution list. Use to AND & OR of resolution subnet mask 
#define	DH_CAPTURE_SIZE_D1			0x00000001
#define DH_CAPTURE_SIZE_HD1			0x00000002
#define DH_CAPTURE_SIZE_BCIF		0x00000004
#define DH_CAPTURE_SIZE_CIF			0x00000008
#define DH_CAPTURE_SIZE_QCIF		0x00000010	
#define DH_CAPTURE_SIZE_VGA			0x00000020	
#define DH_CAPTURE_SIZE_QVGA		0x00000040
#define DH_CAPTURE_SIZE_SVCD		0x00000080
#define DH_CAPTURE_SIZE_QQVGA		0x00000100
#define DH_CAPTURE_SIZE_SVGA		0x00000200
#define DH_CAPTURE_SIZE_XVGA		0x00000400
#define DH_CAPTURE_SIZE_WXGA		0x00000800
#define DH_CAPTURE_SIZE_SXGA		0x00001000
#define DH_CAPTURE_SIZE_WSXGA		0x00002000   
#define DH_CAPTURE_SIZE_UXGA		0x00004000
#define DH_CAPTURE_SIZE_WUXGA       0x00008000
#define DH_CAPTURE_SIZE_LFT         0x00010000
#define DH_CAPTURE_SIZE_720		    0x00020000
#define DH_CAPTURE_SIZE_1080		0x00040000
#define DH_CAPTURE_SIZE_1_3M        0x00080000
#define DH_CAPTURE_SIZE_2M			0x00100000
#define DH_CAPTURE_SIZE_5M			0x00200000
#define DH_CAPTURE_SIZE_3M			0x00400000	
#define DH_CAPTURE_SIZE_5_0M        0x00800000
#define DH_CPTRUTE_SIZE_1_2M 		0x01000000
#define DH_CPTRUTE_SIZE_1408_1024   0x02000000
#define DH_CPTRUTE_SIZE_8M	        0x04000000	
#define DH_CPTRUTE_SIZE_2560_1920   0x08000000
#define DH_CAPTURE_SIZE_960H        0x10000000	
#define DH_CAPTURE_SIZE_960_720     0x20000000				

// Encode mode list. Use to work AND & OR operation of encode mode mask.
#define DH_CAPTURE_COMP_DIVX_MPEG4	0x00000001
#define DH_CAPTURE_COMP_MS_MPEG4 	0x00000002
#define DH_CAPTURE_COMP_MPEG2		0x00000004
#define DH_CAPTURE_COMP_MPEG1		0x00000008
#define DH_CAPTURE_COMP_H263		0x00000010
#define DH_CAPTURE_COMP_MJPG		0x00000020
#define DH_CAPTURE_COMP_FCC_MPEG4	0x00000040
#define DH_CAPTURE_COMP_H264		0x00000080
#define DH_CAPTURE_COMP_H265		0x00000100
#define DH_CAPTURE_COMP_SVAC        0x00000200

// Alarm activation operation. Use to work AND & OR operation of alarm activation operation.
#define DH_ALARM_UPLOAD				0x00000001
#define DH_ALARM_RECORD				0x00000002
#define DH_ALARM_PTZ				0x00000004
#define DH_ALARM_MAIL				0x00000008
#define DH_ALARM_TOUR				0x00000010
#define DH_ALARM_TIP				0x00000020
#define DH_ALARM_OUT				0x00000040
#define DH_ALARM_FTP_UL				0x00000080
#define DH_ALARM_BEEP				0x00000100
#define DH_ALARM_VOICE				0x00000200
#define DH_ALARM_SNAP				0x00000400

// Restore default setup mask. Can use to AND & OR operation
#define DH_RESTORE_COMMON			0x00000001	// General setup
#define DH_RESTORE_CODING			0x00000002	// Encode setup
#define DH_RESTORE_VIDEO			0x00000004	// Record setup
#define DH_RESTORE_COMM				0x00000008	// COM setup
#define DH_RESTORE_NETWORK			0x00000010	//network setup
#define DH_RESTORE_ALARM			0x00000020	// Alarm setup
#define DH_RESTORE_VIDEODETECT		0x00000040	// Video detection
#define DH_RESTORE_PTZ				0x00000080	// PTZ control 
#define DH_RESTORE_OUTPUTMODE		0x00000100	// Output mode
#define DH_RESTORE_CHANNELNAME		0x00000200	// Channel name
#define DH_RESTORE_VIDEOINOPTIONS   0x00000400  // Camera attribute
#define DH_RESTORE_CPS              0x00000800  // TrafficSnapshot
#define DH_RESTORE_INTELLIGENT      0x00001000  // Intelligent Component
#define DH_RESTORE_REMOTEDEVICE     0x00002000  // Remote device configuration
#define DH_RESTORE_DECODERVIDEOOUT  0x00004000  // decode video out
#define DH_RESTORE_LINKMODE         0x00008000  // link mode
#define DH_RESTORE_COMPOSITE        0x00010000  // split screen   
#define DH_RESTORE_ALL				0x80000000	// Reset all

// PTZ property list
// Lower four bytes subnet mask
#define PTZ_DIRECTION				0x00000001	// Direction
#define PTZ_ZOOM					0x00000002	// Zoom
#define PTZ_FOCUS					0x00000004	// Focus
#define PTZ_IRIS					0x00000008	// Aperture
#define PTZ_ALARM					0x00000010	// Alarm function 
#define PTZ_LIGHT					0x00000020	// Light 
#define PTZ_SETPRESET				0x00000040	// Set preset 
#define PTZ_CLEARPRESET				0x00000080	// Delete preset
#define PTZ_GOTOPRESET				0x00000100	// Go to a preset
#define PTZ_AUTOPANON				0x00000200	// Enable pan
#define PTZ_AUTOPANOFF				0x00000400	// isable pan
#define PTZ_SETLIMIT				0x00000800	// Set limit
#define PTZ_AUTOSCANON				0x00001000	// Enable auto scan
#define PTZ_AUTOSCANOFF				0x00002000	// Disable auto scan 
#define PTZ_ADDTOUR					0x00004000	// Add tour point
#define PTZ_DELETETOUR				0x00008000	// Delete tour point
#define PTZ_STARTTOUR				0x00010000	// Begin tour
#define PTZ_STOPTOUR				0x00020000	// Stop tour
#define PTZ_CLEARTOUR				0x00040000	// Delete tour
#define PTZ_SETPATTERN				0x00080000	// Set pattern
#define PTZ_STARTPATTERN			0x00100000	// Enbale pattern
#define PTZ_STOPPATTERN				0x00200000	// Disable pattern
#define PTZ_CLEARPATTERN			0x00400000	// Delete pattern
#define PTZ_POSITION				0x00800000	// Position 
#define PTZ_AUX						0x01000000	// auxiliary button 
#define PTZ_MENU					0x02000000	// Speed dome menu 
#define PTZ_EXIT					0x04000000	// Exit speed dome menu 
#define PTZ_ENTER					0x08000000	// Confirm
#define PTZ_ESC						0x10000000	// Cancel 
#define PTZ_MENUUPDOWN				0x20000000	// Menu up/down
#define PTZ_MENULEFTRIGHT			0x40000000	// Menu left/right 
#define PTZ_OPT_NUM					0x80000000	// Operation amount
// Higher four bytes subnet mask
#define PTZ_DEV						0x00000001	// PTZ control 
#define PTZ_MATRIX					0x00000002	// Matrix control 

// Snapshot video encode type
#define CODETYPE_MPEG4                    0
#define CODETYPE_H264                     1
#define CODETYPE_JPG                      2

// Bit stream control control list
#define DH_CAPTURE_BRC_CBR                0
#define DH_CAPTURE_BRC_VBR                1
//#define DH_CAPTURE_BRC_MBR              2

//The frame type mask definition
#define FRAME_TYPE_MOTION                   0x00000001      // MD frame

// the type of intelligent analysis event 
#define EVENT_IVS_ALL						0x00000001		// subscription all event
#define EVENT_IVS_CROSSLINEDETECTION		0x00000002		// cross line event(Corresponding to DEV_EVENT_CROSSLINE_INFO)
#define EVENT_IVS_CROSSREGIONDETECTION		0x00000003		// cross region event(Corresponding to DEV_EVENT_CROSSREGION_INFO)
#define EVENT_IVS_PASTEDETECTION			0x00000004		// past event(Corresponding to DEV_EVENT_PASTE_INFO)
#define EVENT_IVS_LEFTDETECTION				0x00000005		// left event(Corresponding to DEV_EVENT_LEFT_INFO)
#define EVENT_IVS_STAYDETECTION				0x00000006		// stay event(Corresponding to DEV_EVENT_STAY_INFO)
#define EVENT_IVS_WANDERDETECTION			0x00000007		// wander event(Corresponding to DEV_EVENT_WANDER_INFO)
#define EVENT_IVS_PRESERVATION				0x00000008		// reservation event(Corresponding to DEV_EVENT_PRESERVATION_INFO) 
#define EVENT_IVS_MOVEDETECTION				0x00000009		// move event(Corresponding to DEV_EVENT_MOVE_INFO)
#define EVENT_IVS_TAILDETECTION				0x0000000A		// tail event(Corresponding to DEV_EVENT_TAIL_INFO)
#define EVENT_IVS_RIOTERDETECTION			0x0000000B		// rioter event(Corresponding to DEV_EVENT_RIOTERL_INFO)
#define EVENT_IVS_FIREDETECTION				0x0000000C		// fire event(Corresponding to DEV_EVENT_FIRE_INFO)
#define EVENT_IVS_SMOKEDETECTION			0x0000000D		// smoke event(Corresponding to DEV_EVENT_SMOKE_INFO)
#define EVENT_IVS_FIGHTDETECTION			0x0000000E		// fight event(Corresponding to DEV_EVENT_FLOWSTAT_INFO)
#define EVENT_IVS_FLOWSTAT					0x0000000F		// flow stat event(Corresponding to DEV_EVENT_FLOWSTAT_INFO)
#define EVENT_IVS_NUMBERSTAT				0x00000010		// number stat event(Corresponding to DEV_EVENT_NUMBERSTAT_INFO)
#define EVENT_IVS_CAMERACOVERDDETECTION		0x00000011		// camera cover event
#define EVENT_IVS_CAMERAMOVEDDETECTION		0x00000012		// camera move event
#define EVENT_IVS_VIDEOABNORMALDETECTION	0x00000013		// video abnormal event(Corresponding to DEV_EVENT_VIDEOABNORMALDETECTION_INFO)
#define EVENT_IVS_VIDEOBADDETECTION			0x00000014		// video bad event
#define EVENT_IVS_TRAFFICCONTROL			0x00000015		// traffic control event(Corresponding to DEV_EVENT_TRAFFICCONTROL_INFO)
#define EVENT_IVS_TRAFFICACCIDENT			0x00000016		// traffic accident event(Corresponding to DEV_EVENT_TRAFFICACCIDENT_INFO)
#define EVENT_IVS_TRAFFICJUNCTION			0x00000017		// traffic junction event(Corresponding to DEV_EVENT_TRAFFICJUNCTION_INFO)
#define EVENT_IVS_TRAFFICGATE				0x00000018		// traffic gate event(Corresponding to DEV_EVENT_TRAFFICGATE_INFO)
#define EVENT_TRAFFICSNAPSHOT				0x00000019		// traffic snapshot(Corresponding to DEV_EVENT_TRAFFICSNAPSHOT_INFO)
#define EVENT_IVS_FACEDETECT                0x0000001A      // face detection(Corresponding to DEV_EVENT_FACEDETECT_INFO)
#define EVENT_IVS_TRAFFICJAM                0x0000001B      // traffic-Jam(Corresponding to DEV_EVENT_TRAFFICJAM_INFO)
#define EVENT_IVS_TRAFFIC_RUNREDLIGHT		0x00000100		// traffic-RunRedLight(Corresponding to DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO)
#define EVENT_IVS_TRAFFIC_OVERLINE			0x00000101		// traffic-Overline(Corresponding to DEV_EVENT_TRAFFIC_OVERLINE_INFO)
#define EVENT_IVS_TRAFFIC_RETROGRADE		0x00000102		// traffic-Retrograde(Corresponding to DEV_EVENT_TRAFFIC_RETROGRADE_INFO)
#define EVENT_IVS_TRAFFIC_TURNLEFT			0x00000103		// traffic-TurnLeft(Corresponding to DEV_EVENT_TRAFFIC_TURNLEFT_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHT			0x00000104		// traffic-TurnRight(Corresponding to DEV_EVENT_TRAFFIC_TURNRIGHT_INFO)	
#define EVENT_IVS_TRAFFIC_UTURN				0x00000105		// traffic-Uturn(Corresponding to DEV_EVENT_TRAFFIC_UTURN_INFO)
#define EVENT_IVS_TRAFFIC_OVERSPEED			0x00000106		// traffic-Overspeed(Corresponding to DEV_EVENT_TRAFFIC_OVERSPEED_INFO)
#define EVENT_IVS_TRAFFIC_UNDERSPEED		0x00000107		// traffic-Underspeed(Corresponding to DEV_EVENT_TRAFFIC_UNDERSPEED_INFO)
#define EVENT_IVS_TRAFFIC_PARKING           0x00000108      // traffic-Parking(Corresponding to DEV_EVENT_TRAFFIC_PARKING_INFO)
#define EVENT_IVS_TRAFFIC_WRONGROUTE        0x00000109      // traffic-WrongRoute(Corresponding to DEV_EVENT_TRAFFIC_WRONGROUTE_INFO)
#define EVENT_IVS_TRAFFIC_CROSSLANE         0x0000010A      // traffic-CrossLane(Corresponding to DEV_EVENT_TRAFFIC_CROSSLANE_INFO)
#define EVENT_IVS_TRAFFIC_OVERYELLOWLINE    0x0000010B      // traffic-OverYellowLine(Corresponding to DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO)
#define EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER 0x0000010C      // traffic-DrivingOnShoulder(Corresponding to DEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO)   
#define EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE 0x0000010E      // traffic-YellowPlateInLane(Corresponding to DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO)
#define EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY 0x0000010F		// Traffic offense-Pedestral has higher priority at the  crosswalk(Corresponding to DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO)
#define EVENT_IVS_CROSSFENCEDETECTION       0x0000011F      // cross fence(Corresponding to DEV_EVENT_CROSSFENCEDETECTION_INFO) 
#define EVENT_IVS_ELECTROSPARKDETECTION     0X00000110      // ElectroSpark event(Corresponding to DEV_EVENT_ELECTROSPARK_INFO) 
#define EVENT_IVS_TRAFFIC_NOPASSING         0x00000111      // no passing(Corresponding to DEV_EVENT_TRAFFIC_NOPASSING_INFO)
#define EVENT_IVS_ABNORMALRUNDETECTION      0x00000112      // abnormal run(Corresponding to DEV_EVENT_ABNORMALRUNDETECTION_INFO)
#define EVENT_IVS_RETROGRADEDETECTION       0x00000113      // retrograde(Corresponding to DEV_EVENT_RETROGRADEDETECTION_INFO)
#define EVENT_IVS_INREGIONDETECTION         0x00000114      // in region detection(Corresponding to DEV_EVENT_INREGIONDETECTION_INFO)
#define EVENT_IVS_TAKENAWAYDETECTION        0x00000115      // taking away things(Corresponding to DEV_EVENT_TAKENAWAYDETECTION_INFO)
#define EVENT_IVS_PARKINGDETECTION          0x00000116      // parking(Corresponding to DEV_EVENT_PARKINGDETECTION_INFO)
#define EVENT_IVS_FACERECOGNITION			0x00000117		// face recognition(Corresponding to DEV_EVENT_FACERECOGNITION_INFO)
#define EVENT_IVS_TRAFFIC_MANUALSNAP        0x00000118      // manual snap(Corresponding to DEV_EVENT_TRAFFIC_MANUALSNAP_INFO)
#define EVENT_IVS_TRAFFIC_FLOWSTATE			0x00000119		// traffic flow state(Corresponding to DEV_EVENT_TRAFFIC_FLOW_STATE)
#define EVENT_IVS_TRAFFIC_STAY				0x0000011A		// traffic stay(Corresponding to DEV_EVENT_TRAFFIC_STAY_INFO)
#define EVENT_IVS_TRAFFIC_VEHICLEINROUTE	0x0000011B		// traffic vehicle route(Corresponding to DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO)
#define EVENT_ALARM_MOTIONDETECT            0x0000011C      // motion detect(Corresponding to DEV_EVENT_ALARM_INFO)
#define EVENT_ALARM_LOCALALARM              0x0000011D      // local alarm(Corresponding to DEV_EVENT_ALARM_INFO)
#define EVENT_IVS_PRISONERRISEDETECTION		0x0000011E		// prisoner rise detect(Corresponding to DEV_EVENT_PRISONERRISEDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_TOLLGATE			0x00000120		// traffic tollgate(Corresponding to DEV_EVENT_TRAFFICJUNCTION_INFO)
#define EVENT_IVS_DENSITYDETECTION			0x00000121      // density detection of persons(Corresponding to DEV_EVENT_DENSITYDETECTION_INFO)
#define EVENT_IVS_VIDEODIAGNOSIS            0x00000122		// video diagnosis result(Corresponding to NET_VIDEODIAGNOSIS_COMMON_INFO and NET_REAL_DIAGNOSIS_RESULT)
#define EVENT_IVS_QUEUEDETECTION            0x00000123      // queue detection(Corresponding to DEV_EVENT_QUEUEDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE 0x00000124      // take up in bus route(Corresponding to DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO)
#define EVENT_IVS_TRAFFIC_BACKING           0x00000125      // illegal astern(Corresponding to DEV_EVENT_IVS_TRAFFIC_BACKING_INFO) 
#define EVENT_IVS_AUDIO_ABNORMALDETECTION   0x00000126      // audio abnormity(Corresponding to DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT    0x00000127      // run yellow light(Corresponding to DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO)
#define EVENT_IVS_CLIMBDETECTION            0x00000128      // climb detection(Corresponding to DEV_EVENT_IVS_CLIMB_INFO) 
#define EVENT_IVS_LEAVEDETECTION            0x00000129      // leave detection(Corresponding to DEV_EVENT_IVS_LEAVE_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX    0x0000012A        // parking on yellow box(Corresponding to DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING   0x0000012B        // parking space parking(Corresponding to DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING 0x0000012C        // parking space no parking(Corresponding to DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO)
#define EVENT_IVS_TRAFFIC_PEDESTRAIN            0x0000012D        // passerby(Corresponding to DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO)
#define EVENT_IVS_TRAFFIC_THROW                 0x0000012E        // throw(Corresponding to DEV_EVENT_TRAFFIC_THROW_INFO)
#define EVENT_IVS_TRAFFIC_IDLE                  0x0000012F        // idle(Corresponding to DEV_EVENT_TRAFFIC_IDLE_INFO)
#define EVENT_ALARM_VEHICLEACC                  0x00000130        // Vehicle ACC power outage alarm events(Corresponding to DEV_EVENT_ALARM_VEHICLEACC_INFO)
#define EVENT_ALARM_VEHICLE_TURNOVER            0x00000131        // Vehicle rollover alarm events(Corresponding to DEV_EVENT_VEHICEL_ALARM_INFO)
#define EVENT_ALARM_VEHICLE_COLLISION           0x00000132        // Vehicle crash alarm events(Corresponding to DEV_EVENT_VEHICEL_ALARM_INFO)
#define EVENT_ALARM_VEHICLE_LARGE_ANGLE         0x00000133        // On-board camera large Angle turn events
#define EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE  0x00000134        // Parking line pressing events(Corresponding to DEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO)
#define EVENT_IVS_MULTISCENESWITCH              0x00000135        // Many scenes switching events(Corresponding to DEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO)
#define EVENT_IVS_TRAFFIC_RESTRICTED_PLATE      0X00000136        // Limited license plate event(Corresponding to DEV_EVENT_TRAFFIC_RESTRICTED_PLATE)
#define EVENT_IVS_TRAFFIC_OVERSTOPLINE          0X00000137        // Cross stop line event(Corresponding to DEV_EVENT_TRAFFIC_OVERSTOPLINE)
#define EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT      0x00000138        // Traffic unfasten seat belt event(Corresponding to DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT) 
#define EVENT_IVS_TRAFFIC_DRIVER_SMOKING        0x00000139        // Driver smoking event(Corresponding to DEV_EVENT_TRAFFIC_DRIVER_SMOKING) 
#define EVENT_IVS_TRAFFIC_DRIVER_CALLING        0x0000013A        // Driver call event(Corresponding to DEV_EVENT_TRAFFIC_DRIVER_CALLING) 
#define EVENT_IVS_TRAFFIC_PEDESTRAINRUNREDLIGHT 0x0000013B        // Pedestrain red light(Corresponding to DEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO)
#define EVENT_IVS_TRAFFIC_PASSNOTINORDER        0x0000013C        // Pass not in order(corresponding DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO)
#define EVENT_IVS_OBJECT_DETECTION              0x00000141        // Object feature detection event(Corresponding to DEV_EVENT_TRAFFIC_OBJECT_DETECTION) 
#define EVENT_ALARM_ANALOGALARM                 0x00000150        // Analog alarm channel?¡¥s alarm event(correspondingDEV_EVENT_ALARM_ANALOGALRM_INFO)
#define EVENT_IVS_CROSSLINEDETECTION_EX	        0x00000151        // Warning lineexpansion event(Corresponding to DEV_EVENT_CROSSLINE_INFO_EX) 
#define EVENT_ALARM_COMMON                      0x00000152        // Normal Record
#define EVENT_ALARM_VIDEOBLIND                  0x00000153        // Video tampering event(Corresponding to DEV_EVENT_ALARM_VIDEOBLIND)
#define EVENT_ALARM_VIDEOLOSS                   0x00000154        // Video loss event
#define EVENT_IVS_GETOUTBEDDETECTION			0x00000155		  // Event of getting out bed detection(Corresponding to DEV_EVENT_GETOUTBED_INFO)
#define EVENT_IVS_PATROLDETECTION			    0x00000156		  // Event of patrol detection(Corresponding to DEV_EVENT_PATROL_INFO)
#define EVENT_IVS_ONDUTYDETECTION				0x00000157		  // Event of on duty detection(Corresponding to DEV_EVENT_ONDUTY_INFO)
#define EVENT_IVS_VIDEOSTATIC                   0x0000015D        // Event of static video detect(corresponding DEV_EVENT_ALARM_VIDEOSTATIC_INFO)
#define EVENT_IVS_VIDEOTIMING                   0x0000015E        // Event of video timing detect(corresponding DEV_EVENT_ALARM_VIDEOTIMING_INFO)
#define EVENT_IVS_HEATMAP                       0x0000015F        // Heat map (Corresponding to )
#define EVENT_IVS_CITIZENIDCARD                 0x00000160        // ID info reading event (Corresponding to  DEV_EVENT_ALARM_CITIZENIDCARD_INFO)
#define EVENT_IVS_PICINFO                       0x00000161        // Image info event(Corresponding to DEV_EVENT_ALARM_PIC_INFO)
#define EVENT_IVS_NETPLAYCHECK					0x00000162		   // NetPlayCheck event(corresponding DEV_EVENT_ALARM_NETPLAYCHECK_INFO)
#define EVENT_IVS_TRAFFIC_JAM_FORBID_INTO		0x00000163		   // Jam Forbid into  event(corresponding DEV_EVENT_ALARM_JAMFORBIDINTO_INFO)
#define EVENT_IVS_SNAPBYTIME                    0x00000164        // Snap by time event(corresponding DEV_EVENT_SNAPBYTIME)
#define EVENT_IVS_PTZ_PRESET                    0x00000165        // PTZ turn to preset event(corresponding to DEV_EVENT_ALARM_PTZ_PRESET_INFO)
#define EVENT_IVS_RFID_INFO                     0x00000166        // Event of infrared detect info(corresponding to DEV_EVENT_ALARM_RFID_INFO)
#define	EVENT_IVS_STANDUPDETECTION				0X00000167		  // Event of standing up detection

#define EVENT_IVS_TRAFFIC_ALL                   0x000001FF        // All event start with [TRAFFIC]
                                                                  // EVENT_IVS_TRAFFICCONTROL -> EVENT_TRAFFICSNAPSHOT
                                                                  // EVENT_IVS_TRAFFIC_RUNREDLIGHT -> EVENT_IVS_TRAFFIC_UNDERSPEED
#define EVENT_IVS_VIDEOANALYSE                  0x00000200        // All IVS events (Corresponding to )
#define EVENT_IVS_LINKSD                        0x00000201        // LinkSD events(Corresponding to )
#define	EVENT_IVS_VEHICLEANALYSE				0x00000202		  // ³µÁ¾ÌØÕ÷¼ì²â·ÖÎö(¶ÔÓ¦DEV_EVENT_VEHICLEANALYSE)


//Storage Point
#define STOR_POINT_READ_WRITE                   0x00001001      // Read-Write group
#define STOR_POINT_READ_ONLY                    0x00001002      // Read-Only group
#define STOR_POINT_REDUNDANT                    0x00001003      // Redundant group
#define STOR_POINT_BACKUP                       0x00001004      // Backup group
#define STOR_POINT_DRAW_FRAME                   0x00001005      // Drawframe group
#define STOR_POINT_NAS_FTP                      0x00001006      // Remote group(protocol type:FTP)
#define STOR_POINT_NAS_NFS                      0x00001007      // Remote group(protocol type:NFS)
#define STOR_POINT_NAS_SMB                      0x00001008      // Remote group(protocol type:SMB)
#define STOR_POINT_NAS_ISCSI                    0x00001009      // Remote group(protocol type:ISCSI)
#define STOR_POINT_NAS_CLOUD                    0x0000100A      // Remote group(protocol type:Cloud)


//Traffic statistics event using macros
#define FLOWSTAT_ADDR_NAME                     16              //Has long place name

// interface CLIENT_OperateTrafficList, All kinds of string length definition
#define DH_TARFFIC_NAME_LEN                     16                
#define DH_CREATE_TIME_LEN                      32
#define DH_AUTHORITY_NUM                        16


// Error type code. Corresponding to the return value of CLIENT_GetLastError
#define _EC(x)						(0x80000000|x)
#define NET_NOERROR 				0			// No error 
#define NET_ERROR					-1			// Unknown error
#define NET_SYSTEM_ERROR			_EC(1)		// Windows system error
#define NET_NETWORK_ERROR			_EC(2)		// Protocol error it may result from network timeout
#define NET_DEV_VER_NOMATCH			_EC(3)		// Device protocol does not match 
#define NET_INVALID_HANDLE			_EC(4)		// Handle is invalid
#define NET_OPEN_CHANNEL_ERROR		_EC(5)		// Failed to open channel 
#define NET_CLOSE_CHANNEL_ERROR		_EC(6)		// Failed to close channel 
#define NET_ILLEGAL_PARAM			_EC(7)		// User parameter is illegal 
#define NET_SDK_INIT_ERROR			_EC(8)		// SDK initialization error 
#define NET_SDK_UNINIT_ERROR		_EC(9)		// SDK clear error 
#define NET_RENDER_OPEN_ERROR		_EC(10)		// Error occurs when apply for render resources.
#define NET_DEC_OPEN_ERROR			_EC(11)		// Error occurs when opening the decoder library 
#define NET_DEC_CLOSE_ERROR			_EC(12)		// Error occurs when closing the decoder library 
#define NET_MULTIPLAY_NOCHANNEL		_EC(13)		// The detected channel number is 0 in multiple-channel preview. 
#define NET_TALK_INIT_ERROR			_EC(14)		// Failed to initialize record library 
#define NET_TALK_NOT_INIT			_EC(15)		// The record library has not been initialized
#define	NET_TALK_SENDDATA_ERROR		_EC(16)		// Error occurs when sending out audio data 
#define NET_REAL_ALREADY_SAVING		_EC(17)		// The real-time has been protected.
#define NET_NOT_SAVING				_EC(18)		// The real-time data has not been save.
#define NET_OPEN_FILE_ERROR			_EC(19)		// Error occurs when opening the file.
#define NET_PTZ_SET_TIMER_ERROR		_EC(20)		// Failed to enable PTZ to control timer.
#define NET_RETURN_DATA_ERROR		_EC(21)		// Error occurs when verify returned data.
#define NET_INSUFFICIENT_BUFFER		_EC(22)		// There is no sufficient buffer.
#define NET_NOT_SUPPORTED			_EC(23)		// The current SDK does not support this fucntion.
#define NET_NO_RECORD_FOUND			_EC(24)		// There is no searched result.
#define NET_NOT_AUTHORIZED			_EC(25)		// You have no operation right.
#define NET_NOT_NOW					_EC(26)		// Can not operate right now. 
#define NET_NO_TALK_CHANNEL			_EC(27)		// There is no audio talk channel.
#define NET_NO_AUDIO				_EC(28)		// There is no audio.
#define NET_NO_INIT					_EC(29)		// The network SDK has not been initialized.
#define NET_DOWNLOAD_END			_EC(30)		// The download completed.
#define NET_EMPTY_LIST				_EC(31)		// There is no searched result.
#define NET_ERROR_GETCFG_SYSATTR	_EC(32)		// Failed to get system property setup.
#define NET_ERROR_GETCFG_SERIAL		_EC(33)		// Failed to get SN.
#define NET_ERROR_GETCFG_GENERAL	_EC(34)		// Failed to get general property.
#define NET_ERROR_GETCFG_DSPCAP		_EC(35)		// Failed to get DSP capacity description.
#define NET_ERROR_GETCFG_NETCFG		_EC(36)		// Failed to get network channel setup.
#define NET_ERROR_GETCFG_CHANNAME	_EC(37)		// Failed to get channel name.
#define NET_ERROR_GETCFG_VIDEO		_EC(38)		// Failed to get video property.
#define NET_ERROR_GETCFG_RECORD		_EC(39)		// Failed to get record setup
#define NET_ERROR_GETCFG_PRONAME	_EC(40)		// Failed to get decoder protocol name 
#define NET_ERROR_GETCFG_FUNCNAME	_EC(41)		// Failed to get 232 COM function name.
#define NET_ERROR_GETCFG_485DECODER	_EC(42)		// Failed to get decoder property
#define NET_ERROR_GETCFG_232COM		_EC(43)		// Failed to get 232 COM setup
#define NET_ERROR_GETCFG_ALARMIN	_EC(44)		// Failed to get external alarm input setup
#define NET_ERROR_GETCFG_ALARMDET	_EC(45)		// Failed to get motion detection alarm
#define NET_ERROR_GETCFG_SYSTIME	_EC(46)		// Failed to get device time
#define NET_ERROR_GETCFG_PREVIEW	_EC(47)		// Failed to get preview parameter
#define NET_ERROR_GETCFG_AUTOMT		_EC(48)		// Failed to get audio maintenance setup
#define NET_ERROR_GETCFG_VIDEOMTRX	_EC(49)		// Failed to get video matrix setup
#define NET_ERROR_GETCFG_COVER		_EC(50)		// Failed to get privacy mask zone setup
#define NET_ERROR_GETCFG_WATERMAKE	_EC(51)		// Failed to get video watermark setup
#define NET_ERROR_GETCFG_MULTICAST	_EC(52)	    // Failed to get config¡êomulticast port by channel
#define NET_ERROR_SETCFG_GENERAL	_EC(55)		// Failed to modify general property
#define NET_ERROR_SETCFG_NETCFG		_EC(56)		// Failed to modify channel setup
#define NET_ERROR_SETCFG_CHANNAME	_EC(57)		// Failed to modify channel name
#define NET_ERROR_SETCFG_VIDEO		_EC(58)		// Failed to modify video channel 
#define NET_ERROR_SETCFG_RECORD		_EC(59)		// Failed to modify record setup 
#define NET_ERROR_SETCFG_485DECODER	_EC(60)		// Failed to modify decoder property 
#define NET_ERROR_SETCFG_232COM		_EC(61)		// Failed to modify 232 COM setup 
#define NET_ERROR_SETCFG_ALARMIN	_EC(62)		// Failed to modify external input alarm setup
#define NET_ERROR_SETCFG_ALARMDET	_EC(63)		// Failed to modify motion detection alarm setup 
#define NET_ERROR_SETCFG_SYSTIME	_EC(64)		// Failed to modify device time 
#define NET_ERROR_SETCFG_PREVIEW	_EC(65)		// Failed to modify preview parameter
#define NET_ERROR_SETCFG_AUTOMT		_EC(66)		// Failed to modify auto maintenance setup 
#define NET_ERROR_SETCFG_VIDEOMTRX	_EC(67)		// Failed to modify video matrix setup 
#define NET_ERROR_SETCFG_COVER		_EC(68)		// Failed to modify privacy mask zone
#define NET_ERROR_SETCFG_WATERMAKE	_EC(69)		// Failed to modify video watermark setup 
#define NET_ERROR_SETCFG_WLAN		_EC(70)		// Failed to modify wireless network information 
#define NET_ERROR_SETCFG_WLANDEV	_EC(71)		// Failed to select wireless network device
#define NET_ERROR_SETCFG_REGISTER	_EC(72)		// Failed to modify the actively registration parameter setup.
#define NET_ERROR_SETCFG_CAMERA		_EC(73)		// Failed to modify camera property
#define NET_ERROR_SETCFG_INFRARED	_EC(74)		// Failed to modify IR alarm setup
#define NET_ERROR_SETCFG_SOUNDALARM	_EC(75)		// Failed to modify audio alarm setup
#define NET_ERROR_SETCFG_STORAGE    _EC(76)		// Failed to modify storage position setup
#define NET_AUDIOENCODE_NOTINIT		_EC(77)		// The audio encode port has not been successfully initialized. 
#define NET_DATA_TOOLONGH			_EC(78)		// The data are too long.
#define NET_UNSUPPORTED				_EC(79)		// The device does not support current operation. 
#define NET_DEVICE_BUSY				_EC(80)		// Device resources is not sufficient.
#define NET_SERVER_STARTED			_EC(81)		// The server has boot up 
#define NET_SERVER_STOPPED			_EC(82)		// The server has not fully boot up 
#define NET_LISTER_INCORRECT_SERIAL	_EC(83)		// Input serial number is not correct.
#define NET_QUERY_DISKINFO_FAILED	_EC(84)		// Failed to get HDD information.
#define NET_ERROR_GETCFG_SESSION	_EC(85)		// Failed to get connect session information.
#define NET_USER_FLASEPWD_TRYTIME	_EC(86)		// The password you typed is incorrect. You have exceeded the maximum number of retries.
#define NET_LOGIN_ERROR_PASSWORD	_EC(100)	// Password is not correct
#define NET_LOGIN_ERROR_USER		_EC(101)	// The account does not exist
#define NET_LOGIN_ERROR_TIMEOUT		_EC(102)	// Time out for log in returned value.
#define NET_LOGIN_ERROR_RELOGGIN	_EC(103)	// The account has logged in 
#define NET_LOGIN_ERROR_LOCKED		_EC(104)	// The account has been locked
#define NET_LOGIN_ERROR_BLACKLIST	_EC(105)	// The account bas been in the black list
#define NET_LOGIN_ERROR_BUSY		_EC(106)	// Resources are not sufficient. System is busy now.
#define NET_LOGIN_ERROR_CONNECT		_EC(107)	// Time out. Please check network and try again.
#define NET_LOGIN_ERROR_NETWORK		_EC(108)	// Network connection failed.
#define NET_LOGIN_ERROR_SUBCONNECT	_EC(109)	// Successfully logged in the device but can not create video channel. Please check network connection.
#define NET_LOGIN_ERROR_MAXCONNECT  _EC(110)    // exceed the max connect number
#define NET_LOGIN_ERROR_PROTOCOL3_ONLY _EC(111)	// protocol 3 support
#define NET_LOGIN_ERROR_UKEY_LOST	_EC(112)	// There is no USB or USB info error
#define NET_LOGIN_ERROR_NO_AUTHORIZED _EC(113)  // Client-end IP address has no right to login
#define NET_RENDER_SOUND_ON_ERROR	_EC(120)	// Error occurs when Render library open audio.
#define NET_RENDER_SOUND_OFF_ERROR	_EC(121)	// Error occurs when Render library close audio 
#define NET_RENDER_SET_VOLUME_ERROR	_EC(122)	// Error occurs when Render library control volume
#define NET_RENDER_ADJUST_ERROR		_EC(123)	// Error occurs when Render library set video parameter
#define NET_RENDER_PAUSE_ERROR		_EC(124)	// Error occurs when Render library pause play
#define NET_RENDER_SNAP_ERROR		_EC(125)	// Render library snapshot error
#define NET_RENDER_STEP_ERROR		_EC(126)	// Render library stepper error
#define NET_RENDER_FRAMERATE_ERROR	_EC(127)	// Error occurs when Render library set frame rate.
#define NET_RENDER_DISPLAYREGION_ERROR	_EC(128)// Error occurs when Render lib setting show region
#define NET_RENDER_GETOSDTIME_ERROR _EC(129)    // An error occurred when Render library getting current play time
#define NET_GROUP_EXIST				_EC(140)	// Group name has been existed.
#define	NET_GROUP_NOEXIST			_EC(141)	// The group name does not exist. 
#define NET_GROUP_RIGHTOVER			_EC(142)	// The group right exceeds the right list!
#define NET_GROUP_HAVEUSER			_EC(143)	// The group can not be removed since there is user in it!
#define NET_GROUP_RIGHTUSE			_EC(144)	// The user has used one of the group right. It can not be removed. 
#define NET_GROUP_SAMENAME			_EC(145)	// New group name has been existed
#define	NET_USER_EXIST				_EC(146)	// The user name has been existed
#define NET_USER_NOEXIST			_EC(147)	// The account does not exist.
#define NET_USER_RIGHTOVER			_EC(148)	// User right exceeds the group right. 
#define NET_USER_PWD				_EC(149)	// Reserved account. It does not allow to be modified.
#define NET_USER_FLASEPWD			_EC(150)	// password is not correct
#define NET_USER_NOMATCHING			_EC(151)	// Password is invalid
#define NET_USER_INUSE				_EC(152)	// account in use
#define NET_ERROR_GETCFG_ETHERNET	_EC(300)	// Failed to get network card setup.
#define NET_ERROR_GETCFG_WLAN		_EC(301)	// Failed to get wireless network information.
#define NET_ERROR_GETCFG_WLANDEV	_EC(302)	// Failed to get wireless network device.
#define NET_ERROR_GETCFG_REGISTER	_EC(303)	// Failed to get actively registration parameter.
#define NET_ERROR_GETCFG_CAMERA		_EC(304)	// Failed to get camera property 
#define NET_ERROR_GETCFG_INFRARED	_EC(305)	// Failed to get IR alarm setup
#define NET_ERROR_GETCFG_SOUNDALARM	_EC(306)	// Failed to get audio alarm setup
#define NET_ERROR_GETCFG_STORAGE    _EC(307)	// Failed to get storage position 
#define NET_ERROR_GETCFG_MAIL		_EC(308)	// Failed to get mail setup.
#define NET_CONFIG_DEVBUSY			_EC(309)	// Can not set right now. 
#define NET_CONFIG_DATAILLEGAL		_EC(310)	// The configuration setup data are illegal.
#define NET_ERROR_GETCFG_DST        _EC(311)    // Failed to get DST setup
#define NET_ERROR_SETCFG_DST        _EC(312)    // Failed to set DST 
#define NET_ERROR_GETCFG_VIDEO_OSD  _EC(313)    // Failed to get video osd setup.
#define NET_ERROR_SETCFG_VIDEO_OSD  _EC(314)    // Failed to set video osd 
#define NET_ERROR_GETCFG_GPRSCDMA   _EC(315)    // Failed to get CDMA\GPRS configuration
#define NET_ERROR_SETCFG_GPRSCDMA   _EC(316)    // Failed to set CDMA\GPRS configuration
#define NET_ERROR_GETCFG_IPFILTER   _EC(317)    // Failed to get IP Filter configuration
#define NET_ERROR_SETCFG_IPFILTER   _EC(318)    // Failed to set IP Filter configuration
#define NET_ERROR_GETCFG_TALKENCODE _EC(319)    // Failed to get Talk Encode configuration
#define NET_ERROR_SETCFG_TALKENCODE _EC(320)    // Failed to set Talk Encode configuration
#define NET_ERROR_GETCFG_RECORDLEN  _EC(321)    // Failed to get The length of the video package configuration
#define NET_ERROR_SETCFG_RECORDLEN  _EC(322)    // Failed to set The length of the video package configuration
#define	NET_DONT_SUPPORT_SUBAREA	_EC(323)	// Not support Network hard disk partition
#define	NET_ERROR_GET_AUTOREGSERVER	_EC(324)	// Failed to get the register server information
#define	NET_ERROR_CONTROL_AUTOREGISTER		_EC(325)	// Failed to control actively registration
#define	NET_ERROR_DISCONNECT_AUTOREGISTER	_EC(326)	// Failed to disconnect actively registration
#define NET_ERROR_GETCFG_MMS				_EC(327)	// Failed to get mms configuration
#define NET_ERROR_SETCFG_MMS				_EC(328)	// Failed to set mms configuration
#define NET_ERROR_GETCFG_SMSACTIVATION      _EC(329)	// Failed to get SMS configuration
#define NET_ERROR_SETCFG_SMSACTIVATION      _EC(330)	// Failed to set SMS configuration
#define NET_ERROR_GETCFG_DIALINACTIVATION	_EC(331)	// Failed to get activation of a wireless connection
#define NET_ERROR_SETCFG_DIALINACTIVATION	_EC(332)	// Failed to set activation of a wireless connection
#define NET_ERROR_GETCFG_VIDEOOUT           _EC(333)    // Failed to get the parameter of video output
#define NET_ERROR_SETCFG_VIDEOOUT			_EC(334)	// Failed to set the configuration of video output
#define NET_ERROR_GETCFG_OSDENABLE			_EC(335)	// Failed to get osd overlay enabling
#define NET_ERROR_SETCFG_OSDENABLE			_EC(336)	// Failed to set OSD overlay enabling
#define NET_ERROR_SETCFG_ENCODERINFO        _EC(337)    // Failed to set digital input configuration of front encoders
#define NET_ERROR_GETCFG_TVADJUST		    _EC(338)	// Failed to get TV adjust configuration
#define NET_ERROR_SETCFG_TVADJUST			_EC(339)	// Failed to set TV adjust configuration
#define NET_ERROR_CONNECT_FAILED			_EC(340)	// Failed to request to establish a connection
#define NET_ERROR_SETCFG_BURNFILE			_EC(341)	// Failed to request to upload burn files
#define NET_ERROR_SNIFFER_GETCFG			_EC(342)	// // Failed to get capture configuration information
#define NET_ERROR_SNIFFER_SETCFG			_EC(343)	// Failed to set capture configuration information
#define NET_ERROR_DOWNLOADRATE_GETCFG		_EC(344)	// Failed to get download restrictions information
#define NET_ERROR_DOWNLOADRATE_SETCFG		_EC(345)	// Failed to set download restrictions information
#define NET_ERROR_SEARCH_TRANSCOM			_EC(346)	// Failed to query serial port parameters
#define NET_ERROR_GETCFG_POINT				_EC(347)	// Failed to get the preset info
#define NET_ERROR_SETCFG_POINT				_EC(348)	// Failed to set the preset info
#define NET_SDK_LOGOUT_ERROR				_EC(349)    // SDK log out the device abnormally
#define NET_ERROR_GET_VEHICLE_CFG			_EC(350)	// Failed to get vehicle configuration
#define NET_ERROR_SET_VEHICLE_CFG			_EC(351)	// Failed to set vehicle configuration
#define NET_ERROR_GET_ATM_OVERLAY_CFG		_EC(352)	// Failed to get ATM overlay configuration
#define NET_ERROR_SET_ATM_OVERLAY_CFG		_EC(353)	// Failed to set ATM overlay configuration
#define NET_ERROR_GET_ATM_OVERLAY_ABILITY	_EC(354)	// Failed to get ATM overlay ability
#define NET_ERROR_GET_DECODER_TOUR_CFG		_EC(355)	// Failed to get decoder tour configuration
#define NET_ERROR_SET_DECODER_TOUR_CFG		_EC(356)	// Failed to set decoder tour configuration
#define NET_ERROR_CTRL_DECODER_TOUR			_EC(357)	// Failed to control decoder tour
#define NET_GROUP_OVERSUPPORTNUM			_EC(358)	// Beyond the device supports for the largest number of user groups
#define NET_USER_OVERSUPPORTNUM				_EC(359)	// Beyond the device supports for the largest number of users 
#define NET_ERROR_GET_SIP_CFG				_EC(368)	// Failed to get SIP configuration
#define NET_ERROR_SET_SIP_CFG				_EC(369)	// Failed to set SIP configuration
#define NET_ERROR_GET_SIP_ABILITY			_EC(370)	// Failed to get SIP capability
#define NET_ERROR_GET_WIFI_AP_CFG			_EC(371)	// Failed to get "WIFI ap' configuration 
#define NET_ERROR_SET_WIFI_AP_CFG			_EC(372)	// Failed to set "WIFI ap" configuration  
#define NET_ERROR_GET_DECODE_POLICY		    _EC(373)	// Failed to get decode policy 
#define NET_ERROR_SET_DECODE_POLICY			_EC(374)	// Failed to set decode policy 
#define NET_ERROR_TALK_REJECT				_EC(375)	// refuse talk
#define NET_ERROR_TALK_OPENED				_EC(376)	// talk has opened by other client
#define NET_ERROR_TALK_RESOURCE_CONFLICIT   _EC(377)	// resource conflict
#define NET_ERROR_TALK_UNSUPPORTED_ENCODE   _EC(378)	// unsupported encode type
#define NET_ERROR_TALK_RIGHTLESS			_EC(379)	// no right
#define NET_ERROR_TALK_FAILED				_EC(380)	// request failed
#define NET_ERROR_GET_MACHINE_CFG			_EC(381)	// Failed to get device relative config
#define NET_ERROR_SET_MACHINE_CFG			_EC(382)	// Failed to set device relative config
#define NET_ERROR_GET_DATA_FAILED			_EC(383)	// get data failed
#define NET_ERROR_MAC_VALIDATE_FAILED       _EC(384)    // MAC validate failed
#define NET_ERROR_GET_INSTANCE              _EC(385)    // Failed to get server instance 
#define NET_ERROR_JSON_REQUEST              _EC(386)    // Generated json string is error
#define NET_ERROR_JSON_RESPONSE             _EC(387)    // The responding json string is error
#define NET_ERROR_VERSION_HIGHER            _EC(388)    // The protocol version is lower than current version
#define NET_SPARE_NO_CAPACITY				_EC(389)	// Hotspare disk operation failed. The capacity is low
#define NET_ERROR_SOURCE_IN_USE				_EC(390)	// Display source is used by other output
#define NET_ERROR_REAVE                     _EC(391)    // advanced users grab low-level user resource
#define NET_ERROR_NETFORBID                 _EC(392)    // net forbid
#define NET_ERROR_GETCFG_MACFILTER			_EC(393)    // get MAC filter configuration error
#define NET_ERROR_SETCFG_MACFILTER			_EC(394)    // set MAC filter configuration error
#define NET_ERROR_GETCFG_IPMACFILTER		_EC(395)    // get IP/MAC filter configuration error
#define NET_ERROR_SETCFG_IPMACFILTER		_EC(396)    // set IP/MAC filter configuration error
#define NET_ERROR_OPERATION_OVERTIME        _EC(397)    // operation over time 
#define NET_ERROR_SENIOR_VALIDATE_FAILED    _EC(398)    // senior validation failure
#define NET_ERROR_DEVICE_ID_NOT_EXIST		_EC(399)	// device ID is not exist
#define NET_ERROR_UNSUPPORTED               _EC(400)    // unsupport operation
#define NET_ERROR_PROXY_DLLLOAD				_EC(401)	// proxy dll load error
#define NET_ERROR_PROXY_ILLEGAL_PARAM		_EC(402)	// proxy user parameter is not legal
#define NET_ERROR_PROXY_INVALID_HANDLE		_EC(403)	// handle invalid
#define NET_ERROR_PROXY_LOGIN_DEVICE_ERROR	_EC(404)	// login device error
#define NET_ERROR_PROXY_START_SERVER_ERROR	_EC(405)	// start proxy server error
#define NET_ERROR_SPEAK_FAILED				_EC(406)	// request speak failed
#define NET_ERROR_NOT_SUPPORT_F6            _EC(407)    // unsupport F6
#define NET_ERROR_CD_UNREADY				_EC(408)	// CD is not ready
#define NET_ERROR_DIR_NOT_EXIST				_EC(409)	// Directory does not exist
#define NET_ERROR_UNSUPPORTED_SPLIT_MODE	_EC(410)	// The device does not support the segmentation model
#define NET_ERROR_OPEN_WND_PARAM			_EC(411)	// Open the window parameter is illegal
#define NET_ERROR_LIMITED_WND_COUNT			_EC(412)	// Open the window more than limit
#define NET_ERROR_UNMATCHED_REQUEST			_EC(413)	// Request command with the current pattern don't match
#define NET_RENDER_ENABLELARGEPICADJUSTMENT_ERROR	_EC(414)	// Render Library to enable high-definition image internal adjustment strategy error
#define NET_ERROR_UPGRADE_FAILED            _EC(415)    // Upgrade equipment failure
#define	NET_ERROR_NO_TARGET_DEVICE			_EC(416)	// Can't find the target device
#define	NET_ERROR_NO_VERIFY_DEVICE			_EC(417)	// Can't find the verify device 
#define	NET_ERROR_CASCADE_RIGHTLESS			_EC(418)	// No cascade permissions
#define NET_ERROR_LOW_PRIORITY				_EC(419)	// low priority
#define NET_ERROR_REMOTE_REQUEST_TIMEOUT	_EC(420)	// The remote device request timeout
#define NET_ERROR_LIMITED_INPUT_SOURCE		_EC(421)	//Input source beyond maximum route restrictions
#define NET_ERROR_SET_LOG_PRINT_INFO        _EC(422)    // Failed to set log print
#define NET_ERROR_PARAM_DWSIZE_ERROR        _EC(423)    // "dwSize" is not initialized in input param
#define NET_ERROR_LIMITED_MONITORWALL_COUNT _EC(424)    // TV wall exceed limit
#define NET_ERROR_PART_PROCESS_FAILED       _EC(425)    // Fail to execute part of the process
#define NET_ERROR_TARGET_NOT_SUPPORT        _EC(426)    // Fail to transmit due to not supported by target
#define NET_ERROR_VISITE_FILE				_EC(510)	// Access to the file failed
#define NET_ERROR_DEVICE_STATUS_BUSY		_EC(511)	// Device busy
#define NET_USER_PWD_NOT_AUTHORIZED         _EC(512)    // Fail to change the password
#define NET_USER_PWD_NOT_STRONG             _EC(513)    // Password strength is not enough
#define NET_ERROR_NO_SUCH_CONFIG            _EC(514)    // No corresponding setup
#define NET_ERROR_AUDIO_RECORD_FAILED       _EC(515)    // Failed to record audio
#define NET_ERROR_SEND_DATA_FAILED          _EC(516)    // Failed to send out data 
#define NET_ERROR_OBSOLESCENT_INTERFACE     _EC(517)    // Abandoned port 
#define NET_ERROR_INSUFFICIENT_INTERAL_BUF  _EC(518)    // Internal buffer is not sufficient 
#define NET_ERROR_NEED_ENCRYPTION_PASSWORD  _EC(519)    // verify password when changing device IP
#define NET_ERROR_SERIALIZE_ERROR           _EC(1010)   // Failed to serialize data
#define NET_ERROR_DESERIALIZE_ERROR         _EC(1011)   // Failed to deserialize data

/************************************************************************
 ** Enumeration Definition
 ***********************************************************************/
//Card information types CLIENT_QueryNetStat interface using
typedef enum tagEM_NET_QUERY_TYPE
{
	NET_APP_DATA_STAT , // Statistics for protocol stack,(input struct NET_IN_NETAPP_NET_DATA_STAT,output struct NET_OUT_NETAPP_NET_DATA_STAT)
	NET_APP_LINK_STAT , // Access to physical link state,(input structNET_IN_NETAPP_LINK_STATUS,output struct NET_OUT_NETAPP_LINK_STATUS)
}EM_NET_QUERY_TYPE;

// Catch a figure type CLIENT_CapturePictureEx interface using
typedef enum tagNET_CAPTURE_FORMATS
{
	NET_CAPTURE_BMP,
	NET_CAPTURE_JPEG, // 100% quality JPEG
	NET_CAPTURE_JPEG_70, // 70% quality JPEG
	NET_CAPTURE_JPEG_50,
	NET_CAPTURE_JPEG_30,
}NET_CAPTURE_FORMATS;

// Device type
typedef enum tagNET_DEVICE_TYPE 
{
	NET_PRODUCT_NONE = 0,
	NET_DVR_NONREALTIME_MACE,					// Non real-time MACE
	NET_DVR_NONREALTIME,						// Non real-time
	NET_NVS_MPEG1,								// Network video server
	NET_DVR_MPEG1_2,							// MPEG1 2-ch DVR
	NET_DVR_MPEG1_8,							// MPEG1 8-ch DVR
	NET_DVR_MPEG4_8,							// MPEG4 8-ch DVR
	NET_DVR_MPEG4_16,							// MPEG4 16-ch DVR
	NET_DVR_MPEG4_SX2,							// LB series DVR
	NET_DVR_MEPG4_ST2,							// GB  series DVR
	NET_DVR_MEPG4_SH2,							// HB  series DVR
	NET_DVR_MPEG4_GBE,							// GBE  series DVR
	NET_DVR_MPEG4_NVSII,						// II network video server
	NET_DVR_STD_NEW,							// New standard configuration protocol
	NET_DVR_DDNS,								// DDNS server
	NET_DVR_ATM,								// ATM series 
	NET_NB_SERIAL,								// 2nd non real-time NB series DVR
	NET_LN_SERIAL,								// LN  series 
	NET_BAV_SERIAL,								// BAV series
	NET_SDIP_SERIAL,							// SDIP series
	NET_IPC_SERIAL,								// IPC series
	NET_NVS_B,									// NVS B series
	NET_NVS_C,									// NVS H series 
	NET_NVS_S,									// NVS S series
	NET_NVS_E,									// NVS E series
	NET_DVR_NEW_PROTOCOL,						// Search device type from QueryDevState. it is in string format
	NET_NVD_SERIAL,								// NVD
	NET_DVR_N5,									// N5
	NET_DVR_MIX_DVR,							// HDVR
	NET_SVR_SERIAL,								// SVR series
	NET_SVR_BS,									// SVR-BS
	NET_NVR_SERIAL,								// NVR series
	NET_DVR_N51,                                // N51
	NET_ITSE_SERIAL,							// ITSE Intelligent Analysis Box
	NET_ITC_SERIAL,                             // Intelligent traffic camera equipment
	NET_HWS_SERIAL,                             // radar speedometer HWS
	NET_PVR_SERIAL,                             // portable video record
	NET_IVS_SERIAL,                             // IVS(intelligent video server series)
	NET_IVS_B,                                  // universal intelligent detect video server series 
	NET_IVS_F,                                  // face recognisation server
	NET_IVS_V,                                  // video quality diagnosis server
	NET_MATRIX_SERIAL,							// matrix
	NET_DVR_N52,								// N52
	NET_DVR_N56,								// N56
	NET_ESS_SERIAL,                             // ESS
	NET_IVS_PC,                                 // number statistic server
	NET_PC_NVR,                                 // pc-nvr
	NET_DSCON,									// screen controller
	NET_EVS,									// network video storage server
	NET_EIVS,									// an embedded intelligent video analysis system
	NET_DVR_N6,                                 // DVR-N6
	NET_UDS,                                    // K-Lite Codec Pack
	NET_AF6016,									// Bank alarm host
	NET_AS5008,									//Video network alarm host
	NET_AH2008,									//Network alarm host
	NET_A_SERIAL,								// Alarm host series
	NET_BSC_SERIAL,								// Access control series of products
    NET_NVS_SERIAL,                             // NVS series product
    NET_VTO_SERIAL,                             // VTO series product
    NET_VTNC_SERIAL,                            // VTNC series product
    NET_TPC_SERIAL,               				// TPC series product, it is the thermal device 
}NET_DEVICE_TYPE ;

// Language type
typedef enum __LANGUAGE_TYPE
{
	DH_LANGUAGE_ENGLISH,						// English 
	DH_LANGUAGE_CHINESE_SIMPLIFIED,				// Simplified Chinese
	DH_LANGUAGE_CHINESE_TRADITIONAL,			// Traditional Chinese
	DH_LANGUAGE_ITALIAN,						// Italian 
	DH_LANGUAGE_SPANISH,						// Spanish
	DH_LANGUAGE_JAPANESE,						// Japanese
	DH_LANGUAGE_RUSSIAN,						// Russian 
	DH_LANGUAGE_FRENCH,							// French
	DH_LANGUAGE_GERMAN, 						// German
	DH_LANGUAGE_PORTUGUESE,						// Portuguese
	DH_LANGUAGE_TURKEY,							// Turkey	
	DH_LANGUAGE_POLISH,							// Polish
	DH_LANGUAGE_ROMANIAN,						// Romanian 
	DH_LANGUAGE_HUNGARIAN,						// Hungarian
	DH_LANGUAGE_FINNISH,						// Finnish
	DH_LANGUAGE_ESTONIAN,						// Estonian	
	DH_LANGUAGE_KOREAN,							// Korean
	DH_LANGUAGE_FARSI,							// Farsi	
	DH_LANGUAGE_DANSK,							// Denmark
	DH_LANGUAGE_CZECHISH,						// Czechish
	DH_LANGUAGE_BULGARIA,						// Bulgaria
	DH_LANGUAGE_SLOVAKIAN,						// Slovakian
	DH_LANGUAGE_SLOVENIA,						// Slovenia
	DH_LANGUAGE_CROATIAN,						// Croatian
	DH_LANGUAGE_DUTCH,							// Dutch
	DH_LANGUAGE_GREEK,							// Greek
	DH_LANGUAGE_UKRAINIAN,						// Ukrainian
	DH_LANGUAGE_SWEDISH,						// Swedish
	DH_LANGUAGE_SERBIAN,						// Serbian
	DH_LANGUAGE_VIETNAMESE,						// Vietnamese
	DH_LANGUAGE_LITHUANIAN,						// Lithuanian
	DH_LANGUAGE_FILIPINO,						// Filipino
	DH_LANGUAGE_ARABIC,							// Arabic
	DH_LANGUAGE_CATALAN,						// Catalan
	DH_LANGUAGE_LATVIAN,						// Latvian
	DH_LANGUAGE_THAI,							// Thai
	DH_LANGUAGE_HEBREW,							// Hebrew
	DH_LANGUAGE_Bosnian,						// Bosnian
} DH_LANGUAGE_TYPE;

// Upgrade type
typedef enum __EM_UPGRADE_TYPE
{
	DH_UPGRADE_BIOS_TYPE = 1,					// BIOS  upgrade
	DH_UPGRADE_WEB_TYPE,						// WEB upgrade
	DH_UPGRADE_BOOT_YPE,						// BOOT upgrade
	DH_UPGRADE_CHARACTER_TYPE,					// Chinese character library
	DH_UPGRADE_LOGO_TYPE,						// LOGO
	DH_UPGRADE_EXE_TYPE,						// EXE such as player
    DH_UPGRADE_DEVCONSTINFO_TYPE,               // upgrade device information
    DH_UPGRADE_PERIPHERAL_TYPE,                 // Peripheral access from (such as car 287 chip)
	DH_UPGRADE_GEOINFO_TYPE,                    // Geographic information positioning chip
	DH_UPGRADE_MENU,                            // Menu (equipment operation interface of the picture)
	DH_UPGRADE_ROUTE,                           // Line files (such as bus lines)
	DH_UPGRADE_ROUTE_STATE_AUTO,                // Stops the audio (with line stops audio)
	DH_UPGRADE_SCREEN,                          // Scheduling screen (e.g., bus operation panel)
} EM_UPGRADE_TYPE;

// Record related (schedule,motion detection,alarm)
typedef enum __REC_TYPE
{
	DH_REC_TYPE_TIM = 0,
	DH_REC_TYPE_MTD,
	DH_REC_TYPE_ALM,
	DH_REC_TYPE_NUM,
} REC_TYPE;

// network type  
typedef enum __GPRSCDMA_NETWORK_TYPE
{
	DH_TYPE_AUTOSEL = 0,						// Automatic selection
	DH_TYPE_TD_SCDMA,							// TD-SCDMA network 
	DH_TYPE_WCDMA,								// WCDMA network
	DH_TYPE_CDMA_1x,							// CDMA 1.x network
	DH_TYPE_EDGE,								// GPRS network
	DH_TYPE_EVDO,								// EVDO network
	DH_TYPE_WIFI,
} EM_GPRSCDMA_NETWORK_TYPE;

// Interface type,responding to the interface CLIENT_SetSubconnCallBack
typedef enum __EM_INTERFACE_TYPE
{
	DH_INTERFACE_OTHER = 0x00000000,			// Unknown interface
	DH_INTERFACE_REALPLAY,						// Realtime monitoring interface
	DH_INTERFACE_PREVIEW,						// Realtime multiple-window preview
	DH_INTERFACE_PLAYBACK,						// Playback interface
	DH_INTERFACE_DOWNLOAD,						// Download interface
	DH_INTERFACE_REALLOADPIC,                   // Download picture interface
} EM_INTERFACE_TYPE;

// realplay disconnect event
typedef enum _EM_REALPLAY_DISCONNECT_EVENT_TYPE
{
	DISCONNECT_EVENT_REAVE,                     // resources is taked by advanced user
	DISCONNECT_EVENT_NETFORBID,                 // forbidden
	DISCONNECT_EVENT_SUBCONNECT,                // sublink disconnect
}EM_REALPLAY_DISCONNECT_EVENT_TYPE;

// event file's tag type
typedef enum __EM_EVENT_FILETAG
{
	DH_ATMBEFOREPASTE = 1,                      // Before ATM Paste
	DH_ATMAFTERPASTE,                           // After ATM Paste
}EM_EVENT_FILETAG;

// IPC type
typedef enum __EM_IPC_TYPE
{
	DH_IPC_PRIVATE,                             // private
	DH_IPC_AEBELL,                              // AEBell
	DH_IPC_PANASONIC,                           // panasonic
	DH_IPC_SONY,                                // sony
	DH_IPC_DYNACOLOR,                           // Dynacolor
	DH_IPC_TCWS = 5 ,                           // TCWS	
	DH_IPC_SAMSUNG,                             // Samsung
	DH_IPC_YOKO,                                // YOKO
	DH_IPC_AXIS,                                // AXIS
	DH_IPC_SANYO,							    // sanyo       
	DH_IPC_BOSH = 10,							// Bosch
	DH_IPC_PECLO,								// PECLO
	DH_IPC_PROVIDEO,							// Provideo
	DH_IPC_ACTI,								// ACTi
	DH_IPC_VIVOTEK,								// Vivotek
	DH_IPC_ARECONT = 15,                        // Arecont
	DH_IPC_PRIVATEEH,			                // PrivateEH	
	DH_IPC_IMATEK,					            // IMatek
	DH_IPC_SHANY,                               // Shany
	DH_IPC_VIDEOTREC,                           // videorec
	DH_IPC_URA = 20,                            // Ura
	DH_IPC_BITICINO,                            // Bticino 
	DH_IPC_ONVIF,                               // Onvif protocol type
	DH_IPC_SHEPHERD,                            // Shepherd
	DH_IPC_YAAN,                                // Yaan
	DH_IPC_AIRPOINT = 25,                       // Airpoint
	DH_IPC_TYCO,                                // TYCO
	DH_IPC_XUNMEI,								// Xunmei
	DH_IPC_HIKVISION,							// HIKVISION
	DH_IPC_LG,                                  // LG
	DH_IPC_AOQIMAN = 30,                        // Aoqiman
	DH_IPC_BAOKANG,                             // baokang  
	DH_IPC_WATCHNET,                            // Watchnet
	DH_IPC_XVISION,                             // Xvision
	DH_IPC_FUSITSU,                             // Fisitu
	DH_IPC_CANON = 35,							// Canon
	DH_IPC_GE,								    // GE
	DH_IPC_Basler,								// Basler
	DH_IPC_Patro,								// Patro
	DH_IPC_CPKNC,								// CPPLUS K series
	DH_IPC_CPRNC = 40,							// CPPLUS R series
	DH_IPC_CPUNC,								// CPPLUS U series
	DH_IPC_CPPLUS,								// cpplus oem 
	DH_IPC_XunmeiS,								// XunmeiS
	DH_IPC_GDDW,									// guangdong power grid
	DH_IPC_PSIA = 45,                               // PSIA
	DH_IPC_GB2818,                                  // GB2818	
	DH_IPC_GDYX,                                    // GDYX
	DH_IPC_OTHER,                                   // custom
	DH_IPC_CPUNR,									// CPPLUS NVR
	DH_IPC_CPUAR = 50,								// CPPLUS DVR
	DH_IPC_AIRLIVE,                                 // Airlive	
	DH_IPC_NPE,										// NPE	
	DH_IPC_AXVIEW,									// AXVIEW
    DH_IPC_DFWL,                                    // DFWL
	DH_IPC_HYUNDAI = 56,							// HYUNDAI DVR
	DH_IPC_APHD,									// APHD
	DH_IPC_WELLTRANS ,								// WELLTRANS
	DH_IPC_CDJF,									// CDJF
	DH_IPC_JVC = 60,						    	// JVC
	DH_IPC_INFINOVA,								// INFINOVA
	DH_IPC_ADT,										// ADT
	DH_IPC_SIVIDI,									// SIVIDI
	DH_IPC_CPUNP,									// CPPLUS PTZ
	DH_IPC_HX = 65,									// HX
	DH_IPC_TJGS,                                    // TJGS
    DH_IPC_MULTICAST = 79,                          // Multicast
    DH_IPC_RVI = 84,								// RVi  
}EM_IPC_TYPE;

// H264 profile rank
typedef enum __EM_H264_PROFILE_RANK
{
    	DH_PROFILE_BASELINE = 1,                 // offer I/P frame, only support progressive and CAVLC
		DH_PROFILE_MAIN,                         // offer I/P/B frame, support progressiv and interlaced,offer CAVLC and CABAC
		DH_PROFILE_EXTENDED,                     // offer I/P/B/SP/SI frame,only support progressive and CAVLC
		DH_PROFILE_HIGH,                         // FRExt,base on Main_Profile:8x8 intra prediction, custom quant, lossless video coding, more yuv
}EM_H264_PROFILE_RANK;

typedef enum __EM_DISK_TYPE
{
    DH_DISK_READ_WRITE,                          // read write disk
		DH_DISK_READ_ONLY,                       // read only disk
		DH_DISK_BACKUP,	                         // back up disk or media disk
		DH_DISK_REDUNDANT,                       // redundancy disk
		DH_DISK_SNAPSHOT,	                     // snapshot disk
}EM_DISK_TYPE;

// stream encrypt algorithm work mode
typedef enum  __EM_ENCRYPT_ALOG_WORKMODE
{
		ENCRYPT_ALOG_WORKMODE_ECB,				// ECB mode
		ENCRYPT_ALOG_WORKMODE_CBC,				// CBC mode
		ENCRYPT_ALOG_WORKMODE_CFB,				// CFB mode
		ENCRYPT_ALOG_WORKMODE_OFB,				// OFB mode
}EM_ENCRYPT_ALOG_WORKMODE;

typedef enum __EM_MOBILE_PPP_STATE
{
	MOBILE_PPP_UP = 0,							// connect has being build
	MOBILE_PPP_DOWN,							// ppp connect has being cut		
	MOBILE_PPP_CONNECTING,						// be connecting		
	MOBILE_PPP_CLOSEING,						// be closing PPP connect
} EM_MOBILE_PPP_STATE;

typedef enum __EM_3GMOBILE_STATE
{
    MOBILE_MODULE_OFF,							// means 3g net card mod is closed   		
	MOBILE_MODULE_STARTING,						// means 3g net card mod is starting
	MOBILE_MODULE_WORKING,						// means 3g net card mod is working
}EM_3GMOBILE_STATE;

typedef enum tagEM_LOGIN_SPAC_CAP_TYPE
{
    EM_LOGIN_SPEC_CAP_TCP               = 0,    // TCP login, default
    EM_LOGIN_SPEC_CAP_ANY               = 1,    // No criteria login
    EM_LOGIN_SPEC_CAP_SERVER_CONN       = 2,    // auto sign up login
    EM_LOGIN_SPEC_CAP_MULTICAST         = 3,    // multicast login, default
    EM_LOGIN_SPEC_CAP_UDP               = 4,    // UDP method login
    EM_LOGIN_SPEC_CAP_MAIN_CONN_ONLY    = 6,    // only main connection login
    EM_LOGIN_SPEC_CAP_SSL               = 7,    // SSL encryption login

    EM_LOGIN_SPEC_CAP_INTELLIGENT_BOX   = 9,    // login IVS box remote device
    EM_LOGIN_SPEC_CAP_NO_CONFIG         = 10,   // login device do not config
    EM_LOGIN_SPEC_CAP_U_LOGIN           = 11,   // USB key device login
    EM_LOGIN_SPEC_CAP_LDAP              = 12,   // LDAP login
    EM_LOGIN_SPEC_CAP_AD                = 13,   // AD¡ê¡§ActiveDirectory¡ê? login
    EM_LOGIN_SPEC_CAP_RADIUS            = 14,   // Radius  login 
    EM_LOGIN_SPEC_CAP_SOCKET_5          = 15,   // Socks5 login
    EM_LOGIN_SPEC_CAP_CLOUD             = 16,   // cloud login
    EM_LOGIN_SPEC_CAP_AUTH_TWICE        = 17,   // dual authentication loin
    EM_LOGIN_SPEC_CAP_TS                = 18,   // TS stream client login
    EM_LOGIN_SPEC_CAP_P2P               = 19,   // web private login
    EM_LOGIN_SPEC_CAP_MOBILE            = 20,   // mobile client login
    EM_LOGIN_SPEC_CAP_INVALID                   // invalid login


}EM_LOGIN_SPAC_CAP_TYPE;

/////////////////////////////////Monitor related/////////////////////////////////

// Preview type.Corresponding to CLIENT_RealPlayEx
typedef enum _RealPlayType
{
	DH_RType_Realplay = 0,						// Real-time preview
	DH_RType_Multiplay,							// Multiple-channel preview 
	DH_RType_Realplay_0,						// Real-time monitor-main stream. It is the same as DH_RType_Realplay
	DH_RType_Realplay_1,						// 1 Real-time monitor---extra stream 1
	DH_RType_Realplay_2,						// 2Real-time monitor-- extra stream 2
	DH_RType_Realplay_3,						// 3 Real-time monitor -- extra stream 3
	DH_RType_Multiplay_1,						// Multiple-channel preview-- 1-window 
	DH_RType_Multiplay_4,						// Multiple-channel preview--4-window
	DH_RType_Multiplay_8,						// Multiple-channel preview--8-window
	DH_RType_Multiplay_9,						// Multiple-channel preview--9-window
	DH_RType_Multiplay_16,						// Multiple-channel preview--16-window
	DH_RType_Multiplay_6,						// Multiple-channel preview--6-window
	DH_RType_Multiplay_12,						// Multiple-channel preview--12-window
    DH_RType_Multiplay_25,                      // Multi-window tour¡ê-25 windows
    DH_RType_Multiplay_36,                      // Multi-window preview¡ê-36 windows
} DH_RealPlayType;

/////////////////////////////////About PTZ/////////////////////////////////

// General PTZ control command
typedef enum _PTZ_ControlType
{
	DH_PTZ_UP_CONTROL = 0,						// Up
	DH_PTZ_DOWN_CONTROL,						// Down
	DH_PTZ_LEFT_CONTROL,						// Left
	DH_PTZ_RIGHT_CONTROL,						// Right
	DH_PTZ_ZOOM_ADD_CONTROL,					// +Zoom in 
	DH_PTZ_ZOOM_DEC_CONTROL,					// -Zoom out 
	DH_PTZ_FOCUS_ADD_CONTROL,					// +Zoom in 
	DH_PTZ_FOCUS_DEC_CONTROL,					// -Zoom out 
	DH_PTZ_APERTURE_ADD_CONTROL,				// + Aperture 
	DH_PTZ_APERTURE_DEC_CONTROL,				// -Aperture
    DH_PTZ_POINT_MOVE_CONTROL,					// Go to preset 
    DH_PTZ_POINT_SET_CONTROL,					// Set 
    DH_PTZ_POINT_DEL_CONTROL,					// Delete
    DH_PTZ_POINT_LOOP_CONTROL,					// Tour 
    DH_PTZ_LAMP_CONTROL							// Light and wiper 
} DH_PTZ_ControlType;

// PTZ control extensive command 
typedef enum _EXTPTZ_ControlType
{
	DH_EXTPTZ_LEFTTOP = 0x20,					// Upper left
	DH_EXTPTZ_RIGHTTOP,							// Upper right 
	DH_EXTPTZ_LEFTDOWN,							// Down left
	DH_EXTPTZ_RIGHTDOWN,						// Down right 
	DH_EXTPTZ_ADDTOLOOP,						// Add preset to tour		tour	 preset value
	DH_EXTPTZ_DELFROMLOOP,						// Delete preset in tour	tour	 preset value
    DH_EXTPTZ_CLOSELOOP,						// Delete tour				tour		
	DH_EXTPTZ_STARTPANCRUISE,					// Begin pan rotation		
	DH_EXTPTZ_STOPPANCRUISE,					// Stop pan rotation		
	DH_EXTPTZ_SETLEFTBORDER,					// Set left limit		
	DH_EXTPTZ_SETRIGHTBORDER,					// Set right limit	
	DH_EXTPTZ_STARTLINESCAN,					// Begin scanning			
    DH_EXTPTZ_CLOSELINESCAN,					// Stop scanning		
    DH_EXTPTZ_SETMODESTART,						// Start mode	mode line		
    DH_EXTPTZ_SETMODESTOP,						// Stop mode	mode line		
	DH_EXTPTZ_RUNMODE,							// Enable mode	Mode line		
	DH_EXTPTZ_STOPMODE,							// Disable mode	Mode line	
	DH_EXTPTZ_DELETEMODE,						// Delete mode	Mode line
	DH_EXTPTZ_REVERSECOMM,						// Flip
	DH_EXTPTZ_FASTGOTO,							// 3D position	X address(8192)	Y address(8192)	zoom(4)
	DH_EXTPTZ_AUXIOPEN,							// auxiliary open	Auxiliary point	
	DH_EXTPTZ_AUXICLOSE,						// Auxiliary close	Auxiliary point
	DH_EXTPTZ_OPENMENU = 0x36,					// Open dome menu 
	DH_EXTPTZ_CLOSEMENU,						// Close menu 
	DH_EXTPTZ_MENUOK,							// Confirm menu 
	DH_EXTPTZ_MENUCANCEL,						// Cancel menu 
	DH_EXTPTZ_MENUUP,							// menu up 
	DH_EXTPTZ_MENUDOWN,							// menu down
	DH_EXTPTZ_MENULEFT,							// menu left
	DH_EXTPTZ_MENURIGHT,						// Menu right 
	DH_EXTPTZ_ALARMHANDLE = 0x40,				// Alarm activate PTZ parm1:Alarm input channel;parm2:Alarm activation type  1-preset 2-scan 3-tour;parm 3:activation value,such as preset value.
	DH_EXTPTZ_MATRIXSWITCH = 0x41,				// Matrix switch parm1:monitor number(video output number);parm2:video input number;parm3:matrix number 
	DH_EXTPTZ_LIGHTCONTROL,						// Light controller
	DH_EXTPTZ_EXACTGOTO,						// 3D accurately positioning parm1:Pan degree(0~3600); parm2: tilt coordinates(0~900); parm3:zoom(1~128)
	DH_EXTPTZ_RESETZERO,                        // Reset  3D positioning as zero
	DH_EXTPTZ_MOVE_ABSOLUTELY,                  // Absolute motion control commands¡ê?param4 corresponding struct PTZ_CONTROL_ABSOLUTELY
	DH_EXTPTZ_MOVE_CONTINUOUSLY,                // Continuous motion control commands¡ê?param4 corresponding struct PTZ_CONTROL_CONTINUOUSLY
	DH_EXTPTZ_GOTOPRESET,                       // PTZ control command, at a certain speed to preset locus¡ê?parm4 corresponding struct PTZ_CONTROL_GOTOPRESET
	DH_EXTPTZ_SET_VIEW_RANGE = 0x49,           	// Set to horizon(param4 corresponding struct PTZ_VIEW_RANGE_INFO)
	DH_EXTPTZ_FOCUS_ABSOLUTELY = 0x4A,         	// Absolute focus(param4 corresponding struct PTZ_FOCUS_ABSOLUTELY)
	DH_EXTPTZ_HORSECTORSCAN = 0x4B,             // Level fan sweep(param4 corresponding PTZ_CONTROL_SECTORSCAN,param1?¡éparam2?¡éparam3 is invalid)
	DH_EXTPTZ_VERSECTORSCAN = 0x4C,             // Vertical sweep fan(param4correspondingPTZ_CONTROL_SECTORSCAN,param1?¡éparam2?¡éparam3 is invalid)
	DH_EXTPTZ_SET_ABS_ZOOMFOCUS = 0x4D,         // Set absolute focus, focus on value, param1 for focal length, range: [0255], param2 as the focus, scope: [0255], param3, param4 is invalid
    DH_EXTPTZ_SET_FISHEYE_EPTZ = 0x4E,          // Control fish eye PTZ¡ê?param4corresponding to structure PTZ_CONTROL_SET_FISHEYE_EPTZ 
    DH_EXTPTZ_SET_TRACK_START = 0x4F,           // Track start control(param4 corresponding to structure  PTZ_CONTROL_SET_TRACK_CONTROL,dwStop set as FALSE£¬ param1¡¢param2¡¢param3 is invalid)
    DH_EXTPTZ_SET_TRACK_STOP = 0x50,            // Track stop control (param4 corresponding to structure PTZ_CONTROL_SET_TRACK_CONTROL,dwStop set as FALSE£¬param1¡¢param2¡¢param3  is invalid)

	DH_EXTPTZ_UP_TELE = 0x70,					// Up + TELE param1=speed (1-8) 
	DH_EXTPTZ_DOWN_TELE,						// Down + TELE
	DH_EXTPTZ_LEFT_TELE,						// Left + TELE
	DH_EXTPTZ_RIGHT_TELE,						// Right + TELE
	DH_EXTPTZ_LEFTUP_TELE,						// Upper left + TELE
	DH_EXTPTZ_LEFTDOWN_TELE,					// Down left + TELE
	DH_EXTPTZ_TIGHTUP_TELE,						// Upper right + TELE
	DH_EXTPTZ_RIGHTDOWN_TELE,					// Down right + TELE
	DH_EXTPTZ_UP_WIDE,							// Up + WIDE param1=speed (1-8) 
	DH_EXTPTZ_DOWN_WIDE,						// Down + WIDE
	DH_EXTPTZ_LEFT_WIDE,						// Left + WIDE
	DH_EXTPTZ_RIGHT_WIDE,						// Right + WIDE
	DH_EXTPTZ_LEFTUP_WIDE,						// Upper left + WIDE
	DH_EXTPTZ_LEFTDOWN_WIDE,					// Down left+ WIDE
	DH_EXTPTZ_TIGHTUP_WIDE,						// Upper right + WIDE
	DH_EXTPTZ_RIGHTDOWN_WIDE,					// Down right + WIDE
	DH_EXTPTZ_TOTAL,							// max command value
} DH_EXTPTZ_ControlType;

// Fish eye electronic PTZ control command 
typedef enum tagNET_FISHEYE_EPTZ_CMD
{
  NET_FISHEYE_EPTZ_CMD_UNKOWN,          // unknown type 
  NET_FISHEYE_EPTZ_CMD_ZOOMIN,          // Zoom in ¡ê?dwParam1 means step length, range 1??8
  NET_FISHEYE_EPTZ_CMD_ZOOMOUT,          // Zoom out¡ê?dwParam1 means step length ¡ê? range 1??8
  NET_FISHEYE_EPTZ_CMD_UP,            // Move up¡ê?dwParam1 means step length ¡ê? range 1??8
  NET_FISHEYE_EPTZ_CMD_DOWN,           // Move down¡ê?dwParam1 means step length ¡ê? range 1??8
  NET_FISHEYE_EPTZ_CMD_LEFT,           // Move left¡ê?dwParam1 means step length ¡ê? range 1??8
  NET_FISHEYE_EPTZ_CMD_RIGHT,           // Move right¡ê?dwParam1 means step length ¡ê? range 1??8
  NET_FISHEYE_EPTZ_CMD_ROTATECLOCK,        // Auto clockwise rotation ¡ê?dwParam1 means step length ¡ê? range 1??8
  NET_FISHEYE_EPTZ_CMD_ROTATEANTICLOCK,      // Auto counterclockwise rotation¡ê?dwParam1 means step length ¡ê? range 1??8
  NET_FISHEYE_EPTZ_CMD_STOP,           // End auto rotation
  NET_FISHEYE_EPTZ_CMD_TAPVIEW,          // Display specific location, instant view¡ê?dwParam1 means eptz¡ê¡§E-PTZ ¡ê? focus coordinate¡ê?as The focus, the rectified image was in the abscissa, take the value does not exceed the rectified output image width
  // dwParam2 means eptz¡ê¡§E-PTZ ¡ê?The focus of the cordinate, the rectified image was focus on the ordinate, take the value does not exceed the rectified output image 
  NET_FISHEYE_EPTZ_CMD_SHOEREGION,        // Panel Zoom in ¡ê?wParam1 means selected rectangle center horizontal corrdinate¡ê?
  // dwParam2 means selected rectangle center horizontal coordinate¡ê?dwParam3 means selected rectangle width
  // dwParam4 means selected rectangle height
}NET_FISHEYE_EPTZ_CMD;

// Track Control Command
typedef enum tagNET_TRACK_CONTROL_CMD
{
    NET_TRACK_CONTROL_CMD_UP,                       // Move up, dwParam1 means step length range 1-8 
    NET_TRACK_CONTROL_CMD_DOWN,                     // Move down, dwParam1 means step length  range 1-8
    NET_TRACK_CONTROL_CMD_LEFT,                     // Move left, dwParam1 means step length  range 1-8
    NET_TRACK_CONTROL_CMD_RIGHT,                    // Move right, dwParam1 means step length  range 1-8
    NET_TRACK_CONTROL_CMD_SETPRESET,                // Set preset£¬dwParam1 means preset value
    NET_TRACK_CONTROL_CMD_CLEARPRESET,              // Clear preset£¬dwParam1 means preset value
    NET_TRACK_CONTROL_CMD_GOTOPRESET,               // Goto preset£¬dwParam1 means preset value
} NET_TRACK_CONTROL_CMD;

// Fish eye correction mode
typedef enum tagNET_CALIBRATE_MODE
{
  NET_FISHEYE_CALIBRATE_MODE_UNKOWN,           // unknown mode 
  NET_FISHEYE_CALIBRATE_MODE_ORIGIAL,           // Original image mode 
  NET_FISHEYE_CALIBRATE_MODE_CONFIG,           // config mode
  NET_FISHEYE_CALIBRATE_MODE_PANORAMA,          // global mode 
  NET_FISHEYE_CALIBRATE_MODE_DOUBLEPANORAMA,       // dual global mode 
  NET_FISHEYE_CALIBRATE_MODE_ORIGIALPLUSTHREEEPTZREGION, // 1+3 mode ¡ê¡§one original Fish eye plus 3 EPtz images¡ê?
  NET_FISHEYE_CALIBRATE_MODE_SINGLE,           // Single image EPtz mode ¡ê¡§only one EPtz video¡ê?
  NET_FISHEYE_CALIBRATE_MODE_FOUREPTZREGION,       // 4 image mode ¡ê¡§4??EPtz control image¡ê?
  NET_FISHEYE_CALIBRATE_MODE_NORMAL,           // normal mode 
}NET_FISHEYE_CALIBRATE_MODE;

typedef enum tagNET_FISHEYE_TYPE
{
  NET_FISHEYE_UNKOWN =0  ,        // unknown 
  NET_FISHEYE_CHIP    ,        //only support device port Fish eye correction
  NET_FISHEYE_PLUGIN   ,        //only support control Fish eye correction
  NET_FISHEYE_CHIP_PLUGIN ,        //support both
}NET_FISHEYE_TYPE;

// Fish eye installation mode 
typedef enum tagNET_FISHEYE_MOUNT_MODE
{
  NET_FISHEYE_MOUNT_MODE_UNKOWN,             // unknown mode          
  NET_FISHEYE_MOUNT_MODE_CEIL,              // ceiling mode 
  NET_FISHEYE_MOUNT_MODE_WALL,              // wall mount mode  
  NET_FISHEYE_MOUNT_MODE_FLOOR,              // ground mode  
}NET_FISHEYE_MOUNT_MODE;

/////////////////////////////////About Log /////////////////////////////////

// Log search type 
typedef enum _DH_LOG_QUERY_TYPE
{
	DHLOG_ALL = 0,								// All logs
	DHLOG_SYSTEM,								// System logs 
	DHLOG_CONFIG,								// Configuration logs 
	DHLOG_STORAGE,								// Storage logs
	DHLOG_ALARM,								// Alarm logs 
	DHLOG_RECORD,								// Record related
	DHLOG_ACCOUNT,								// Account related
	DHLOG_CLEAR,								// Clear log 
	DHLOG_PLAYBACK,								// Playback related 
	DHLOG_MANAGER                               // Concerning the front-end management and running
} DH_LOG_QUERY_TYPE;

// Log Type
typedef enum _DH_LOG_TYPE
{
	DH_LOG_REBOOT = 0x0000,						// Device reboot 
	DH_LOG_SHUT,								// Shut down device 
    DH_LOG_REPORTSTOP,
    DH_LOG_REPORTSTART,
	DH_LOG_UPGRADE = 0x0004,					// Device Upgrade
	DH_LOG_SYSTIME_UPDATE = 0x0005,             // system time update
	DH_LOG_GPS_TIME_UPDATE = 0x0006,			// GPS time update
	DH_LOG_AUDIO_TALKBACK,	  					// Voice intercom, true representative open, false on behalf of the closed
	DH_LOG_COMM_ADAPTER,						// Transparent transmission, true representative open, false on behalf of the closed
    DH_LOG_NET_TIMING,                          // Net sync
	DH_LOG_CONFSAVE = 0x0100,					// Save configuration 
	DH_LOG_CONFLOAD,							// Read configuration 
	DH_LOG_FSERROR = 0x0200,					// File system error
	DH_LOG_HDD_WERR,							// HDD write error 
	DH_LOG_HDD_RERR,							// HDD read error
	DH_LOG_HDD_TYPE,							// Set HDD type 
	DH_LOG_HDD_FORMAT,							// Format HDD
	DH_LOG_HDD_NOSPACE,							// Current working HDD space is not sufficient
	DH_LOG_HDD_TYPE_RW,							// Set HDD type as read-write 
	DH_LOG_HDD_TYPE_RO,							// Set HDD type as read-only
	DH_LOG_HDD_TYPE_RE,							// Set HDD type as redundant 
	DH_LOG_HDD_TYPE_SS,							// Set HDD type as snapshot
	DH_LOG_HDD_NONE,							// No HDD
	DH_LOG_HDD_NOWORKHDD,						// No work HDD
	DH_LOG_HDD_TYPE_BK,							// Set HDD type to backup HDD
	DH_LOG_HDD_TYPE_REVERSE,					// Set HDD type to reserve subarea
	DH_LOG_HDD_START_INFO = 0x20e ,             // note the boot-strap's hard disk info
	DH_LOG_HDD_WORKING_DISK,                    // note the disk number after the disk change
	DH_LOG_HDD_OTHER_ERROR,                     // note other errors of disk
	DH_LOG_HDD_SLIGHT_ERR,						// there has some little errors on disk
	DH_LOG_HDD_SERIOUS_ERR,                     // there has some serious errors on disk
	DH_LOG_HDD_NOSPACE_END,                     // the end of the alarm that current disk has no space left 
	DH_LOG_HDD_TYPE_RAID_CONTROL,               // Raid control
	DH_LOG_HDD_TEMPERATURE_HIGH,				// excess temperature
	DH_LOG_HDD_TEMPERATURE_LOW,					//  lower die temperature
	DH_LOG_HDD_ESATA_REMOVE,					// remove eSATA
	DH_LOG_ALM_IN = 0x0300,						// External alarm begin 
	DH_LOG_NETALM_IN,							// Network alarm input 
	DH_LOG_ALM_END = 0x0302,					// External input alarm stop 
	DH_LOG_LOSS_IN,								// Video loss alarm begin 
	DH_LOG_LOSS_END,							// Video loss alarm stop
	DH_LOG_MOTION_IN,							// Motion detection alarm begin 
	DH_LOG_MOTION_END,							// Motion detection alarm stop 
	DH_LOG_ALM_BOSHI,							// Annunciator alarm input 
	DH_LOG_NET_ABORT = 0x0308,					// Network disconnected 
	DH_LOG_NET_ABORT_RESUME,					// Network connection restore 
	DH_LOG_CODER_BREAKDOWN,						// Encoder error
	DH_LOG_CODER_BREAKDOWN_RESUME,				// Encoder error restore 
	DH_LOG_BLIND_IN,							// Camera masking 
	DH_LOG_BLIND_END,							// Restore camera masking 
	DH_LOG_ALM_TEMP_HIGH,						// High temperature 
	DH_LOG_ALM_VOLTAGE_LOW,						// Low voltage
	DH_LOG_ALM_BATTERY_LOW,						// Battery capacity is not sufficient 
	DH_LOG_ALM_ACC_BREAK,						// ACC power off 
    DH_LOG_ALM_ACC_RES,
	DH_LOG_GPS_SIGNAL_LOST,						// GPS signal lost
	DH_LOG_GPS_SIGNAL_RESUME,					// GPS signal resume
	DH_LOG_3G_SIGNAL_LOST,						// 3G signal lost
	DH_LOG_3G_SIGNAL_RESUME,					// 3G signal resume
    DH_LOG_ALM_IPC_IN,							// IPC external alarms
	DH_LOG_ALM_IPC_END,							// IPC external alarms recovery
	DH_LOG_ALM_DIS_IN,							// Broken network alarm
	DH_LOG_ALM_DIS_END,							// Broken network alarm recovery
	DH_LOG_ALM_UPS_IN, 				            // UPS alarm 
    DH_LOG_ALM_UPS_END, 				        // UPS alarm resume 
    DH_LOG_ALM_NAS_IN,				            // NAS server abnormal alarm 
    DH_LOG_ALM_NAS_END,				            // NAS server abnormal alarm resume 
    DH_LOG_ALM_REDUNDANT_POWER_IN,              // Redundant power alarm 
    DH_LOG_ALM_REDUNDANT_POWER_END,             // Redundant alarm resume  
    DH_LOG_ALM_RECORD_FAILED_IN,				// Record failure alarm 
    DH_LOG_ALM_RECORD_FAILED_END,			    // Record failure alarm resume 
    DH_LOG_ALM_VGEXCEPT_IN,				        // Storage pool abnormal alarm 
    DH_LOG_ALM_VGEXCEPT_END,				    // Storage abnormal alarm resume 		
    DH_LOG_ALM_FANSPEED_IN,			            // Fan alarm starts
    DH_LOG_ALM_FANSPEED_END,			        // Fan alarm stops 
    DH_LOG_ALM_DROP_FRAME_IN,			        // Frame loss alarm starts 
    DH_LOG_ALM_DROP_FRAME_END,			        // Frame loss alarm stops
    DH_LOG_ALM_DISK_STATE_CHECK,		        // HDD pre-check tour alarm event log type 
    DH_LOG_ALARM_COAXIAL_SMOKE,		            // HDCVI smoke alarm event
    DH_LOG_ALARM_COAXIAL_TEMP_HIGH,	            // HDCVI temperature alarm event 
    DH_LOG_ALARM_COAXIAL_ALM_IN,		        // HDCVI external alarm event 
	DH_LOG_INFRAREDALM_IN = 0x03a0,				// Wireless alarm begin 
	DH_LOG_INFRAREDALM_END,						// Wireless alarm end 
	DH_LOG_IPCONFLICT,							// IP conflict 
	DH_LOG_IPCONFLICT_RESUME,					// IP restore
	DH_LOG_SDPLUG_IN,							// SD Card insert
	DH_LOG_SDPLUG_OUT,							// SD Card Pull-out
	DH_LOG_NET_PORT_BIND_FAILED,				// Failed to bind port
	DH_LOG_HDD_BEEP_RESET,                      // Hard disk error beep reset 
	DH_LOG_MAC_CONFLICT,                        // MAC conflict
	DH_LOG_MAC_CONFLICT_RESUME,                 // MAC conflict resume
	DH_LOG_ALARM_OUT,							// alarm out
	DH_LOG_ALM_RAID_STAT_EVENT,                 // RAID state event    
	DH_LOG_ABLAZE_ON,				            // Fire alarm, smoker or high temperature
	DH_LOG_ABLAZE_OFF,			                // Fire alarm reset 
	DH_LOG_INTELLI_ALARM_PLUSE,					// Intelligence pulse alarm
	DH_LOG_INTELLI_ALARM_IN,					// Intelligence alarm start
	DH_LOG_INTELLI_ALARM_END,					// Intelligence alarm end
	DH_LOG_3G_SIGNAL_SCAN,						// 3G signal scan
	DH_LOG_GPS_SIGNAL_SCAN,						// GPS signal scan
	DH_LOG_AUTOMATIC_RECORD = 0x0400,			// Auto record 
	DH_LOG_MANUAL_RECORD = 0x0401,				// Manual record 
	DH_LOG_CLOSED_RECORD,						// Stop record 
	DH_LOG_LOGIN = 0x0500,						// Log in 
	DH_LOG_LOGOUT,								// Log off 
	DH_LOG_ADD_USER,							// Add user
	DH_LOG_DELETE_USER,							// Delete user
	DH_LOG_MODIFY_USER,							// Modify user 
	DH_LOG_ADD_GROUP,							// Add user group 
	DH_LOG_DELETE_GROUP,						// Delete user group 
	DH_LOG_MODIFY_GROUP,						// Modify user group 
	DH_LOG_NET_LOGIN = 0x0508,					// Network Login
	DH_LOG_MODIFY_PASSWORD,						// Modify password
	DH_LOG_CLEAR = 0x0600,						// Clear log 
	DH_LOG_SEARCHLOG,							// Search log 
	DH_LOG_SEARCH = 0x0700,						// Search record 
	DH_LOG_DOWNLOAD,							// Record download
	DH_LOG_PLAYBACK,							// Record playback
	DH_LOG_BACKUP,								// Backup recorded file 
	DH_LOG_BACKUPERROR,							// Failed to backup recorded file
	DH_LOG_BACK_UPRT,							// Real-time backup, that is, copy CD
	DH_LOG_BACKUPCLONE,							//CD copy
	DH_LOG_DISK_CHANGED,						// Manual changed
	DH_LOG_IMAGEPLAYBACK,						// Image playback
	DH_LOG_LOCKFILE,							// Lock the video
	DH_LOG_UNLOCKFILE,							// Unlock the video
	DH_LOG_ATMPOS,								// Add log superposition of ATM card number
	DH_PLAY_PAUSE,								// Pause
	DH_PLAY_START,								// Start
	LOG_PLAY_STOP,								// Stop
	LOG_PLAY_BACK,								// Back
	LOG_PLAY_FAST,								// Fast
	LOG_PLAY_SLOW,								// Slow
	LOG_SMART_SEARCH,							// Search
	LOG_RECORD_SNAP,							// Snap
	LOG_ADD_TAG,								// Add tag
	LOG_DEL_TAG,								// Delete tag
	LOG_USB_IN,									// USB connected
	LOG_USB_OUT,								// USB disconnected
	LOG_BACKUP_FILE,							// Backup file
	LOG_BACKUP_LOG,								// Backup log
	LOG_BACKUP_CONFIG,							// Backup config

    DH_LOG_TIME_UPDATE  = 0x0800,               // Time update
    DH_LOG_REMOTE_STATE = 0x0850,               // remote diary 
    DH_LOG_USER_DEFINE = 0x0900,
	DH_LOG_TYPE_NR = 10,
} DH_LOG_TYPE;

// Extensive log type. Correponding to CLIENT_QueryLogEx, Condition (int nType = 1; parameter reserved = &nType)
typedef enum _DH_NEWLOG_TYPE
{
	DH_NEWLOG_REBOOT = 0x0000,					// Device reboot 
	DH_NEWLOG_SHUT,								// Shut down device
    DH_NEWLOG_REPORTSTOP,
    DH_NEWLOG_REPORTSTART,
	DH_NEWLOG_UPGRADE = 0x0004,					// Device upgrade
	DH_NEWLOG_SYSTIME_UPDATE = 0x0005,          // system time update
	DH_NEWLOG_GPS_TIME_UPDATE = 0x0006,			// GPS time update

	DH_NEWLOG_AUDIO_TALKBACK,	  				// Voice intercom, true representative open, false on behalf of the closed
	DH_NEWLOG_COMM_ADAPTER,						// Transparent transmission, true representative open, false on behalf of the closed	
	DH_NEWLOG_NET_TIMING,						// NTP

	DH_NEWLOG_CONFSAVE = 0x0100,				// Save configuration 
	DH_NEWLOG_CONFLOAD,							// Read configuration 
	DH_NEWLOG_FSERROR = 0x0200,					// File system error
	DH_NEWLOG_HDD_WERR,							// HDD write error 
	DH_NEWLOG_HDD_RERR,							// HDD read error
	DH_NEWLOG_HDD_TYPE,							// Set HDD type 
	DH_NEWLOG_HDD_FORMAT,						// Format HDD
	DH_NEWLOG_HDD_NOSPACE,						// Current working HDD space is not sufficient
	DH_NEWLOG_HDD_TYPE_RW,						// Set HDD type as read-write 
	DH_NEWLOG_HDD_TYPE_RO,						// Set HDD type as read-only
	DH_NEWLOG_HDD_TYPE_RE,						// Set HDD type as redundant 
	DH_NEWLOG_HDD_TYPE_SS,						// Set HDD type as snapshot
	DH_NEWLOG_HDD_NONE,							// No HDD
	DH_NEWLOG_HDD_NOWORKHDD,					// No work HDD
	DH_NEWLOG_HDD_TYPE_BK,						// Set HDD type to backup HDD
	DH_NEWLOG_HDD_TYPE_REVERSE,					// Set HDD type to reserve subareas
	DH_NEWLOG_HDD_START_INFO = 0x20e ,          // note the boot-strap's hard disk info
	DH_NEWLOG_HDD_WORKING_DISK,                 // note the disk number after the disk change
	DH_NEWLOG_HDD_OTHER_ERROR,                  // note other errors of disk
	DH_NEWLOG_HDD_SLIGHT_ERR,					// there has some little errors on disk
	DH_NEWLOG_HDD_SERIOUS_ERR,                  // there has some serious errors on disk
	DH_NEWLOG_HDD_NOSPACE_END,                  // the end of the alarm that current disk has no space left 

	DH_NEWLOG_HDD_TYPE_RAID_CONTROL,            // Raid operation
	DH_NEWLOG_HDD_TEMPERATURE_HIGH,				// excess temperature
	DH_NEWLOG_HDD_TEMPERATURE_LOW,				// lower die temperature
	DH_NEWLOG_HDD_ESATA_REMOVE,					// remove eSATA

	DH_NEWLOG_ALM_IN = 0x0300,					// External alarm begin 
	DH_NEWLOG_NETALM_IN,						// Network alarm input 
	DH_NEWLOG_ALM_END = 0x0302,					// External input alarm stop 
	DH_NEWLOG_LOSS_IN,							// Video loss alarm begin 
	DH_NEWLOG_LOSS_END,							// Video loss alarm stop
	DH_NEWLOG_MOTION_IN,						// Motion detection alarm begin 
	DH_NEWLOG_MOTION_END,						// Motion detection alarm stop 
	DH_NEWLOG_ALM_BOSHI,						// Annunciator alarm input 
	DH_NEWLOG_NET_ABORT = 0x0308,				// Network disconnected 
	DH_NEWLOG_NET_ABORT_RESUME,					// Network connection restore 
	DH_NEWLOG_CODER_BREAKDOWN,					// Encoder error
	DH_NEWLOG_CODER_BREAKDOWN_RESUME,			// Encoder error restore 
	DH_NEWLOG_BLIND_IN,							// Camera masking 
	DH_NEWLOG_BLIND_END,						// Restore camera masking 
	DH_NEWLOG_ALM_TEMP_HIGH,					// High temperature 
	DH_NEWLOG_ALM_VOLTAGE_LOW,					// Low voltage
	DH_NEWLOG_ALM_BATTERY_LOW,					// Battery capacity is not sufficient 
	DH_NEWLOG_ALM_ACC_BREAK,					// ACC power off 
    DH_NEWLOG_ALM_ACC_RES,
	DH_NEWLOG_GPS_SIGNAL_LOST,					// GPS signal lost
	DH_NEWLOG_GPS_SIGNAL_RESUME,				// GPS signal resume
	DH_NEWLOG_3G_SIGNAL_LOST,					// 3G signal lost
	DH_NEWLOG_3G_SIGNAL_RESUME,					// 3G signal resume

	DH_NEWLOG_ALM_IPC_IN,						// IPC external alarms
	DH_NEWLOG_ALM_IPC_END,						// IPC external alarms recovery 
	DH_NEWLOG_ALM_DIS_IN,						//Broken network alarm
	DH_NEWLOG_ALM_DIS_END,						// Broken network alarm recovery

	DH_NEWLOG_INFRAREDALM_IN = 0x03a0,			// Wireless alarm begin 
	DH_NEWLOG_INFRAREDALM_END,					// Wireless alarm end 
	DH_NEWLOG_IPCONFLICT,						// IP conflict 
	DH_NEWLOG_IPCONFLICT_RESUME,				// IP restore
	DH_NEWLOG_SDPLUG_IN,						// SD Card insert
	DH_NEWLOG_SDPLUG_OUT,						// SD Card Pull-out
	DH_NEWLOG_NET_PORT_BIND_FAILED,				// Failed to bind port
	DH_NEWLOG_HDD_BEEP_RESET,                   // Hard disk error beep reset
	DH_NEWLOG_MAC_CONFLICT,                     // MAC conflict
	DH_NEWLOG_MAC_CONFLICT_RESUME,              // MAC conflict resume
	DH_NEWLOG_ALARM_OUT,						// alarm of output state
	DH_NEWLOG_ALM_RAID_STAT_EVENT,              // RAID state change
	DH_NEWLOG_ABLAZE_ON,				        // fire alarm, smoke or temperature
	DH_NEWLOG_ABLAZE_OFF,			            // fire alarm resume
	DH_NEWLOG_INTELLI_ALARM_PLUSE,				// alarm of pulse type
	DH_NEWLOG_INTELLI_ALARM_IN,					// begin of alarm
	DH_NEWLOG_INTELLI_ALARM_END,				// end of alarm
	DH_NEWLOG_3G_SIGNAL_SCAN,					// 3G signal scan
	DH_NEWLOG_GPS_SIGNAL_SCAN,					// GPS signal scan
	DH_NEWLOG_AUTOMATIC_RECORD = 0x0400,		// Auto record 
	DH_NEWLOG_MANUAL_RECORD,					// Manual record 
	DH_NEWLOG_CLOSED_RECORD,					// Stop record 
	DH_NEWLOG_LOGIN = 0x0500,					// Log in 
	DH_NEWLOG_LOGOUT,							// Log off 
	DH_NEWLOG_ADD_USER,							// Add user
	DH_NEWLOG_DELETE_USER,						// Delete user
	DH_NEWLOG_MODIFY_USER,						// Modify user 
	DH_NEWLOG_ADD_GROUP,						// Add user group 
	DH_NEWLOG_DELETE_GROUP,						// Delete user group 
	DH_NEWLOG_MODIFY_GROUP,						// Modify user group
	DH_NEWLOG_NET_LOGIN = 0x0508,				// Network user login
	DH_NEWLOG_CLEAR = 0x0600,					// Clear log 
	DH_NEWLOG_SEARCHLOG,						// Search log 
	DH_NEWLOG_SEARCH = 0x0700,					// Search record 
	DH_NEWLOG_DOWNLOAD,							// Record download
	DH_NEWLOG_PLAYBACK,							// Record playback
	DH_NEWLOG_BACKUP,							// Backup recorded file 
	DH_NEWLOG_BACKUPERROR,						// Failed to backup recorded file

	DH_NEWLOG_BACK_UPRT,						// Real-time backup, that is, copy CD
	DH_NEWLOG_BACKUPCLONE,						// CD copy
	DH_NEWLOG_DISK_CHANGED,						// Manual  changed
	DH_NEWLOG_IMAGEPLAYBACK,					// image palyback
	DH_NEWLOG_LOCKFILE,							// Lock the video
	DH_NEWLOG_UNLOCKFILE,						// Unlock the video
	DH_NEWLOG_ATMPOS,							// Add log superposition of ATM card number

	DH_NEWLOG_TIME_UPDATE  = 0x0800,            // Time update
	DH_NEWLOG_REMOTE_STATE = 0x0850,            // remote diary 

    DH_NEWLOG_USER_DEFINE = 0x0900,
    DH_NEWLOG_TYPE_NR = 10,        
} DH_NEWLOG_TYPE;

///////////////////////////////About audio talk ///////////////////////////////

// Audio encode type 
typedef enum __TALK_CODING_TYPE
{
	DH_TALK_DEFAULT = 0,						// No-head PCM
	DH_TALK_PCM = 1,							// With head PCM
	DH_TALK_G711a,								// G711a
	DH_TALK_AMR,								// AMR
	DH_TALK_G711u,								// G711u
	DH_TALK_G726,								// G726
	DH_TALK_G723_53,							// G723_53
	DH_TALK_G723_63,							// G723_63
	DH_TALK_AAC,								// AAC
	DH_TALK_OGG,                                // OGG
    DH_TALK_G729 = 10,                          // G729
    DH_TALK_MPEG2,                               // MPEG2
    DH_TALK_MPEG2_Layer2,                        // MPEG2-Layer2
    DH_TALK_G722_1,                             // G.722.1
	DH_TALK_ADPCM = 21,                         // ADPCM
	DH_TALK_MP3   = 22,							// MP3
} DH_TALK_CODING_TYPE;

// Record file type
typedef enum __NET_RECORD_TYPE
{
	NET_RECORD_TYPE_ALL,                        // All the video
	NET_RECORD_TYPE_NORMAL,                     // common  video
	NET_RECORD_TYPE_ALARM,                      // External alarm video
	NET_RECORD_TYPE_MOTION,                     // DM alarm video
}NET_RECORD_TYPE;

// Audio talk way 
typedef enum __EM_USEDEV_MODE
{
	DH_TALK_CLIENT_MODE,						// Set client-end mode to begin audio talk 
	DH_TALK_SERVER_MODE,						// Set server mode to begin audio talk 
	DH_TALK_ENCODE_TYPE,						// Set encode format for audio talk 
	DH_ALARM_LISTEN_MODE,						// Set alarm subscribe way 
	DH_CONFIG_AUTHORITY_MODE,					// Set user right to realize configuration management
	DH_TALK_TALK_CHANNEL,						// set talking channel(0~MaxChannel-1)
	DH_RECORD_STREAM_TYPE,                      // set the stream type of the record for query(0-both main and extra stream,1-only main stream,2-only extra stream)  
	DH_TALK_SPEAK_PARAM,                        // set speaking parameter,corresponding to NET_SPEAK_PARAM
	DH_RECORD_TYPE,                             // Set by time video playback and download the video file TYPE (see.net RECORD TYPE)
	DH_TALK_MODE3,								// Set voice intercom parameters of three generations of equipment and the corresponding structure NET TALK the EX
    DH_PLAYBACK_REALTIME_MODE ,                 // set real time playback function(0-off¡ê?1-on)
    DH_TALK_TRANSFER_MODE,                      // Judge the voice intercom if it was a forwarding mode, (corresponding to  NET_TALK_TRANSFER_PARAM)
    DH_TALK_VT_PARAM,                           // ÉèÖÃVT¶Ô½²²ÎÊý, ¶ÔÓ¦½á¹¹Ìå NET_VT_TALK_PARAM
    DH_TARGET_DEV_ID,                           // set target device identifier for searching system capacity information, (not zero - locate device forwards the information)
} EM_USEDEV_MODE;


typedef enum __EM_TALK_DATA_TYPE
{ 
	NET_TALK_DATA_LOCAL_AUDIO = 0,				// Local recording audio data from the library
	NET_TALK_DATA_RECV_AUDIO,					// Receiving device sending audio data
	NET_TALK_DATA_RESPOND,						// Intercom call response data
    NET_TALK_DATA_RECV_VIDEO,                   // Got device sent video data
}EM_TALK_DATA_TYPE;

typedef struct tagNET_TALK_VIDEO_FORMAT
{
	DWORD				dwSize;
	DWORD				dwCompression;			// Video compression format
	int					nFrequency;				// Video sampling frequency
}NET_TALK_VIDEO_FORMAT;
// Three generations of equipment parameters of voice intercom, corresponding to the CLIENT SetDeviceMode DH TALK MODE3 () command
typedef struct tagNET_TALK_EX
{
    DWORD               dwSize;
	int					nChannel;               // channel number 
	int                 nAudioPort;             // Audio transmission listener ports
	int					nWaitTime;              // Ms wait time, unit, use the default value is 0
    HWND				hVideoWnd;				// Visual talk video window
	NET_TALK_VIDEO_FORMAT stuVideoFmt;			// Video encode format
	char				szMulticastAddr[DH_MAX_IPADDR_LEN_EX]; // Multicast address
	WORD				wMulticastLocalPort;	// Multicast local port
	WORD				wMulticastRemotePort;	// Multicast remote port
}NET_TALK_EX;

// AMR Encode Type
typedef enum __EM_ARM_ENCODE_MODE
{
	DH_TALK_AMR_AMR475 = 1,						// AMR475
	DH_TALK_AMR_AMR515,							// AMR515
	DH_TALK_AMR_AMR59,							// AMR59
	DH_TALK_AMR_AMR67,							// AMR67
	DH_TALK_AMR_AMR74,							// AMR74
	DH_TALK_AMR_AMR795,							// AMR795
	DH_TALK_AMR_AMR102,							// AMR102
	DH_TALK_AMR_AMR122,							// AMR122
} EM_ARM_ENCODE_MODE;

typedef struct __NET_SPEAK_PARAM
{
	DWORD           dwSize;                     // struct size 
	int             nMode;                      // 0:talk back(default), 1: propaganda,from propaganda ro talk back,need afresh to configure
	int             nSpeakerChannel;            // reproducer channel
    BOOL            bEnableWait;                // Wait for device to responding or not when enable bidirectional talk. Default setup is no.TRUE:wait ;FALSE:no
} NET_SPEAK_PARAM;

//Open the forwarding mode of intercom or not 
typedef struct tagNET_TALK_TRANSFER_PARAM
{
    DWORD           dwSize;
    BOOL            bTransfer;                  // Open the forwarding mode of intercom or not, TRUE: yes, FALSE: no
}NET_TALK_TRANSFER_PARAM;

/////////////////////////////////Control Related/////////////////////////////////

// Control type    Corresponding to CLIENT_ControlDevice
typedef enum _CtrlType
{
	DH_CTRL_REBOOT = 0,							// Reboot device	
	DH_CTRL_SHUTDOWN,							// Shut down device
	DH_CTRL_DISK,								// HDD management
	DH_KEYBOARD_POWER = 3,						// Network keyboard
	DH_KEYBOARD_ENTER,
	DH_KEYBOARD_ESC,
	DH_KEYBOARD_UP,
	DH_KEYBOARD_DOWN,
	DH_KEYBOARD_LEFT,
	DH_KEYBOARD_RIGHT,
	DH_KEYBOARD_BTN0,
	DH_KEYBOARD_BTN1,
	DH_KEYBOARD_BTN2,
	DH_KEYBOARD_BTN3,
	DH_KEYBOARD_BTN4,
	DH_KEYBOARD_BTN5,
	DH_KEYBOARD_BTN6,
	DH_KEYBOARD_BTN7,
	DH_KEYBOARD_BTN8,
	DH_KEYBOARD_BTN9,
	DH_KEYBOARD_BTN10,
	DH_KEYBOARD_BTN11,
	DH_KEYBOARD_BTN12,
	DH_KEYBOARD_BTN13,
	DH_KEYBOARD_BTN14,
	DH_KEYBOARD_BTN15,
	DH_KEYBOARD_BTN16,
	DH_KEYBOARD_SPLIT,
	DH_KEYBOARD_ONE,
	DH_KEYBOARD_NINE,
	DH_KEYBOARD_ADDR,
	DH_KEYBOARD_INFO,
	DH_KEYBOARD_REC,
	DH_KEYBOARD_FN1,
	DH_KEYBOARD_FN2,
	DH_KEYBOARD_PLAY,
	DH_KEYBOARD_STOP,
	DH_KEYBOARD_SLOW,
	DH_KEYBOARD_FAST,
	DH_KEYBOARD_PREW,
	DH_KEYBOARD_NEXT,
	DH_KEYBOARD_JMPDOWN,
	DH_KEYBOARD_JMPUP,
    DH_KEYBOARD_10PLUS,
    DH_KEYBOARD_SHIFT,
    DH_KEYBOARD_BACK,
    DH_KEYBOARD_LOGIN ,                         // new network keyboard function
    DH_KEYBOARD_CHNNEL ,                        // switch video channel
	DH_TRIGGER_ALARM_IN = 100,					// Activate alarm input
	DH_TRIGGER_ALARM_OUT,						// Activate alarm output 
	DH_CTRL_MATRIX,								// Matrix control 
	DH_CTRL_SDCARD,								// SD card control(for IPC series). Please refer to HDD control
	DH_BURNING_START,							// Burner control:begin burning 
	DH_BURNING_STOP,							// Burner control:stop burning 
	DH_BURNING_ADDPWD,							// Burner control:overlay password(The string ended with '\0'. Max length is 8 bits. )
	DH_BURNING_ADDHEAD,							// Burner control:overlay head title(The string ended with '\0'. Max length is 1024 bytes. Use '\n' to Enter.)
	DH_BURNING_ADDSIGN,							// Burner control:overlay dot to the burned information(No parameter) 
	DH_BURNING_ADDCURSTOMINFO,					// Burner control:self-defined overlay (The string ended with '\0'. Max length is 1024 bytes. Use '\n' to Enter)
	DH_CTRL_RESTOREDEFAULT,						// restore device default setup 
	DH_CTRL_CAPTURE_START,						// Activate device snapshot
	DH_CTRL_CLEARLOG,							// Clear log
	DH_TRIGGER_ALARM_WIRELESS = 200,			// Activate wireless alarm (IPC series)
	DH_MARK_IMPORTANT_RECORD,					// Mark important record
	DH_CTRL_DISK_SUBAREA, 						// Network hard disk partition	
	DH_BURNING_ATTACH,							// Annex burning
	DH_BURNING_PAUSE,							// Burn Pause
	DH_BURNING_CONTINUE,						// Burn Resume
	DH_BURNING_POSTPONE,						// Burn Postponed
	DH_CTRL_OEMCTRL,							// OEM control
	DH_BACKUP_START,							// Start to device backup
	DH_BACKUP_STOP,								// Stop to device backup
	DH_VIHICLE_WIFI_ADD,						// Add WIFI configuration manually for car device
	DH_VIHICLE_WIFI_DEC,						// Delete WIFI configuration manually for car device
	DH_BUZZER_START,                            // Start to buzzer control 
	DH_BUZZER_STOP,                             // Stop to buzzer control
	DH_REJECT_USER,                             // Reject User
	DH_SHIELD_USER,                             // Shield User
	DH_RAINBRUSH,                               // Rain Brush 
	DH_MANUAL_SNAP,                             // manual snap (struct MANUAL_SNAP_PARAMETER)
	DH_MANUAL_NTP_TIMEADJUST,                   // manual ntp time adjust
	DH_NAVIGATION_SMS,                          // navigation info and note
	DH_CTRL_ROUTE_CROSSING,                     // route info
	DH_BACKUP_FORMAT,							// backup device format
	DH_DEVICE_LOCALPREVIEW_SLIPT,               // local preview split(struct DEVICE_LOCALPREVIEW_SLIPT_PARAMETER)    
	DH_CTRL_INIT_RAID,							// RAID init
	DH_CTRL_RAID,								// RAID control
	DH_CTRL_SAPREDISK,							// sapredisk control
	DH_WIFI_CONNECT,							// wifi connect(struct WIFI_CONNECT)
	DH_WIFI_DISCONNECT,							// wifi disconnect(struct WIFI_CONNECT)
	DH_CTRL_ARMED,                              // Arm/disarm operation 
	DH_CTRL_IP_MODIFY,                          // IP modify(struct DHCTRL_IPMODIFY_PARAM)                     
	DH_CTRL_WIFI_BY_WPS,                        // wps connect wifi(struct DHCTRL_CONNECT_WIFI_BYWPS)
	DH_CTRL_FORMAT_PATITION,					// format pattion (struct DH_FORMAT_PATITION)
	DH_CTRL_EJECT_STORAGE,						// eject storage device(struct DH_EJECT_STORAGE_DEVICE)
	DH_CTRL_LOAD_STORAGE,						// load storage device(struct DH_LOAD_STORAGE_DEVICE)
	DH_CTRL_CLOSE_BURNER,                       // close burner(struct NET_CTRL_BURNERDOOR) need wait 6s
	DH_CTRL_EJECT_BURNER,                       // eject burner(struct NET_CTRL_BURNERDOOR) need wait 4s
	DH_CTRL_CLEAR_ALARM,						// alarm elimination corresponding structure NET (CTRL CLEAR ALARM)
	DH_CTRL_MONITORWALL_TVINFO,					// TV wall information display corresponding structure NET (CTRL MONITORWALL TVINFO)
	DH_CTRL_START_VIDEO_ANALYSE,                //  start Intelligent VIDEO analysis (corresponding structure NET CTRL START VIDEO ANALYSE)
	DH_CTRL_STOP_VIDEO_ANALYSE,                 // STOP intelligent VIDEO analysis corresponding structure NET (CTRL STOP VIDEO ANALYSE)
	DH_CTRL_UPGRADE_DEVICE,                     //Controlled start equipment upgrades, independently complete the upgrade process by the equipment do not need to upgrade file
	DH_CTRL_MULTIPLAYBACK_CHANNALES,            // Multi-channel preview playback channel switching corresponding structure NET (CTRL MULTIPLAYBACK CHANNALES)
	DH_CTRL_SEQPOWER_OPEN,						// Turn on the switch power supply timing device output corresponding.net (CTRL SEQPOWER PARAM)
	DH_CTRL_SEQPOWER_CLOSE,						// Close the switch power supply timing device output corresponding.net (CTRL SEQPOWER PARAM)
	DH_CTRL_SEQPOWER_OPEN_ALL,					// Power timing group open the switch quantity output corresponding.net (CTRL SEQPOWER PARAM)
	DH_CTRL_SEQPOWER_CLOSE_ALL,					// Power sequence set close the switch quantity output corresponding.net (CTRL SEQPOWER PARAM)
	DH_CTRL_PROJECTOR_RISE,						// PROJECTOR up corresponding.net (CTRL PROJECTOR PARAM)
	DH_CTRL_PROJECTOR_FALL,						// PROJECTOR drop (corresponding to the.net CTRL PROJECTOR PARAM)
	DH_CTRL_PROJECTOR_STOP,						// PROJECTOR stop (corresponding to the.net CTRL PROJECTOR PARAM)
	DH_CTRL_INFRARED_KEY,						// INFRARED buttons (corresponding to the.net CTRL INFRARED KEY PARAM)
	DH_CTRL_START_PLAYAUDIO,					// Device START playback of audio file corresponding structure NET (CTRL START PLAYAUDIO)
	DH_CTRL_STOP_PLAYAUDIO,						// Equipment stop playback of audio file
	DH_CTRL_START_ALARMBELL,					// Corresponding structure NET open alarm (CTRL ALARMBELL)
	DH_CTRL_STOP_ALARMBELL,						// Close the warning signal corresponding structure NET (CTRL ALARMBELL)
	DH_CTRL_ACCESS_OPEN,						// OPEN ACCESS control - corresponding structure NET (CTRL ACCESS OPEN)	
	DH_CTRL_SET_BYPASS,							//Corresponding structure NET BYPASS function (CTRL SET BYPASS)
	DH_CTRL_RECORDSET_INSERT,					// Add records to record set number (corresponding to the.net CTRL you INSERT PARAM)
	DH_CTRL_RECORDSET_UPDATE,					// Update a record of the number (corresponding to the.net CTRL you PARAM)
	DH_CTRL_RECORDSET_REMOVE,					// According to the record set number to delete a record (corresponding to the.net CTRL you PARAM)
	DH_CTRL_RECORDSET_CLEAR,					// Remove all RECORDSET information corresponding.net (CTRL you PARAM)
	DH_CTRL_ACCESS_CLOSE,						// Entrance guard control - CLOSE corresponding structure NET (CTRL ACCESS CLOSE)
	DH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET,			// Alarm sub system activation setup(corresponding structure NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE)
    DH_CTRL_FORBID_OPEN_STROBE,                 // Disable device open gateway(corresponding to structure  NET_CTRL_FORBID_OPEN_STROBE)
    DH_CTRL_OPEN_STROBE,                        // Enable gateway(corresponding to structure  NET_CTRL_OPEN_STROBE)
    DH_CTRL_TALKING_REFUSE,                     // Talk no response(corresponding to structure  NET_CTRL_TALKING_REFUSE)
    DH_CTRL_ARMED_EX,                           // arm-disarm operation(corresponding to structure CTRL_ARM_DISARM_PARAM_EX), CTRL_ARM_DISARM_PARAM upgrade¡ê?recommended
    DH_CTRL_NET_KEYBOARD = 400,                 // Net keyboard control(corresponding to structure  DHCTRL_NET_KEYBOARD)
    DH_CTRL_AIRCONDITION_OPEN,                  // Open air conditioner(corresponding to structure  NET_CTRL_OPEN_AIRCONDITION)
    DH_CTRL_AIRCONDITION_CLOSE,                 // Close air-conditioner(corresponding to structure  NET_CTRL_CLOSE_AIRCONDITION)
    DH_CTRL_AIRCONDITION_SET_TEMPERATURE,       // Set temperature (corresponding to structure  NET_CTRL_SET_TEMPERATURE)
    DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE,    // Adjust temperature(corresponding to structure  NET_CTRL_ADJUST_TEMPERATURE)
    DH_CTRL_AIRCONDITION_SETMODE,               // Set air work mode(corresponding to structure  NET_CTRL_ADJUST_TEMPERATURE)
    DH_CTRL_AIRCONDITION_SETWINDMODE,           // Set fan mode(corresponding to structure  NET_CTRL_AIRCONDITION_SETMODE)
    DH_CTRL_RESTOREDEFAULT_EX ,                 // Recover device default and set new protocol(corresponding to structure NET_CTRL_RESTORE_DEFAULT)
                                                // Recover config and use this enumeration first, if port failed,
                                                // and CLIENT_GetLastError return NET_UNSUPPORTED, try again DH_CTRL_RESTOREDEFAULT restore config
    DH_CTRL_NOTIFY_EVENT,                       // send event to device (corresponding to  structure  NET_NOTIFY_EVENT_DATA)
    DH_CTRL_SILENT_ALARM_SET,                   // mute alarm setup
	DH_CTRL_START_PLAYAUDIOEX,                  // device start sound report(corresponding to  structure  NET_CTRL_START_PLAYAUDIOEX)
    DH_CTRL_STOP_PLAYAUDIOEX,                   // device stop sound report
    DH_CTRL_CLOSE_STROBE,                       // close gateway(corresponding to  structure  NET_CTRL_CLOSE_STROBE)
	DH_CTRL_SET_ORDER_STATE,                    // set parking reservation status (corresponding to  structure  NET_CTRL_SET_ORDER_STATE)
	DH_CTRL_RECORDSET_INSERTEX,                 // add record¡ê?get record collection no.(corresponding to NET_CTRL_RECORDSET_INSERT_PARAM)
    DH_CTRL_RECORDSET_UPDATEEX,                 // update record set no.?¡¥s record(corresponding to NET_CTRL_RECORDSET_PARAM)
    DH_CTRL_CAPTURE_FINGER_PRINT,               // fingerprint collection (corresponding to structure NET_CTRL_CAPTURE_FINGER_PRINT)
	DH_CTRL_ECK_LED_SET,                           // Parking lot entrance/exit controller LED setup(corresponding structure  NET_CTRL_ECK_LED_SET_PARAM)
    DH_CTRL_ECK_IC_CARD_IMPORT,                    // Intelligent parking system in/out device IC card info import (corresponding structure  NET_CTRL_ECK_IC_CARD_IMPORT_PARAM)
    DH_CTRL_ECK_SYNC_IC_CARD,                      // Intelligent parking system in/out device IC card info sync command, receive this command, device will delete original IC card info(corresponding structure  NET_CTRL_ECK_SYNC_IC_CARD_PARAM)
    DH_CTRL_LOWRATEWPAN_REMOVE,                    // Delete specific wireless device(corresponding structure  NET_CTRL_LOWRATEWPAN_REMOVE)
    DH_CTRL_LOWRATEWPAN_MODIFY,                    // Modify wireless device info(corresponding structure  NET_CTRL_LOWRATEWPAN_MODIFY)	
    DH_CTRL_ECK_SET_PARK_INFO,                     // Set up the vehicle spot information of the machine at the passageway of the intelligent parking system (corresponding to  NET_CTRL_ECK_SET_PARK_INFO_PARAM)
    DH_CTRL_VTP_DISCONNECT,                        // hang up the video phone (corresponding to NET_CTRL_VTP_DISCONNECT)
    DH_CTRL_UPDATE_FILES,                          // the update of the remote multimedia files (corresponding to NET_CTRL_UPDATE_FILES)
    DH_CTRL_MATRIX_SAVE_SWITCH,                    // Save up the relationship between the hyponymy matrixes (corresponding to NET_CTRL_MATRIX_SAVE_SWITCH)
    DH_CTRL_MATRIX_RESTORE_SWITCH,                 // recover the relationship between the hyponymy matrixes (corresponding to NET_CTRL_MATRIX_RESTORE_SWITCH)
    DH_CTRL_VTP_DIVERTACK,                         // video talk phone divert ack(corresponding to NET_CTRL_VTP_DIVERTACK)
    DH_CTRL_RAINBRUSH_MOVEONCE,                    // Rain-brush brush one time, efficient when set as manual mode(corresponding to NET_CTRL_RAINBRUSH_MOVEONCE)
    DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY,            // Rain-brush brush cyclic, efficient when set as manal mode(corresponding to NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
    DH_CTRL_RAINBRUSH_STOPMOVE,                    // Rain-brush stop, efficient when set as manal mode(corresponding to NET_CTRL_RAINBRUSH_STOPMOVE)
    DH_CTRL_ALARM_ACK,                             // affirm the alarm event(corresponding to NET_CTRL_ALARM_ACK)                                                   // DH_CTRL_ALARM_ACK DO NOT call this method in callback interface
    DH_CTRL_RECORDSET_IMPORT,                      // Batch import record set info (Corresponding to NET_CTRL_RECORDSET_PARAM)    
                                                   // The following commands are only for  CLIENT_ControlDeviceEx 
    DH_CTRL_THERMO_GRAPHY_ENSHUTTER = 0x10000,     // Enable or disable thermal shutter, pInBuf= NET_IN_THERMO_EN_SHUTTER*, pOutBuf= NET_OUT_THERMO_EN_SHUTTER * 
    DH_CTRL_RADIOMETRY_SETOSDMARK,                 // NET_IN_RADIOMETRY_SETOSDMARK*, pOutBuf= NET_OUT_RADIOMETRY_SETOSDMARK *    
    DH_CTRL_AUDIO_REC_START_NAME,                  // Enable audio record and get audio name, pInBuf = NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
    DH_CTRL_AUDIO_REC_STOP_NAME,                   // Close audio file and return file name, pInBuf ,NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
    DH_CTRL_SNAP_MNG_SNAP_SHOT,                    // Manual snap, pInBuf = NET_IN_SNAP_MNG_SHOT *, pOutBuf = NET_OUT_SNAP_MNG_SHOT *
    DH_CTRL_LOG_STOP,                              // Forcedly sync buffer data to the database and close the database, pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *
    DH_CTRL_LOG_RESUME,                            // Resume database, pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *
    DH_CTRL_POS_ADD,                               // Add a POS device, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
    DH_CTRL_POS_REMOVE,                            // Del a POS device, pInBuf = NET_IN_POS_REMOVE *, pOutBuf = NET_OUT_POS_REMOVE *
    DH_CTRL_POS_REMOVE_MULTI,                      // Del several POS device, pInBuf = NET_IN_POS_REMOVE_MULTI *, pOutBuf = NET_OUT_POS_REMOVE_MULTI *
    DH_CTRL_POS_MODIFY,                            // Modify a POS device, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
    DH_CTRL_SET_SOUND_ALARM,                       // Trigger alarm with sound, pInBuf = NET_IN_SOUND_ALARM *, pOutBuf = NET_OUT_SOUND_ALARM *
	DH_CTRL_AUDIO_MATRIX_SILENCE,				   // audiomatrix silence,pInBuf = NET_IN_AUDIO_MATRIX_SILENCE*,  pOutBuf =  NET_OUT_AUDIO_MATRIX_SILENCE*
    DH_CTRL_MANUAL_UPLOAD_PICTURE,                 // manual upload picture, pInBuf = NET_IN_MANUAL_UPLOAD_PICTURE *, pOutBUf = NET_OUT_MANUAL_UPLOAD_PICTURE *
    DH_CTRL_REBOOT_NET_DECODING_DEV,               // reboot network decoding device, pInBuf = NET_IN_REBOOT_NET_DECODING_DEV *, pOutBuf = NET_OUT_REBOOT_NET_DECODING_DEV *
	DH_CTRL_SET_IC_SENDER,						   // ParkingControl about setting IC Sender, pInBuf = NET_IN_SET_IC_SENDER *, pOutBuf = NET_OUT_SET_IC_SENDER * 
    DH_CTRL_SET_MEDIAKIND,                         // set the media type ,e.g. audio only,video only , audio & video ,pInBuf = NET_IN_SET_MEDIAKIND *, pOutBuf = NET_OUT_SET_MEDIAKIND *
	DH_CTRL_LOWRATEWPAN_ADD,                       // Add wireless device info(corresponding structure  NET_CTRL_LOWRATEWPAN_ADD)
	DH_CTRL_LOWRATEWPAN_REMOVEALL,                 // remove all the wireless device info(corresponding structure  NET_CTRL_LOWRATEWPAN_REMOVEALL)
	DH_CTRL_SET_DOOR_WORK_MODE,                    // Set the work mode of door(corresponding structure NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE)
} CtrlType;

// the parameter of saving the relationship between the hyponymy matrixes(corresponding to DH_CTRL_MATRIX_SAVE_SWITCH)
typedef struct tagNET_CTRL_MATRIX_SAVE_SWITCH 
{
    DWORD           dwSize;
    const char*     pszName;                        //the relationship between the hyponymy matrixes
} NET_CTRL_MATRIX_SAVE_SWITCH;

// recover the relationship between the hyponymy matrixes (corresponding to DH_CTRL_MATRIX_RESTORE_SWITCH)
typedef struct tagNET_CTRL_MATRIX_RESTORE_SWITCH
{
    DWORD           dwSize;
    const char*     pszName;                        // the relationship between the hyponymy matrixes
} NET_CTRL_MATRIX_RESTORE_SWITCH;

// Restore default config new protocol input parameter
typedef struct tagNET_CTRL_RESTORE_DEFAULT
{
    DWORD			dwSize;
    const char*		szCfgNames;		// Config name and'&&' as interval, config see dhconfigsdk.h CLIENT_GetNewDevConfig and CLIENT_SetNewDevConfig port command 
}NET_CTRL_RESTORE_DEFAULT;

// Open air-conditioner parameter(corresponding to DH_CTRL_AIRCONDITION_OPEN)
typedef struct tagNET_CTRL_OPEN_AIRCONDITION
{
    DWORD               dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// Device SN
} NET_CTRL_OPEN_AIRCONDITION;

// Close air-conditioner parameter(corresponding to command DH_CTRL_AIRCONDITION_CLOSE)
typedef struct tagNET_CTRL_CLOSE_AIRCONDITION
{
    DWORD               dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// Device SN
} NET_CTRL_CLOSE_AIRCONDITION;

// Set temperature parameter (corresponding command DH_CTRL_AIRCONDITION_SET_TEMPERATURE)
typedef struct tagNET_CTRL_SET_TEMPERATURE
{
    DWORD               dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// SN 
    int                 nTemperature;                           // Temperature value(??)
} NET_CTRL_SET_TEMPERATURE;

// Adjust temperature parameter(corresponding command DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE)
typedef struct tagNET_CTRL_ADJUST_TEMPERATURE
{
    DWORD               dwSize;
    char				szDeviceID[DH_MAX_DEV_ID_LEN];			// SN 
    int                 nTemperatureScale;                      // Set value
} NET_CTRL_ADJUST_TEMPERATURE;

// Set air condition working mode parameter (corresponding command DH_CTRL_AIRCONDITION_SETMODE)
typedef struct tagNET_CTRL_AIRCONDITION_SETMODE
{
    DWORD                       dwSize;
    char				        szDeviceID[DH_MAX_DEV_ID_LEN];	// SN 
    EM_AIRCONDITION_MODE        emAirconditionMode;             // Air conditioner working mode
    int                         nTemperature;                   // Set value (??)
} NET_CTRL_AIRCONDITION_SETMODE;

// Set fan mode parameter(corresponding command DH_CTRL_AIRCONDITION_SETWINDMODE)
typedef struct tagNET_CTRL_AIRCONDITION_SETWINDMODE
{
    DWORD                       dwSize;
    char				        szDeviceID[DH_MAX_DEV_ID_LEN];	// SN 
    EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;         // Fan mode¨º?
} NET_CTRL_AIRCONDITION_SETWINDMODE;

// IO control command. Corresponding to CLIENT_QueryIOControlState
typedef enum _IOTYPE
{
	DH_ALARMINPUT = 1,							// Control alarm input 
	DH_ALARMOUTPUT = 2,							// ontrol alarm output 
	DH_DECODER_ALARMOUT = 3,					// Control alarm decoder output 
	DH_WIRELESS_ALARMOUT = 5,					// Control wireless alarm output 
	DH_ALARM_TRIGGER_MODE = 7,					// Alarm activation type(auto/manual/close). Use TRIGGER_MODE_CONTROL structure 
} DH_IOTYPE;

/////////////////////////////////Configuration Related/////////////////////////////////

// Resolution enumeration. For DH_DSP_ENCODECAP to use 
typedef enum _CAPTURE_SIZE
{
	CAPTURE_SIZE_D1,							// 704*576(PAL)  704*480(NTSC)
	CAPTURE_SIZE_HD1,							// 352*576(PAL)  352*480(NTSC)
	CAPTURE_SIZE_BCIF,							// 704*288(PAL)  704*240(NTSC)
	CAPTURE_SIZE_CIF,							// 352*288(PAL)  352*240(NTSC)
	CAPTURE_SIZE_QCIF,							// 176*144(PAL)  176*120(NTSC)
	CAPTURE_SIZE_VGA,							// 640*480
	CAPTURE_SIZE_QVGA,							// 320*240
	CAPTURE_SIZE_SVCD,							// 480*480
	CAPTURE_SIZE_QQVGA,							// 160*128
	CAPTURE_SIZE_SVGA,							// 800*592
	CAPTURE_SIZE_XVGA,							// 1024*768
	CAPTURE_SIZE_WXGA,							// 1280*800
	CAPTURE_SIZE_SXGA,							// 1280*1024  
	CAPTURE_SIZE_WSXGA,							// 1600*1024  
	CAPTURE_SIZE_UXGA,							// 1600*1200
	CAPTURE_SIZE_WUXGA,							// 1920*1200
	CAPTURE_SIZE_LTF,							// 240*192
	CAPTURE_SIZE_720,							// 1280*720
	CAPTURE_SIZE_1080,							// 1920*1080
	CAPTURE_SIZE_1_3M,							// 1280*960
	CAPTURE_SIZE_2M,							// 1872*1408
	CAPTURE_SIZE_5M,							// 3744*1408
	CAPTURE_SIZE_3M,							// 2048*1536
	CAPTURE_SIZE_5_0M,                          // 2432*2050
	CPTRUTE_SIZE_1_2M,							// 1216*1024
	CPTRUTE_SIZE_1408_1024,                     // 1408*1024
	CPTRUTE_SIZE_8M,                            // 3296*2472
	CPTRUTE_SIZE_2560_1920,                     // 2560*1920(5M)
	CAPTURE_SIZE_960H,                          // 960*576(PAL) 960*480(NTSC)
	CAPTURE_SIZE_960_720,                       // 960*720
	CAPTURE_SIZE_NHD,							// 640*360
	CAPTURE_SIZE_QNHD,							// 320*180
	CAPTURE_SIZE_QQNHD,							// 160*90
	CAPTURE_SIZE_960_540,						// 960*540
	CAPTURE_SIZE_640_352,						// 640*352
	CAPTURE_SIZE_640_400,						// 640*400
	CAPTURE_SIZE_320_192,						// 320*192	
	CAPTURE_SIZE_320_176,						// 320*176
	CAPTURE_SIZE_NR=255  
} CAPTURE_SIZE;

// Configuration file type. For CLIENT_ExportConfigFile to use. 
typedef enum __DH_CONFIG_FILE_TYPE
{
	DH_CONFIGFILE_ALL = 0,						// All configuration file 
	DH_CONFIGFILE_LOCAL,						// Local configuration file 
	DH_CONFIGFILE_NETWORK,						// Network configuration file 
	DH_CONFIGFILE_USER,							// User configuration file 
} DH_CONFIG_FILE_TYPE;

// NTP
typedef enum __DH_TIME_ZONE_TYPE
{
	DH_TIME_ZONE_0,								// {0, 0*3600,"GMT+00:00"}
	DH_TIME_ZONE_1,								// {1, 1*3600,"GMT+01:00"}
	DH_TIME_ZONE_2,								// {2, 2*3600,"GMT+02:00"}
	DH_TIME_ZONE_3,								// {3, 3*3600,"GMT+03:00"}
	DH_TIME_ZONE_4,								// {4, 3*3600+1800,"GMT+03:30"}
	DH_TIME_ZONE_5,								// {5, 4*3600,"GMT+04:00"}
	DH_TIME_ZONE_6,								// {6, 4*3600+1800,"GMT+04:30"}
	DH_TIME_ZONE_7,								// {7, 5*3600,"GMT+05:00"}
	DH_TIME_ZONE_8,								// {8, 5*3600+1800,"GMT+05:30"}
	DH_TIME_ZONE_9,								// {9, 5*3600+1800+900,"GMT+05:45"}
	DH_TIME_ZONE_10,							// {10, 6*3600,"GMT+06:00"}
	DH_TIME_ZONE_11,							// {11, 6*3600+1800,"GMT+06:30"}
	DH_TIME_ZONE_12,							// {12, 7*3600,"GMT+07:00"}
	DH_TIME_ZONE_13,							// {13, 8*3600,"GMT+08:00"}
	DH_TIME_ZONE_14,							// {14, 9*3600,"GMT+09:00"}
	DH_TIME_ZONE_15,							// {15, 9*3600+1800,"GMT+09:30"}
	DH_TIME_ZONE_16,							// {16, 10*3600,"GMT+10:00"}
	DH_TIME_ZONE_17,							// {17, 11*3600,"GMT+11:00"}
	DH_TIME_ZONE_18,							// {18, 12*3600,"GMT+12:00"}
	DH_TIME_ZONE_19,							// {19, 13*3600,"GMT+13:00"}
	DH_TIME_ZONE_20,							// {20, -1*3600,"GMT-01:00"}
	DH_TIME_ZONE_21,							// {21, -2*3600,"GMT-02:00"}
	DH_TIME_ZONE_22,							// {22, -3*3600,"GMT-03:00"}
	DH_TIME_ZONE_23,							// {23, -3*3600-1800,"GMT-03:30"}
	DH_TIME_ZONE_24,							// {24, -4*3600,"GMT-04:00"}
	DH_TIME_ZONE_25,							// {25, -5*3600,"GMT-05:00"}
	DH_TIME_ZONE_26,							// {26, -6*3600,"GMT-06:00"}
	DH_TIME_ZONE_27,							// {27, -7*3600,"GMT-07:00"}
	DH_TIME_ZONE_28,							// {28, -8*3600,"GMT-08:00"}
	DH_TIME_ZONE_29,							// {29, -9*3600,"GMT-09:00"}
	DH_TIME_ZONE_30,							// {30, -10*3600,"GMT-10:00"}
	DH_TIME_ZONE_31,							// {31, -11*3600,"GMT-11:00"}
	DH_TIME_ZONE_32,							// {32, -12*3600,"GMT-12:00"}
} DH_TIME_ZONE_TYPE;

typedef enum _SNAP_TYPE
{
	SNAP_TYP_TIMING = 0,
	SNAP_TYP_ALARM,
	SNAP_TYP_NUM,
} SNAP_TYPE;

typedef enum _CONNECT_STATE
{
	CONNECT_STATE_UNCONNECT  = 0,
	CONNECT_STATE_CONNECTING,
	CONNECT_STATE_CONNECTED,
	CONNECT_STATE_ERROR = 255,
} CONNECT_STATE;

// Snap mode
typedef enum tagDH_TRAFFIC_SNAP_MODE
{	
	DH_TRAFFIC_SNAP_MODE_COIL = 1,				       // Loop snap
	DH_TRAFFIC_SNAP_MODE_COIL_PICANALYSIS,		       // Loop snap   picture analysis
	DH_TRAFFIC_SNAP_MODE_STREAM,				       // Video snap
	DH_TRAFFIC_SNAP_MODE_STREAM_IDENTIFY,		       // Video snap and recognize
} DH_TRAFFIC_SNAP_MODE;

// carport light type
typedef enum 
{
	NET_CARPORTLIGHT_TYPE_RED,                           // red
	NET_CARPORTLIGHT_TYPE_GREEN,                         // green
}NET_CARPORTLIGHT_TYPE;

// carport light mode
typedef enum
{
	NET_CARPORTLIGHT_MODE_OFF,                           // off 
	NET_CARPORTLIGHT_MODE_ON,                            // on
	NET_CARPORTLIGHT_MODE_GLINT,                         // glint
}NET_CARPORTLIGHT_MODE;

/////////////////////////////////Intelligent transportation related/////////////////////////////////
//Black and white list type operation
typedef enum _EM_OPERATE_TYPE
{
	NET_TRAFFIC_LIST_INSERT	    ,								// Increase the record operation
	NET_TRAFFIC_LIST_UPDATE		,								// Record update operation
	NET_TRAFFIC_LIST_REMOVE		,								// Delete the record operation
	NET_TRAFFIC_LIST_MAX		,
}EM_RECORD_OPERATE_TYPE ;

//License plate type
typedef enum _EM_NET_PLATE_TYPE
{
	NET_PLATE_TYPE_UNKNOWN					,
	NET_PLATE_TYPE_NORMAL					,		// "Normal" Blue card black card
	NET_PLATE_TYPE_YELLOW					,		// "Yellow" yellow card
	NET_PLATE_TYPE_DOUBLEYELLOW				,		// "DoubleYellow" Double yellow back card
	NET_PLATE_TYPE_POLICE					,		// "Police" Police card
	NET_PLATE_TYPE_ARMED					,		// "Armed" Armed card
	NET_PLATE_TYPE_MILITARY					,		// "Military" Force plate
	NET_PLATE_TYPE_DOUBLEMILITARY			,		// "DoubleMilitary" Forces double
	NET_PLATE_TYPE_SAR						,		// "SAR" Hong Kong and Macao SAR plate	
	NET_PLATE_TYPE_TRAINNING				,		// "Trainning" Drivers Ed plate
	NET_PLATE_TYPE_PERSONAL					,		// "Personal" Personality plate
	NET_PLATE_TYPE_AGRI						,		// "Agri" Agri-using card
	NET_PLATE_TYPE_EMBASSY					,		// "Embassy" The embassy of plate
	NET_PLATE_TYPE_MOTO						,		// "Moto" Motorcycle plate
	NET_PLATE_TYPE_TRACTOR					,		// "Tractor" The tractor plate
	NET_PLATE_TYPE_OFFICIALCAR				,		// "OfficialCar " officer's car
	NET_PLATE_TYPE_PERSONALCAR				,		// "PersonalCar" private car
	NET_PLATE_TYPE_WARCAR					,		// "WarCar"  for military use
	NET_PLATE_TYPE_OTHER					,		// "Other" The other plate
}EM_NET_PLATE_TYPE;


//The license plate color
typedef enum _EM_NET_PLATE_COLOR_TYPE
{
	NET_PLATE_COLOR_OTHER 						,				//	other colors
	NET_PLATE_COLOR_BLUE						,				//	blue		"Blue"
	NET_PLATE_COLOR_YELLOW						,				//	yellow		"Yellow"	
	NET_PLATE_COLOR_WHITE						,				//	white		"White"
	NET_PLATE_COLOR_BLACK						,				//	black		"Black"
	NET_PLATE_COLOR_YELLOW_BOTTOM_BLACK_TEXT	,				//	 Yellow Bottom Positive Figure	"YellowbottomBlackText"
	NET_PLATE_COLOR_BLUE_BOTTOM_WHITE_TEXT		,				//	blue-mask LCD" 
	NET_PLATE_COLOR_BLACK_BOTTOM_WHITE_TEXT		,				//	White on Black	"BlackBottomWhiteText"
}EM_NET_PLATE_COLOR_TYPE;

//vehicle type
typedef enum _EM_NET_VEHICLE_TYPE
{
	NET_VEHICLE_TYPE_UNKNOW					  ,				//  unknown type
	NET_VEHICLE_TYPE_MOTOR					  ,				// "Motor" Motor vehicles"		   
	NET_VEHICLE_TYPE_NON_MOTOR				  ,				// "Non-Motor"non-Motor vehicles"		
	NET_VEHICLE_TYPE_BUS					  ,				// "Bus"bus		
	NET_VEHICLE_TYPE_BICYCLE				  ,				// "Bicycle"Bicycle		
    NET_VEHICLE_TYPE_MOTORCYCLE               ,             // "Motorcycle"        
	NET_VEHICLE_TYPE_UNLICENSEDMOTOR		  ,				// "UnlicensedMotor": A motor vehicle without a license
	NET_VEHICLE_TYPE_LARGECAR				  ,				// "LargeCar"  LargeCar
	NET_VEHICLE_TYPE_MICROCAR				  ,				// "MicroCar" MicroCar
	NET_VEHICLE_TYPE_EMBASSYCAR				  ,				// "EmbassyCar" EmbassyCa
	NET_VEHICLE_TYPE_MARGINALCAR			  ,				// "MarginalCar" MarginalCar
	NET_VEHICLE_TYPE_AREAOUTCAR				  ,				// "AreaoutCar" AreaoutCar
	NET_VEHICLE_TYPE_FOREIGNCAR				  ,				// "ForeignCar" ForeignCar
	NET_VEHICLE_TYPE_DUALTRIWHEELMOTORCYCLE	  ,				// "DualTriWheelMotorcycle"Two or three rounds of motorcycle
	NET_VEHICLE_TYPE_LIGHTMOTORCYCLE		  , 			// "LightMotorcycle"  light motorcycle
	NET_VEHICLE_TYPE_EMBASSYMOTORCYCLE		  ,				// "EmbassyMotorcycle "The embassy of the motorcycle
	NET_VEHICLE_TYPE_MARGINALMOTORCYCLE		  ,				// "MarginalMotorcycle "Consulate motorcycle
	NET_VEHICLE_TYPE_AREAOUTMOTORCYCLE		  ,				// "AreaoutMotorcycle "Outside the motorcycle
	NET_VEHICLE_TYPE_FOREIGNMOTORCYCLE		  ,				// "ForeignMotorcycle "Foreign motorcycle
	NET_VEHICLE_TYPE_FARMTRANSMITCAR		  ,				// "FarmTransmitCar" agricultural vehicle
	NET_VEHICLE_TYPE_TRACTOR				  ,				// "Tractor" tractor
	NET_VEHICLE_TYPE_TRAILER				  ,				// "Trailer"  trailer
	NET_VEHICLE_TYPE_COACHCAR				  ,				// "CoachCar "Car coach
	NET_VEHICLE_TYPE_COACHMOTORCYCLE		  ,				// "CoachMotorcycle " coach Motorcycle
	NET_VEHICLE_TYPE_TRIALCAR				  ,				// "TrialCar" trial car 
    NET_VEHICLE_TYPE_TRIALMOTORCYCLE,                   // "TrialMotorcycle "Test motorcycle
	NET_VEHICLE_TYPE_TEMPORARYENTRYCAR		  ,				// "TemporaryEntryCar"Temporary entry vehicle
	NET_VEHICLE_TYPE_TEMPORARYENTRYMOTORCYCLE ,				// "TemporaryEntryMotorcycle"Temporary entry of motorcycle
	NET_VEHICLE_TYPE_TEMPORARYSTEERCAR		  ,			    // "TemporarySteerCar"Temporary driving car
	NET_VEHICLE_TYPE_PASSENGERCAR			  ,				// "PassengerCar" passenger car
	NET_VEHICLE_TYPE_LARGETRUCK				  ,				// "LargeTruck" LargeTruck
	NET_VEHICLE_TYPE_MIDTRUCK				  ,				// "MidTruck" MidTruck
	NET_VEHICLE_TYPE_SALOONCAR				  ,				// "SaloonCar" SaloonCar
	NET_VEHICLE_TYPE_MICROBUS                 ,				// "Microbus" Microbus
	NET_VEHICLE_TYPE_MICROTRUCK				  ,				// "MicroTruck" MicroTruck
    NET_VEHICLE_TYPE_TRICYCLE				  ,				// "Tricycle" Tricycle
	NET_VEHICLE_TYPE_PASSERBY				  ,				// "Passerby" Passerby
}EM_NET_VEHICLE_TYPE;


//body color
typedef enum _EM_NET_VEHICLE_COLOR_TYPE
{
	NET_VEHICLE_COLOR_OTHER					,				//other color	
	NET_VEHICLE_COLOR_WHITE					,				//white		"White"
	NET_VEHICLE_COLOR_BLACK					,				//black		"Black"
	NET_VEHICLE_COLOR_RED					,				//red		"Red"
	NET_VEHICLE_COLOR_YELLOW				,				//yellow		"Yellow"
	NET_VEHICLE_COLOR_GRAY					,				//grey		"Gray"
	NET_VEHICLE_COLOR_BLUE					,				//blue		"Blue"
	NET_VEHICLE_COLOR_GREEN					,				//green		"Green"
	NET_VEHICLE_COLOR_PINK					,				//pink	"Pink"
	NET_VEHICLE_COLOR_PURPLE				,				//purple		"Purple"
	NET_VEHICLE_COLOR_BROWN					,				//brown		"Brown"
}EM_NET_VEHICLE_COLOR_TYPE;

//Open the coil
typedef enum _EM_NET_TRAFFIC_CAR_CONTROL_TYPE
{
	NET_CAR_CONTROL_OTHER					,
	NET_CAR_CONTROL_OVERDUE_NO_CHECK		,				// Back inspection "OverdueNoCheck"
	NET_CAR_CONTROL_BRIGANDAGE_CAR			,				//  steal "BrigandageCar"
	NET_CAR_CONTROL_BREAKING				,				// hit-and-run "CausetroubleEscape"
	NET_CAR_CONTROL_CAUSETROUBLE_ESCAPE		,				// break rules and regulations		"Breaking"
}EM_NET_TRAFFIC_CAR_CONTROL_TYPE;

typedef enum _EM_NET_AUTHORITY_TYPE
{
	NET_AUTHORITY_UNKNOW					,
	NET_AUTHORITY_OPEN_GATE					,				//c
}EM_NET_AUTHORITY_TYPE;

typedef enum _EM_NET_RECORD_TYPE
{
  NET_RECORD_UNKNOWN,

  NET_RECORD_TRAFFICREDLIST,              // Traffic white list account record
                                          // search criteria corresponding to FIND_RECORD_TRAFFICREDLIST_CONDITION structure 
                                          // record info corresponding to NET_TRAFFIC_LIST_RECORD structure 
  NET_RECORD_TRAFFICBLACKLIST,            // Traffic black list account record
                                          // search criteria corresponding to FIND_RECORD_TRAFFICREDLIST_CONDITION structure 
                                          // record info corresponding to NET_TRAFFIC_LIST_RECORD structure 
  NET_RECORD_BURN_CASE,                   // burning case record
                                          // search criteria corresponding to FIND_RECORD_BURN_CASE_CONDITION structure 
                                          // record info corresponding to NET_BURN_CASE_INFO structure 
  NET_RECORD_ACCESSCTLCARD,               // access control card
                                          // search criteria corresponding to FIND_RECORD_ACCESSCTLCARD_CONDITION structure 
                                          // record info corresponding to NET_RECORDSET_ACCESS_CTL_CARD structure 
  NET_RECORD_ACCESSCTLPWD,                // access control password
                                          // search criteria corresponding to FIND_RECORD_ACCESSCTLPWD_CONDITION structure 
                                          // record info corresponding to NET_RECORDSET_ACCESS_CTL_PWD
  NET_RECORD_ACCESSCTLCARDREC,            // access control in/out record
                                          // search criteria corresponding to FIND_RECORD_ACCESSCTLCARDREC_CONDITION structure 
                                          // record info corresponding to 
  NET_RECORD_ACCESSCTLHOLIDAY,            // holiday record set
                                          // search criteria corresponding to FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION structure 
                                          // record info corresponding to 
  NET_RECORD_TRAFFICFLOW_STATE,           // search Traffic flow record 
                                          // search criteria corresponding to FIND_RECORD_TRAFFICFLOW_CONDITION structure 
                                          // record info corresponding to NET_RECORD_TRAFFIC_FLOW_STATE structure 
  NET_RECORD_VIDEOTALKLOG,                // call record 
                                          // search criteria corresponding to FIND_RECORD_VIDEO_TALK_LOG_CONDITION structure 
                                          // record info corresponding to NET_RECORD_VIDEO_TALK_LOG structure 
  NET_RECORD_REGISTERUSERSTATE,           // status record 
                                          // search criteria corresponding to FIND_RECORD_REGISTER_USER_STATE_CONDITION structure 
                                          // record info corresponding to NET_RECORD_REGISTER_USER_STATE structure 
  NET_RECORD_VIDEOTALKCONTACT,            //contact record 
                                          // search criteria corresponding to FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION structure 
														// record info corresponding to NET_RECORD_VIDEO_TALK_CONTACT structure 
	NET_RECORD_ANNOUNCEMENT,							// Record info corresponding to structure NET_RECORD_ANNOUNCEMENT_INFO 
														// No search criteria 
														
	NET_RECORD_ALARMRECORD,								// Record info corresponding to structure NET_RECORD_ALARMRECORD_INFO 
														// No search criteria 

    NET_RECORD_COMMODITYNOTICE,                         // Issue commodiy record 
                                                        // Record info corresponding to structre NET_RECORD_COMMODITY_NOTICE 
    NET_RECORD_HEALTHCARENOTICE,                        // Medical info  
                                                        // Record info corresponding to structre NET_RECORD_HEALTH_CARE_NOTICE
    NET_RECORD_ACCESSCTLCARDREC_EX,                     // A&C entry-exit record(can select some critera to search. Please replace NET_RECORD_ACCESSCTLCARDREC)
                                                        // Search criteria corresponding to strcture FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX
                                                        // Record info corresponding to structre NET_RECORDSET_ACCESS_CTL_CARDREC

    NET_RECORD_GPS_LOCATION,                            // GPS position information reocrd, support import and clear only.
                                                        // Record info corresponding to structure NET_RECORD_GPS_LOCATION_INFO 
}EM_NET_RECORD_TYPE;

// time type
typedef enum
{
	NET_TIME_TYPE_ABSLUTE,                                  // absolute time  
	NET_TIME_TYPE_RELATIVE,                                 // Relative time, relative to the video file header frame as the time basis points, the first frame corresponding to the UTC (0000-00-00 00:00:00)
}EM_TIME_TYPE;

// color type
typedef enum
{
	NET_COLOR_TYPE_RED,                                     // red
	NET_COLOR_TYPE_YELLOW,                                  // yellow
	NET_COLOR_TYPE_GREEN,                                   // green
	NET_COLOR_TYPE_CYAN,                                    // cyan
	NET_COLOR_TYPE_BLUE,                                    // glue
	NET_COLOR_TYPE_PURPLE,                                  // purple
	NET_COLOR_TYPE_BLACK,                                   // black
	NET_COLOR_TYPE_WHITE,                                   // white
	NET_COLOR_TYPE_MAX,
}EM_COLOR_TYPE;

/////////////////////////////////Face recognition related/////////////////////////////////
// Personnel type
typedef enum 
{
	PERSON_TYPE_UNKNOWN,
	PERSON_TYPE_NORMAL,                                     // common person
	PERSON_TYPE_SUSPICION,                                  // Suspects
}EM_PERSON_TYPE;

// ID type
typedef enum
{
	CERTIFICATE_TYPE_UNKNOWN,
	CERTIFICATE_TYPE_IC,                                    // ID
	CERTIFICATE_TYPE_PASSPORT,                              // passport 
}EM_CERTIFICATE_TYPE;

// Face recognition database operations
typedef enum
{
	NET_FACERECONGNITIONDB_UNKOWN, 
	NET_FACERECONGNITIONDB_ADD,							// Add personnel information and face samples, if researchers already exists, image data and the original data
	NET_FACERECONGNITIONDB_DELETE,						// Delete the personnel information and face samples
    NET_FACERECONGNITIONDB_MODIFY,                      // Modify person info and human face sample, must input person UID
    NET_FACERECONGNITIONDB_DELETE_BY_UID,               // Delete person info and human face via UID
}EM_OPERATE_FACERECONGNITIONDB_TYPE;

// Face contrast pattern
typedef enum 
{
	NET_FACE_COMPARE_MODE_UNKOWN,
		NET_FACE_COMPARE_MODE_NORMAL,                  // normal
		NET_FACE_COMPARE_MODE_AREA,                    // Specify the face region combination area
		NET_FACE_COMPARE_MODE_AUTO,                    // Intelligent model, the algorithm according to the situation of facial regions automatically select combination
}EM_FACE_COMPARE_MODE;

// Face region
typedef enum
{
	NET_FACE_AREA_TYPE_UNKOWN,
		NET_FACE_AREA_TYPE_EYEBROW,                    // eyebrow
		NET_FACE_AREA_TYPE_EYE,                        // eye 
		NET_FACE_AREA_TYPE_NOSE,                       // nose
		NET_FACE_AREA_TYPE_MOUTH,                      // mouth
		NET_FACE_AREA_TYPE_CHEEK,                      // face
}EM_FACE_AREA_TYPE;

// face data type
typedef enum
{
	    NET_FACE_DB_TYPE_UNKOWN,
		NET_FACE_DB_TYPE_HISTORY,						// History database, storage is to detect the human face information, usually does not contain face corresponding personnel information
		NET_FACE_DB_TYPE_BLACKLIST,						// The blacklist database
		NET_FACE_DB_TYPE_WHITELIST,						// The whitelist database
		NET_FACE_DB_TYPE_ALARM  ,						// Alarm library 
}EM_FACE_DB_TYPE;

// Face recognition event type
typedef enum 
{
	NET_FACERECOGNITION_ALARM_TYPE_UNKOWN,
	NET_FACERECOGNITION_ALARM_TYPE_ALL,                // blacklist and whitelist
	NET_FACERECOGNITION_ALARM_TYPE_BLACKLIST,          // The blacklist
	NET_FACERECOGNITION_ALARM_TYPE_WHITELIST,          // The whitelist
}EM_FACERECOGNITION_ALARM_TYPE;

// Face recognition face type
typedef enum
{
	EM_FACERECOGNITION_FACE_TYPE_UNKOWN,
	EM_FACERECOGNITION_FACE_TYPE_ALL,                  // All the faces 
	EM_FACERECOGNITION_FACE_TYPE_REC_SUCCESS,          // recognition success
	EM_FACERECOGNITION_FACE_TYPE_REC_FAIL,             // recognition fail
}EM_FACERECOGNITION_FACE_TYPE;

// Frame type enumeration values  
typedef enum __EM_FRAME_TYPE
{
	EM_FRAME_UNKOWN,                                   // unknown type
	EM_FRAME_TYPE_MOTION,                              // DM frame, corresponding frame information structure NET MOTION FRAM INFO
}EM_FRAME_TYPE;

/////////////////////////////////Cancelled Type/////////////////////////////////

// Configuration type. The interface that uses the enumberaiton has been canceled. Please do not use. 
typedef enum _CFG_INDEX
{
    CFG_GENERAL = 0,							// General 
	CFG_COMM,									// COM
	CFG_NET,									// Network
	CFG_RECORD,									// Record
	CFG_CAPTURE,								// Video setup
	CFG_PTZ,									// PTZ
	CFG_DETECT,									// Motion detection
	CFG_ALARM,									// Alarm 
	CFG_DISPLAY,								// Display 
	CFG_RESERVED,								// Reserved to keet type consecutive
	CFG_TITLE = 10,								// channel title 
	CFG_MAIL = 11,								// Mail function 
	CFG_EXCAPTURE = 12,							// preview video setup
	CFG_PPPOE = 13,								// pppoe setup
	CFG_DDNS = 14,								// DDNS  setup
	CFG_SNIFFER	= 15,							// Network monitor capture setup
	CFG_DSPINFO	= 16,							// Encode capacity information
	CFG_COLOR = 126,							// Color setup information 
	CFG_ALL,									// Reserved 
} CFG_INDEX;


/************************************************************************
 ** Structure Definition 
 ***********************************************************************/
//display area relative to the original display area coordinates
typedef struct
{
    double				dleft;					//left
	double				dright;					//right
	double				dtop;					//top
	double				dbottom;				//bottom
} DH_DISPLAYRREGION;
// Time
typedef struct 
{
	DWORD				dwYear;					// Year
	DWORD				dwMonth;				// Month
	DWORD				dwDay;					// Date
	DWORD				dwHour;					// Hour
	DWORD				dwMinute;				// Minute
	DWORD				dwSecond;				// Second
} NET_TIME,*LPNET_TIME;

typedef struct 
{
	DWORD				dwYear;					// Year
	DWORD				dwMonth;				// Month
	DWORD				dwDay;					// Date
	DWORD				dwHour;					// Hour
	DWORD				dwMinute;				// Minute
	DWORD				dwSecond;				// Second
	DWORD               dwMillisecond;          // Millisecond
	DWORD               dwReserved[2];          // reserved
} NET_TIME_EX,*LPNET_TIME_EX;

// The time definition in the log information
typedef struct _DHDEVTIME
{
	DWORD				second		:6;			// Second	1-60		
	DWORD				minute		:6;			// Minute	1-60		
	DWORD				hour		:5;			// Hour		1-24		
	DWORD				day			:5;			// Date		1-31		
	DWORD				month		:4;			// Month	1-12		
	DWORD				year		:6;			// Year	2000-2063	
} DHDEVTIME, *LPDHDEVTIME;

typedef struct tagRANGE
{
    float               fMax;                               // Max value
    float               fMin;                               // Min value
    BOOL                abStep;                             // Enable step or not 
    float               fStep;                              // Step 
    BOOL                abDefault;                          // Enable default value or not 
    float               fDefault;                           // Default value 
    char reserved[16];
} RANGE;

// callback data(Asynchronous interface)
typedef struct __NET_CALLBACK_DATA 
{
	int					nResultCode;			// Result code;0:Success
	char				*pBuf;					// Receive data,buffer is opened by the user,from the interface parameters
	int					nRetLen;				// the length of receive data
	LLONG				lOperateHandle;			// Operating handle
	void*				userdata;				// User parameters
	char				reserved[16];
} NET_CALLBACK_DATA, *LPNET_CALLBACK_DATA;

///////////////////////////////Monitor Related Definition ///////////////////////////////

// Frame parameter structure of Callback video data frame 
typedef struct _tagVideoFrameParam
{
	BYTE				encode;					// Encode type 
	BYTE				frametype;				// I = 0, P = 1, B = 2...
	BYTE				format;					// PAL - 0, NTSC - 1
	BYTE				size;					// CIF - 0, HD1 - 1, 2CIF - 2, D1 - 3, VGA - 4, QCIF - 5, QVGA - 6 ,
												// SVCD - 7,QQVGA - 8, SVGA - 9, XVGA - 10,WXGA - 11,SXGA - 12,WSXGA - 13,UXGA - 14,WUXGA - 15,
	DWORD				fourcc;					// If it is H264 encode it is always 0,Fill in FOURCC('X','V','I','D') in MPEG 4;
	DWORD				reserved;				// Reserved
	NET_TIME			struTime;				// Time information 
} tagVideoFrameParam;

// Frame parameter structure of audio data callback 
typedef struct _tagCBPCMDataParam
{
	BYTE				channels;				// Track amount 
	BYTE				samples;				// sample 0 - 8000, 1 - 11025, 2 - 16000, 3 - 22050, 4 - 32000, 5 - 44100, 6 - 48000
	BYTE				depth;					// Sampling depth. Value:8/16 show directly
	BYTE				param1;					// 0 - indication no symbol,1-indication with symbol
	DWORD				reserved;				// Reserved
} tagCBPCMDataParam;

// Data structure of channel video title overlay 
typedef struct _DH_CHANNEL_OSDSTRING
{
	BOOL				bEnable;				// Enable 
	DWORD				dwPosition[MAX_STRING_LINE_LEN];//Character position in each line. The value ranges from 1 to 9.Corresponding to the small keyboard.
												//		7upper left 	8upper		9upper right 
												//		4left			5middle 	6right 
												//		1down left		2down	    3down right 
	char				szStrings[MAX_STRING_LINE_LEN][MAX_PER_STRING_LEN];	// Max 6 lines. Each line max 20 bytes.
} DH_CHANNEL_OSDSTRING;

// Para struct of YUV callback
typedef struct _tagCBYUVDataParam
{
	long				nWidth;                 // Width of image
	long				nHeight;				// Height of image
	DWORD				reserved[8];			// reserved
} tagCBYUVDataParam;

///////////////////////////////Definition relate with playback///////////////////////////////
// Type of video search
typedef enum tagEmQueryRecordType
{
    EM_RECORD_TYPE_ALL              = 0,            // All the recorded video  
    EM_RECORD_TYPE_ALARM            = 1,            // The video of external alarm
    EM_RECORD_TYPE_MOTION_DETECT    = 2,            // The video of dynamic detection alarm
    EM_RECORD_TYPE_ALARM_ALL        = 3,            // All the alarmed video
    EM_RECORD_TYPE_CARD             = 4,            // query by the card number
    EM_RECORD_TYPE_CONDITION        = 5,            // query by condition
    EM_RECORD_TYPE_JOIN             = 6,            //combination query 
    EM_RECORD_TYPE_CARD_PICTURE     = 8,            // query pictures by the card number¡ê?used by HB-U?¡éNVS
    EM_RECORD_TYPE_PICTURE          = 9,            // query pictures¡ê?used by HB-U?¡éNVS
    EM_RECORD_TYPE_FIELD            = 10,           // query by field
    EM_RECORD_TYPE_INTELLI_VIDEO   = 11,			// Smart record search 
    EM_RECORD_TYPE_NET_DATA         = 15,           // query network data¡ê?used by Jinqiao Internet Bar
    EM_RECORD_TYPE_TRANS_DATA       = 16,           // query the video of serial data
    EM_RECORD_TYPE_IMPORTANT        = 17,           // query the important video
    EM_RECORD_TYPE_TALK_DATA        = 18,           // query the recording file
    
    EM_RECORD_TYPE_INVALID          = 256,          // invalid query type
    
}EM_QUERY_RECORD_TYPE;

// Record file information
typedef struct
{
    unsigned int		ch;						// Channel number
    char				filename[124];			// File name 
	unsigned int        framenum;               // the total number of file frames
    unsigned int		size;					// File length 
    NET_TIME			starttime;				// Start time 
    NET_TIME			endtime;				// End time 
    unsigned int		driveno;				// HDD number 
    unsigned int		startcluster;			// Initial cluster number 
	BYTE				nRecordFileType;		// Recorded file type  0:general record;1:alarm record ;2:motion detection;3:card number record ;4:image 
	BYTE                bImportantRecID;		// 0:general record 1:Important record
	BYTE                bHint;					// Document Indexing
	BYTE                bRecType;               // 0-main stream record 1-sub1 stream record 2-sub2 stream record 3-sub3 stream record
} NET_RECORDFILE_INFO, *LPNET_RECORDFILE_INFO;

// info of enrichment record file 
typedef struct tagNET_SynopsisFileInfo
{
	DWORD				dwSize;					// struct size 
    char				szFileName[MAX_PATH];	// file name,like :\a.dav
    NET_TIME			stuStartTime;			// start time
    NET_TIME			stuEndTime;				// end time
	unsigned int		nTaskID;				// server mark,with szFileName[] a choise
	BYTE				bFileType;				// 1-record file, 2- source file
	BYTE				byMode;					// Download mode: 0 - by file downloads, 1 - according to the time to download, 2 - according to download file offset
	BYTE				bReserved[2];
	unsigned int		nFileLength;			// file length (byte)
	unsigned int		nStartFileOffset;		// Starting file offset, unit: KB
	unsigned int		nEndFileOffset;			// The end of the file offset, the unit: KB
    int                 nChannel;                   // Í¨µÀºÅ, NVR»Ø·Å×¨ÓÃ(Ã»ÓÐTaskID), ¶ÔÅ¨Ëõ·þÎñÆ÷ÎÞÐ§
    int                 nCluster;                   // ´ØºÅ, NVR»Ø·Å×¨ÓÃ(Ã»ÓÐTaskID), ¶ÔÅ¨Ëõ·þÎñÆ÷ÎÞÐ§
}NET_SYNOPSISFILE_INFO, *LPNET_SYNOPSISFILE_INFO;

// Playback data callback function prototype
// pBuffer: data buffer, memory malloc or free was managed by SDK interior
typedef int (CALLBACK *fDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

typedef struct __NET_MULTI_PLAYBACK_PARAM 
{
	DWORD                      dwSize; 
	int                        nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM]; // Preview the channel number
	int                        nChannelNum;                         // Preview the channel number
	int                        nType;                               // Playback file type, 0: ordinary video; 1: alarm video; 2: the mobile detection; 3: video card number; Picture 4:
	NET_TIME                   stStartTime;                         // Playback start time
	NET_TIME                   stEndTime;                           // The playback end time
	int                        nFPS;                                // Frame rate, 1 ~ 25
	int                        nBitRate;                            // Code flow values, 192 ~ 1024
	char                       szResolution[DH_MAX_CAPTURE_SIZE_NUM]; // Resolution, "D1", "HD1", "2 CIF", "CIF", "QCIF"
	int                        nWaitTime;                           // Timeout waiting time
	HWND                       hWnd;                                // Video playback window handle
	fDataCallBack              fDownLoadDataCallBack;               // Video data correction
	LDWORD                     dwDataUser;                          // 
}NET_MULTI_PLAYBACK_PARAM;

// record state of everyday in one month
typedef struct
{
	BYTE 	    flag[32];						// has record this day 0-no, 1-yes
	BYTE		Reserved[64];					// reserved
}NET_RECORD_STATUS, *LPNET_RECORD_STATUS;

// Asynchronous query results callback function prototype, nError = 0 means query success, nError = 1 said memory application failure, timeout nError = 2, nError = 3 said equipment return data validation is not through, nError = 4 send query request failed
typedef void (CALLBACK *fQueryRecordFileCallBack)(LLONG lQueryHandle, LPNET_RECORDFILE_INFO pFileinfos, int nFileNum, int nError, void *pReserved, LDWORD dwUser);

// CLIENT_StartQueryRecordFile Interface input parameters
typedef struct tagNET_IN_START_QUERY_RECORDFILE
{ 
	DWORD               dwSize;                            // The structure size
	int                 nChannelId;                        // To query the channel number
	int                 nRecordFileType;                   // For video query types
	int                 nStreamType;                       // Query stream type, 0 to advocate complementary code stream, 1 - the main stream, 2 - auxiliary stream
	NET_TIME            stStartTime;                       // Query starting time
	NET_TIME            stEndTime;                         // Query the end time
    char*               pchCardid;                         // card id information
	int                 nWaitTime;                         // Timeout waiting time, ms
	fQueryRecordFileCallBack cbFunc;                       // The query results callback function 
	LDWORD              dwUser;                            // userinfo
}NET_IN_START_QUERY_RECORDFILE;

typedef struct tagNET_OUT_START_QUERY_RECORDFILE
{
	DWORD                dwSize;                           //The structure size
	LLONG                lQueryHandle;                     //return handle    
}NET_OUT_START_QUERY_RECORDFILE;

//  function prototype of play back progress 
typedef void (CALLBACK *fDownLoadPosCallBack)(LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, LDWORD dwUser);
// record play back parameter in
typedef struct tagNET_IN_PLAY_BACK_BY_TIME_INFO
{
    NET_TIME            stStartTime;                       // Begin time
    NET_TIME            stStopTime;                        // End time
    HWND                hWnd;                              // Play window
    fDownLoadPosCallBack cbDownLoadPos;                    // Download pos callback
    LDWORD              dwPosUser;                         // Pos user
    fDataCallBack       fDownLoadDataCallBack;             // Download data callback
    LDWORD              dwDataUser;                        // Data user
    int                 nPlayDirection;                    // Playback direction
    int                 nWaittime;                         // Watiting time
    BYTE                bReserved[1024];                   // Reserved
}NET_IN_PLAY_BACK_BY_TIME_INFO;
// record play back parameter out
typedef struct tagNET_OUT_PLAY_BACK_BY_TIME_INFO
{
    BYTE                bReserved[1024];                   // ?¡è¨¢?¡Á??¨²
}NET_OUT_PLAY_BACK_BY_TIME_INFO;
typedef struct
{
	unsigned short      left;                   // 0~8192
    unsigned short      right;                  // 0~8192
    unsigned short      top;                    // 0~8192
    unsigned short      bottom;                 // 0~8192
} MotionDetectRect;

// Smart Playback Information
typedef struct 
{
	MotionDetectRect    motion_rect;             // MotionDetect area
    NET_TIME            stime;                   // PlayBack start time
    NET_TIME            etime;                   // PlayBack stop time
	BYTE                bStart;                  // 1,start,2:stop
    BYTE                reserved[116];
} IntelligentSearchPlay, *LPIntelligentSearchPlay;

// The first recording time
typedef struct  
{
	int					nChnCount;				// Channel amount
	NET_TIME			stuFurthestTime[16];	// The first recording time, valid value is 0 to (nChnCount-1).If there is no video, the first recording time is 0.
	DWORD				dwFurthestTimeAllSize;	// when channel >16,use this field.means pStuFurthestTimeAll memory size.
	NET_TIME*			pStuFurthestTimeAll;	// when channel >16,use this field.need user apply, memory size(nChnCount*sizeof(NET_TIME)).
	BYTE				bReserved[376];			// Reserved words
} NET_FURTHEST_RECORD_TIME;

// CLIENT_FindFramInfo Interface input parameters
typedef struct __NET_IN_FIND_FRAMEINFO_PRAM
{
	DWORD                 dwSize;               // The structure size 
	BOOL                  abFileName;           // Whether the file name as a valid query conditions, if the file name is valid, is don't have to fill the file information (stRecordInfo)
	char                  szFileName[MAX_PATH]; // file name
	NET_RECORDFILE_INFO   stuRecordInfo;        // file information
	DWORD                 dwFramTypeMask;       // Frame type mask, see the "frame type mask defined"
}NET_IN_FIND_FRAMEINFO_PRAM;

// CLIENT_FindFramInfo Interface input parameters
typedef struct __NET_OUT_FIND_FRAMEINFO_PRAM
{
	DWORD                 dwSize;               // The structure size 
	LLONG                 lFindHandle;          // File search handle
}NET_OUT_FIND_FRAMEINFO_PRAM;

// DM frame information
typedef struct __NET_MOTION_FRAME_INFO
{
	DWORD                 dwSize;               //  The structure size 
	NET_TIME              stuTime;              // The current frame, timestamp
	int					  nMotionRow;		    // The number of rows dynamic detection area
	int					  nMotionCol;		    // The number of columns of dynamic detection area
	BYTE				  byRegion[DH_MOTION_ROW][DH_MOTION_COL];// Detection area, up to 32 * 32 area
}NET_MOTION_FRAME_INFO;

// file frame information
typedef struct __NET_FILE_FRAME_INFO
{
	DWORD                 dwSize;               // The structure size 
	int                   nChannelId;           // channel number 
	NET_TIME              stuStartTime;         // the starting time 
	NET_TIME              stuEndTime;           // the ending time
	WORD                  wRecType;             // 0- main stream video code 1-auxiliary stream video 2 - auxiliary stream 3 auxiliary stream video
	WORD                  wFameType;            // Frame TYPE, see EM FRAM TYPE
	void*                 pFramInfo;            // Corresponding to the type of frame information, the space application by the user
}NET_FILE_FRAME_INFO;

// CLIENT_FindNextFramInfo Interface input parameters
typedef struct __NET_IN_FINDNEXT_FRAMEINFO_PRAM
{
	DWORD                 dwSize;               // The structure size
	int                   nFramCount;           // To query the frame number, 0, said all the frame information query conforms to the query conditions
}NET_IN_FINDNEXT_FRAMEINFO_PRAM;

// CLIENT_FindNextFramInfo Interface output parameters
typedef struct __NET_OUT_FINDNEXT_FRAMEINFO_PRAM
{
	DWORD                 dwSize;               // The structure size 
	NET_FILE_FRAME_INFO*   pFramInfos;           // Frame information, by the user application space, the space size of sizeof (.net FILE FRAM INFO) * nMaxFramCount
	int                   nMaxFramCount;        // The number of the frame of information in the user application
    int                   nRetFramCount;        // The actual returns the number of frame information
}NET_OUT_FINDNEXT_FRAMEINFO_PRAM;

///////////////////////////////Alarm Related Definition ///////////////////////////////

// General alarm informaiton 
typedef struct
{
	int					channelcount;
	int					alarminputcount;
	unsigned char		alarm[16];				// External alarm 
	unsigned char		motiondection[16];		// Motion detection 
	unsigned char		videolost[16];			// Video loss 
} NET_CLIENT_STATE;

// General alarm information
typedef struct
{
	int					channelcount;
	int					alarminputcount;
    unsigned char		alarm[32];				// External alarm 
	unsigned char		motiondection[32];		// Motion detection 
	unsigned char		videolost[32];			// Video loss 
	BYTE                bReserved[32];
} NET_CLIENT_STATE_EX;

// struct of input alarm
typedef struct
{
	DWORD              dwSize;
	int				   alarminputcount;
	DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
}NET_CLIENT_ALARM_STATE;

// struct of video loss alarm
typedef struct
{
	DWORD              dwSize;
	int				   channelcount;
	DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
}NET_CLIENT_VIDEOLOST_STATE;

// struct of motion alarm
typedef struct
{
	DWORD              dwSize;
	int				   channelcount;
	DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
}NET_CLIENT_MOTIONDETECT_STATE;

// struct of blind alarm
typedef struct
{
	DWORD              dwSize;
	int				   channelcount;
	DWORD              dwAlarmState[DH_MAX_CHANMASK]; //DWORD value is the state by bit of 32 channels,0-no alarm,1-alarm
}NET_CLIENT_VIDEOBLIND_STATE;

// struct of querying detailed motion alarm
typedef struct
{
	DWORD              dwSize;
	int                nChannelID;				// channel id
	BOOL               bAlarm;					// alarm or not,value is TRUE/FALSE
	int                nLevel;					// alarm level,in 1/1000 as a unit
}NET_CLIENT_DETAILEDMOTION_STATE;

// Alarm IO control 
typedef struct 
{
	unsigned short		index;					// Port serial number 
	unsigned short		state;					// Port status 
} ALARM_CONTROL;

//Activation type 
typedef struct
{
	unsigned short		index;					// Port serial number 
	unsigned short		mode;					// Activation way(0:close.1:manual.2:auto); The SDK reserves the original setup if you do not set channel here. 
	BYTE				bReserved[28];			
} TRIGGER_MODE_CONTROL;

// Alarm decoder control 
typedef struct 
{
	int					decoderNo;				// Alarm decoder. It begins from 0. 
	unsigned short		alarmChn;				// Alarm output port. It begin from o., 
	unsigned short		alarmState;				// Alarm output status;1:open,0:close.
} DECODER_ALARM_CONTROL;

// Call No-response Alarm Event
typedef struct __ALARM_NO_RESPONSE_INFO
{
	DWORD		dwSize;
	char        szCallID[DH_MAX_CALLID];                             //Call ID
}ALARM_NO_RESPONSE_INFO;

// Alarm information of alarm upload function
typedef struct  
{
	DWORD				dwAlarmType;			// Alarm type,when dwAlarmType = DH_UPLOAD_EVENT,dwAlarmMask and bAlarmDecoderIndex are invalid.
	DWORD				dwAlarmMask;			// Alarm information subnet mask. Bit represents each alarm status
	char				szGlobalIP[DH_MAX_IPADDR_LEN];				// Client-end IP address 
	char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];		// Client-end domain name
	int					nPort;					// The port client-end connected when upload alarm 
	char				szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];	// Alarm occurred time 
	BYTE				bAlarmDecoderIndex;		// It means which alarm decoder. It is valid when dwAlarmType = DH_UPLOAD_DECODER_ALARM.
	BYTE				bReservedSpace[15];
} NEW_ALARM_UPLOAD;

// Smoke alarm events, alarm center
typedef struct __ALARM_UPLOAD_SMOKESENSOR_INFO
{
	DWORD			dwSize;
	char			szGlobalIP[DH_MAX_IPADDR_LEN];				// Remote IP address
	char			szDomainName[DH_MAX_DOMAIN_NAME_LEN];		// The client domain name
	int				nPort;										// When alarm upload client connection port
	char			szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];	// The time of the alarm
	int             nChannel;									// Alarm channel Starting from 0
	BYTE            byHighTemperature;							// 1: high temperature alarm, 0: high temperature alarm
	BYTE            bySmoke;									// 1: smoke alarm, 0: smoke alarm over
}ALARM_UPLOAD_SMOKESENSOR_INFO;

// intelligent alarm center
typedef struct __ALARM_UPLOAD_IVS_INFO
{
	DWORD				dwSize;
	NET_TIME			stuTime;                                  // occur time	
	char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];	  // client domain name
	int					nChannelID;                               // channel,from 0
	char				szType[MAX_PATH];                         // alarm type,check rule
	int					nState;                                   // alarm state, 0-reset,1-setting,2-pulse
    char                szRuleName[DH_COMMON_STRING_128];         // Rule Name  
    char                szIPAddress[DH_MAX_IPADDR_LEN_EX];        // Device IP Address  
    int                 nPort;                                    // Device Port No.
    char                szMacAddress[DH_MACADDR_LEN];             // Device-end mac address
    char                szPicFilePath[MAX_PATH];                  // Picture Storage Path
    int                 nPicFileNum;                              // Current alarm folder number
    int                 nUploadPicFileNum;                        // Uploaded FTP picture  number
    DWORD               dwChannelMask;                            // Snapshot video channel mask¡ê?15 means this alarm has 1,2,3,4 channels 
} ALARM_UPLOAD_IVS_INFO;

// Alarm center external alarm extension info
typedef struct _ALARM_UPLOAD_ALARMEX_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                                    // Event time    
    char            szDomainName[DH_MAX_DOMAIN_NAME_LEN];       // Client domain name
    DWORD           dwAlarmMask;                                // Alarm info mask¡ê?by bit means each alarm channel status, 7 means 1,2,3 alarm input channel
    char            szDevMac[DH_MACADDR_LEN];                   // Device port mac address
    char            szPicFilePath[MAX_PATH];                    // Picture storage file path
    int             nPicFileNum;                                // Current alarm corresponding picture file quantity
    int             nUploadPicFileNum;                          // Uploaded FTP picture file quantity
    char            szAreaName[DH_COMMON_STRING_128];           // Zone name
    DWORD           dwChannelMask;                              // Snapshot video channel mask¡ê?15 means this alarm has 1,2,3,4 channels 
}ALARM_UPLOAD_ALARMEX_INFO;

typedef enum _EM_LOGIN_FAILED_TYPE
{
    LOGIN_FAILED_UNKNOW = 0 ,
    LOGIN_FAILED_PASSWORD   ,           //Password error
    LOGIN_FAILED_USER       ,           //User error
    LOGIN_FAILED_TIMEOUT    ,           //Time out
    LOGIN_FAILED_RELOGGIN   ,           //Relogin
    LOGIN_FAILED_LOCKED     ,           //Account locked
    LOGIN_FAILED_BLACKLIST  ,           //Account in black list
    LOGIN_FAILED_ERROR_BUSY ,           //Resource is busy
    LOGIN_FAILED_VERSION    ,           //Vesion error 
}EM_LOGIN_FAILED_TYPE;

//Login failed alarm upload
typedef struct  __ALARM_UPLOAD_LOGIN_FAILED_INFO
{
    DWORD                   dwSize;
    EM_LOGIN_FAILED_TYPE    emFailedType;                       //Failed type
    char                    szDeviceIP[DH_COMMON_STRING_64];    //Device ip
    DWORD                   nDevicePort;                        //Device port
}ALARM_UPLOAD_LOGIN_FAILED_INFO;

// Recording-changed alarm information
typedef struct
{
	int					nChannel;				// Record channel number
	char				reserved[12];
} ALARM_RECORDING_CHANGED;

#define NET_MAX_WINDINGID_NUM    8

// CoilFault alarm event
typedef struct __ALARM_WINGDING_INFO
{
	int                 nDriveWayID;            // road number
	int                 nWindingID;             // coil ID
	NET_TIME            stuTime;                // event happen time 
	int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
	DWORD				dwChannel;				// Channel of alarm
	char                reserve[28];
    int                 nWindingIDNum;          // Coil ID number
    int                 nWindingIDs[NET_MAX_WINDINGID_NUM];// Detailed coil ID 
} ALARM_WINGDING_INFO;

// traffic congestion alarm 
typedef struct __ALARM_TRAF_CONGESTION_INFO
{
	int                 nDriveWayID;            // road number
	int                 nCongestionLevel;       // traffic congestion grade:1,2,3,4,5,6;1 indicate the most one 
	NET_TIME            stuTime;                // event happen time 
	int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
	DWORD				dwChannel;				// Channel of alarm
	char                reserve[28];
} ALARM_TRAF_CONGESTION_INFO;

// traffic exception alarm
typedef struct __ALARM_TRAF_EXCEPTION_INFO
{
	int                 nDriveWayID;            // road number
	NET_TIME            stuTime;                // event happen time
	int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
	DWORD				dwChannel;				// Channel of alarm
	char                reserve[28];
} ALARM_TRAF_EXCEPTION_INFO;

// fill equipment alarm 
typedef struct __ALARM_EQUIPMENT_FILL_INFO
{
	int                 nDriveWayID;            // road number
	NET_TIME            stuTime;                // event happen time
	int                 nState;                 // Device state,0 indicate fault recover,1 indicate fault happen
	DWORD				dwChannel;				// Channel of alarm
	char                reserve[28];
} ALARM_EQUIPMENT_FILL_INFO;

// alarm arm disarm state info
typedef struct __ALARM_ARM_DISARM_STATE_INFO
{
	BYTE                bState;                 // arm-disarm,0 means disarm,1 means arm, 2 means ForceOn
	char                reserve[31];
} ALARM_ARM_DISARM_STATE_INFO;

// 3G flow exceed state info 
typedef struct __DHDEV_3GFLOW_EXCEED_STATE_INFO
{
	BYTE                bState;                 //  3G flow exceed state,0 means not exceed,1 means exceed
	char                reserve[31];
} DHDEV_3GFLOW_EXCEED_STATE_INFO;

// alarm of speed limit (DH_DEVSTATE_SPEED_LIMIT)
typedef struct __ALARM_SPEED_LIMIT
{
	char                szType[DH_SPEEDLIMIT_TYPE_LEN];   // alarm type oLowerSpeed, UpperSpeed
	int                 iSpeedLimit;            // limit speed KM/H 
	int                 iSpeed;                 // speed KM/H
	char                szCrossingID[DH_MAX_CROSSING_ID]; // crossing ID
	DWORD				dwLongitude;			// longitude(millionth degree, 0-360)
    DWORD				dwLatidude;				// latidude(millionth degree,0-180)
	DHDEVTIME           stTime;                 // time
	BYTE                bOffline;               // 0-in real time,1-to fill 
	char				reserve[19];
}ALARM_SPEED_LIMIT;

// alarm of over loading
typedef struct __ALARM_OVER_LOADING
{
    NET_TIME			stuCurTime;             // current time
    DWORD				dwLatidude;				// latidude(millionth degree,0-180)
    DWORD				dwLongitude;			// longitude(millionth degree, 0-360)
    char				szDriverNo[DH_VEHICLE_DRIVERNO_LEN];    // driver id
    DWORD				dwCurSpeed;             // current speed
    BYTE				byReserved[128]; 
}ALARM_OVER_LOADING;

// alarm of hard braking
typedef struct __ALARM_HARD_BRAKING
{
    NET_TIME			stuCurTime;             // current time
    DWORD				dwLatidude;				// latidude(millionth degree,0-180)
    DWORD				dwLongitude;			// longitude(millionth degree, 0-360)
    char				szDriverNo[DH_VEHICLE_DRIVERNO_LEN];    // driver id
    DWORD				dwCurSpeed;             // current speed
    BYTE				byReserved[128]; 
}ALARM_HARD_BRAKING;

// alarm of smoke sensor
typedef struct __ALARM_SMOKE_SENSOR
{
	NET_TIME			stuCurTime;             // current time
	int					nChannel;               // channel
	BYTE				byHighTemperature;      // 1:hight temperature alarm start,0:end
	BYTE				bySmoke;                // 1:smoke alarm start,0:end
	BYTE				byReservrd[126];
}ALARM_SMOKE_SENSOR;

// alarm of traffic light
typedef struct _LIGHT_INFO
{
	BYTE               byDirection;            // direction: 1-left,2-right,3-straight , 4-turn round
	BYTE               byState;                // light state: 1-fault,2-normal
	BYTE               byReserved[62];         // reserved
}LIGHT_INFO;

typedef struct __ALARM_TRAFFIC_LIGHT_FAULT 
{
	NET_TIME           stTime;                 // alarm time
	int                nInfoNumber;            // info number
	LIGHT_INFO         stLightInfo[8];         // info
	BYTE               byReserved[128];        // reserved
}ALARM_TRAFFIC_LIGHT_FAULT;

// Flux alarm channel information
typedef struct __ALARM_TRAFFIC_FLUX_LANE_INFO
{
	NET_TIME            stuCurTime;            // current time
	int                 nLane;                 // lane number
	int                 nState;                // state:1-traffic jam, 2-traffic jam recover, 3-normal 4-break, 5-break recover
	int                 nFlow;                 // flow value,unit:per/second
	BYTE                byReserved[124];       // reserved
}ALARM_TRAFFIC_FLUX_LANE_INFO;

// SIP state alarm
typedef struct __ALARM_SIP_STATE
{
	int					nChannelID;
	BYTE				byStatus;               //0:succeed,1:unregistered ,2:invalid,3:registing,4:talking
	BYTE				bReserved[63];			//reserved
}ALARM_SIP_STATE;

// vehicle info uploading (DH_DEVSTATE_VIHICLE_INFO_UPLOAD)
typedef struct __ALARM_VEHICLE_INFO_UPLOAD
{
    char                szType[DH_VEHICLE_TYPE_LEN];            //type: DriverCheck ,Driver check in or check out
	char                szCheckInfo[DH_VEHICLE_INFO_LEN];       //Check in, Check out
    char                szDirverNO[DH_VEHICLE_DRIVERNO_LEN];    //Driver NO. string
	DHDEVTIME           stTime;                                      // time
	BYTE                bOffline;                                    // 0-real time 1-to fill 
	char                reserved[59];                     
}ALARM_VEHICLE_INFO_UPLOAD;

// card record uploading
typedef struct __ALARM_CARD_RECORD_INFO_UPLOAD
{
	int					nChannel;				// channel id
	BOOL				bEnable;				// is recording
	char				szCardInfo[DH_MAX_CARD_INFO_LEN];	// card info
	NET_TIME			stuTime;				// card start time
	BOOL                bPreviewOverlayEn;      // preview overlay enable
	BYTE                byOverlayPos;           // overlay position,1-left top,2-left bottom,3-right top,4-right bottom
	char				reserved[59];
}ALARM_CARD_RECORD_INFO_UPLOAD;


typedef enum __ATMTradeTypes{
	TRADE_TYPE_INC = 0,							// INSERTCARD
	TRADE_TYPE_WDC,								// WITHDRAWCARD
	TRADE_TYPE_CKT,								// CHECKTIME
	TRADE_TYPE_INQ,								// Query
	TRADE_TYPE_CWD,								// draw 
	TRADE_TYPE_PIN,								// change password
	TRADE_TYPE_TFR,								// debit
	TRADE_TYPE_DEP,								// deposit
	TRADE_TYPE_NCINQ,							// card less query
	TRADE_TYPE_NCDEP,							// card less deposit
	TRADE_TYPE_OTHERS,							// other
	TRADE_TYPE_ALL,								// all
}DH_eATMTradeTypes;

typedef struct __ALARM_ATM_INFO_UPLOAD_CHNL
{
	int					nChannel;				// channel
	char				szATMID[32];			// ATM id
	char				szCardNo[32];			// card number, 6222421541208230456 
	char				szTradetime[32];		// trade time, 20111118112200 means 2011-11-18 11:22:00
	DH_eATMTradeTypes	emTradeType;			// trade type
	int					nAmount;				// trade mount	0-4294967296
	BYTE				byRerved[32];			// reserved
}ALARM_ATM_INFO_UPLOAD_CHNL;

// ATM trade info uploading info
typedef struct __ALARM_ATM_INFO_UPLOAD
{
	int							nCnt;
	ALARM_ATM_INFO_UPLOAD_CHNL	m_stAtmInfo[DH_MAX_CHANNUM];
}ALARM_ATM_INFO_UPLOAD;

// camera move alarm
typedef struct __ALARM_CAMERA_MOVE_INFO
{
	int                         nChannelNum;                        // the number of alarm channel
	unsigned char               alarmChannels[DH_MAX_CHANNUM_EX];   // the channel information of alarm happened
	BYTE                        byReserved[128];
}ALARM_CAMERA_MOVE_INFO;

// detailed motion alarm
typedef struct __ALARM_DETAILEDMOTION_CHNL_INFO
{
	DWORD              dwSize;
	int                nChannelID;    // channel
	BOOL               bAlarm;        // alarm or not,value is TRUE/FALSE
	int                nLevel;        // alarm level,in 1/1000 as a unit
}ALARM_DETAILEDMOTION_CHNL_INFO;

// storage failure alarm info
typedef struct __ALARM_STORAGE_FAILURE
{
	DWORD     dwSize;                                     // struct size
	UINT      ActionType;                                 // 0:stop 1:start
	char      szProtocol[DH_MAX_STRING_LEN];              // protocol type
	char      szServerAddr[DH_MAX_IPADDR_OR_DOMAIN_LEN];  // server device's ip 
	DWORD     dwPort;                                     // port number
	NET_TIME  stuTime;                                    // event happen time	
	int		  nChannel;									  // channel, from 1, 0 means does not distinguish
}ALARM_STORAGE_FAILURE;

// front IPC disconnect alarm info
typedef struct __ALARM_FRONTDISCONNET_INFO
{
	DWORD              dwSize;                           // struct size
	int                nChannelID;                       // channel id
	int                nAction;                          // 0:stop 1:start
	NET_TIME           stuTime;                          // event happen time
	char               szIpAddress[MAX_PATH];            // front IP's address
}ALARM_FRONTDISCONNET_INFO;

// battery low power alarm info
typedef struct __ALARM_BATTERYLOWPOWER_INFO
{
	DWORD             dwSize;                            // struct size
	int               nAction;                           // 0:stop 1:start
	int               nBatteryLeft;                      // battery left, unit:%
	NET_TIME          stTime;                            // event happen time
	int               nChannelID;                        // channel no. Mark sub-device battery. Begins with 0. 
}ALARM_BATTERYLOWPOWER_INFO;

// temperature alarm info
typedef struct __ALARM_TEMPERATURE_INFO
{
	DWORD              dwSize;                           // struct size
	char               szSensorName[DH_MACHINE_NAME_NUM];// sensor name
	int                nChannelID;                       // channel id
	int                nAction;                          // 0:stop 1:start
	float              fTemperature;                     // current temperature, unit:degree centigrade
	NET_TIME           stTime;                           // event happen time
}ALARM_TEMPERATURE_INFO;

// Fatigue Driving Alarm
typedef struct __ALARM_TIREDDRIVE_INFO
{
	DWORD             dwSize;                            // struct size
	int               nAction;                           // 0:stop 1:start
	int               nDriveTime;                        // drive time, unit:minute
	NET_TIME          stTime;                            // event happen time
}ALARM_TIREDDRIVE_INFO;

//Alarm of record loss
typedef struct __ALARM_LOST_RECORD
{
	DWORD     dwSize;                                     //Structure size
	UINT      ActionType;                                 // 0: Stop, 1: start
	UINT      nChannelID;                                 // Channel ID, start from 1
	UINT      nStreamType;                                // Bit Stream type, 0: main stream; 1: extra stream1; 2: extra stream2; 3: extra stream3; 4: snapshot stream
	NET_TIME  stuTime;                                    // Event occurrence time	
}ALARM_LOST_RECORD;

// Alarm of High CPU Occupancy rate, temporarily we set the max limit as 95%
typedef struct __ALARM_HIGH_CPU
{
	DWORD     dwSize;                                     //Structure size
	UINT      ActionType;                                 // 0: Stop, 1: start
	UINT      nUsed;                                      // 1000 times of  CPU Occupancy rate
	NET_TIME  stuTime;                                    // Event occurrence time
}ALARM_HIGH_CPU;


// Alarm of netpackage loss
typedef struct __ALARM_LOST_NETPACKET
{
	DWORD     dwSize;                                     //Structure size
	UINT      ActionType;                                 //0: Stop, 1: start
	UINT      nChannelID;                                 // Channel ID, start from 1
	UINT      nStreamType;                                // Bit stream type, 0: main stream; 1: extra stream1; 2: extra stream2; 3: extra stream3; 4: snapshot stream
	char      szRemoteIP[DH_MAX_IPADDR_LEN];              // IP address of sending
	DWORD     dwRemotePort;                               // Port address of sending 
	NET_TIME  stuTime;                                    // Event occurrence time
}ALARM_LOST_NETPACKET;

// Alarm of High memory Occupancy rate, temporarily we set the max limit as 95%
typedef struct __ALARM_HIGH_MEMORY
{
	DWORD     dwSize;                                     //Structure size
	UINT      ActionType;                                 // 0: Stop, 1: start
	UINT      nUsed;                                      // 1000 times of  memory Occupancy rate
	NET_TIME  stuTime;                                    // Event occurrence time	
}ALARM_HIGH_MEMORY;

// black list snap info
typedef struct __DH_BLACKLIST_SNAP_INFO
{
	DWORD     dwSize;
	char      szPlateNumber[32];                          // number of plate
	NET_TIME  stuTime;                                    // time
}DH_BLACKLIST_SNAP_INFO;

// disk flux abnormal
typedef struct __ALARM_DISK_FLUX
{
	DWORD				dwSize;	
	DWORD				dwAction;							// 0-start, 1-stop
	DWORD				dwDataFlux;							// data flux,KB			
	NET_TIME			stuTime;							// time
} ALARM_DISK_FLUX;

// net flux abnormal
typedef struct __ALARM_NET_FLUX
{
	DWORD				dwSize;	
	DWORD				dwAction;							// 0-start, 1-stop
	DWORD				dwDataFlux;							// data flux,KB	
	NET_TIME			stuTime;							// time
} ALARM_NET_FLUX;

// fan speed abnormal
typedef struct __ALARM_FAN_SPEED
{
	DWORD				dwSize;	
	DWORD				dwAction;							// 0-start, 1-stop
	DWORD				dwIndex;							// index
	char				szName[DH_MACHINE_NAME_NUM];		// name
	NET_TIME			stuTime;							// time
	DWORD				dwCurrent;							// current speed
} ALARM_FAN_SPEED;

// disk alarm
typedef struct __ALARM_DISK_INFO 
{
	DWORD				dwSize;
	DWORD				nChannel;							// channel number
	DWORD				nHDDNumber;							// number, 0: main trank,1: extern trank1, 2: extern trank2 
	DWORD				nHDDState;							// state, 0: Unknown, 1: Running, 2: Offline, 3: Warning, 4: Failed
} ALARM_DISK_INFO;

// alarm of file system
typedef struct __ALARM_FILE_SYSTEM_INFO 
{
	DWORD				dwSize;
	char				szMountDir[MAX_PATH];				// mount name
	DWORD				nState;								// state, 0: Unkown, 1: Normal, 2: Error
} ALARM_FILE_SYSTEM_INFO;

// alarm of remote 
typedef struct __ALARM_REMOTE_ALARM_INFO
{
	DWORD      dwSize;
	int        nChannelID;                               // channel ID,from 1
	int        nState;                                   // state,0-reset,1-setting
}ALARM_REMOTE_ALARM_INFO;

// alarm of ivs
typedef struct __ALARM_IVS_INFO
{
	DWORD      dwSize;
	NET_TIME   stuTime;                                  // time	
	int        nChannelID;                               // channel ID,from 0
	char	   szType[MAX_PATH];                         // type
	int        nState;                                   // state,0-reset,1-setting,2-pulse
}ALARM_IVS_INFO;

// alarm of good weight
typedef struct __ALARM_GOODS_WEIGHT_INFO
{
	DWORD		dwSize;
	int			nAction;							// 0-start, 1-stop
	int			nAlarmType;							// 0-greater than dwMaxGoodsWeight, 1-less than dwMinGoodsWeight, 2-the change greater than dwAlarmWeight
	DWORD		dwGoodsWeight;						// good weight(kg)
	DWORD		dwSelfWeight;						// self weight(kg)
	DWORD		dwTotalWeight;						// total weight(kg)
	DWORD		dwStandardWeight;					// standard weight(kg)
	DWORD		dwWeightScale;						// weight scale
	DWORD		dwMaxGoodsWeight;					// the max(kg)
	DWORD		dwMinGoodsWeight;					// the min(kg)
	DWORD		dwAlarmWeight;						// alarm of threshold(kg)
	int			nWeightChange;						// whight change when gather(kg)
	int			nCheckTime;							// gather time(s)
} ALARM_GOODS_WEIGHT_INFO;

// goods weight upload
typedef struct __ALARM_GOODS_WEIGHT_UPLOAD_INFO 
{
	DWORD		dwSize;
	DWORD		dwGoodsWeight;						// goods weight(kg)
	DWORD		dwSelfWeight;						// self weight(kg)
	DWORD		dwTotalWeight;						// total weight(kg)
	DWORD		dwStandardWeight;					// standard weight(kg)
	DWORD		dwWeightScale;						// weight scale	
    char        szCardNO[DH_MAX_CARDINFO_LEN];      //card number
} ALARM_GOODS_WEIGHT_UPLOAD_INFO;

// GPS status info
typedef struct _NET_GPS_STATUS_INFO
{
    NET_TIME                revTime;				    // time
    char                    DvrSerial[50];			    // device number
    double                  longitude;				    // longitude(1/1000000,range[0-360])
    double                  latidude;				    // latitude(1/1000000,range[0-180])
    double                  height;					    // highness(m)
    double                  angle;					    // angle(north is source point,clockwise is positive)
    double                  speed;					    // speed(sea mile,speed/1000*1.852km/h)
    WORD                    starCount;				    // star count
    NET_THREE_STATUS_BOOL   antennaState;			    // antenna state(true good, false bad)
    NET_THREE_STATUS_BOOL   orientationState;		    // orientation state(true orientation, false not)
	int                     workStae;                   // working state(true normal, false abnormity)

    int                     nAlarmCount;                 // alarm count
    int                     nAlarmState[128];            // alarm type
    BYTE                    bOffline;                    // 0- real time 1-fill 
    BYTE                    bSNR;                        // SNR for GPS, range£º0~100, 0 for unusable
    BYTE                    byRserved[126];              // reserved bytes
} NET_GPS_STATUS_INFO,*LPNET_GPS_STATUS_INFO;

// alarm of disk burned full
typedef struct __ALARM_DISKBURNED_FULL_INFO
{
	DWORD		dwSize;
	int         nIndex;                             //index
}ALARM_DISKBURNED_FULL_INFO;

// alarm of storage low space
typedef struct tagALARM_STORAGE_LOW_SPACE_INFO 
{
	DWORD				dwSize;
	int					nAction;						// 0:start 2:stop
	char				szName[DH_EVENT_NAME_LEN];		// name
	char				szDevice[DH_STORAGE_NAME_LEN];	// device name
	char				szGroup[DH_STORAGE_NAME_LEN];	// group name 
	INT64				nTotalSpace;					// total space byte
	INT64				nFreeSpace;						// free space byte
	int					nPercent;						// used percent 
} ALARM_STORAGE_LOW_SPACE_INFO;

// storage error
typedef enum __EM_STORAGE_ERROR
{
	STORAGE_ERROR_NONE,							// no error
    STORAGE_ERROR_PATITION,						// patition error 		
	STORAGE_ERROR_INIT_FS,						// init system file error	
	STORAGE_ERROR_READ_DATA,					// read data error
	STORAGE_ERROR_WRITE_DATA,					// write data error
	STORAGE_ERROR_RAID_FAILED,					// RAID error
	STORAGE_ERROR_RAID_DEGRADED,				// RAID degranded 
    STORAGE_ERROR_ISCSI_FAILED,                     // iSCSI error
} EM_STORAGE_ERROR;

// alarm of storage failure
typedef struct __ALARM_STORAGE_FAILURE_EX
{
	DWORD				dwSize;
	int					nAction;						// 0:start 1:stop
	char				szName[DH_EVENT_NAME_LEN];		// name 
	char				szDevice[DH_STORAGE_NAME_LEN];	// device name
	char				szGroup[DH_STORAGE_NAME_LEN];	// group name
	char				szPath[MAX_PATH];				// path
	EM_STORAGE_ERROR	emError;						// error type
} ALARM_STORAGE_FAILURE_EX;

// alarm of record failed 
typedef struct __ALARM_RECORD_FAILED_INFO 
{
	DWORD				dwSize;
	int					nAction;						// 0:start 1:stop
	int					nIndex;							// index
} ALARM_RECORD_FAILED_INFO;

// storage break down
typedef struct __ALARM_STORAGE_BREAK_DOWN_INFO 
{
	DWORD				dwSize;
	int					nAction;						// 0:start 1:stop
} ALARM_STORAGE_BREAK_DOWN_INFO;

// hot plug action mode
typedef enum tagEM_STORAGE_HOT_PLUG_ACTION
{
    HOT_PLUG_ACTION_UNKNOW = 0  ,
    HOT_PLUG_ACTION_ADD         ,       //Insert device
    HOT_PLUG_ACTION_REMOVE      ,       //Remove device 
}EM_STORAGE_HOT_PLUG_ACTION;
// storage hot plug action event (corresponding to DH_ALARM_STORAGE_HOT_PLUG)
typedef struct __ALARM_STORAGE_HOT_PLUG_INFO
{
    int                         nAction;                            // 0:Start 1:stop
    EM_STORAGE_HOT_PLUG_ACTION  emHotPLugAction;                    // Hot swap operation type 
    char                        szDevice[DH_STORAGE_NAME_LEN];      // Storage device name 
    char                        szMediaType[DH_COMMON_STRING_32];   // Media type 
    char                        szBusType[DH_COMMON_STRING_32];     // BUS type 
    char                        szMountOn[DH_COMMON_STRING_128];    // Device mount position 
    int                         nPhysicNo;                          // Physical SN. Begins with 1. 
    int                         nLogicNo;                           // Logic SN
    BYTE                        bReserved[256];                     // Reserved byte. To be developed .
}ALARM_STORAGE_HOT_PLUG_INFO;
typedef enum tagEM_NET_UPS_STATUS
{
	EM_NET_UPS_SYS_SIGN=0	 	,	//System temperature the sign bit. 1: negative temperature; 0:positive temperature
	EM_NET_UPS_SYS_SHUTDOWN 	,	//System shutdown. 1: shutdown activated state
	EM_NET_UPS_SYS_TEST 		,	//System tests. 1: said tests
	EM_NET_UPS_SYS_TYPE 		,	//UPS type. 1: backup machine; 0: said online machine
	EM_NET_UPS_SYS_FAULT 		,	//UPS fault. 1: UPS internal fault; Zero: normal
	EM_NET_UPS_ELE_SUPPLY 		,	//The bypass/inverter state. 1: AC power supply; 0: batteries
	EM_NET_UPS_VOL_LOW 			,	//Low battery voltage. 1: low battery voltage; Zero: it means the battery is normal
	EM_NET_UPS_BYPASS_STATUS	,	//Mains failure. 1: mains failure; Zero: it means the mains is normal
	EM_NET_UPS_MAX = 64			,	//
}EM_NET_UPS_STATUS;

typedef struct tagNET_UPS_INFO
{
	DWORD dwSize;
	float fInputVoltage;						//Specific reference input voltage intelligent transportation special power communication protocol (V1.2), blue shield special definition
	float fInputAbnormalVoltage;				//Abnormal input voltage
	float fOutputVoltage;						//output voltage
	float fOutputCurrent;						//Output current percentage, the unit (%)
	float fInputFrequency;						//incoming frequency
	float fVoltage;								//voltage
	float fTemp;								// temperature
	BYTE  bStatusInfo[EM_NET_UPS_MAX];			//Set UPS STATUS, see.net UPS STATUS enumeration
	char  szVersionInfo[DH_MAX_VERSION_STR];	//version
}NET_UPS_INFO;

typedef struct tagALARM_COMM_PORT_EVENT_INFO
{
	DWORD           dwSize;
	UINT      		nEventAction;	// Event Action¡ê?0=Impulse Event,1=Begin a Continued Event,2=the Event End;
	NET_UPS_INFO	stUPSInfo;		// UPS's COM Information
}ALARM_COMM_PORT_EVENT_INFO;

// ininvalid of video input channel(example:)DH_ALARM_VIDEO_ININVALID
typedef struct __ALARM_VIDEO_ININVALID_INFO 
{
	DWORD               dwSize;                         // struct size
	int                 nChannelID;                     // channel ID,from 0
} ALARM_VIDEO_ININVALID_INFO;


// No Information of Event in Storage Group
typedef struct tagALARM_STORAGE_NOT_EXIST_INFO 
{
    DWORD           dwSize;
    int             nAction;                            // 0:start 1:stop
    char            szGroup[DH_STORAGE_NAME_LEN];       // Storage Droup Name
    NET_TIME        stuTime;                            // the Time of Event triggering)
}ALARM_STORAGE_NOT_EXIST_INFO;

//the Type of Network Fault Event)
typedef enum __EM_NETABORT_EVENT_TYPE
{
	EM_NETABORT_EVENT_TYPE_WIRE = 0,				// Wired Network Fault Event 
	EM_NETABORT_EVENT_TYPE_WIRELESS,				// Wireless Network Fault Event 
	EM_NETABORT_EVENT_TYPE_3G,						//3G Network Fault Event
}EM_NETABORT_EVENT_TYPE;

// Network Fault Event
typedef struct tagALARM_NETABORT_INFO
{
	DWORD			dwSize;
	int				nAction;						//0=Start 1=Stop
	EM_NETABORT_EVENT_TYPE	emNetAbortType;			// Event Type
	NET_TIME		stuTime;						// Event Triggering Time
}ALARM_NETABORT_INFO;

// IP Clash Event
typedef struct tagALARM_IP_CONFLICT_INFO
{
	DWORD			dwSize;
	int				nAction;						//0=Start 1=Stop
	NET_TIME		stuTime;						// Event Triggering Time)
}ALARM_IP_CONFLICT_INFO;


// MAC Clash Evnet)
typedef struct tagALARM_MAC_CONFLICT_INFO
{
	DWORD			dwSize;
	int				nAction;						// 0=Start 1=Stop
	NET_TIME		stuTime;						// Event Triggering Time
}ALARM_MAC_CONFLICT_INFO;


// Power Type
typedef enum __EM_POWER_TYPE
{
	EM_POWER_TYPE_MAIN = 0,							// Main Power
	EM_POWER_TYPE_BACKUP,							// Spare Power
}EM_POWER_TYPE;

// the Type of Power Fault Event
typedef enum __EM_POWERFAULT_EVENT_TYPE
{
	EM_POWERFAULT_EVENT_LOST = 0					// Power Down
}EM_POWERFAULT_EVENT_TYPE;

// Power Fault Event
typedef struct tagALARM_POWERFAULT_INFO
{
	DWORD					dwSize;			
	EM_POWER_TYPE			emPowerType;			// Power Type
	EM_POWERFAULT_EVENT_TYPE	emPowerFaultEvent;	// Power Fault Event
	NET_TIME				stuTime;				// Alarm Event Begin Time 
	int						nAction;				// 0=Start 1=Stop 
}ALARM_POWERFAULT_INFO;

// Tamper Alarm Event 
typedef struct tagALARM_CHASSISINTRUDED_INFO
{
	DWORD				dwSize;
	int					nAction;				//  0=Start 1=Stop 
	NET_TIME			stuTime;				// Alarm Event Begin Time
	int                 nChannelID;             // Channel ID
	char				szReaderID[DH_COMMON_STRING_32];// Reader ID
}ALARM_CHASSISINTRUDED_INFO;

// Expand Module Alarm Event
typedef struct tagALARM_ALARMEXTENDED_INFO
{
	DWORD				dwSize;
	int                 nChannelID;             //  Channel ID
	int					nAction;				// 0=Start 1=Stop (1=stop) 
	NET_TIME			stuTime;				//  Alarm Event Begin Time
}ALARM_ALARMEXTENDED_INFO;


// Interphone's Initiator 
typedef enum __EM_TALKING_CALLER
{
	EM_TALKING_CALLER_UNKNOWN = 0,				// Uunbeknown Initiator 
	EM_TALKING_CALLER_PLATFORM,					//Interphone's initiator is Platform
}EM_TALKING_CALLER;

// Invite Evnet remote device protocol
typedef enum tagTALKINGINVITE_REMOTEDEVICE_PROTOCOL
{
    EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_UNKNOWN = 0,     // UNKNOWN;
    EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_HIKVISION        // HIKVISION
}EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL;

#define MAX_REMOTEDEVICEINFO_IPADDR_LEN         128       // max remote device IP address length
#define MAX_REMOTEDEVICEINFO_USERNAME_LEN       128       // max remote device username length
#define MAX_REMOTEDEVICEINFO_USERPSW_LENGTH     128       // max remote device password length

// Invite Evnet remote device information
typedef struct tagTALKINGINVITE_REMOTEDEVICEINFO
{
    char		                            szIP[MAX_REMOTEDEVICEINFO_IPADDR_LEN];	        // device's IP
	int	                                    nPort;							                // port
	EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL  emProtocol;                                     // protocol type
	char		                            szUser[MAX_REMOTEDEVICEINFO_USERNAME_LEN];	    // user name
	char		                            szPassword[MAX_REMOTEDEVICEINFO_USERPSW_LENGTH];// password
	char                                    szReverse[1024];                                // reverse word
}TALKINGINVITE_REMOTEDEVICEINFO;

// Alarm Event TypeDH_ALARM_TALKING_INVITE Device ask Other Side InitiateInterphone Event )Corresponding Data Description Information 
typedef struct tagALARM_TALKING_INVITE_INFO
{
    DWORD                                   dwSize;
    EM_TALKING_CALLER                       emCaller;                       // Interphone's Initiator is Device Desired 
    NET_TIME                                stuTime;                        // Event Triggering Time
    char                                    szCallID[DH_COMMON_STRING_64];	// Unique ID for calling
    int                                     nLevel;						    // The level of current calling device 
    TALKINGINVITE_REMOTEDEVICEINFO          stuRemoteDeviceInfo;             // remote device info
}ALARM_TALKING_INVITE_INFO;

// Alarm Event Type DH_ALARM_TALKING_HANGUP corresponding data description
typedef struct tagALARM_TALKING_IGNORE_INVITE_INFO
{
    DWORD                dwSize;
} ALARM_TALKING_IGNORE_INVITE_INFO;
// data describe info corresponding alarm event mode:DH_ALARM_TALKING_HANGUP
typedef struct tagALARM_TALKING_HANGUP_INFO 
{
    DWORD               dwSize;
    NET_TIME            stuTime;                // Event trigger time
}ALARM_TALKING_HANGUP_INFO;

// Station Update Event Status
typedef enum tagEM_GUARD_EVENT_STATE
{
	EM_GUARD_EVENT_STATE_UNKNOWN = 0,	// unknown status
	EM_GUARD_EVNET_STATE_ONGUARD,		// on guard
	EM_GUARD_EVENT_STATE_OFFGUARD		// off guard
}EM_GUARD_EVENT_STATE;

// station info update event ,DH_ALARM_GUARD_INFO_UNPDATE data description info
typedef struct tagALARM_GUARD_UPDATE_INFO
{
	DWORD				 dwSize;
	EM_GUARD_EVENT_STATE emEventState;							// station update event status
	int					 nIDCount;								// trigger detection event staff ID number
	int					 nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT];// staff ID group
	NET_TIME			 stuTime;								// event trigger time
}ALARM_GUARD_UPDATE_INFO;

// station detection event ,DH_ALARM_GUARD_DETECTcorresponding to data description info
typedef struct tagALARM_GUARD_DETECT_INFO
{
	DWORD				dwSize;
	int					nAction;								// 0: start 1: stop
	int					nIndex;									// station detection config mark	
	int					nIDCount;								// trigger detection event staff ID number
	int					nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT];	// staff ID group number
	NET_TIME			stuTime;								// event trigger time
}ALARM_GUARD_DETECT_INFO;

//Bank card event DH_ALARM_BANKCARDINSERT corresponding data info
typedef struct tagALARM_BANKCARDINSERT_INFO 
{
    DWORD               dwSize;
    int                 nAction;                // -1:unknown 0: start 1:stop
}ALARM_BANKCARDINSERT_INFO;

#define MAX_CARD_RECORD_FIELD_NUM 16            // card no. max domain quantity

// event trigger record,stop storage strategy
typedef enum tagNET_RECORD_SAVEFLAG
{
    NET_RECORD_SAVEFLAG_UNKNOWN = 0,            //unknown type
	NET_RECORD_SAVEFLAG_MARK,                   //save record and lock
	NET_RECORD_SAVEFLAG_SAVE,                   //only save record
}NET_RECORD_SAVEFLAG;

//card no. record event DH_ALARM_CARD_RECORD corresponding to group decryption info
typedef struct tagALARM_CARD_RECORD_INFO 
{
    DWORD               dwSize;
    int                 nAction;                // -1:unknown 0:start 1:stop
    int                 nChannelID;             // channel no.¡ê?from 0
    unsigned int        nFieldCount;            // domain quantity
    char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256]; // domain info
    NET_RECORD_SAVEFLAG emRecordSaveFlag;       // event trigger record¡ê?stop storage strategy ,see  NET_RECORD_SAVEFLAG
}ALARM_CARD_RECORD_INFO;

// CLIENT_ControlDevice port DH_CTRL_NOTIFY_EVNENT command parameter(send event to device)
typedef struct tagALARM_NET_INFO
{
    DWORD               dwSize;
    int                 nAction;                // -1:Unknown, 0:Start 1:stop
    int                 nChannelID;             // Channel No. Begins with 0. 
} ALARM_NET_INFO;

// DH_CTRL_NOTIFY_EVNENT command parameter of CLIENT_ControlDevice interface (send event to device)
typedef struct tagNET_NOTIFY_EVENT_DATA
{
    DWORD                       dwSize;
    LONG                        lCommand;       // event type
    void*                       pEventData;     // event content,and lCommandcorresponding to structure indicator
}NET_NOTIFY_EVENT_DATA;

// Sensor's Sense Method Enumeration Type
typedef enum tagNET_SENSE_METHOD
{
	NET_SENSE_UNKNOWN = -1,		//Unknowed type
	NET_SENSE_DOOR=0,			//Door Contact
	NET_SENSE_PASSIVEINFRA,		//Passive Infrared
	NET_SENSE_GAS,				//Gase Induce)
	NET_SENSE_SMOKING,			//Smoking Induce
	NET_SENSE_WATER,			//Wwater Induce)
	NET_SENSE_ACTIVEFRA,		//Initiative Infrared
	NET_SENSE_GLASS,			//Glass Broken
	NET_SENSE_EMERGENCYSWITCH,	//Emergency switch
	NET_SENSE_SHOCK,			//Shock
	NET_SENSE_DOUBLEMETHOD,		//Double Method(Infrare+Microwave)
	NET_SENSE_THREEMETHOD,		//Three Method
	NET_SENSE_TEMP,				//Temperature
	NET_SENSE_HUMIDITY,			//Humidity
	NET_SENSE_WIND,             //Wind
	NET_SENSE_CALLBUTTON,		//Call button
    NET_SENSE_GASPRESSURE,      //Gas Pressure
    NET_SENSE_GASCONCENTRATION, //Gas Concentration
    NET_SENSE_GASFLOW,          //Gas Flow
	NET_SENSE_OTHER,			//Other
    NET_SENSE_OIL,              //oil detection¡ê?gasoline, diesel vehicles detection
    NET_SENSE_MILEAGE,          //mileage detection
    NET_SENSE_URGENCYBUTTON,    //Urgency button
    NET_SENSE_STEAL,            //Steal
    NET_SENSE_PERIMETER,        //Permeter
    NET_SENSE_PREVENTREMOVE,    //Prevent remove
    NET_SENSE_DOORBELL,         //Door bell
    NET_SENSE_ALTERVOLT,        //Alter voltage sensor
    NET_SENSE_DIRECTVOLT,       //Direct voltage sensor
    NET_SENSE_ALTERCUR,         //Alter current sensor
    NET_SENSE_DIRECTCUR,        //Direct current sensor
    NET_SENSE_RSUGENERAL,       //RSU general analog sensor, 4~20mA or 0~5V
    NET_SENSE_RSUDOOR,          //RSU door sensor
    NET_SENSE_RSUPOWEROFF,      //RSU power off sensor	
    NET_SENSE_TEMP1500 ,        //1500 temperature sensor	
    NET_SENSE_TEMPDS18B20 ,     //DS18B20 temperature sensor	
    NET_SENSE_HUMIDITY1500,     //1500 humidity sensor	
	NET_SENSE_NUM,				//Number of enumeration type
}NET_SENSE_METHOD;


// Protect/Cancel Protect Mode 
typedef enum tagNET_ALARM_MODE
{	
	NET_ALARM_MODE_UNKNOWN = -1,	// Unknown
	NET_ALARM_MODE_DISARMING,		// Cancel Protect 
	NET_ALARM_MODE_ARMING,			// Install protect
	NET_ALARM_MODE_FORCEON,			// Forceon protect
}NET_ALARM_MODE;

// Arm/Disarm scene mode
typedef enum tagNET_SCENE_MODE
{
	NET_SCENE_MODE_UNKNOWN,			// Unknown scene
	NET_SCENE_MODE_OUTDOOR,			// Outdoor mode
	NET_SCENE_MODE_INDOOR,			// Inner mode
    NET_SCENE_MODE_WHOLE,           // global mode
    NET_SCENE_MODE_RIGHTNOW,        // immediate mode
}NET_SCENE_MODE;

// trigger mode
typedef enum tagNET_EM_TRIGGER_MODE
{
    NET_EM_TRIGGER_MODE_UNKNOWN = 0,
    NET_EM_TRIGGER_MODE_NET,            // Network user(Platform?¨°Web)
    NET_EM_TRIGGER_MODE_KEYBOARD,       // keyboard
    NET_EM_TRIGGER_MODE_REMOTECONTROL,  // remote control
}NET_EM_TRIGGER_MODE;

// Protect Transformate Event's Information
typedef struct tagALARM_ARMMODE_CHANGE_INFO
{
	DWORD				dwSize;
	NET_TIME			stuTime;			// Alarm Event Begin Time
	NET_ALARM_MODE		bArm;				// Statue of Transformated
	NET_SCENE_MODE		emSceneMode;		// ContextualMode
    DWORD               dwID;               // ID number, remote control number or keypad address, emTriggerMode=0 when  belong to NET_EM_TRIGGER_MODE_NET
    NET_EM_TRIGGER_MODE emTriggerMode;      // trigger mode
}ALARM_ARMMODE_CHANGE_INFO;

// defence zone type
typedef enum
{
	NET_DEFENCEAREA_TYPE_UNKNOWN,		//Unknown Type Defence Area
	NET_DEFENCEAREA_TYPE_ALARM,			// Switching Value Defence Area 
}NET_DEFENCEAREA_TYPE;

// Bypass Statue Type
typedef enum
{
	NET_BYPASS_MODE_UNKNOW,			//UnknownBypass Statue
	NET_BYPASS_MODE_BYPASS,			//Bypass
	NET_BYPASS_MODE_NORMAL,			//Normal
	NET_BYPASS_MODE_ISOLATED,		//Isolated
}NET_BYPASS_MODE;

// The Information of Bypass's Statue Change Event
typedef struct tagALARM_BYPASSMODE_CHANGE_INFO
{
	DWORD                   dwSize;
	int	                    nChannelID;                 // Channel ID
	NET_TIME                stuTime;                    // Alarm Event Begin Time
	NET_DEFENCEAREA_TYPE    emDefenceType;              // Defence Area Type
	int                     nIsExtend;                  // Whether or not It Is Expand¡ê¡§Channel¡ê?Defence Area ¡ê?1=Expand Channel¡ê?0=Non Expand Channel)
	NET_BYPASS_MODE	        emMode;	                    // Changed Mode 
    DWORD                   dwID;                       // ID number, remote control number or keypad address, emTriggerMode=0 when belong to NET_EM_TRIGGER_MODE_NET
    NET_EM_TRIGGER_MODE     emTriggerMode;              // trigger mode
}ALARM_BYPASSMODE_CHANGE_INFO;


// Emergency Event¡ê¡§Correspond DH_URGENCY_ALARM_EX2,DH_URGENCY_ALARM_EX Update¡ê?That is Artificially Triggered Emergency,General Treatment is Linkage External Communications Functions for Help¡ê?
typedef struct tagALARM_URGENCY_ALARM_EX2 
{
	DWORD		dwSize;
	NET_TIME	stuTime;			//Event Begin Time
    DWORD           nID;                         // used to mark different emergency event
}ALARM_URGENCY_ALARM_EX2;

// Alarm Input Source Event Details(As Long As There Will Have to Change The Input Event, Regardless of the Current Mode of The Defence Zone Can not be Shielded)
typedef struct tagALARM_INPUT_SOURCE_SIGNAL_INFO
{
	DWORD		dwSize;
	int			nChannelID;             // Channel ID
	int			nAction;				//0=Start 1=Stop 
	NET_TIME	stuTime;				// Alarm Event Begin Time
}ALARM_INPUT_SOURCE_SIGNAL_INFO;

// Analog Input Channel Alarm Event Information(Corresponding DH_ALARM_ANALOGALARM_EVENT)¡ê?
typedef struct tagALARM_ANALOGALARM_EVENT_INFO 
{
	DWORD		dwSize;
	int			nChannelID;             // Alarm Event Begin Time
	int			nAction;				// 0=Start 1=Stop 
	NET_TIME	stuTime;				//  Alarm Event Begin Time
	NET_SENSE_METHOD	emSensorType;	// the Sensor's Type
	char		szName[DH_COMMON_STRING_128];	// Channel Name
    int             nIsValid;                           // Data is valid or not,-1: unknown,0:invalid,1:valid
    int             nStatus;                            // Data status, -1: unknown,0:noemal,1:invalid data(over limit),
                                                        // 2:over threshold value1,3: over threshold value 2,4: over threshold value 3,5: over threshold value 4,
                                                        // 6:below threshold value 1,7: below threshold value2,8: below threshold value3,9: below threshold value4
    float           fValue;                             // Detector value
    NET_TIME        stuCollectTime;                     // Data collection time(UTC)
    NET_GPS_STATUS_INFO stGPSStatus;                    // GPS status
}ALARM_ANALOGALARM_EVENT_INFO;


// Access Control Status Type
typedef enum tagNET_ACCESS_CTL_STATUS_TYPE
{
	NET_ACCESS_CTL_STATUS_TYPE_UNKNOWN = 0,
	NET_ACCESS_CTL_STATUS_TYPE_OPEN,		// Open
	NET_ACCESS_CTL_STATUS_TYPE_CLOSE,		// Close
    NET_ACCESS_CTL_STATUS_TYPE_ABNORMAL,    // Abnormal

}NET_ACCESS_CTL_STATUS_TYPE;

// Access control status event
typedef struct tagALARM_ACCESS_CTL_STATUS_INFO 
{
	DWORD		dwSize;
	int			nDoor;						// Door channel no.
	NET_TIME	stuTime;					// Event time
	NET_ACCESS_CTL_STATUS_TYPE	emStatus;	// Access control status
}ALARM_ACCESS_CTL_STATUS_INFO;

// Access Control Snapshot Type
typedef enum tagNET_ACCESS_SNAP_TYPE
{
    NET_ACCESS_SNAP_TYPE_UNKNOWN = 0,
    NET_ACCESS_SNAP_TYPE_CARD,                          // Swipe
    NET_ACCESS_SNAP_TYPE_PASSWORD,                      // Password
}NET_ACCESS_SNAP_TYPE;

// Access Control Snapshot Event
typedef struct tagALARM_ACCESS_SNAP_INFO
{
    DWORD           dwSize;
    NET_ACCESS_SNAP_TYPE emType;                        // Type
    char            szCardNO[DH_COMMON_STRING_32];      // Card no., swipe card valie
    char            szPassword[DH_COMMON_STRING_64];    // Password, valid when unlock by password    
    char            szFtpUrl[MAX_PATH];                 // ftp upload address, picturepath
    int             nImageNum;                          // Snapshot picture
    NET_TIME        stuTime;                            // Event time
}ALARM_ACCESS_SNAP_INFO;

// Clear Alarm Event
typedef struct tagALARM_ALARMCLEAR_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // Channel No.
    NET_TIME        stuTime;                            // Alarm event time
    int             bEventAction;                       // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
}ALARM_ALARMCLEAR_INFO;
// CIDÊÂ¼þ
typedef struct tagALARM_CIDEVENT_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                            // Alarm event time
    char			szCID[DH_COMMON_STRING_32];         // CID code, standard protocolcode, string length is 16¡ê?string value is 0~F
                                                        // 4 bit user code + 2 bit recognition code + 1 bit event limit code + 3 bit event code + 2 bit system code + 3 bit zone code + 1 bit parity code
}ALARM_CIDEVENT_INFO;

// Emergency Help Event Type
typedef enum tagEM_RCEMERGENCY_CALL_TYPE
{
    EM_RCEMERGENCY_CALL_UNKNOWN = 0,
    EM_RCEMERGENCY_CALL_FIRE,                           // Fire
    EM_RCEMERGENCY_CALL_DURESS,                         // Forced
    EM_RCEMERGENCY_CALL_ROBBER,                         // Robber
    EM_RCEMERGENCY_CALL_MEDICAL,                        // Medical
    EM_RCEMERGENCY_CALL_EMERGENCY,                      // Emergency
}EM_RCEMERGENCY_CALL_TYPE;

// alarm method
typedef enum tagEM_RCEMERGENCY_MODE_TYPE
{
    EM_RCEMERGENCY_MODE_UNKNOWN = 0,
    EM_RCEMERGENCY_MODE_KEYBOARD,                       //  keyboard
    EM_RCEMERGENCY_MODE_WIRELESS_CONTROL,               // remote control
}EM_RCEMERGENCY_MODE_TYPE;

// Emergency Help Event Details
typedef struct tagALARM_RCEMERGENCY_CALL_INFO 
{
    DWORD                   dwSize;
    int                     nAction;                    // 0:start 1:stop
    EM_RCEMERGENCY_CALL_TYPE  emType;                   // emergency type
    NET_TIME                stuTime;                    // event time
    EM_RCEMERGENCY_MODE_TYPE  emMode;                   // alarm method
    DWORD                   dwID;                       // for different emergency events (only emMode is remote control type, it is valid , means remote control no. , 0 means invalid ID)
}ALARM_RCEMERGENCY_CALL_INFO;

// multi-people unlock event(corresponding to DH_ALARM_OPENDOORGROUP type)
typedef struct tagALARM_OPEN_DOOR_GROUP_INFO
{
    DWORD           dwSize;
    int             nChannelID;                         // door channel(from 0)
    NET_TIME        stuTime;                            // event time
}ALARM_OPEN_DOOR_GROUP_INFO;

// get fingerprint event(corresponding to DH_ALARM_FINGER_PRINT type)
typedef struct tagALARM_CAPTURE_FINGER_PRINT_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // door channel no.( from 0)
    NET_TIME        stuTime;                            // event time
    char            szReaderID[DH_COMMON_STRING_32];    // card reader ID
    int             nPacketLen;                         // single fingerprint data length
    int             nPacketNum;                         // fingerprint data number
    char*           szFingerPrintInfo;                  // fingerprint data(data total length as nPacketLen*nPacketNum)
}ALARM_CAPTURE_FINGER_PRINT_INFO;

// sub system status type
typedef enum __EM_SUBSYSTEM_STATE_TYPE
{
    EM_SUBSYSTEM_STATE_UNKNOWN = 0,                     // unknown
    EM_SUBSYSTEM_STATE_ACTIVE,                          // activated
    EM_SUBSYSTEM_STATE_INACTIVE,                        // not activated
}EM_SUBSYSTEM_STATE_TYPE;

// sub system statua change event
typedef struct tagALARM_SUBSYSTEM_STATE_CHANGE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                 // sub system no.(from 0)
    NET_TIME                stuTime;                    // event time
    EM_SUBSYSTEM_STATE_TYPE emState;                    // changed status
}ALARM_SUBSYSTEM_STATE_CHANGE_INFO;

// battery scheduled notice event
typedef struct tagALARM_BATTERYPOWER_INFO
{
    DWORD       dwSize;
    int         nChannel;                                  // battery no.
    NET_TIME    stuTime;                                   // event time
    int         nPercent;                                  // battery percentage
}ALARM_BATTERYPOWER_INFO;

//bell status event
typedef struct tagALARM_BELLSTATUS_INFO 
{
    DWORD       dwSize;
    int         nChannel;                                   // bell channel no. 
    NET_TIME    stuTime;                                    // event time
    int         nAction;                                    // 0:start 1:stop
}ALARM_BELLSTATUS_INFO;

// zone status change event, corresponding to event type DH_ALARM_DEFENCE_STATE_CHANGE_EVENT
typedef struct tagALARM_DEFENCE_STATUS_CHANGE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // zone ID¡ê?as alarm input channel no.(from 0)
    NET_TIME                stuTime;                        // event time
    EM_DEFENCE_STATE_TYPE   emStatus;                       // zone changed status
}ALARM_DEFENCE_STATUS_CHANGE_INFO;

// login failed event
typedef struct tagALARM_LOGIN_FAILIUR_INFO
{
    DWORD                   dwSize;
    int                     nAction;                        // 0:start 1:stop
    unsigned int            nSequence;                      // no.
    char                    szName[DH_EVENT_NAME_LEN];      // event name¡ê?fill in user name
    char                    szType[DH_COMMON_STRING_128];   // login type
    char                    szAddr[DH_MAX_IPADDR_EX_LEN];   // source IP address
    int                     nError;                         // user login failed error code
}ALARM_LOGIN_FAILIUR_INFO;

// ticket statistics info event corresponding to event type DH_ALARM_TICKET_STATISTIC
typedef struct tagALARM_TICKET_STATISTIC
{
    DWORD                   dwSize;
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS info
    NET_TIME                stuTime;                        // event report time
    int                     nNormalCount;                   // general ticket number
    int                     nDiscountCount;                 // discount ticket
    int                     nSubsidyCount;                  // yound and old ticket number
    int                     nDriverCount;                   // driver ticket number
    int                     nNormalPrice;                   // general ticket price
    int                     nDiscountPrice;                 // discount ticket price
    int                     nSubsidyPrice;                  // young and old ticket price
}ALARM_TICKET_STATISTIC;

#define MAX_ALARMEXT_MODULE_NUM     256                     // max expansionmodule quantity

// BUS type
typedef enum tagNET_BUS_TYPE
{
    NET_BUS_TYPE_UNKNOWN = 0,
    NET_BUS_TYPE_MBUS,                                      // M-BUS
    NET_BUS_TYPE_RS485,                                     // RS-485
}NET_BUS_TYPE;

// expansion module offline event  corresponding to event type DH_ALARM_MODULE_LOST
typedef struct tagALARM_MODULE_LOST_INFO 
{
    DWORD                   dwSize;
    NET_TIME                stuTime;                        // event report time
    int                     nSequence;                      // expansion module BUS no.(from 0)
    NET_BUS_TYPE            emBusType;                      // BUS type
    int                     nAddr;                          // offline expansion module quantity
    int                     anAddr[MAX_ALARMEXT_MODULE_NUM];// offline expansionmodule no.(from 0)
	char					szDevType[DH_COMMON_STRING_64];	// device type "SmartLock"when type of"AlarmDefence"Index address is Alarm number
	BOOL					bOnline;						// Online status. The default setup is false. False=offline, true=online
}ALARM_MODULE_LOST_INFO;

// PSTN offline event
typedef struct tagALARM_PSTN_BREAK_LINE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                 // tel wire no.(from 0)
    int                     nAction;                    // 0:start  1:stop
    NET_TIME                stuTime;                    // event time
}ALARM_PSTN_BREAK_LINE_INFO;

// analog alarm event(instant event), specific sensot type(as overspeed, mealige, oil)trigger
typedef struct tagALARM_ANALOGPULSE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // analog alarm channel no.
    NET_TIME                stuEventTime;                   // alarm event time
    NET_SENSE_METHOD        emSense;                        // sensor type
    char                    szName[DH_COMMON_STRING_128];   // sensor name
    int                     nStatus;                        // data status, -1:unknown,0:normal,1:invalid data(over range),
                                                            // 2:over threshold 1,3:over threshold 2,4: over threshold 3,5 over threshold 4,
                                                            // 6:below threshold 1,7: below threshold 2,8: below threshold 3,9: below threshold 4
    float                   fValue;                         // senspr value
    NET_TIME                stuCollectTime;                 // collection time
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS info
}ALARM_ANALOGPULSE_INFO;

//dispatch info confirmation type 
typedef enum tagNET_MISSION_CONFIRM_TYPE
{
    NET_MISSION_CONFIRM_UNKNOWN = 0 ,                        // unknown 
    NET_MISSION_CONFIRM_YES ,                                // agree and execute
	NET_MISSION_CONFIRM_NO ,                                 // refuse
}NET_MISSION_CONFIRM_TYPE;

// task confirmation event(corresponding to command DH_ALARM_MISSION_CONFIRM)
typedef struct tagALARM_MISSION_CONFIRM_INFO 
{
    DWORD                   dwSize;
    char                    szTitle[DH_COMMON_STRING_256];    // task name
    char                    szMissionID[DH_COMMON_STRING_256];// task ID
    char                    szComment[DH_COMMON_STRING_256];  // replay content
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                 // GPS info
    NET_MISSION_CONFIRM_TYPE emConfirmType;                   //dispatch info confirmation type 
}ALARM_MISSION_CONFIRM_INFO;

// collect Node group  type 
typedef enum tagNET_CLUSTER_GROUP_TYPE
{
  NET_CLUSTER_GROUP_UNKNOWN,             // unknown 
  NET_CLUSTER_GROUP_IDLE,               // stand alone
  NET_CLUSTER_GROUP_MASTER,              // host
  NET_CLUSTER_GROUP_SLAVE,              // spare
}NET_CLUSTER_GROUP_TYPE;

// Node activate event , corresponding to event type DH_ALARM_NODE_ACTIVE
typedef struct tagALARM_NODE_ACTIVE_INFO 
{
  DWORD          dwSize;
  int           nChannelID;         // collect node no.
  NET_TIME        stuTime;          // event occurred event 
  NET_CLUSTER_GROUP_TYPE emGroup;          //  current Node group
}ALARM_NODE_ACTIVE_INFO;

// collect Node status 
typedef struct tagNET_CLUSTER_STATE_INFO 
{
  DWORD          dwSize;
  NET_CLUSTER_GROUP_TYPE emGroup;          //  current Node group
}NET_CLUSTER_STATE_INFO;

// device alarm mode 
typedef enum tagEM_ALARM_VIDEO_STATIC_MODE
{
  EM_ALARM_VIDEO_STATIC_MODE_UNKNOWN,         // unknown 
  EM_ALARM_VIDEO_STATIC_MODE_INDOOR,         // indoor mode "Indoor"
  EM_ALARM_VIDEO_STATIC_MODE_OUTDOOR,         // outdoor mode "Outdoor"
}EM_ALARM_VIDEO_STATIC_MODE;

// video statis detection event , corresponding to event type DH_ALARM_VIDEO_STATIC
typedef struct tagALARM_VIDEO_STATIC_INFO 
{
  DWORD            dwSize;
  DWORD            dwAction;            // event action, 0:Start, 1:Stop
  EM_ALARM_VIDEO_STATIC_MODE emMode;             // device alarm mode 
  int             nChannelID;           // video statis detection alarm channel no.
}ALARM_VIDEO_STATIC_INFO;

// active registration device re-login event , corresponding to event type DH_ALARM_REGISTER_REONLINE
typedef struct tagALARM_REGISTER_REONLINE_INFO
{
  DWORD      dwSize;
}ALARM_REGISTER_REONLINE_INFO;

// connection status 
typedef enum tagEM_ALARM_ISCSI_STATUS
{
  EM_ALARM_ISCSI_STATUS_UNKNOWN,         // unknown 
  EM_ALARM_ISCSI_STATUS_CONNECTED,        // connected
  EM_ALARM_ISCSI_STATUS_NOT_CONNECTED,      // unconnected
  EM_ALARM_ISCSI_STATUS_CONNECT_FAILED,      // connection failed
  EM_ALARM_ISCSI_STATUS_AUTHENTICATION_FAILED,  // authentication failed
  EM_ALARM_ISCSI_STATUS_CONNECT_TIMEOUT,     // connection timed out
  EM_ALARM_ISCSI_STATUS_NOT_EXIST,        // device does not exist
}EM_ALARM_ISCSI_STATUS;

// ISCSI alarm event , corresponding to event type DH_ALARM_ISCSI_STATUS
typedef struct tagALARM_ISCSI_STATUS_INFO
{
  DWORD          dwSize;
  int           nIndex;               // means ISCSIdevice index no.
  char          szAddress[DH_COMMON_STRING_32];   // server address
  char          szName[DH_COMMON_STRING_64];    // Target name 
  char          szUserName[DH_COMMON_STRING_64];  // username
  EM_ALARM_ISCSI_STATUS  emStatus;              // connection status 
}ALARM_ISCSI_STATUS_INFO;

// detection collection device alarm event , corresponding to event type DH_ALARM_SCADA_DEV_ALARM
typedef struct tagALARM_SCADA_DEV_INFO 
{
    DWORD       dwSize;
    int         nChannel;                           // channel no.
    NET_TIME    stuTime;                            // event occur time
    char        szDevName[DH_COMMON_STRING_64];     // failure device name 
    char        szDesc[DH_COMMON_STRING_256];       // alarm description
    int         nAction;                            // -1:unknown, 0:pulse, 1:start, 2:stop
    char        szID[DH_COMMON_STRING_32];          // point ID, current len is 16 bytes
    char        szSensorID[DH_COMMON_STRING_32];    // sensor ID, current len is 16 bytes
    char        szDevID[DH_COMMON_STRING_32];       // device ID, current len is 16 bytes
    char        szPointName[DH_COMMON_STRING_64];   // point name, matching with spot chart
}ALARM_SCADA_DEV_INFO;

// vehicle ACC alarm event, correspond event: DH_ALARM_VEHICLE_ACC
typedef struct tagALARM_VEHICLE_ACC_INFO 
{
    DWORD                   dwSize;
    int                     nACCStatus;                         // ACC state, 0:invalid, 1:open, 2:close 
    int                     nAction;                            // event action, 0:Start, 1:Stop
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                   // GPS informmation
    int                     nConstantElectricStatus;            // Constant electric states, 0:unknown, 1:connect, 2:break                            
}ALARM_VEHICLE_ACC_INFO;

typedef NET_ACCESS_CTL_STATUS_TYPE  NET_ACCESS_LOCK_STATUS_TYPE;

// locked status, correspond to DH_ALARM_ACCESS_LOCK_STATUS
typedef struct tagALARM_ACCESS_LOCK_STATUS_INFO 
{
    DWORD                       dwSize;
    int                         nChannel;                       // door channal (from 0)
    NET_TIME                    stuTime;                        // the time of event occurs
    NET_ACCESS_LOCK_STATUS_TYPE emLockStatus;                   // locked status
}ALARM_ACCESS_LOCK_STATUS_INFO;

// SEVER TYPE
typedef enum tagEM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE
{
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_UNKNOWN,         // Unknown
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_ORGANIZATION,    // Organization wealth investment 
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_SEAL,            // Sealed wealth investment 
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_EXCLUSIVE,       // Exclusive wealth investment 
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_GATHER,          // Combination wealth investment 
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_EVEN,            // Capital protection wealth investment 
}EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE;

// Finace event, correspond to DH_ALARM_FINACE_SCHEME
typedef struct tagALARM_FINACE_SCHEME_INFO 
{
    DWORD                       dwSize;
    int                         nChannel;                                   // channel ID
    char                        szBusinessSeverID[DH_COMMON_STRING_64];     // business sever ID
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE  emBusinessSeverType;        // business sever type
    NET_TIME                    stuFinaceSchemeTime;                        // finance scheme time
    NET_TIME                    stuSchemeStartTime;                         // scheme start time
    NET_TIME                    stuSchemeEndTime;                           // scheme end time
    char                        szProductName[DH_COMMON_STRING_128];        // product name
    char                        szCardNo[DH_COMMON_STRING_64];              // card ID
    char                        szPersonID[DH_COMMON_STRING_64];            // persion ID
    char                        szPersonName[DH_COMMON_STRING_64];          // persion name
    char                        szOrgNo[DH_COMMON_STRING_64];               // subbranch No
    char                        szStuffID[DH_COMMON_STRING_64];             // stuff ID
    NET_TIME                    stuRecStartTime;                            // record start time
    NET_TIME                    stuRecEndTime;                              // record end time
}ALARM_FINACE_SCHEME_INFO;

//////////////////////////////////////////////////////////////////////////

// New Record Set Operation(Insert)Parameter
typedef struct tagNET_CTRL_RECORDSET_IN
{
	DWORD	dwSize;
	EM_NET_RECORD_TYPE	emType;					// Record Information Type
	void*	pBuf;								// Record Information Cache,The EM_NET_RECORD_TYPE Note is Details
	int		nBufLen;							// Record Information Cache Size
}NET_CTRL_RECORDSET_INSERT_IN;

// Record New Operation(Insert) Parameter
typedef struct tagNET_CTRL_RECORDSET_OUT 
{
    DWORD           dwSize;
    int             nRecNo;                             // Record Number(The Device Come Back When New Insert )
}NET_CTRL_RECORDSET_INSERT_OUT;

// Record New Operation (Insert)Parameter 
typedef struct tagNET_CTRL_RECORDSET_INSERT_PARAM 
{
    DWORD                           dwSize;
    NET_CTRL_RECORDSET_INSERT_IN    stuCtrlRecordSetInfo;       // Record Information(User Write)
    NET_CTRL_RECORDSET_INSERT_OUT   stuCtrlRecordSetResult;     // Record Information(the Device Come Back)
}NET_CTRL_RECORDSET_INSERT_PARAM;

// Record Operation Parameter
typedef struct tagNET_CTRL_RECORDSET_PARAM 
{
    DWORD               dwSize;
    EM_NET_RECORD_TYPE  emType;                         // Record Information Type
    void*               pBuf;                           // New/Renew/Inquire,It is Record Information Cache¡ê?the EM_NET_RECORD_TYPE Note is Details)
                                                        // Delete,It is Record Number(Int Model)
    int                    nBufLen;                     // Record Information Cache Size
}NET_CTRL_RECORDSET_PARAM;

// Card Statue
typedef enum tagNET_ACCESSCTLCARD_STATE
{
    NET_ACCESSCTLCARD_STATE_UNKNOWN = -1,
    NET_ACCESSCTLCARD_STATE_NORMAL = 0,                 // Normal
    NET_ACCESSCTLCARD_STATE_LOSE   = 0x01,              // Lose
    NET_ACCESSCTLCARD_STATE_LOGOFF = 0x02,              // Logoff
    NET_ACCESSCTLCARD_STATE_FREEZE = 0x04,              // Freeze
    NET_ACCESSCTLCARD_STATE_ARREARAGE = 0x08,           // Arrears
    NET_ACCESSCTLCARD_STATE_OVERDUE = 0x10,             // Overdue
}NET_ACCESSCTLCARD_STATE;

// Card Type 
typedef enum tagNET_ACCESSCTLCARD_TYPE
{
    NET_ACCESSCTLCARD_TYPE_UNKNOWN = -1,
    NET_ACCESSCTLCARD_TYPE_GENERAL,                     // General Card
    NET_ACCESSCTLCARD_TYPE_VIP,                         // VIP Card
    NET_ACCESSCTLCARD_TYPE_GUEST,                       // Guest Card
    NET_ACCESSCTLCARD_TYPE_PATROL,                      // Patrol Card
    NET_ACCESSCTLCARD_TYPE_BLACKLIST,                   // Blacklist Card
    NET_ACCESSCTLCARD_TYPE_CORCE,                       // Corce Card
    NET_ACCESSCTLCARD_TYPE_MOTHERCARD = 0xff,           // Mother Card
}NET_ACCESSCTLCARD_TYPE;

#define DH_MAX_DOOR_NUM               32                // Max Door Number 
#define DH_MAX_TIMESECTION_NUM        32                // Max Time Section Number
#define DH_MAX_CARDNAME_LEN           64                // access control naming max length
#define DH_MAX_CARDNO_LEN             32                // Max Card-Number Len
#define DH_MAX_USERID_LEN             32                // Max User ID Len

// fingerprint data, for sending only
typedef struct tagNET_ACCESSCTLCARD_FINGERPRINT_PACKET
{
    DWORD   dwSize;	
	int		nLength;		// length of a finger print packet, unit: byte
	int		nCount;			// packet number 
	char*	pPacketData;	// all fingerprint packet in a single buffer, allocated and filled by user, nLength*nCount bytes
}NET_ACCESSCTLCARD_FINGERPRINT_PACKET;

// fingerprint data, for sending and receiving
typedef struct tagNET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX
{
    int     nLength;        // length of a finger print packet, unit: byte
    int     nCount;         // packet number 
    char*   pPacketData;    // all fingerprint packet in a single buffer, allocated by user
    int     nPacketLen;     // pPacketData buffer length, set by user
    int     nRealPacketLen; // The actual fingerprint size returned to the user, equal to nLength*nCount
    BYTE    byReverseed[1024]; //Reserved size 
}NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX;
// record set info of entrance guard card 

//Entrance Guard Record Information
typedef struct tagNET_RECORDSET_ACCESS_CTL_CARD
{
    DWORD           dwSize;
    int             nRecNo;                                 // Record Number,Read-Only
    NET_TIME        stuCreateTime;                          // Creat Time
    char            szCardNo[DH_MAX_CARDNO_LEN];            // Card number
    char            szUserID[DH_MAX_USERID_LEN];            // User's ID
    NET_ACCESSCTLCARD_STATE       emStatus;                 // Card Stetue
    NET_ACCESSCTLCARD_TYPE        emType;                   // Card Type
    char            szPsw[DH_MAX_CARDPWD_LEN];              // Card Password
    int             nDoorNum;                               // Valid Door Number;
    int             sznDoors[DH_MAX_DOOR_NUM];              // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
    int             nTimeSectionNum;                        // the Number of Effective Open Time
    int             sznTimeSectionNo[DH_MAX_TIMESECTION_NUM];  // Open Time Segment Index,That is CFG_ACCESS_TIMESCHEDULE_INFO Array subscript
    int             nUserTime;                              // Frequency of Use
    NET_TIME        stuValidStartTime;                      // Valid Start Time 
    NET_TIME        stuValidEndTime;                        // Valid End Time
    BOOL            bIsValid;                               // Wether Valid,True =Valid,False=Invalid
    NET_ACCESSCTLCARD_FINGERPRINT_PACKET stuFingerPrintInfo;// fingerprint data info (send only), DEPRECATED! use stuFingerPrintInfoEx instead
    BOOL            bFirstEnter;                            // has first card or not
    char            szCardName[DH_MAX_CARDNAME_LEN];        // card naming
    char            szVTOPosition[DH_COMMON_STRING_64];     // VTO link position
    BOOL            bHandicap;                              // Card for handicap, TRUE:yes, FALSE:no
    BOOL            bEnableExtended;                        // Enabled member stuFingerPrintInfoEx
    NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX     stuFingerPrintInfoEx; // fingerprint data info structure    
}NET_RECORDSET_ACCESS_CTL_CARD;

// Entrance Guard Record  Information
typedef struct tagNET_RECORDSET_ACCESS_CTL_PWD 
{
    DWORD           dwSize;
    int             nRecNo;                                 // Record Number,Read-Only
    NET_TIME        stuCreateTime;                          // Create Time
    char            szUserID[DH_MAX_USERID_LEN];            // User's ID
    char            szDoorOpenPwd[DH_MAX_CARDPWD_LEN];      // Open Password
    char            szAlarmPwd[DH_MAX_CARDPWD_LEN];         // Alarm Password
    int             nDoorNum;                               // Valid Door Number
    int             sznDoors[DH_MAX_DOOR_NUM];              // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
    char            szVTOPosition[DH_COMMON_STRING_64];     // VTO link position
}NET_RECORDSET_ACCESS_CTL_PWD;


// Door Open Method(Entrance Guard Configure,One Way of Door Work )
typedef enum tagNET_DOOR_OPEN_METHOD
{
    NET_DOOR_OPEN_METHOD_UNKNOWN = 0,
    NET_DOOR_OPEN_METHOD_PWD_ONLY,                          // Password Open is Only
    NET_DOOR_OPEN_METHOD_CARD,                              // Card  open is Only
    NET_DOOR_OPEN_METHOD_PWD_OR_CARD,                       // Password or Card
    NET_DOOR_OPEN_METHOD_CARD_FIRST,                        // First Card then Password
    NET_DOOR_OPEN_METHOD_PWD_FIRST,                         // First Card then Password
    NET_DOOR_OPEN_METHOD_SECTION,                           // Sub-Periods
}NET_DOOR_OPEN_METHOD;

// Door Open Method(Entrance Guard Event,Entrance Guard get In/Out Record¡ê?Actual Open Door Method)
typedef enum tagNET_ACCESS_DOOROPEN_METHOD
{
    NET_ACCESS_DOOROPEN_METHOD_UNKNOWN = 0,
    NET_ACCESS_DOOROPEN_METHOD_PWD_ONLY,                    // Password
    NET_ACCESS_DOOROPEN_METHOD_CARD,                        // Card
    NET_ACCESS_DOOROPEN_METHOD_CARD_FIRST,                  // First Card Then Password
    NET_ACCESS_DOOROPEN_METHOD_PWD_FIRST,                   // First Password Then Card 
    NET_ACCESS_DOOROPEN_METHOD_REMOTE,                      // Long-Range Open,Such as Through theIndoor Unit or Unlock the Door Machine Platform
    NET_ACCESS_DOOROPEN_METHOD_BUTTON,                      // Open Door Button
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT,                 // fingerprint lock
    NET_ACCESS_DOOROPEN_METHOD_PWD_CARD_FINGERPRINT,        // password+swipe card+fingerprint combination unlock
    NET_ACCESS_DOOROPEN_METHOD_PWD_FINGERPRINT = 10,        // password+fingerprint combination unlock
    NET_ACCESS_DOOROPEN_METHOD_CARD_FINGERPRINT = 11,       // swipe card+fingerprint combination unlock
    NET_ACCESS_DOOROPEN_METHOD_PERSONS = 12,                // multi-people unlock
    NET_ACCESS_DOOROPEN_METHOD_KEY = 13,                    // Key
    NET_ACCESS_DOOROPEN_METHOD_COERCE_PWD = 14,             // Use force password to open the door 
}NET_ACCESS_DOOROPEN_METHOD;

// Access Control card Record Information
typedef struct tagNET_RECORDSET_ACCESS_CTL_CARDREC
{
    DWORD           dwSize;
    int             nRecNo;                                 // Record Number,Read-Only
    char            szCardNo[DH_MAX_CARDNO_LEN];            // Card Number
    char            szPwd[DH_MAX_CARDPWD_LEN];              // Password
    NET_TIME        stuTime;                                // Swing Card Time
    BOOL            bStatus;                                // Swing Card Result,True is Success,False is Fail
    NET_ACCESS_DOOROPEN_METHOD    emMethod;                 // Open Door Method
    int             nDoor;                                  // Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript 
    char            szUserID[DH_MAX_USERID_LEN];            // user ID
    int             nReaderID;                              // card reader ID (abandoned)
	char			szSnapFtpUrl[MAX_PATH];					// unlock snap upload ftp url
	char            szReaderID[DH_COMMON_STRING_32];    	// card reader ID
	NET_ACCESSCTLCARD_TYPE      emCardType;                         // Card Type
    int                         nErrorCode;                         // Reason of unlock failure, only because it is valid when bStatus is FALSE
                                                                    // 0x00 no error
                                                                    // 0x10 unauthorized
                                                                    // 0x11 card lost or cancelled
                                                                    // 0x12 no door right
                                                                    // 0x13 unlock mode error
                                                                    // 0x14 valid period error
                                                                    // 0x15 anti sneak into mode
                                                                    // 0x16 forced alarm not unlocked
                                                                    // 0x17 door NC status
                                                                    // 0x18 AB lock status
                                                                    // 0x19 patrol card
                                                                    // 0x1A device is under intrusion alarm status
                                                                    // 0x20 period error
                                                                    // 0x21 unlock period error in holiday period
                                                                    // 0x30 first card right check required
                                                                    // 0x40 card correct, input password error
                                                                    // 0x41 card correct, input password timed out
                                                                    // 0x42 card correct, input fingerprint error
                                                                    // 0x43 card correct, input fingerprint timed out
                                                                    // 0x44 fingerprint correct, input password error
                                                                    // 0x45 fingerprint correct, input password timed out
                                                                    // 0x50 group unlock sequence error
                                                                    // 0x51 test required for group unlock
                                                                    // 0x60 test passed, control unauthorized
	
	
	
}NET_RECORDSET_ACCESS_CTL_CARDREC;

// Holiday Record Iinformation
typedef struct tagNET_RECORDSET_HOLIDAY
{
    DWORD           dwSize;
    int             nRecNo;                                 // Record Number,Read-Only
    int             nDoorNum;                               // Valid Door Number    
    int             sznDoors[DH_MAX_DOOR_NUM];              // Privileged Door Number,That is CFG_CMD_ACCESS_EVENT Configure Array Subscript
    NET_TIME        stuStartTime;                           // Start Time
    NET_TIME        stuEndTime;                             // End Time
    BOOL            bEnable;                                // Holiday Enable
	char            szHolidayNo[DH_COMMON_STRING_32];       // Holiday No
}NET_RECORDSET_HOLIDAY;

// GPS position record set info 
typedef struct tagNET_RECORD_GPS_LOCATION_INFO
{
    DWORD           dwSize;                                 // Structure size 
    int             nRecNo;                                 // Read set SN. Read-only. 
    double          dLongitude;                             // GPS longitude. Unit is degree
    double          dLatitude;                              // GPS latitude. Unit is degree. 
    char            szPlaceName[128];                       // GPS coordinates name 
    char            szRadius[16];                           // Radius
} NET_RECORD_GPS_LOCATION_INFO;


// call type 
typedef enum tagEM_VIDEO_TALK_LOG_CALLTYPE
{
  EM_VIDEO_TALK_LOG_CALLTYPE_UNKNOWN = 0,     // unknown 
  EM_VIDEO_TALK_LOG_CALLTYPE_INCOMING,      // call in
  EM_VIDEO_TALK_LOG_CALLTYPE_OUTGOING,      // call out
  EM_VIDEO_TALK_LOG_CALLTYPE_MAX,         //
}EM_VIDEO_TALK_LOG_CALLTYPE;

// terminal status 
typedef enum tagEM_VIDEO_TALK_LOG_ENDSTATE
{
  EM_VIDEO_TALK_LOG_ENDSTATE_UNKNOWN = 0,     // unknown 
  EM_VIDEO_TALK_LOG_ENDSTATE_MISSED,       // missed
  EM_VIDEO_TALK_LOG_ENDSTATE_RECEIVED,      // answered
  EM_VIDEO_TALK_LOG_ENDSTATE_MAX,         //
}EM_VIDEO_TALK_LOG_ENDSTATE;

// opposite type 
typedef enum tagEM_VIDEO_TALK_LOG_PEERTYPE
{
  EM_VIDEO_TALK_LOG_PEERTYPE_UNKNOWN = 0,     // unknown 
  EM_VIDEO_TALK_LOG_PEERTYPE_VTO,         // VTO
  EM_VIDEO_TALK_LOG_PEERTYPE_VTH,         // VTH
  EM_VIDEO_TALK_LOG_PEERTYPE_VTS,         // management centre server
}EM_VIDEO_TALK_LOG_PEERTYPE;

// call record record set info 
typedef enum tagNET_RECORD_READFLAG
{
	NET_RECORD_READFLAG_UNREADED = 0, //Unread
	NET_RECORD_READFLAG_READED,	    //Read
	NET_RECORD_READFLAG_UNKNOWN,      //Unknown
}NET_RECORD_READFLAG;
// video talk record set log
typedef struct tagNET_RECORD_VIDEO_TALK_LOG
{
  DWORD              dwSize;
  int               nRecNo;               // record set no., read-only
  NET_TIME            stuCreateTime;           // start time
  EM_VIDEO_TALK_LOG_CALLTYPE   emCallType;             // call type 
  EM_VIDEO_TALK_LOG_ENDSTATE   emEndState;             // terminal status 
  char              szPeerNumber[DH_COMMON_STRING_64]; // opposite number	may be short no. or middle no., long no.
  EM_VIDEO_TALK_LOG_PEERTYPE   emPeerType;             // opposite type 
  char              szLocalNumber[DH_COMMON_STRING_64]; // local no.	may be short no. or middle no., long no.
  int               nTalkTime;             // talk time	unit second
  int               nMessageTime;            // message time	unit second
  char              szPicturePath[DH_COMMON_STRING_128];// 
}NET_RECORD_VIDEO_TALK_LOG;


// audio talk status 
typedef enum tagEM_REGISTER_USER_STATE
{
  EM_REGISTER_USER_STATE_UNKNOWN = 0,         // unknown 
  EM_REGISTER_USER_STATE_IDLE,                // initial status 
  EM_REGISTER_USER_STATE_CALLING,             // call status ¡ê¡§no response¡ê?
  EM_REGISTER_USER_STATE_RINGING,             // ring status ¡ê¡§opposite response¡ê?but no response¡ê?
  EM_REGISTER_USER_STATE_PREVIEWING,          // previewing
  EM_REGISTER_USER_STATE_LEAVINGMESSAGE,      // messaging
  EM_REGISTER_USER_STATE_TALKING,             // talking
  EM_REGISTER_USER_STATE_MAX,                 //
}EM_REGISTER_USER_STATE;

// device type
typedef enum tagEM_REGISTER_USER_STATE_DEV_TYPE
{
    EM_REGISTER_USER_STATE_DEV_TYPE_UNKNOWN = 0,            // unknown
    EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTH,              // digital VTH
    EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTH,             // analogue VTH
    EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTO,              // digital VTO
    EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTO,             // analogue VTO
    EM_REGISTER_USER_STATE_DEV_TYPE_MAX,                    //
}EM_REGISTER_USER_STATE_DEV_TYPE;

// support lock or not
typedef enum tagEM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE
{
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_UNKNOWN = 0,                // Unknown
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_SUPPORTLOCK,                // Support
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_NOT_SUPPORTLOCK,            // Do not support
}EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE;

typedef enum tagNET_MONITORSTATE_TYPE
{
	NET_MONITORSTATE_TYPE_UNMONITORED = 0,		// 0 unmonitor (initial status)
	NET_MONITORSTATE_TYPE_MONITORREQUEST,		// 1 receive monitor query 
	NET_MONITORSTATE_TYPE_MONITORED,			// 2 monitor status 
	NET_MONITORSTATE_TYPE_UNKNOWN,				// Unknown status 
}NET_MONITORSTATE_TYPE;
// state record set info
typedef struct tagNET_RECORD_REGISTER_USER_STATE
{
    DWORD                                   dwSize;
    int                                     nRecNo;	                        // record set no., read-only
    NET_TIME                                stuCreateTime;                  // create time
    char                                    szUserID[DH_MAX_USERID_LEN];    // user ID
    BOOL									bOnline;                        // online or not
    char                                    szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];   // network address
    int                                     nPort;                          // port no.  
    EM_REGISTER_USER_STATE                  emVideoTalkState;               // audio talk status 
    NET_TIME                                stuOnlineTime;                  // online time
    NET_TIME                                stuOfflineTime;                 // offline time
    EM_REGISTER_USER_STATE_DEV_TYPE         emDevType;                      // device type
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE	emSupportLock;                  // whether support lock
	NET_MONITORSTATE_TYPE					emMonitorState;						// ¼àÊÓ×´Ì¬
}NET_RECORD_REGISTER_USER_STATE;

// visual talk analog VTH input mode 
typedef enum tagEM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE
{
  EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_UNKNOWN,       // unknown 
  EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEADDRESS,     // via SlaveAddress
  EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEID_SLAVEPORT,  // via SlaveID+SlavePort
}EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE;

// user type 
typedef enum tagEM_VIDEO_TALK_CONTACT_TYPE
{
  EM_VIDEO_TALK_CONTACT_TYPE_UNKNOWN,       // unknown 
  EM_VIDEO_TALK_CONTACT_TYPE_VTH,         // "VTH" VTH
  EM_VIDEO_TALK_CONTACT_TYPE_VTO,         // "VTO" VTO
}EM_VIDEO_TALK_CONTACT_TYPE;

// registration method
typedef enum tagEM_VIDEO_TALK_CONTACT_REGISTER_TYPE
{
  EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_UNKNOWN,        // unknown 
  EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_PUBLIC,         // "public"
  EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_LOCAL,         // "local"
}EM_VIDEO_TALK_CONTACT_REGISTER_TYPE;

// contact record set info 
typedef struct tagNET_RECORD_VIDEO_TALK_CONTACT
{
  DWORD                  dwSize;
  int                   nRecNo;                 // record  set no.¡ê?read-only
  NET_TIME                stuCreateTime;             // create time
  char                  szFirstName[DH_COMMON_STRING_32];    // name
  char                  szFamilyName[DH_COMMON_STRING_32];   // last name
  char                  szVTShortNumber[DH_COMMON_STRING_16];  // visual talk short no.
  char                  szVTMiddleNumber[DH_COMMON_STRING_32]; // visual talk middle no.
  char                  szVTLongNumber[DH_COMMON_STRING_64];  // visual talk long no.¡ê?or VTH analogue VTH SN
  char                  szVTNetAddress[DH_MAX_IPADDR_LEN_EX];  // visual talk network address
  char                  szVTOPosition[DH_COMMON_STRING_64];   // VTH link to VTO position
  EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE  emVTSlaveBindMode;           // visual talk analogue VTH input mode 
  char                  szVTSlaveId[DH_COMMON_STRING_32];    // visual talk analogue  VTH input distributor address
  char                  szVTSlavePort[DH_COMMON_STRING_32];   // visual talk analogue  VTH input distributor port
  char                  szVTSlaveAddress[DH_COMMON_STRING_64]; // visual talk analogue VTH address
  char                  szNickname[DH_COMMON_STRING_64];    // nickname
  char                  szNotes[DH_COMMON_STRING_64];      // note
  EM_VIDEO_TALK_CONTACT_TYPE       emType;                 // user type 
  EM_VIDEO_TALK_CONTACT_REGISTER_TYPE   emRegisterType;             // registration method
  char                  szVTHPassword[DH_COMMON_STRING_64];   // registration password
  char                  szVTOBuilding[DH_COMMON_STRING_64];   // building no.
  char                  szVTOUnit[DH_COMMON_STRING_64];     // unit no.
  char                  szGroupNumber[DH_COMMON_STRING_64];   // group
    int                                     nVTSlaveId;                             // ¿ÉÊÓ¶Ô½²Ä£ÄâÊÒÄÚ»ú½ÓÈëÊ±µÄ·ÖÅäÆ÷µØÖ·
    int                                     nVTSlavePort;                           // ¿ÉÊÓ¶Ô½²Ä£ÄâÊÒÄÚ»ú½ÓÈëÊ±µÄ·ÖÅäÆ÷¶Ë¿Ú
}NET_RECORD_VIDEO_TALK_CONTACT;

//Bulletin status
typedef enum tagNET_ANNOUNCE_STATE
{
	NET_ANNOUNCE_STATE_UNSENDED = 0, //Initial status (to be send)
	NET_ANNOUNCE_STATE_SENDED,		//Sent
	NET_ANNOUNCE_STATE_EXPIRED,		//Expired
	NET_ANNOUNCE_STATE_UNKNOWN,		//Unknown
}NET_ANNOUNCE_STATE;

//The bulletin has been reviewed or not
typedef enum tagNET_ANNOUNCE_READFLAG
{
	NET_ANNOUNCE_READFLAG_UNREADED = 0, //Unread
	NET_ANNOUNCE_READFLAG_READED,	    //Read
	NET_ANNOUNCE_READFLAG_UNKNOWN,      //Unknown
}NET_ANNOUNCE_READFLAG;

// Bulletin record info 
typedef struct tagNET_RECORD_ANNOUNCEMENT_INFO
{
	DWORD									dwSize;									
	int										nRecNo;									// Record set SN. read only 
	NET_TIME                                stuCreateTime;                          // Creation time 
	NET_TIME								stuIssueTime;							// Bulletin released time 
	char									szAnnounceTitle[DH_COMMON_STRING_64];	// Bulletin title
	char									szAnnounceContent[DH_COMMON_STRING_256];//Bulletin contents 
	char									szAnnounceDoor[DH_COMMON_STRING_16];	//The room No. the bulletin to be sent to. 
	NET_TIME								stuExpireTime;							//Bulletin expire time 
	NET_ANNOUNCE_STATE						emAnnounceState;						//Bulletin status
	NET_ANNOUNCE_READFLAG					emAnnounceReadFlag;						//Bulletin has been reviewed or not
}NET_RECORD_ANNOUNCEMENT_INFO;


// Bulletin record info search criteria 
typedef struct tagFIND_RECORD_ANNOUNCEMENT_CONDITION
{
	DWORD                     dwSize;
	BOOL                      bTimeEnable;                      // Enable search period 
	NET_TIME                  stStartTime;                      // Start time
	NET_TIME                  stEndTime;                        // End time
}FIND_RECORD_ANNOUNCEMENT_CONDITION;


//Alarm record info 
typedef struct tagNET_RECORD_ALARMRECORD_INFO
{
	DWORD									dwSize;
	int										nRecNo;									// Record set SN. Read-only 
	NET_TIME                                stuCreateTime;							// Alarm time. UTC second. Read-only 
	int										nChannelID;								// Alarm channel 
	NET_SENSE_METHOD						emSenseMethod;							// Sensor respond type 
	char									szRoomNumber[DH_MAX_DOOR_NUM];			// Alarm room No. 
	NET_ANNOUNCE_READFLAG					emReadFlag;								// 0=unread, 1-=read 
}NET_RECORD_ALARMRECORD_INFO;

//Alarm record search criteria
typedef struct tagFIND_RECORD_ALARMRECORD_CONDITION
{
	DWORD                     dwSize;
	BOOL                      bTimeEnable;                      // Enable search period 
	NET_TIME                  stStartTime;                      // Start time
	NET_TIME                  stEndTime;                        // End time
}FIND_RECORD_ALARMRECORD_CONDITION;


// A&C not close event detailed info
typedef struct tagALARM_ACCESS_CTL_NOT_CLOSE_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // Door Channel Number
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
    NET_TIME        stuTime;                                // Alarm Event Triggered Time
    int             nAction;                                // 0=Start 1=Stop 
}ALARM_ACCESS_CTL_NOT_CLOSE_INFO;

// Break Event Detail Information
typedef struct tagALARM_ACCESS_CTL_BREAK_IN_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // Door Channel Number
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
    NET_TIME        stuTime;                                // Alarm Event Triggered Time
}ALARM_ACCESS_CTL_BREAK_IN_INFO;


// Repeatedly Entry  Event Detail Information
typedef struct tagALARM_ACCESS_CTL_REPEAT_ENTER_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // Door Channel Number
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
    NET_TIME        stuTime;                                // Alarm Event Triggered Time
	char            szCardNo[DH_MAX_CARDNO_LEN];            // Card number
}ALARM_ACCESS_CTL_REPEAT_ENTER_INFO;


// Forced Card Swing Card  Event Detail Information
typedef struct tagALARM_ACCESS_CTL_DURESS_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // Door Channel Number
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // Entrance Guard Name
    char            szCardNo[DH_MAX_CARDNO_LEN];            // Forced Card Number
    NET_TIME        stuTime;                                // Alarm Event Triggered Time
}ALARM_ACCESS_CTL_DURESS_INFO;


// Entrance Guard Event Type
typedef enum tagNET_ACCESS_CTL_EVENT_TYPE
{
    NET_ACCESS_CTL_EVENT_UNKNOWN = 0,
    NET_ACCESS_CTL_EVENT_ENTRY,                             // Get In
    NET_ACCESS_CTL_EVENT_EXIT,                              // Get Out
}NET_ACCESS_CTL_EVENT_TYPE;


// Entrance Guard Event
typedef struct tagALARM_ACCESS_CTL_EVENT_INFO 
{
    DWORD                       dwSize;
    int                         nDoor;                              // Door Channel Number
    char                        szDoorName[DH_MAX_DOORNAME_LEN];    // Entrance Guard Name
    NET_TIME                    stuTime;                            // Alarm Event Triggered Time
    NET_ACCESS_CTL_EVENT_TYPE   emEventType;                        // Entrance Guard Event Type
    BOOL                        bStatus;                            // Swing Card Result,True is Success,False is Fail
    NET_ACCESSCTLCARD_TYPE      emCardType;                         // Card Type
    NET_ACCESS_DOOROPEN_METHOD  emOpenMethod;                       // Open The Door Method
    char                        szCardNo[DH_MAX_CARDNO_LEN];        // Card Number
    char                        szPwd[DH_MAX_CARDPWD_LEN];          // Password
    char                        szReaderID[DH_COMMON_STRING_32];    // Reader ID
    char                        szUserID[DH_COMMON_STRING_64];      // unlock user
    char                        szSnapURL[DH_COMMON_STRING_256];    // snapshot picture storage address
    int                         nErrorCode;                         // Reason of unlock failure, only because it is valid when bStatus is FALSE
                                                                    // 0x00 no error
                                                                    // 0x10 unauthorized
                                                                    // 0x11 card lost or cancelled
                                                                    // 0x12 no door right
                                                                    // 0x13 unlock mode error
                                                                    // 0x14 valid period error
                                                                    // 0x15 anti sneak into mode
                                                                    // 0x16 forced alarm not unlocked
                                                                    // 0x17 door NC status
                                                                    // 0x18 AB lock status
                                                                    // 0x19 patrol card
                                                                    // 0x1A device is under intrusion alarm status
                                                                    // 0x20 period error
                                                                    // 0x21 unlock period error in holiday period
                                                                    // 0x30 first card right check required
                                                                    // 0x40 card correct, input password error
                                                                    // 0x41 card correct, input password timed out
                                                                    // 0x42 card correct, input fingerprint error
                                                                    // 0x43 card correct, input fingerprint timed out
                                                                    // 0x44 fingerprint correct, input password error
                                                                    // 0x45 fingerprint correct, input password timed out
                                                                    // 0x50 group unlock sequence error
                                                                    // 0x51 test required for group unlock
                                                                    // 0x60 test passed, control unauthorized
    int                         nPunchingRecNo;                     // punching record number 
}ALARM_ACCESS_CTL_EVENT_INFO;

typedef enum tagEM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE
{
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_UNKNOWN,				// Unknown 
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_SUPERMARKET,			// Super market
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_RESTAURANT,			// Dining hall
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_FRUITSTORE,     		// Fruit store
}EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE;

typedef enum tagEM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE
{
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_UNKNOWN,        // Unknown
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_YES,            // Bargain
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_NO,             // No Bargain
}EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE;
// commodity notice record set info
typedef struct tagNET_RECORD_COMMODITY_NOTICE
{
    DWORD                                           dwSize;
    int                                             nRecNo;                                 // ¼ÇÂ¼¼¯±àºÅ£¬Ö»¶Á
    NET_TIME                                        stuSaleTime;                            // »õÆ·ÉÏ¼ÜÊ±¼ä
    char                                            szName[DH_COMMON_STRING_128];           // »õÆ·Ãû³Æ
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE      emSource;                               // »õÆ·ÀàÐÍ
    char                                            szURL[DH_COMMON_STRING_256];            // »õÆ·Í¼Æ¬Â·¾¶, ftp Â·¾¶
    float                                           fPrice;                                 // »õÆ·¼Û¸ñ, µ¥Î»£ºÔª float
    char                                            szID[DH_COMMON_STRING_64];              // IDºÅ£¬ÓÉÆ½Ì¨Í³Ò»¹ÜÀí	Ò»ÖÖ»õÆ·ÓÐÎ¨Ò»µÄID±êÊ¶
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE     emBargain;                              // ÊÇ·ñÌØ¼ÛÉÌÆ·
}NET_RECORD_COMMODITY_NOTICE;

typedef enum tagEM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE
{
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_UNKNOWN,           // Unknown
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_DIGEST,            // Digest 
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_STOMATOLOGY,       // Stomatology
}EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE;
// health care notice record set info
typedef struct tagNET_RECORD_HEALTH_CARE_NOTICE
{
    DWORD                                           dwSize;
    int                                             nRecNo;                                 // ¼ÇÂ¼¼¯±àºÅ£¬Ö»¶Á
    NET_TIME                                        stuStartTime;                           // ÉÏ°àÊ±¼ä
    NET_TIME                                        stuEndTime;                             // ÏÂ°àÊ±¼ä
    char                                            szHospital[DH_COMMON_STRING_128];       // ¾ÍÕïÒ½Ôº
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE    emOffice;                               // ¿ÆÊÒ
    char                                            szOfficeNumber[DH_COMMON_STRING_64];    // ¿ÆÊÒºÅ
    char                                            szDoctorName[DH_COMMON_STRING_128];     // Ò½ÉúÐÕÃû
    char                                            szID[DH_COMMON_STRING_64];              // IDºÅ£¬ÓÉÆ½Ì¨Í³Ò»¹ÜÀí	Ò»ÖÖ»õÆ·ÓÐÎ¨Ò»µÄID±êÊ¶
}NET_RECORD_HEALTH_CARE_NOTICE;
///////////////////////// Alarm of intelligent transportation[CLIENT_StartListenEx] /////////////////////////////////////

//type DH_IVS_TRAFFIC_REALFLOWINFO(traffic real flow info)
typedef struct tagALARM_IVS_TRAFFIC_REALFLOW_INFO
{
	int                 nChannelID;                       // channel ID
	char                szName[128];                      // name
	char                bReserved1[4];                    // reserved
	double              PTS;                              // PTS(ms)
	NET_TIME_EX         UTC;                              // time of occurrence
	int                 nEventID;                         // event ID
	unsigned int        nSequence;                        // sequence
	BYTE                bEventAction;                     // event action,0 pulse,1 durable events begin, 2 durable events end
	BYTE                byReserved[3];
	int                 nLane;                            // lane number
	int                 nCount;                           // cars count
	int					nSpeed;							  // speed,km/h
	int                 nOverPercent;                     // over percent
	int                 nMetersUints;                     // meter unit 0:km,1:mile
	BYTE                bReserved[1024];                  // reserved
}ALARM_IVS_TRAFFIC_REALFLOW_INFO;

// Alarm Event Type,DH_ALARM_VEHICLE_TURNOVER's Data Describe Information
typedef struct tagALARM_VEHICEL_TURNOVER_EVENT_INFO
{
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                bReserved[1023];                // Hold Byte,For Extension.
}ALARM_VEHICEL_TURNOVER_EVENT_INFO;

// Alarm Event Type,DH_ALARM_VEHICLE_COLLISION'sData Describe Information
typedef struct tagALARM_VEHICEL_COLLISION_EVENT_INFO
{
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                bReserved[1023];                // Hold Byte,For Extension.
}ALARM_VEHICEL_COLLISION_EVENT_INFO;

// Alarm Event Type,DH_ALARM_VEHICLE_CONFIRM'sData Describe Information
typedef struct tagALARM_VEHICEL_CONFIRM_INFO
{
    DWORD               dwStructSize;                   // StructSize
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                byRserved[3];                   // Hold Byte,For Extension.
    char                szInfo[128];                    // Upload Alarm Concrete Information
}ALARM_VEHICEL_CONFIRM_INFO;

//Alarm Event Type,DH_EVENT_REGISTER_OFF's Data Describe Information
typedef struct tagEVENT_REGISTER_OFF_INFO
{
    DWORD               dwStructSize;                   // StructSize
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                byRserved[3];                   // Aline
}EVENT_REGISTER_OFF_INFO;

// Alarm Event Type,DH_ALARM_VIDEO_TIMING's Data Describe Information
typedef struct tagALARM_VIDEO_TIMING
{
    DWORD               dwStructSize;                   // StructSize
    DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
    DWORD               dwChannelID;                    // Video Channel ID
}ALARM_VIDEO_TIMING;

// Alarm Event Type,DH_ALARM_VEHICLE_LARGE_ANGLE's Data Describe Information
typedef struct tagALARM_VEHICEL_LARGE_ANGLE
{
    DWORD               dwStructSize;                   // StructSize
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS Information
    BYTE                bEventAction;                   // Event Action,0=Impluse Event,1=Continued Event Start,2=Continued Event End;
    BYTE                byRserved[3];                   // Aline
    unsigned int        nSequence;                      // no.
}ALARM_VEHICEL_LARGE_ANGLE;

// Alarm Event Type,DH_ALARM_AUDIO_ANOMALY's Data Describe Information
typedef struct tagALARM_AUDIO_ANOMALY
{
    DWORD               dwStructSize;                   // StructSize
    DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
    DWORD               dwChannelID;                    // Audio Channel ID
    int                 nDecibel;                       // Audio sensitivity
    int                 nFrequency;                     // Audio frequency 
}ALARM_AUDIO_ANOMALY;

// Alarm Event Type,DH_ALARM_AUDIO_MUTATION's Data Describe Information
typedef struct tagALARM_AUDIO_MUTATION
{
    DWORD               dwStructSize;                   // StructSize
    DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
    DWORD               dwChannelID;                    // Audio Channel ID
}ALARM_AUDIO_MUTATION;

// Corresponding data description info of alarm event type (alarm event type) DH_ALARM_AUDIO_DETECT (audio detect event)
typedef struct tagALARM_AUDIO_DETECT
{
    DWORD               dwAction;                       // Event operation, 1:Start, 2:Stop
    DWORD               dwChannelID;                    // Audio channel No.
    char                reserved[512];                  // Reserved 
} ALARM_AUDIO_DETECT;

#define MAX_SENSORID_NUMBER 20                          // Sensor max amount 
#define MAX_TYRE_NUM        128                         // Max tyre amount 

// Tyre alarm mark enumeration 
typedef enum tagAlarmTyreFlag
{
    ALARM_TYRE_FLAG_NONE,                               // None Valid Data
    ALARM_TYRE_FLAG_NORMAL,                             // Normal
    ALARM_TYRE_FLAG_HIGHPRESSURE,                       // High Pressure
    ALARM_TYRE_FLAG_LOWERPRESSURE,                      // Low Pressure
    ALARM_TYRE_FLAG_HIGHTEMP,                           // High Temperature
    ALARM_TYRE_FLAG_HIGHTEMP_HIGHPRESSURE,              // High Pressure?¡éHigh Temperature
    ALARM_TYRE_FLAG_HIGHTEMP_LOWERPRESSURE,             // High Temperature ?¡éLow Pressure

    ALARM_TYRE_FLAG_INVALID,                            // Illegal Flag Data
}EM_ALARM_TYER_FALG;

// Tyre Information Struct
typedef struct tagTYRE_INFO_UNIT
{
    DWORD               dwStructSize;                    // StructSize
    DWORD               dwSensorIDNum;                   // Sensor Number
    DWORD               dwSensorID[MAX_SENSORID_NUMBER]; // Sensor ID Information
    DWORD               dwTyreNum;                       // Tyre Number
    DWORD               dwTyrePlace;                     // Tyre at the First Few Shaft

    EM_ALARM_TYER_FALG  emAlarmFlag;                     // Tyre Alarm Flag

    int                 nTemp;                           // Temperature,Unit:??
    int                 nTempLimit;                      // Temperature,Unit:??

    float               fPressure;                       // Pressure,Unit:Kpa
    float               fUpperLimit;                     // Alarm Threshold Pressure Upper Limit
    float               fLowerLimit;                     // Alarm Threshold Pressure Lower Limit
    float               fVoltage;                        // Sensor Current Voltage,Unit:V
}TYRE_INFO_UNIT;

// Alarm Event Type,DH_EVENT_TYREINFO's Data Describe Information
typedef struct tagEVENT_TYRE_INFO
{
    DWORD               dwStructSize;                   // StructSize
    DWORD               dwAction;                       // Event Action,0=Pause,1=Start,2=Stop
    DWORD               dwTyreNum;                      // Tyre Number
    TYRE_INFO_UNIT      *pstuTyre;                      // Tyre Information
}EVENT_TYRE_INFO;

/////////////////////////////Audio Talk Related Definition/////////////////////////////

// Audio format information 
typedef struct
{
	BYTE				byFormatTag;			// Encode type such as 0:PCM
	WORD				nChannels;				// Track number 
	WORD				wBitsPerSample;			// Sampling depth 	
	DWORD				nSamplesPerSec;			// Sampling rate
} DH_AUDIO_FORMAT, *LPDH_AUDIO_FORMAT;

/////////////////////////////User Management Corresponding Definition /////////////////////////////

// Support the device with max 8 bits user name. Corresponding to the CLIENT_QueryUserInfo and CLIENT_OperateUserInfo.
// Right information 
typedef struct _OPR_RIGHT
{
	DWORD				dwID;
	char				name[DH_RIGHT_NAME_LENGTH];
	char				memo[DH_MEMO_LENGTH];
} OPR_RIGHT;

// User information 
typedef struct _USER_INFO
{
	DWORD				dwID;
	DWORD				dwGroupID;
	char				name[DH_USER_NAME_LENGTH];
	char				passWord[DH_USER_PSW_LENGTH];
	DWORD				dwRightNum;
	DWORD				rights[DH_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
	DWORD				dwReusable;				// Reuse or not;1:enable reuse;0:disable reuse 
} USER_INFO;

// User group information 
typedef struct _USER_GROUP_INFO
{
	DWORD				dwID;
	char				name[DH_USER_NAME_LENGTH];
	DWORD				dwRightNum;
	DWORD				rights[DH_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO;

// User information list 
typedef struct _USER_MANAGE_INFO
{
	DWORD				dwRightNum;				// Right information 
	OPR_RIGHT			rightList[DH_MAX_RIGHT_NUM];
	DWORD				dwGroupNum;				// User group information 
	USER_GROUP_INFO		groupList[DH_MAX_GROUP_NUM];
	DWORD				dwUserNum;				// User information 
	USER_INFO			userList[DH_MAX_USER_NUM];
	DWORD				dwSpecial;				// User account reuse; 1:support account to be reused. 0:Does not support account to be reused.
} USER_MANAGE_INFO;

// Support the device of max 8-bit or 16-bit name. Corresponding interface to CLIENT_QueryUserInfoEx and CLIENT_OperateUserInfoEx
#define DH_USER_NAME_LENGTH_EX		16			// User name length 
#define DH_USER_PSW_LENGTH_EX		16			// Password 

// Right information
typedef struct _OPR_RIGHT_EX
{
	DWORD				dwID;
	char				name[DH_RIGHT_NAME_LENGTH];
	char				memo[DH_MEMO_LENGTH];
} OPR_RIGHT_EX;

// User information 
typedef struct _USER_INFO_EX
{
	DWORD				dwID;
	DWORD				dwGroupID;
	char				name[DH_USER_NAME_LENGTH_EX];
	char				passWord[DH_USER_PSW_LENGTH_EX];
	DWORD				dwRightNum;
	DWORD				rights[DH_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
	DWORD				dwFouctionMask;			// Subnet mask,0x00000001 - support reuse  
	BYTE				byReserve[32];
} USER_INFO_EX;

// User group information 
typedef struct _USER_GROUP_INFO_EX
{
	DWORD				dwID;
	char				name[DH_USER_NAME_LENGTH_EX];
	DWORD				dwRightNum;
	DWORD				rights[DH_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_EX;

// User information sheet 
typedef struct _USER_MANAGE_INFO_EX
{
	DWORD				dwRightNum;				// Right information 
	OPR_RIGHT_EX		rightList[DH_MAX_RIGHT_NUM];
	DWORD				dwGroupNum;				// User group information 
	USER_GROUP_INFO_EX  groupList[DH_MAX_GROUP_NUM];
	DWORD				dwUserNum;				// User information 
	USER_INFO_EX		userList[DH_MAX_USER_NUM];
	DWORD				dwFouctionMask;			// Subnet mask;0x00000001 - support reuse, 0x00000002 - Password has been modified , it needs to be verified.
	BYTE				byNameMaxLength;		// The supported user name max length 
	BYTE				byPSWMaxLength;			// The supported password max length
	BYTE				byReserve[254];
} USER_MANAGE_INFO_EX;

// Max support a device of 64-channel. Corresponding extension interface CLIENT_QueryUserInfoNew and CLIENT_OperateUserInfoNew
#define DH_NEW_MAX_RIGHT_NUM        1024
#define DH_NEW_USER_NAME_LENGTH	 128			// User name length
#define DH_NEW_USER_PSW_LENGTH	 128			// password

// Rights info
typedef struct _OPR_RIGHT_NEW
{
	DWORD               dwSize;
	DWORD				dwID;
	char				name[DH_RIGHT_NAME_LENGTH];
	char				memo[DH_MEMO_LENGTH];
} OPR_RIGHT_NEW;

// User info
typedef struct _USER_INFO_NEW
{
	DWORD               dwSize;
	DWORD				dwID;
	DWORD				dwGroupID;
	char				name[DH_NEW_USER_NAME_LENGTH];
	char				passWord[DH_NEW_USER_PSW_LENGTH];
	DWORD				dwRightNum;
	DWORD				rights[DH_NEW_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
	DWORD				dwFouctionMask;			// Sub mask,0x00000001 - Support account reusable
    NET_TIME            stuTime;                // Last Revise Time
    BYTE                byIsAnonymous;          // Whether Can Be Anonymous Login,0=Can't Be Anonymous Login,1=Can be Anonymous Login
    BYTE                byReserve[7];
} USER_INFO_NEW;

// User group info
typedef struct _USER_GROUP_INFO_NEW
{
	DWORD               dwSize;
	DWORD				dwID;
	char				name[DH_USER_NAME_LENGTH_EX];
	DWORD				dwRightNum;
	DWORD				rights[DH_NEW_MAX_RIGHT_NUM];
	char				memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_NEW;

// user group information expand,user group lengthen
typedef struct _USER_GROUP_INFO_EX2
{
    DWORD               dwSize;
    DWORD               dwID;
    char                name[DH_NEW_USER_NAME_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_NEW_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_EX2;

// User info list
typedef struct _USER_MANAGE_INFO_NEW
{
	DWORD               dwSize;
	DWORD				dwRightNum;				// Rights info
	OPR_RIGHT_NEW		rightList[DH_NEW_MAX_RIGHT_NUM];
	DWORD				dwGroupNum;				// User group info
	USER_GROUP_INFO_NEW  groupList[DH_MAX_GROUP_NUM];
	DWORD				dwUserNum;				// User info
	USER_INFO_NEW		userList[DH_MAX_USER_NUM];
	DWORD				dwFouctionMask;			// Sub mask; 0x00000001 - Support account reusable,0x00000002 - Verification needed when change password
	BYTE				byNameMaxLength;		// Max user name length supported
	BYTE				byPSWMaxLength;			// Max password length supported
	BYTE				byReserve[254];
    USER_GROUP_INFO_EX2 groupListEx[DH_MAX_GROUP_NUM];      // User Group Information Expand
} USER_MANAGE_INFO_NEW;

///////////////////////////////Search Related Definition ///////////////////////////////

// The language types device supported 
typedef struct _DH_LANGUAGE_DEVINFO
{
	DWORD				dwLanguageNum;			// The language amount supported
	BYTE				byLanguageType[252];	// Enumeration value please refer to DH_LANGUAGE_TYPE
} DH_DEV_LANGUAGE_INFO, *LPDH_DEV_LANGUAGE_INFO;

// the IPC types device supported
typedef struct
{
	int                 nTypeCount;              // The IPC type amount supported
	BYTE                bSupportTypes[128];      // Enumeration value please refer to EM_IPC_TYPE
}DH_DEV_IPC_INFO;

//3G net flow info
typedef struct
{
	int					nStrategy;              // strategy,0: charged by flow every month 1:charged by time every month
	int                 nUplimit;               // up limit flow, by flow: MB, by time: h
	int                 nUsed;                  // have used flow, by flow: MB, by time: h
	BYTE                bReserved[64];          // reserved
}DH_DEV_3GFLOW_INFO;

// 3G module info
typedef struct
{
	BYTE			    byEthNum;				// 3G model number
	BYTE				byReserved[255];        // reserved
}DH_DEV_3GMODULE_INFO;

typedef struct
{
	DWORD				dwId;                            // ddns server id
	char				szState[DH_MAX_DDNS_STATE_LEN];	 // ddns status
	BYTE				bReserved[512];                  // reserved
}DH_DEV_DNS_INFO;
typedef struct
{
	DWORD				dwDdnsServerNum;	
	DH_DEV_DNS_INFO     stDdns[DH_MAX_DDNS_NUM];
}DH_DEV_MULTI_DDNS_INFO;

// device URL info
typedef struct
{
	char				szURLInfo[512];         // device URL info, by string
	BYTE				bReserved[512];
}DH_DEV_URL_INFO;
// HDD informaiton 
typedef struct
{
	DWORD				dwVolume;				// HDD capacity 
	DWORD				dwFreeSpace;			// HDD free space 
	BYTE				dwStatus;				// higher 4 byte instruct hdd type, see the enum struct EM_DISK_TYPE; lower four byte instruct HDD status,0-hiberation,1-active,2-malfucntion and etc.;Devide DWORD into four BYTE
	BYTE				bDiskNum;				// HDD number
	BYTE				bSubareaNum;			// Subarea number
	BYTE				bSignal;				// Symbol. 0:local. 1:remote
} NET_DEV_DISKSTATE,*LPNET_DEV_DISKSTATE;

// Device HDD informaiton 
typedef struct _DH_HARDDISK_STATE
{
	DWORD				dwDiskNum;				// Amount 
	NET_DEV_DISKSTATE	stDisks[DH_MAX_DISKNUM];// HDD or subarea information 
} DH_HARDDISK_STATE, *LPDH_HARDDISK_STATE;

typedef DH_HARDDISK_STATE	DH_SDCARD_STATE;	// SD card. Please refer to HDD information for data structure. 

// Audio encode information 
typedef struct  
{
	DH_TALK_CODING_TYPE	encodeType;				// Encode type 
	int					nAudioBit;				// Bit:8/16
	DWORD				dwSampleRate;			// Sampling rate such as 8000 or 16000
    int                 nPacketPeriod;          // Pack Period,Unit ms
    char                reserved[60];
} DHDEV_TALKDECODE_INFO;

// The audio talk type the device supported
typedef struct 
{
	int					nSupportNum;			// Amount
	DHDEV_TALKDECODE_INFO type[64];				// Encode type 
	char				reserved[64];
} DHDEV_TALKFORMAT_LIST;

// PTZ property information
#define  NAME_MAX_LEN 16
typedef struct 
{
	DWORD				dwHighMask;				// Operation mask high bit 
	DWORD				dwLowMask;				// Operation mask low bit 
	char				szName[NAME_MAX_LEN];	// Operation protocol name 
	WORD				wCamAddrMin;			// Channel address min value
	WORD				wCamAddrMax;			// Channel address max value
	WORD				wMonAddrMin;			// Monitor address min value
	WORD				wMonAddrMax;			// Monitor address max value
	BYTE				bPresetMin;				// Preset min value
	BYTE				bPresetMax;				// Preset max value
	BYTE				bTourMin;				// Auto tour min value
	BYTE				bTourMax;				// Auto tour max value
	BYTE				bPatternMin;			// Pattern min value
	BYTE				bPatternMax;			// Pattern max value
	BYTE				bTileSpeedMin;			// Tilt speed min value
	BYTE				bTileSpeedMax;			// Tilt speed max value
	BYTE				bPanSpeedMin;			// Pan speed min value
	BYTE				bPanSpeedMax;			// Pan speed max value
	BYTE				bAuxMin;				// Aux function min value
	BYTE				bAuxMax;				// Aux function max value
	int					nInternal;				// Command interval
	char				cType;					// Protocol type
	BYTE				bReserved_1;			// Reserved
	BYTE				bFuncMask;				// function mask :0x01 - support PTZ-inside function
	BYTE				bReserved_2;
	char				Reserved[4];
} PTZ_OPT_ATTR;

// Burner informaiton 
typedef struct _NET_DEV_BURNING
{
	DWORD				dwDriverType;			// Burner driver type;0:DHFS,1:DISK,2:CDRW
	DWORD				dwBusType;				// Bus type;0:USB,1:1394,2:IDE
	DWORD				dwTotalSpace;			// Total space(KB)
	DWORD				dwRemainSpace;			// Free space(KB)
	BYTE				dwDriverName[DH_BURNING_DEV_NAMELEN];	// Burner driver name
} NET_DEV_BURNING, *LPNET_DEV_BURNING;

// Device burner informaiton 
typedef struct _DH_BURNING_DEVINFO
{
	DWORD				dwDevNum;				// Burner device amount
	NET_DEV_BURNING		stDevs[DH_MAX_BURNING_DEV_NUM];	// Each burner device information 
} DH_BURNING_DEVINFO, *LPDH_BURNING_DEVINFO;

// Burner progress 
typedef struct _DH_BURNING_PROGRESS
{
	BYTE				bBurning;				// Burner status;0:ready to burn,1:burner types is not correct. It does not match. 
												// 2:there is no burner available(remainSpace is 0),3:There is burning in process,4:Burner is not free(It is backup or buring or playback.) 
	BYTE				bRomType;				// CD type;0:private file system,1:Portable HDD or flash disk,2:CD
	BYTE				bOperateType;			// Operation type;0:free,1:backup,2:burning,3:playback from the cd 
	BYTE				bType;					// Backup pr burning status:0:stop or end,1:start,2:error,3:full,4:initializing
	NET_TIME			stTimeStart;			// Begin time 
	DWORD				dwTimeElapse;			// Burning time(second)
	DWORD				dwTotalSpace;			// Total space
	DWORD				dwRemainSpace;			// Free space
	DWORD				dwBurned;				// Burned capacity 
	WORD				dwStatus;				// Reserved
	WORD				wChannelMask;			// The burning channel mask 
} DH_BURNING_PROGRESS, *LPDH_BURNING_PROGRESS;

// Log information. Corresponding to CLIENT_QueryLog
typedef struct _DH_LOG_ITEM
{
    DHDEVTIME			time;					// Date 
    unsigned short		type;					// Type
    unsigned char		reserved;				// Reserved
    unsigned char		data;					// Data 
    unsigned char		context[8];				// Content
} DH_LOG_ITEM, *LPDH_LOG_ITEM;

// Log information. Corresponding to CLIENT_QueryLogEx, parameter reserved(int nType=1;reserved=&nType;)
typedef struct _DH_NEWLOG_ITEM
{
	DHDEVTIME			time;					// Date
	WORD				type;					// Type
	WORD				data;					// data
	char				szOperator[8]; 			// User name 
	BYTE				context[16];		    // Content	
} DH_NEWLOG_ITEM, *LPDH_NEWLOG_ITEM;

// Log information. Corresponding to CLIENT_QueryDeviceLog
typedef struct _DH_DEVICE_LOG_ITEM
{
	int					nLogType;				// Log type 
	DHDEVTIME			stuOperateTime;			// Date
	char				szOperator[16]; 		// Operator
	BYTE				bReserved[3];
	BYTE				bUnionType;				// union structure type,0:szLogContext;1:stuOldLog
	union
	{
		char			szLogContext[64];		// Log content
		struct 
		{
			DH_LOG_ITEM		stuLog;				// Old log structure 
			BYTE			bReserved[48];		// Reserved
		}stuOldLog;
	};
	char				reserved[16];
} DH_DEVICE_LOG_ITEM, *LPDH_DEVICE_LOG_ITEM;

// new Log information. Corresponding to CLIENT_QueryDeviceLog
typedef struct _DH_DEVICE_LOG_ITEM_EX
{
	int					nLogType;				// Log type 
	DHDEVTIME			stuOperateTime;			// Date
	char				szOperator[16]; 		// Operator
	BYTE				bReserved[3];
	BYTE				bUnionType;				// union structure type,0:szLogContext;1:stuOldLog
	union
	{
		char			szLogContext[64];		// Log content
		struct 
		{
			DH_LOG_ITEM		stuLog;				// Old log structure 
			BYTE			bReserved[48];		// Reserved
		}stuOldLog;
	};
	char                szOperation[32];        // Detail operation
	char				szDetailContext[4 * 1024];  // DetailContext
} DH_DEVICE_LOG_ITEM_EX, *LPDH_DEVICE_LOG_ITEM_EX;

// Record log informaiton. Corresponding to the context of log structure 
typedef struct _LOG_ITEM_RECORD
{
	DHDEVTIME			time;					// Time 
	BYTE				channel;				// Channel
	BYTE				type;					// Record type
	BYTE				reserved[2];
} LOG_ITEM_RECORD, *LPLOG_ITEM_RECORD;

typedef struct _QUERY_DEVICE_LOG_PARAM
{
	 DH_LOG_QUERY_TYPE	emLogType;				// Searched log type
	 NET_TIME			stuStartTime;			// The searched log start time
	 NET_TIME			stuEndTime;				// The searched log end time. 
	 int				nStartNum;				// The search begins from which log in one period. It shall begin with 0 if it is the first time search.
	 int				nEndNum;				// The ended log serial number in one search,the max returning number is 1024 
	 BYTE                nLogStuType;           // log struct type,0:DH_DEVICE_LOG_ITEM;1:DH_DEVICE_LOG_ITEM_EX
	BYTE                reserved[3];            // Reserved
	unsigned int        nChannelID;             // Channel no. 0:Compatible with previous all channel numbers. The channel No. begins with 1.1: The first channel.
	BYTE				bReserved[40];
} QUERY_DEVICE_LOG_PARAM;

// record information in the hard disk
typedef struct __DEV_DISK_RECORD_INFO 
{
	NET_TIME			stuBeginTime;			// The first time video
	NET_TIME			stuEndTime;				// Recently video
	char				reserved[128];
} DEV_DISK_RECORD_INFO;

// disk record time
typedef struct __DEV_DISK_RECORD_TIME
{
	NET_TIME             stuStartTime1;		    // start time 1
	NET_TIME	         stuEndTime1;			// end time 1
	BOOL	             bTwoPart;			    // have two part or not
	NET_TIME	         stuStartTime2;		    // start time 2
	NET_TIME	         stuEndTime2;			// end time 2
	BYTE			  	 bDiskNum;				// disk number 
	BYTE				 bSubareaNum;			// subarea num
	BYTE                 byReserved[62];        // reserved

}DEV_DISK_RECORD_TIME;

///////////////////////////////Control Related Definition///////////////////////////////
//new network keyboard control
typedef struct _NKB_PARAM
{
    BYTE                bAddressCode;           // for DVR and etc. device physical address no.,0xFF as broadcast address
    BYTE                bKeyStatus;             // status code 0/1 0 means press by key 1 means release key
    BYTE                bExtern1;               // expansion field 1
    BYTE                bExtern2;               // expansion field 2
    BYTE                bReserved[60];
}NKB_PARAM;

// HDD operation
typedef struct _DISKCTRL_PARAM
{
	DWORD				dwSize;					// Structure size. For version control.
	int					nIndex;					// Subscript of array stDisks of information structure DH_HARDDISK_STATE. It begins from 0. 
	int					ctrlType;				// Operation type
												// 0 -  clear data, 1 - set as read-write HDD , 2 -  set as read-only HDD
												// 3 - set as redundant , 4 - restore error , 5 -set as snapshot disk  
	NET_DEV_DISKSTATE	stuDisk;				// diskInfo, replace nIndex
} DISKCTRL_PARAM;

typedef struct  
{
	BYTE				bSubareaNum;			// The number of pre-partition
	BYTE				bIndex;					// Subscript of array stDisks of information structure DH_HARDDISK_STATE. It begins from 0. 
	BYTE				bSubareaSize[32];		// partition Size(Percentage)
	BYTE				bReserved[30];			// Reservations
} DISKCTRL_SUBAREA;

// Alarm status
typedef struct _ALARMCTRL_PARAM
{
	DWORD				dwSize;
	int					nAlarmNo;				// Alarm channel. It begins from 0. 
	int					nAction;				// 1:activate alarm,0:stop alarm  
} ALARMCTRL_PARAM;

// Matrix control 
typedef struct _MATRIXCTRL_PARAM
{
	DWORD				dwSize;
	int					nChannelNo;				// Video input number. It begins from  0.
	int					nMatrixNo;				// Matrix output number. It begins from 0
} MATRIXCTRL_PARAM;

// Burner control 
typedef struct _BURNING_PARM
{
	int					channelMask;			// channel subnet mask. Bit means the channel to be burned.
	BYTE				devMask;				// Burner subnet mask.  Use bit to represent according to the searched burner list 
	BYTE                bySpicalChannel;        // PIP channel(Channel No.+32)
	BYTE                byReserved[2];          // Reserved
} BURNNG_PARM;

// Annex burn
typedef struct _BURNING_PARM_ATTACH
{
	BOOL				bAttachBurn;			// Whether,0:Not; 1:Yes
	BYTE				bReserved[12];			// Reservations
} BURNING_PARM_ATTACH;

// Manual snap parameter
typedef struct  _MANUAL_SNAP_PARAMETER{
	int                 nChannel;               // snap channel,start with 0
	BYTE                bySequence[64];	        // snap sequence string
	BYTE                byReserved[60];         // reserved
}MANUAL_SNAP_PARAMETER;

// local preview split parameter
typedef struct _DEVICE_LOCALPREVIEW_SLIPT_PARAMETER
{
	int                 nSliptMode;            // split mode
	int                 nSubSliptNum;          // split num, start with 1
	BYTE                byReserved[64];        // reserved
}DEVICE_LOCALPREVIEW_SLIPT_PARAMETER;

// local preview split capability
typedef struct _DEVICE_LOCALPREVIEW_SLIPT_CAP
{
	int                 nModeNumber;
	int                 nSliptMode[36];        // split array
	BYTE                byReserved[64];        // reserved
}DEVICE_LOCALPREVIEW_SLIPT_CAP;

// Crossing information
typedef struct  _CROSSING_INFO
{
	char              szCrossingID[DH_MAX_CROSSING_ID];  // Crossing ID
	DWORD             dwLatitude;				// Latitude(0-180 Degree, 30.183382 degree==120183382)
	DWORD             dwLongitude;				// Longitude(0-360 Degree, 120.178274 degree==300178274)
	WORD              wSpeedLimit;				// limit speed(KM/H)
	BYTE 	          byReserved[22];
}CROSSING_INFO;

// Route crossing information
typedef struct  _ROUTE_CROSSING_INFO
{
	BYTE 			   byCrossingNum;             // valid number is 1~DH_MAX_CROSSING_NUM
	BYTE			   byReserved1; 
	WORD               wCrossingRange;            // Crossing range(m)
	CROSSING_INFO 	   stCrossingInfo[DH_MAX_CROSSING_NUM]; // Crossing information struct array
    BYTE			   byReserved2[2044];
}ROUTE_CROSSING_INFO;

// raid control
typedef struct _CTRL_RAID_INFO
{
	char				szAction[16];						// Add,Delete
	char				szName[16];							// Raid name
	int					nType;								// type 1:Jbod     2:Raid0      3:Raid1     4:Raid5
	int					nStatus;							// status 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
	int					nCntMem;							// nMember count
	int					nMember[32];						// 1,2,3,... 
	int					nCapacity;							// capacity(G)
	int					nRemainSpace;						// remain space(M)
	int					nTank;								// tank 0:main,1:tank1,2:tank2.....
	char				reserved[128];
}CTRL_RAID_INFO;

// spake disk info
typedef struct _CTRL_SPARE_DISK_INFO
{
	char				szAction[16];						// Enable
	char				szScope[16];						// Global,Local
	char				szName[16];							// name
	unsigned int        nIndex;								// disk index
    const char*         pszDevName;                         // device name
    char                reserved[124];
}CTRL_SPARE_DISK_INFO;

typedef struct _CTRL_SPARE_DISK_INFO_A
{
	int						nCnt;							// count
	CTRL_SPARE_DISK_INFO	stSpaceDiskInfo[32];			// spare disk info array
}CTRL_SPARE_DISK_INFO_A;

// Alarm arm and disarm control
typedef struct __CTRL_ARM_DISARM_PARAM
{
	BYTE                bState;                             // Arm/disarm state, 0 means disarm, 1 means arm, 2 means forced arm
    char                reserve[3];
    const char*         szDevPwd;                           // User's Password
    NET_SCENE_MODE      emSceneMode;                        // Contextual Mode
    const char*         szDevID;                            // Forwarding the Target Device ID,Null=Non Forward
    char                reserve1[16];
} CTRL_ARM_DISARM_PARAM;

// alarm arm/disarm control expansion input parameter
typedef struct tagCTRL_ARM_DISARM_PARAM_EX_IN
{
    DWORD               dwSize;
    NET_ALARM_MODE      emState;                // arm/disarm status 
    const char*         szDevPwd;               // user password
    NET_SCENE_MODE      emSceneMode;            // scene mode 
    const char*         szDevID;                // transfer target device ID, as NULL means not transfer
} CTRL_ARM_DISARM_PARAM_EX_IN;

#define ARM_DISARM_ZONE_MAX (256)               // zone max number 

// alarm arm/disarm control expansion output parameter
typedef struct tagCTRL_ARM_DISARM_PARAM_EX_OUT
{
    DWORD               dwSize;
    DWORD               dwSourceNum;                    //  alarm source input arming failed zone number 
    int                 nSource[ARM_DISARM_ZONE_MAX];   //  alarm source input failed zone no.,zone no. start from 0
    DWORD               dwLinkNum;                      // link alarm arming failed zone number 
    int                 nLink[ARM_DISARM_ZONE_MAX];     // link alarm failed zone no., zone no. start from 0
} CTRL_ARM_DISARM_PARAM_EX_OUT;

// alarm arm/diarm control expansion(corresponding to DH_CTRL_ARMED_EX)
typedef struct tagCTRL_ARM_DISARM_PARAM_EX
{
    DWORD               dwSize;
    CTRL_ARM_DISARM_PARAM_EX_IN stuIn;                  // alarm arm/disarm control input
    CTRL_ARM_DISARM_PARAM_EX_OUT stuOut;                // alarm arm/disarm control output
} CTRL_ARM_DISARM_PARAM_EX;

typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_IN
{
	DWORD				dwSize;
	int                 nType;                         // WPS connect type,0:virtual buttons; 1:(device)pin; 2:(wifi hot point)pin
	char                szSSID[DH_MAX_SSID_LEN];       // when SSID,nType is 1 or 2,availability,biggest support 32-bit
	char                szApPin[DH_MAX_APPIN_LEN];     // APPIN, when nType = 2,availability,PIN is 8 digits,from the wife(hot point)
	char                szWLanPin[DH_MAX_APPIN_LEN];   // device pin,when nType = 1,availability.produced by the device when empty,not empty soecified by the user,need to increase in wifi
}DHCTRL_CONNECT_WIFI_BYWPS_IN;

typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_OUT
{
	DWORD				dwSize;
	char                szRetWLanPin[DH_MAX_APPIN_LEN];// return pin,when WPS's connect type is device end,this parameter is valid.
}DHCTRL_CONNECT_WIFI_BYWPS_OUT;

// CLIENT_ControlDevice interface DH_CTRL_WIFI_BY_WPS command parameter(WPS rapid configuration WIFI)
typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS
{
	DWORD				dwSize;
	DHCTRL_CONNECT_WIFI_BYWPS_IN     stuWpsInfo;         // connect parameter(user to fill in)
	DHCTRL_CONNECT_WIFI_BYWPS_OUT    stuWpsResult;       // return data(device to return to)
} DHCTRL_CONNECT_WIFI_BYWPS;

// CLIENT_ControlDevice interface DH_CTRL_CLOSE_BURNER 
typedef struct tagNET_CTRL_BURNERDOOR
{
	DWORD		        dwSize;
	const char*         szBurnerName;                  // cd name,like "/dev/sda"
	BOOL                bResult;                       // operate result
    BOOL                bSafeEject;                    // Whether The Security Pop-up Drive, Data Save TRUE- pop Up Before, FALSE- Display)
}NET_CTRL_BURNERDOOR;

// CLIENT_ControlDevice interface DH_CTRL_START_PLAYAUDIO Order Parameter
typedef struct tagNET_CTRL_START_PLAYAUDIO
{
    DWORD               dwSize;
    char                szAudioPath[DH_MAX_AUDIO_PATH];
}NET_CTRL_START_PLAYAUDIO;

// report unit type
typedef enum tagNET_PLAYAUDIO_TYPE
{
    NET_PLAYAUDIO_TYPE_UNKNOWN = 0,
    NET_PLAYAUDIO_TYPE_PHRASE,                          // message type¡ê?no analysis¡ê?read in order¡ê?supported by audio file
    NET_PLAYAUDIO_TYPE_FILE,                            // play soecific path?¡¥s audiofile(device complete path)
    NET_PLAYAUDIO_TYPE_PLATERNUM,                       // report plate no.¡ê?read by plate format
    NET_PLAYAUDIO_TYPE_MONEY,                           // report amount¡ê?read byamount format
    NET_PLAYAUDIO_TYPE_DATE,                            // report date¡ê?read by date format
    NET_PLAYAUDIO_TYPE_TIME,                            // report time¡ê?read by time format
    NET_PLAYAUDIO_TYPE_EMPTY,                           // null type¡ê?stop one character time
}NET_PLAYAUDIO_TYPE;

// audio report content
typedef struct tagNET_CTRL_PLAYAUDIO_INFO
{
    DWORD               dwSize;
    NET_PLAYAUDIO_TYPE  emPlayAudioType;                // report unit type,see NET_PLAYAUDIO_TYPE
    char                szDetail[DH_COMMON_STRING_128]; // detailed content type detail¡êo
                                                        // Phrase type:"Welcome"
                                                        // File type: "/home/parking.pcm"
                                                        // PlateNumbe type: "??A12345"
                                                        // Money type: "80.12 yuan"
                                                        // Date type: "2014/4/10"
                                                        // Time type : "1 day 10 hours 20 min 5 seconds
}NET_CTRL_PLAYAUDIO_INFO;

#define DH_MAX_PLAYAUDIO_COUNT    16  // max report content items
// CLIENT_ControlDevice port DH_CTRL_START_PLAYAUDIOEX command parameter
typedef struct tagNET_CTRL_START_PLAYAUDIOEX
{
    DWORD                       dwSize;
    unsigned int                nAudioCount;                            // report content quantity               
    NET_CTRL_PLAYAUDIO_INFO     stuAudioInfos[DH_MAX_PLAYAUDIO_COUNT];  // audioplay content
}NET_CTRL_START_PLAYAUDIOEX;

// CLIENT_ControlDevice port DH_CTRL_START_ALARMBELL?¡éDH_CTRL_STOP_ALARMBELL command parameter
typedef struct tagNET_CTRL_ALARMBELL
{
    DWORD               dwSize;
    int                 nChannelID;             // Channel ID (start from 0)            
}NET_CTRL_ALARMBELL;

// CLIENT_ControlDevice's param: DH_CTRL_ACCESS_OPEN
typedef struct tagNET_CTRL_ACCESS_OPEN
{
    DWORD               dwSize;
    int                 nChannelID;             // Channel ID (start from 0) 
    const char*         szTargetID;             // Target ID, NULL equals to not transmit
}NET_CTRL_ACCESS_OPEN;

// the enum for work mode of door
typedef enum tagEM_NET_DOOR_WORK_MODE_TYPE
{
    NET_DOOR_WORK_MODE_UNKNOWN,            // Unknown
	NET_DOOR_WORK_MODE_NORMAL,             // Normal
	NET_DOOR_WORK_MODE_SHUTDOWN,           // shutdown
	NET_DOOR_WORK_MODE_UNUSED,             // unused
	NET_DOOR_WORK_MODE_OPEN_DOOR_CONTINUE, // continued opening

}EM_NET_DOOR_WORK_MODE_TYPE;

// the input param for setting the work mode of door
typedef struct tagNET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE
{
	DWORD                   dwSize;
	EM_NET_DOOR_WORK_MODE_TYPE emWorkMode;    // the work mode
}NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE;

// the output param for setting the work mode of door
typedef struct tagNET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE
{
    DWORD                   dwSize;
}NET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE;

// the input param for synchronizing the cabin led's time
typedef struct tagNET_IN_CTRL_SYNC_CABINLED_TIME
{
    DWORD                   dwSize;
}NET_IN_CTRL_SYNC_CABINLED_TIME;

// the output param for synchronizing the cabin led's time
typedef struct tagNET_OUT_CTRL_SYNC_CABINLED_TIME
{
    DWORD                   dwSize;
}NET_OUT_CTRL_SYNC_CABINLED_TIME;

// the enum for control mode of playing the cabin led
typedef enum tagEM_NET_CABIN_LED_PLAY_CONTROL_MODE
{
    NET_CABIN_LED_PLAY_CONTROL_MODE_UNKNOWN,          // Unknown
    NET_CABIN_LED_PLAY_CONTROL_MODE_NORMAL_TURN_ON,   // Normal mode (turn on the screen)
    NET_CABIN_LED_PLAY_CONTROL_MODE_NEXT_PROGRAM,     // Next program      
    NET_CABIN_LED_PLAY_CONTROL_MODE_PREVIOUS_PROGRAM, // Pre program
    NET_CABIN_LED_PLAY_CONTROL_MODE_PAUSE,            // Pause
    NET_CABIN_LED_PLAY_CONTROL_MODE_PAUSE_TURN_OFF,   // Pause (turn off the screen)
    NET_CABIN_LED_PLAY_CONTROL_MODE_PLAY_GO_ON,       // Go on playing
    NET_CABIN_LED_PLAY_CONTROL_MODE_GO_TO_TEST_ITSELF,// Go to test itself
    NET_CABIN_LED_PLAY_CONTROL_MODE_EXIT_TEST_ITSELF, // Exit testing itself
    NET_CABIN_LED_PLAY_CONTROL_MODE_SYSTEM_RESET,     // Reset the system
}EM_NET_CABIN_LED_PLAY_CONTROL_MODE;

// the input param for play and control the cabin led
typedef struct tagNET_IN_CTRL_CABINLED_PLAYCONTROL
{
    DWORD                                   dwSize;
    EM_NET_CABIN_LED_PLAY_CONTROL_MODE         emAction; // Play mode
}NET_IN_CTRL_CABINLED_PLAYCONTROL;

// the output param for play and control the cabin led
typedef struct tagNET_OUT_CTRL_CABINLED_PLAYCONTROL
{
    DWORD                   dwSize;
}NET_OUT_CTRL_CABINLED_PLAYCONTROL;

#define NET_CTRL_CABINLED_MODIFY_CONTENT_MAX_NUM 10  // the max text line num of modify the cabin led's content

// the enum for cmd of modify the cabin led's content
typedef enum tagEM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE
{
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_UNKNOWN,
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_ADD       = 0, // Add
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_MODIFY    = 1, // Modify
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_DELETE    = 2, // Delete
}EM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE;

// the enum for effect of modify the cabin led's content
typedef enum tagEM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE
{
    NET_MODIFY_CONTENT_EFFECT_TYPE_UNKNOWN,
    NET_MODIFY_CONTENT_EFFECT_TYPE_SHOW = 0,                      // Show normal
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_LEFT,                     // Move to left
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_RIGHT,                    // Move to right
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_UP,                       // Move to up
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_DOWN,                     // Move to down
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT,                  // Fill up the left
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_RIGHT,                 // Fill up the right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP,                    // Fill up the up
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN,                  // Fill up the down
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_LEFT,               // Fill up the up-left
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN_LEFT,             // Fill up the down-left
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_RIGHT,              // Fill up the up-right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN_RIGHT,            // Fill up the down-right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT_RIGHT_TO_CENTER,  // Fill up from left-right to center
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_LEFT_RIGHT,  // Fill up from center to left-right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_DOWN_TO_CENTER,     // Fill up from up-down to center
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_UP_DOWN,     // Fill up from center to up-down
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT_CROSS_RIGHT,      // Fill up with cross left-right
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_CROSS_DOWN,         // Fill up with cross up-down
    NET_MODIFY_CONTENT_EFFECT_TYPE_VERTICAL_BLINDS,               // Vertical_blinds
    NET_MODIFY_CONTENT_EFFECT_TYPE_HORIZONTAL_BLINDS,             // Horizontal_blinds  
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_SIDES,       // Fill up from center to sides
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_SIDES_TO_CENTER,       // Fill up from sides to center
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_CORNER,      // Fill up from center to corner
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CORNER_TO_CENTER,      // Fill up from corner to center
    NET_MODIFY_CONTENT_EFFECT_TYPE_ROTATE_360,                    // Rotate 360
    NET_MODIFY_CONTENT_EFFECT_TYPE_ROTATE_180,                    // Rotate_180
}EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE;

// the enum for color of modify the cabin led's content
typedef enum tagEM_NET_CABIN_LED_MODIFY_CONTENT_COLOR_TYPE
{
    NET_CABIN_LED_MODIFY_CONTENT_COLOR_TYPE_UNKNOWN,
    NET_CABIN_LED_MODIFY_CONTENT_COLOR_TYPE_RED       = 1,       // Red
    NET_CABIN_LED_MODIFY_CONTENT_COLOR_TYPE_GEREEN    = 2,       // Green
    NET_CABIN_LED_MODIFY_CONTENT_COLOR_TYPE_YELLOW    = 3,       // Yellow
    NET_CABIN_LED_MODIFY_CONTENT_COLOR_TYPE_BLUE      = 4,       // Blue
}EM_NET_CABIN_LED_MODIFY_CONTENT_COLOR_TYPE;

// the input param for modify the cabin led's content
typedef struct tagNET_IN_CTRL_CABINLED_MODIFY_CONTENT
{
    DWORD                                    dwSize;
    EM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE    emCmd;             // Cmd type
    int                                      nMsgID;            // Msg id,default for 0
    EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE emEffect;          // Effect type
    int                                      nSpeed;            // Show speed,range of 0 to 15
    int                                      nDuration;         // Duration time,Unit:second
    int                                      nTextNum;          // Text num
    char                                     szText[NET_CTRL_CABINLED_MODIFY_CONTENT_MAX_NUM][DH_COMMON_STRING_128]; // Text data
    EM_NET_CABIN_LED_MODIFY_CONTENT_COLOR_TYPE  emColor[NET_CTRL_CABINLED_MODIFY_CONTENT_MAX_NUM];                      // Text color

}NET_IN_CTRL_CABINLED_MODIFY_CONTENT;

// the output param for modify the cabin led's content
typedef struct tagNET_OUT_CTRL_CABINLED_MODIFY_CONTENT
{
    DWORD                   dwSize;
}NET_OUT_CTRL_CABINLED_MODIFY_CONTENT;

// the type of control caibin led
typedef enum tagEM_CABIN_LED_CONTROL_TYPE
{
    DH_CABIN_LED_CONTROL_UNKNOWN,                       // Unknown                  
    DH_CABIN_LED_CONTROL_SYNC_TIME,                     // Synchronize the time of cabin led (corresponding structure NET_IN_CTRL_SYNC_CABINLED_TIME)
    DH_CABIN_LED_CONTROL_PLAY_CONTROL,                  // Control the play mode of cabin led (corresponding structure NET_IN_CTRL_CABINLED_PLAYCONTROL)
    DH_CABIN_LED_CONTROL_MODIFY_CONTENT,                // Modify the content of cabin led (corresponding structure NET_IN_CTRL_CABINLED_MODIFY_CONTENT)

}EM_CABIN_LED_CONTROL_TYPE;


// CLIENT_ControlDevice's param: DH_CTRL_ACCESS_CLOSE
typedef struct tagNET_CTRL_ACCESS_CLOSE
{
    DWORD               dwSize;
    int                 nChannelID;             // Channel ID (start from 0) 
}NET_CTRL_ACCESS_CLOSE;

typedef enum tagNET_ALARM_TYPE
{
    NET_ALARM_LOCAL = 0,                        // SwitchingValue Defence Area's Alarm Information
    NET_ALARM_ALARMEXTENDED,                    // Expand Module Alarm Event)
    NET_ALARM_TEMP,                             // Temperature Alarm Event)
    NET_ALARM_URGENCY,                          // Emergency Alarm Event)
    NET_ALARM_RCEMERGENCYCALL,                  //Emergency call alarm event (corresponding to DH_ALARM_RCEMERGENCY_CALL event )
}NET_ALARM_TYPE;

// CLIENT_ControlDevice's param: DH_CTRL_CLEAR_ALARM
typedef struct tagNET_CTRL_CLEAR_ALARM
{
    DWORD               dwSize;
    int                 nChannelID;             // Defence Area's ID
    NET_ALARM_TYPE      emAlarmType;            // Event Type
    const char*         szDevPwd;               // Landing Equipment Such As Password, Do not Use Encryption Disappear the Police, Direct Assignment of NULL
    BOOL                bEventType;             // Means if enable nEventType field, TRUE:nEventType replaces emAlarmType field, FALSE: use emAlarmType field , ignore nEventType field 
    int                 nEventType;             // Event type, corresponding fMessCallBack called lCommand field , as CLIENT_StartListenEx port got event type
                                                // Such as DH_ALARM_ALARM_EX2 means local alarm event
}NET_CTRL_CLEAR_ALARM;

// TV Wall Display Information Control Parameters
typedef struct tagNET_CTRL_MONITORWALL_TVINFO 
{
    DWORD               dwSize;
    int                 nMonitorWallID;         // TV Wall ID
    BOOL                bDecodeChannel;         // Display Decoding Channel Information
    BOOL                bControlID;             // ÏÔÊ¾ÆÁÄ»¿ØÖÆID, DH_CTRL_MONITORWALL_TVINFO ÌîÐ´
    BOOL                bCameraID;              // ÏÔÊ¾½âÂëÍ¨µÀÊÓÆµÔ´¿ØÖÆID, DH_CTRL_MONITORWALL_TVINFO ÌîÐ´
} NET_CTRL_MONITORWALL_TVINFO;

// CLIENT_ControlDevice's param: DH_CTRL_START_VIDEO_ANALYSE
typedef struct tagNET_CTRL_START_VIDEO_ANALYSE
{
    DWORD               dwSize; 
    int                 nChannelId;             // Channel ID  
}NET_CTRL_START_VIDEO_ANALYSE;

// CLIENT_ControlDevice's param: DH_CTRL_STOP_VIDEO_ANALYSE 
typedef struct tagNET_CTRL_STOP_VIDEO_ANALYSE
{
    DWORD               dwSize; 
    int                 nChannelId;             // Channel ID  
}NET_CTRL_STOP_VIDEO_ANALYSE;

// CLIENT_ControlDevice's param DH_CTRL_MULTIPLAYBACK_CHANNALES 
typedef struct tagNET_CTRL_MULTIPLAYBACK_CHANNALES
{
    DWORD               dwSize;
    LLONG               lPlayBackHandle;        // Playback Handle¡ê?CLIENT_MultiPlayBack Returns the Value
    int                 nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM];// Preview Channel ID
    int                 nChannelNum;            // Preview Channel Number 
}NET_CTRL_MULTIPLAYBACK_CHANNALES;

// CLIENT_ControlDevice's param: DH_CTRL_SET_BYPASS 
typedef struct tagNET_CTRL_SET_BYPASS
{
    DWORD               dwSize;
    const char*         szDevPwd;               // Login Device Password
    NET_BYPASS_MODE     emMode;                 // Channel Statue
    int                 nLocalCount;            // Local Alarm Input Channel Number
    int*                pnLocal;                // Local Alarm Input Channel ID    
    int                 nExtendedCount;         // Expand Module Alarm Input Channel Number
    int*                pnExtended;             // Expand Module Alarm Input Channel ID
}NET_CTRL_SET_BYPASS;

// CLIENT_ControlDevice's param: DH_CTRL_SET_MEDIAKIND 
typedef struct tagNET_CTRL_SET_MEDIAKIND
{
    DWORD                dwSize;                        //  set dwSize to sizeof(NET_CTRL_SET_MEDIAKIND)
    int                  nMediaKind;                    //  media type,0:video and audio,1:video only,2:audio only
    DWORD                dwChannelCount;                //  channel count
    int                  nChannels[256];                //  video channel (start form 0)
} NET_IN_SET_MEDIAKIND;

// CLIENT_ControlDevice's param: DH_CTRL_SET_MEDIAKIND 
typedef struct tagNET_OUT_SET_MEDIAKIND
{
    DWORD                dwSize;                        //  set dwSize to sizeof(NET_OUT_SET_MEDIAKIND)
} NET_OUT_SET_MEDIAKIND;

// CLIENT_QueryDevState's param: DH_DEVSTATE_GET_BYPASS 
typedef struct tagNET_DEVSTATE_GET_BYPASS
{
    DWORD               dwSize;
    int                 nLocalCount;            // Local Alarm Input Channel Number
    int*                pnLocal;                // Local Alarm Input Channel ID    
    int                 nExtendedCount;         // Expand Module Alarm Input Channel Number
    int*                pnExtended;             // Expand Module Alarm Input Channel ID
    NET_BYPASS_MODE*    pemLocal;               // Local Alarm Input Channel Statue
    NET_BYPASS_MODE*    pemExtended;            // Expand Module Alarm Input Channel Statue
}NET_DEVSTATE_GET_BYPASS;

// CLIENT_QueryDevState's param: DH_DEVSTATE_BURNERDOOR 
typedef struct tagNET_DEVSTATE_BURNERDOOR
{
	DWORD		        dwSize;
	const char*         szBurnerName;                  // cd name,like "/dev/sda"
	bool                bEjected;                      // ejected or not
	BYTE				Reserved[3];			       // reserved
}NET_DEVSTATE_BURNERDOOR;

// CLIENT_QueryDevState iterface DH_DEVSTATE_GET_DATA_CHECK
typedef struct tagNET_DEVSTATE_DATA_CHECK
{
    DWORD		        dwSize;                     // struct size
    const char*         szBurnerName;               // cd name,like"/dev/s",if it is multiple track, including one of path is ok
    char                szState[DH_MAX_STRING_LEN]; // "NotStart" "Verifying" "Failed" "Succeed"
    int                 nPercent;                   // check percent:0-100,when state  = Verifying,availability.
}NET_DEVSTATE_DATA_CHECK;

// CLIENT_ListenServer backcall interface, fServiceCallBack support command mode
enum { 
	DH_DVR_DISCONNECT=-1,	                        // Device disconnection callback during the verification period
	DH_DVR_SERIAL_RETURN=1,                         // Device send out SN callback char* szDevSerial
	NET_DEV_AUTOREGISTER_RETURN,                    // when device registering,serial number and token to carry, corresponding NET_CB_AUTOREGISTER
    NET_DEV_NOTIFY_IP_RETURN,                       // Éè±¸½öÉÏ±¨IP, ²»×÷ÎªÖ÷¶¯×¢²áÓÃ, ÓÃ»§»ñÈ¡ipºóÖ»ÄÜ°´ÕÕÔ¼¶¨µÄ¶Ë¿Ú°´ÕÕ·ÇÖ÷¶¯×¢²áµÄÀàÐÍµÇÂ¼
};
typedef struct tagNET_CB_AUTOREGISTER
{
	DWORD			dwSize;                          // struct size
	char            szDevSerial[DH_DEV_SERIALNO_LEN];// device serial
	char            szToken[MAX_PATH];               // token
}NET_CB_AUTOREGISTER;

// public agency registration
typedef struct tagCLOUDSERVICE_CONNECT_PARAM
{
	DWORD               dwSize;   
	char                szDstIp[DH_MAX_IPADDR_EX_LEN];    // server IP
	int                 nDstPort;                         // server port 
	DWORD               dwConnectType;                    // connect type,0:main connect, 1:the tunnel connection,2:data connect,3:dynamic registration link(use 0xb4)
	char                szToken[MAX_PATH];                // the only id token
}NET_CLOUDSERVICE_CONNECT_PARAM;

typedef struct tagCLOUDSERVICE_CONNECT_RESULT
{
	DWORD               dwSize;  
	DWORD               dwConnectState;                   // connect state ,1 succeed, 2 failed
	char                szMessage[DH_MAX_CLOUDCONNECT_STATE_LEN]; // connect status info,"Success","Password Error","Network Error","Timeout"
}NET_CLOUDSERVICE_CONNECT_RESULT;
///////////////////////////////definition of configuration///////////////////////////////

//-------------------------------Device Property ---------------------------------
// Device information 
typedef struct
{
	BYTE				sSerialNumber[DH_SERIALNO_LEN];	// SN
	BYTE				byAlarmInPortNum;		// DVR alarm input amount
	BYTE				byAlarmOutPortNum;		// DVR alarm output amount
	BYTE				byDiskNum;				// DVR HDD amount 
	BYTE				byDVRType;				// DVR type.Please refer to DHDEV_DEVICE_TYPE
    union
    {
	BYTE				byChanNum;				// DVR channel amount 
        BYTE            byLeftLogTimes;         // When login failed due to password error, notice user via this parameter, remaining login times¡ê?is 0 means this parameter is invalid
    };
} NET_DEVICEINFO, *LPNET_DEVICEINFO;

// Device extension info 
typedef struct
{
    BYTE                sSerialNumber[DH_SERIALNO_LEN];	    // serial number
    int	                nAlarmInPortNum;                    // count of DVR alarm input
    int	                nAlarmOutPortNum;                   // count of DVR alarm output
    int	                nDiskNum;                           // number of DVR disk
    int	                nDVRType;                           // DVR type, refer to DHDEV_DEVICE_TYPE
    int                 nChanNum;                           // number of DVR channel
    BYTE                byLimitLoginTime;                   // Online Timeout, Not Limited Access to 0, not 0 Minutes Limit Said
    BYTE                byLeftLogTimes;                     // When login failed due to password error, notice user via this parameter, remaining login times¡ê?is 0 means this parameter is invalid	char				Reserved[30];			// reserved
    BYTE                bReserved[2];                       // keep bytes¡ê?bytes aligned
    int                 nLockLeftTime;                      // when log in failed¡ê?the left time for users to unlock (seconds), -1 indicate the device haven?¡¥t set the parameter 
    char                Reserved[24];                       // reserved
} NET_DEVICEINFO_Ex, *LPNET_DEVICEINFO_Ex;

//Device software version information. The higher 16-bit means the main version number and low 16-bit means second version number. 
typedef struct 
{
	DWORD				dwSoftwareVersion;
	DWORD				dwSoftwareBuildDate;
	DWORD				dwDspSoftwareVersion;
	DWORD				dwDspSoftwareBuildDate;
	DWORD				dwPanelVersion;
	DWORD				dwPanelSoftwareBuildDate;
	DWORD				dwHardwareVersion;
	DWORD				dwHardwareDate;
	DWORD				dwWebVersion;
	DWORD				dwWebBuildDate;
} DH_VERSION_INFO, *LPDH_VERSION_INFO;

// Device software version information. Corresponding to CLIENT_QueryDevState
typedef struct  
{
	char				szDevSerialNo[DH_DEV_SERIALNO_LEN];	// Serial number 
	char				byDevType;							// Device type, please refer to DHDEV_DEVICE_TYPE
	char				szDevType[DH_DEV_TYPE_LEN];			// Device detailed type. String format. It may be null.
	int					nProtocalVer;						// Protocol version number 
	char				szSoftWareVersion[DH_MAX_URL_LEN];
	DWORD				dwSoftwareBuildDate;
    char                szPeripheralSoftwareVersion[DH_MAX_URL_LEN];// From the Slice Version Information, The String Format, May Be Empty
    DWORD               dwPeripheralSoftwareBuildDate;
    char                szGeographySoftwareVersion[DH_MAX_URL_LEN]; // Geographical Iinformation Positioning Chip Version Information, The String Format, May Be empty
    DWORD               dwGeographySoftwareBuildDate;
	char				szHardwareVersion[DH_MAX_URL_LEN];
	DWORD				dwHardwareDate;
	char				szWebVersion[DH_MAX_URL_LEN];
	DWORD				dwWebBuildDate;
	char				reserved[256];
} DHDEV_VERSION_INFO;

// DSP capacity description. Correspondign to CLIENT_GetDevConfig
typedef struct 
{
	DWORD				dwVideoStandardMask;	// video format mask. Bit stands for the video format device supported.
	DWORD				dwImageSizeMask;		// Resolution mask bit. Bit stands for the resolution setup devices supported.
	DWORD				dwEncodeModeMask;		// Encode mode mask bit. Bit stands for the encode mode devices supported.
	DWORD				dwStreamCap;			// The multiple-media function the devices supported
												// The first bit:main stream
												// The second bit:extra stream 1
												// The third bit:extra stream 2
												// The fifth bit: snapshot in .jpg format
	DWORD				dwImageSizeMask_Assi[8];// When the main stream is the corresponding resolution, the supported extra stream resolution mask.
	DWORD				dwMaxEncodePower;		// The highest encode capacity DSP supported
	WORD				wMaxSupportChannel;		// The max video channel amount each DSP supported.
	WORD				wChannelMaxSetSync;		// Max encode bit setup in each DSP channel  are synchronized or not ;0:does not synchronized,1:synchronized
} DH_DSP_ENCODECAP, *LPDH_DSP_ENCODECAP;

// DSP capacity description. Extensive type. Corresponding to CLIENT_QueryDevState
typedef struct 
{
	DWORD				dwVideoStandardMask;	// video format mask. Bit stands for the video format device supported.
	DWORD				dwImageSizeMask;		// Resolution mask bit. Bit stands for the resolution setup devices supported.
	DWORD				dwEncodeModeMask;		// Encode mode mask bit. Bit stands for the encode mode devices supported.
	DWORD				dwStreamCap;			// The multiple-media function the devices supported
												// The first bit:main stream
												// The second bit:extra stream 1
												// The third bit:extra stream 2
												// The fifth bit: snapshot in .jpg format
	DWORD				dwImageSizeMask_Assi[32];// When the main stream is the corresponding resolution, the supported extra stream resolution mask.
	DWORD				dwMaxEncodePower;		// The highest encode capacity DSP supported
	WORD				wMaxSupportChannel;		// The max video channel amount each DSP supported.
	WORD				wChannelMaxSetSync;		// Max encode bit setup in each DSP channel  are synchronized or not;0:do not synchronized,1:synchronized
	BYTE				bMaxFrameOfImageSize[32];// The max sampling frame rate in different resolution. Bit corresponding to the dwVideoStandardMask.
	BYTE				bEncodeCap;				// Symbol. The configuration shall meet the following requirements, otherwise the configuration is invalid.
												// 0:main stream encode capacity+extra stream encode capacity<= device encode capacity 
												// 1:main stream encode capacity +extra stream encode capacity<= device encode capacity 
												// Extra stream encode capacity <=main stream encode capacity 
												// Extra stream resolution<=main stream resolution 
												// Main stream resolution and extra stream resolution <=front-end video collection frame rate
												// 2:N5 Device
												// Extra stream encode capacity <=main stream encode capacity
												// Query  the supported resolution and the corresponding maximum frame rate
	char				reserved[95];
} DHDEV_DSP_ENCODECAP, *LPDHDEV_DSP_ENCODECAP;

// DSP extend capacity description. Corresponding to CLIENT_QueryDevState
typedef struct 
{
	DWORD				dwVideoStandardMask;	// video format mask. Bit stands for the video format device supported.
	DWORD				dwImageSizeMask;		// Resolution mask bit. Bit stands for the resolution setup devices supported.
	DWORD				dwEncodeModeMask;		// Encode mode mask bit. Bit stands for the encode mode devices supported.
	DWORD				dwStreamCap;			// The multiple-media function the devices supported.
												// The first bit:main stream
												// The second bit:extra stream 1
												// The third bit:extra stream 2
												// The forth bit:extra stream 3
												// The fifth bit: snapshot in .jpg format
	DWORD				dwImageSizeMask_Assi[3][64];// When the main stream is the corresponding resolution, the supported extra stream resolution mask, the 0,1,2 member in the group correspond extra stream1,2,3
	DWORD				dwMaxEncodePower;		// The highest encode capacity DSP supported
	WORD				wMaxSupportChannel;		// The max video channel amount each DSP supported.
	WORD				wChannelMaxSetSync;		// Max encode bit setup in each DSP channel  are synchronized or not;0:do not synchronized,1:synchronized
	BYTE				bMaxFrameOfImageSize[32];// The max sampling frame rate in different resolution. Bit corresponding to the dwVideoStandardMask.
	BYTE				bEncodeCap;				// Symbol. The configuration shall meet the following requirements, otherwise the configuration is invalid.
												// 0:main stream encode capacity+extra stream encode capacity<= device encode capacity 
												// 1:main stream encode capacity +extra stream encode capacity<= device encode capacity 
												// Extra stream encode capacity <=main stream encode capacity 
												// Extra stream resolution<=main stream resolution 
												// Main stream resolution and extra stream resolution <=front-end video collection frame rate
												// 2:N5 Device
												// Extra stream encode capacity <=main stream encode capacity
												// Query  the supported resolution and the corresponding maximum frame rate
	BYTE				btReserve1[3];			// reserved
	DWORD				dwExtraStream;			// bit0-main stream, bit1-extra stream1, bit2-extra stream2
	DWORD				dwCompression[3];		// extra stream compression

	char				reserved[108];
} DHDEV_DSP_ENCODECAP_EX, *LPDHDEV_DSP_ENCODECAP_EX;

// System information
typedef struct 
{
	DWORD				dwSize;
	/* The following are read only for device. */
	DH_VERSION_INFO		stVersion;
	DH_DSP_ENCODECAP	stDspEncodeCap;			// DSP  capacity description 
	BYTE				szDevSerialNo[DH_DEV_SERIALNO_LEN];	// SN
	BYTE				byDevType;				// device type. Please refer to enumeration DHDEV_DEVICE_TYPE
	BYTE				szDevType[DH_DEV_TYPE_LEN];	// Device detailed type. String format. It may be empty.
	BYTE				byVideoCaptureNum;		// Video port amount
	BYTE				byAudioCaptureNum;		// Audio port amount 
	BYTE				byTalkInChanNum;		// NSP
	BYTE				byTalkOutChanNum;		// NSP
	BYTE				byDecodeChanNum;		// NSP
	BYTE				byAlarmInNum;			// Alarm input port amount
	BYTE				byAlarmOutNum;			// Alarm output amount port
	BYTE				byNetIONum;				// network port amount 
	BYTE				byUsbIONum;				// USB USB port amount
	BYTE				byIdeIONum;				// IDE amount 
	BYTE				byComIONum;				// COM amount 
	BYTE				byLPTIONum;				// LPT amount
	BYTE				byVgaIONum;				// NSP
	BYTE				byIdeControlNum;		// NSP
	BYTE				byIdeControlType;		// NSP
	BYTE				byCapability;			// NSP, expansible description 
	BYTE				byMatrixOutNum;			// video matrix output amount 
	/* The following are read-write part for device */
	BYTE				byOverWrite;			// Operate when HDD is full(overwrite/stop)
	BYTE				byRecordLen;			// Video file Package length
	BYTE				byDSTEnable;			// Enable  DTS or not  1--enable. 0--disable
	WORD				wDevNo;					// Device serial number. Remote control can use this SN to control.
	BYTE				byVideoStandard;		// Video format
	BYTE				byDateFormat;			// Date format
	BYTE				byDateSprtr;			// Date separator(0:".",1:"-",2:"/")
	BYTE				byTimeFmt;				// Time separator  (0-24H,1-12H)
	BYTE				byLanguage;				// Please refer to DH_LANGUAGE_TYPE for enumeration value
} DHDEV_SYSTEM_ATTR_CFG, *LPDHDEV_SYSTEM_ATTR_CFG;

// The returned information after modify device 
typedef struct
{
	DWORD				dwType;					// Type (type of GetDevConfig and SetDevConfig)
	WORD				wResultCode;			// Returned bit;0:succeeded,1:failed,2:illegal data,3:can not set right now,4:have no right 
	WORD   				wRebootSign;			// Reboot symbol;0:do not need to reboot,1:need to reboot to get activated 
	DWORD				dwReserved[2];			// Reserved 
} DEV_SET_RESULT;

// play result
typedef struct
{
	DWORD              dwResultCode;            // result code,
                                                // 1:no authority,2:device not support,3:insufficient resources,4:get data error, 
                                                // 11:resouces are taked by advance users, 12:forbidden, 13:limited from reading disk data
                                                // 14:multi window preview already open, out of resource, compressed playback failed, 15: compressed playback already open
	LLONG               lPlayHandle;            // play handle
	BYTE               byReserved[32];          // reserved   
	                    
}DEV_PLAY_RESULT;

// request audio tal error return info
typedef struct
{
    DWORD               dwResultCode;               // error return code CLIENT_GetLastError port return value
                                                    // NET_ERROR_TALK_REJECT _EC(375) // refuse talk
                                                    // NET_ERROR_TALK_RESOURCE_CONFLICIT _EC(377) // resource conflict
                                                    // NET_ERROR_TALK_UNSUPPORTED_ENCODE _EC(378) // not support talk encode format
                                                    // NET_ERROR_TALK_RIGHTLESS _EC(379) // no right
    LLONG               lTalkHandle;                // correspoinding handle
    BYTE                byReserved[32];             // reserved text                         
}DEV_TALK_RESULT;

//DST(Daylight Save Time) setup
typedef struct  
{
	int					nYear;					// Year[200 - 2037]
	int					nMonth;					// Month[1 - 12]
	int					nHour;					// Hour[0 - 23]
	int					nMinute;				// Minute [0 - 59]
	int					nWeekOrDay;				// [-1 - 4]0:It means it adopts the date calculation method. 
												// 1:in week: the first week ,2:the second week,3:the third week,4: The fourth week ,-1: the last week  
	union
	{
		int				iWeekDay;				// week[0 - 6](nWeekOrDay:calculated in week )0: Sunday, 1:Monday , 2:Tuesday ,3: Wednesday,4:Thirsday ,5: Friday,6:Saturday 
		int				iDay;					// date[1 - 31] (nWeekOrDay: in date)
	};
	
	DWORD				dwReserved[8];			// Reserved 
}DH_DST_POINT;

typedef struct  
{
	DWORD				dwSize;
	int					nDSTType;				// DST position way. 0: position in date  , 1:position in week  
	DH_DST_POINT        stDSTStart;             // Enable DTS
	DH_DST_POINT        stDSTEnd;				// End DTS
	DWORD				dwReserved[16];			// Reserved
}DHDEV_DST_CFG;


// Auto maintenance setup
typedef struct
{
	DWORD				dwSize;
	BYTE				byAutoRebootDay;		// Auto reboot;0:never, 1:each day,2:each Sunday,3:Each Monday ,......
	BYTE				byAutoRebootTime;		// 0:0:00,1:1:00,......23:23:00
	BYTE				byAutoDeleteFilesTime;	// Auto delete file;0:never,1:24H,2:48H,3:72H,4:96H,5:ONE WEEK,6:ONE MONTH
	BYTE				reserved[13];			// Reserved bit
} DHDEV_AUTOMT_CFG;

// car's disk info
typedef struct  
{
	DWORD				dwSize;										// struct size,must initialize
	DWORD				dwVolume;									// disk volume
	DWORD				dwFreeSpace;								// free space MB
	BYTE				byModle[DH_MAX_HARDDISK_TYPE_LEN];			// disk mode
	BYTE				bySerialNumber[DH_MAX_HARDDISK_SERIAL_LEN];	// serial number
}DHDEV_VEHICLE_DISK;

// car's 3G mode info,the largest support DH_MAX_SIM_NUM
typedef struct
{
	DWORD				dwSize;						// struct size,must initialize
	BYTE				szIMSI[DH_MAX_SIM_LEN];		// SIM's value = 460012002778636,top three for the country code MCC,4-6for the network code MNC,the last is MSIN,a total of not more than 15 characters
	BYTE				szMDN[DH_MAX_MDN_LEN];		// MDN
}DHDEV_VEHICLE_3GMODULE;

// car basic info
typedef struct 
{
	DWORD					dwSize;								// struct size,must initialize
	DWORD					dwSoftwareBuildDate;				// soft ware build date
	char					szVersion[DH_MAX_VERSION_LEN];		// version
	char					szDevSerialNo[DH_DEV_SERIALNO_LEN];	// device serial no.
	char					szDevType[DH_DEV_TYPE_LEN];			// device type,string format,can empty
	DWORD					dwDiskNum;							// disk number
	DHDEV_VEHICLE_DISK		stuHarddiskInfo[DH_MAX_DISKNUM];	// disk info
	DWORD					dw3GModuleNum;						// count of 3G module
	DHDEV_VEHICLE_3GMODULE	stu3GModuleInfo[DH_MAX_SIM_NUM];	// 3G module info
}DHDEV_VEHICLE_INFO;

// net interface,the largest support DH_MAX_NETINTERFACE_NUM
typedef struct tagDHDEV_NETINTERFACE_INFO
{
	int             dwSize;
	BOOL			bValid;								// valid or not
	BOOL			bVirtual;							// support virtual or not
	int             nSpeed;								// theory of speed (Mbps)
	int             nDHCPState;							// 0-disable, 1-getting, 2-get succeed
	char			szName[DH_NETINTERFACE_NAME_LEN];	// net port mane
	char			szType[DH_NETINTERFACE_TYPE_LEN];	// net type
	char			szMAC[DH_MACADDR_LEN];			    // MAC addr
	char			szSSID[DH_MAX_SSID_LEN];			// SSID, if only szType == "Wireless",availability
	char            szConnStatus[DH_MAX_CONNECT_STATUS_LEN]; // Wifi,3G connect status,"Inexistence" : not exist, "Down": close "Disconn": disconnect "Connecting" "Connected"
	int             nSupportedModeNum;                  // support mode number
	char            szSupportedModes[DH_MAX_MODE_NUM][DH_MAX_MODE_LEN];// support 3G net mode	"TD-SCDMA", "WCDMA", "CDMA1x", "EDGE", "EVDO"
} DHDEV_NETINTERFACE_INFO;
//-----------------------------Video Channel Property -------------------------------

// Time period structure 															    
typedef struct 
{
	int				bEnable;				// Current record period . Bit means the four Enable functions. From the low bit to the high bit:Motion detection record, alarm record and general record, when Motion detection and alarm happened at the same time can record.
	int					iBeginHour;
	int					iBeginMin;
	int					iBeginSec;
	int					iEndHour;
	int					iEndMin;
	int					iEndSec;
} DH_TSECT, *LPDH_TSECT;

// Zone;Each margin is total lenght :8192
typedef struct 
{
    long					left;
    long					top;
    long					right;
    long					bottom;
} DH_RECT, *LPDH_RECT;

typedef struct tagNET_RECT
{
    int             nLeft;
    int             nTop;
    int             nRight;
    int             nBottom;
} NET_RECT;

// 2 dimension point
typedef struct 
{
	short					nx;
	short					ny;
} DH_POINT, *LPDH_POINT;

// 
typedef struct
{
	int        nPointNum;                           // point number
	DH_POINT   stuPoints[DH_MAX_DETECT_REGION_NUM]; // point info
}DH_POLY_POINTS;

// struct of OSD attribute
typedef struct  tagENCODE_WIDGET
{
	DWORD				rgbaFrontground;		// Object front view. Use bit to represent:red, green, blue and transparency.
	DWORD				rgbaBackground;			// Object back ground. Use bit to represent:red, green, blue and transparency.
	DH_RECT				rcRect;					// Position
	BYTE				bShow;					// Enable display
	BYTE                bExtFuncMask;           // Extended function,mask 
                                                // bit0 indicate week showing,0-not show 1-show 
	BYTE				byReserved[2];
} DH_ENCODE_WIDGET, *LPDH_ENCODE_WIDGET;

// Channel audio property 
typedef struct 
{
	// Video property 
	BYTE				byVideoEnable;			// Enable video;1:open,0:close 
	BYTE				byBitRateControl;		// Bit stream control;Please refer to constant Bit Stream Control definition 
	BYTE				byFramesPerSec;			// Frame rate
	BYTE				byEncodeMode;			// Encode mode:please refer to constant Encode Mode definition
	BYTE				byImageSize;			// Resolution:please refer to constant Resolution definition.
	BYTE				byImageQlty:7;			// Level 1-6
	BYTE                byImageQltyType:1;       
	WORD				wLimitStream;			// Limit stream parameter
	// Audio property 
	BYTE				byAudioEnable;			// Enable audio;1:open,0:close
	BYTE				wFormatTag;				// Audio encode mode:0:G711A,1:PCM,2:G711U,3:AMR,4:AAC 
	WORD				nChannels;				// Track amount 
	WORD				wBitsPerSample;			// Sampling depth 	
	BYTE				bAudioOverlay;			// Enabling audio
	BYTE				bH264ProfileRank;       // H.264 Profile rank(when byEncodeMode is h264, this value works ), see enmu struct EM_H264_PROFILE_RANK,when this value is 0, it means nothing
	DWORD				nSamplesPerSec;			// Sampling rate 
	BYTE				bIFrameInterval;		// 0-149. I frame interval amount. Describe the P frame amount between two I frames.
	BYTE				bScanMode;				// NSP
	BYTE				bReserved_3;
	BYTE				bReserved_4;
} DH_VIDEOENC_OPT, *LPDH_VIDEOENC_OPT;

// Image color property  
typedef struct 
{
	DH_TSECT			stSect;
	BYTE				byBrightness;			// Brightness:0-100
	BYTE				byContrast;				// Contrast:0-100
	BYTE				bySaturation;			// Saturation:0-100
	BYTE				byHue;					// Hue:0-100
	BYTE				byGainEn;				// Enable gain
	BYTE				byGain;					// Gain:0-100
	BYTE				byGamma;                // gamma 0-100
	BYTE				byReserved[1];
} DH_COLOR_CFG, *LPDH_COLOR_CFG;

// Image channel property structure 
typedef struct 
{
	WORD				dwSize;
	BYTE				bNoise;
	BYTE				bMode;   // (vehicle's special need)model 1 (quality first): 4-way video resolution D1, frame rate 2fps, bit rate 128kbps(225MB per hour) 
	                             // Mode 2 (fluency preferred): 4-way video resolution CIF, frame rate of 12fps, bit rate 256kbps (550MB per hour) 
                                 // Mode 3 (Custom) video resolution can be defined by the user, limited the maximum capacity of 4CIF/25fps
	char				szChannelName[DH_CHAN_NAME_LEN];
	DH_VIDEOENC_OPT		stMainVideoEncOpt[DH_REC_TYPE_NUM];
	DH_VIDEOENC_OPT		stAssiVideoEncOpt[DH_N_ENCODE_AUX];		
	DH_COLOR_CFG		stColorCfg[DH_N_COL_TSECT];
	DH_ENCODE_WIDGET	stTimeOSD;
	DH_ENCODE_WIDGET	stChannelOSD;
	DH_ENCODE_WIDGET	stBlindCover[DH_N_COVERS];	// Single privacy mask zone
	BYTE				byBlindEnable;				// Privacy mask zone enable button;0x00:disable privacy mask ,0x01:privacy mask local preview ,0x10:privacy mask record and network preview,0x11: Privacy mask all
	BYTE				byBlindMask;				// Privacy mask zone subnet mask. The first bit; device local preview ;The second bit :record (and network preview ) */
	BYTE				bVolume;					// volume(0~100)
	BYTE				bVolumeEnable;				// volume enable
} DHDEV_CHANNEL_CFG, *LPDHDEV_CHANNEL_CFG;

// Preview image property 
typedef struct 
{
	DWORD				dwSize;
	DH_VIDEOENC_OPT		stPreView;
	DH_COLOR_CFG		stColorCfg[DH_N_COL_TSECT];
}DHDEV_PREVIEW_CFG;

// snap control configuration
typedef struct _config_snap_control
{
	BYTE               bySnapState[32];           // every channel's snap on-off: 0 Autumn(other configuration and event will control whether snap picture ); 1: turn on snap; 2: turn off snap
    BYTE               byReserved[480];
}DHDEV_SNAP_CONTROL_CFG;

enum _gps_mode
{
	GPS_OR_GLONASS_MODE,	// GPS,GLONASS
	GLONASS_MODE,			// GLONASS
	GPS_MODE,				// GPS
};
// DH_DEV_GPS_MODE_CFG configuration
typedef struct tagDHDEV_GPS_MODE_CFG
{
	BYTE				byGPSMode; // GPS mode
	BYTE				byRev[255];
}DHDEV_GPS_MODE_CFG;

// snap upload DH_DEV_SNAP_UPLOAD_CFG configuration
typedef struct tagDHDEV_SNAP_UPLOAD_CFG
{
	int					nUploadInterval;		// the interval time of upload picture(s)
	BYTE				byReserved[252];	
}DHDEV_SNAP_UPLOAD_CFG;

// DH_DEV_SPEED_LIMIT_CFG configuration
typedef struct tagDHDEV_SPEED_LIMIT_CFG
{
	BYTE       byEnable;						// Enable speed limit;1:enable,0:disable
	BYTE       byReserved1;      
	WORD       wMaxSpeed;						// upper speed(KM/H) 0: none limit speed, >0:limit speed
	WORD       wMinSpeed;						// low speed(KM/H) 0: none limit speed, >0:limit speed
	BYTE       byReserved2[122];  
}DHDEV_SPEED_LIMIT_CFG;

// wireless routing config
typedef struct
{
	BOOL		bEnable;						// enable
	char		szSSID[36];						// SSID
	BOOL		bHideSSID;						// hide SSID
	char		szIP[DH_MAX_IPADDR_LEN];		// IP
	char		szSubMark[DH_MAX_IPADDR_LEN];	// sub mark
	char		szGateWay[DH_MAX_IPADDR_LEN];	// gateway
	char		szCountry[32];					// country
	int			nSafeType;						// safe type: 1-no encryption; 2-WEP; 2-WPA-PSK; 3-WPA2-PSK
	int			nEncryption;					// encryption: WEP(1-auto 2-open 3-shareable); WPA-PSK/WPA2-PSK(4-TKIP 5-AES)
	char		szKey[32];						// key
	int			nChannel;						// channel
	BOOL		bAutoChannelSelect;				// auto channel select
}DHDEV_WIRELESS_ROUTING_CFG;

//-------------------------------COM property ---------------------------------

// COM basic property 
typedef struct
{
	BYTE				byDataBit;				// Data bit;0:5,1:6,2:7,3:8
	BYTE				byStopBit;				// Stop bit;0:1 bit,1:1.5 bit,2:2 bits
	BYTE				byParity;				// Parity;0: None,1: Odd;2: even;3:sign;4:empty
	BYTE				byBaudRate;				// Baud rate;0:300,1:600,2:1200,3:2400,4:4800,
												// 5:9600,6:19200,7:38400,8:57600,9:115200
} DH_COMM_PROP;

// 485 decoder setup 
typedef struct
{ 
	DH_COMM_PROP		struComm;
	BYTE				wProtocol;				// Protocol type. Corresponding to the subscript of Protocol Name List
	BYTE				bPTZType;				// 0-Compatible,local ptz 1-remote network ptz, the capability refer to DEV_ENCODER_CFG.
	BYTE				wDecoderAddress;		// Decoder address;0 - 255
	BYTE 				byMartixID;				// Matrix number 
} DH_485_CFG;

// 232 COM setup 
typedef struct
{
	DH_COMM_PROP		struComm;
	BYTE				byFunction;				// COM function,Corresponding to the subscript of Function Name list. 
	BYTE				byReserved[3];
} DH_RS232_CFG;

// COM configuration structure 
typedef struct
{
	DWORD				dwSize;

	DWORD				dwDecProListNum;										// Decoder protocol amount
	char				DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];	// Protocol name list
	DH_485_CFG			stDecoder[DH_MAX_DECODER_NUM];							// Each decoder current property

	DWORD				dw232FuncNameNum;										// 232 function amount 
	char				s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];			// Function name list 
	DH_RS232_CFG		st232[DH_MAX_232_NUM];									// Current 232 COM property 
} DHDEV_COMM_CFG;

// Extended COM configuration structure 
typedef struct
{
	DWORD				dwSize;
	
	DWORD				dwDecProListNum;			                           // Decoder protocol amount
	char				DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];  // Protocol name list
	DH_485_CFG			stDecoder[DH_MAX_DECODER_NUM];						   // Each decoder current property
	
	DWORD				dw232FuncNameNum;									   // 232 function amount
	char				s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];	       // Function name list
	DWORD               dw232ComNum;										   // 232 com amount  
	DH_RS232_CFG		st232[DH_MAX_232_NUM_EX];	                           // Current 232 COM property
} DHDEV_COMM_CFG_EX;

// Serial port status
typedef struct
{
	unsigned int		uBeOpened;
	unsigned int		uBaudRate;
	unsigned int		uDataBites;
	unsigned int		uStopBits;
	unsigned int		uParity;
	BYTE				bReserved[32];
} DH_COMM_STATE;

//-------------------------------Record configuration---------------------------------

// Scheduled record 
typedef struct 
{
	DWORD				dwSize;
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	BYTE				byPreRecordLen;			// Pre-record button. Unit is second. 0 means disable pre-record 
	BYTE				byRedundancyEn;			// Record redundant enable button 
	BYTE                byRecordType;           // Video bit-stream type:0:Main Stream 1:Assist Stream1 2:Assist Stream2 3:Assist Stream3
	BYTE				byReserved;
} DHDEV_RECORD_CFG, *LPDH_RECORD_CFG;

// NTP setup 
typedef struct  
{
	BOOL				bEnable;				// Enable or not
	int					nHostPort;				// NTP  server default port is 123
	char				szHostIp[32];			// Host IP
	char				szDomainName[128];		// Domain name 
	int					nType;					// Read only ,0:IP,1:domain name ,2:IP and domain name 
	int					nUpdateInterval;		// Update time(minute)
	int					nTimeZone;				// Please refer to DH_TIME_ZONE_TYPE
	char				reserved[128];
} DHDEV_NTP_CFG;

// FTP upload setup 
typedef struct
{
	struct
	{
		DH_TSECT		struSect;				// Enable function is disabled during the period. Can ignore
		BOOL			bMdEn;					// Upload motion detection record
		BOOL			bAlarmEn;				// Upload external alarm record 
		BOOL			bTimerEn;				// Upload scheduled record 
		DWORD			dwRev[4];
	} struPeriod[DH_TIME_SECTION];
} DH_FTP_UPLOAD_CFG;

typedef struct
{
	DWORD				dwSize;
	BOOL				bEnable;							// Enable or not
	char				szHostIp[DH_MAX_IPADDR_LEN];		// Host IP
	WORD				wHostPort;							// Host port 
	char				szDirName[DH_FTP_MAX_PATH];			// FTP path
	char				szUserName[DH_FTP_USERNAME_LEN];	// User name
	char				szPassword[DH_FTP_PASSWORD_LEN];	// Password 
	int					iFileLen;							// File length
	int					iInterval;							// Time interval between two near files.
	DH_FTP_UPLOAD_CFG	struUploadCfg[DH_MAX_CHANNUM][DH_N_WEEKS];
	char 				protocol;							// 0-FTP 1-SMB 2-NFS,3-ISCSI
	char				NASVer;								// Network storage server version 0=Old FTP(There is time period in the user interface),1=NAS storage(There is no time period in the user interface. )
	DWORD				dwFunctionMask;						// Function capacity mask. Use bit to represent. Lower 16-bit:FTP,SMB,NFS, ISCSI and higher 16-bit:(Local storage)DISK,U
	BYTE                bDataType;                          // data type, 0-all, 1-video, 2-image
	BYTE 				reserved[123];
} DHDEV_FTP_PROTO_CFG;

// extend FTP upload setup (support setting the FTP's path, maximal picture number)
typedef struct 
{
    int            nMaxPictures;                             // the maximal number of the FTP can save,can set limit of the picture number in the every chennel's direct;
	                                                         // if the saved picture number extended the limit the old picture will be covered by new one; the value 0 indecate that it will save picture untill the disck was full.
    char           szPreChannelName[DH_FTP_MAX_SUB_PATH];    // the picture named mod
    char           szFTPChannelPath[DH_FTP_MAX_SUB_PATH];    // the FTP's sub direction
    char           szRev[128];                               // reserved
}DHDEV_FTP_CHANNEL_CFG; 


typedef struct 
{ 
	DHDEV_FTP_PROTO_CFG      stuFtpNormalSet;                // the normal function of the FTP
	DHDEV_FTP_CHANNEL_CFG     stuFtpChannelSet[DH_MAX_CHANNUM]; // the extended function of the FTP
	char                      szRev[128];                    // reserved
}DHDEV_FTP_PROTO_CFG_EX;

//-------------------------------Network Configuration---------------------------------

// Ethernet Configuration
typedef struct 
{
	char				sDevIPAddr[DH_MAX_IPADDR_LEN];	// DVR IP  address
	char				sDevIPMask[DH_MAX_IPADDR_LEN];	// DVR IP subnet mask    
	char				sGatewayIP[DH_MAX_IPADDR_LEN];	// Gateway address

	/*
	 * 1:10Mbps full-duplex
	 * 2:10Mbps auto-duplex
	 * 3:10Mbps half-duplex
	 * 4:100Mbps full-duplex
	 * 5:100Mbps auto-duplex
	 * 6:100Mbps half-duplex
	 * 7:auto
	 */
	// Divide DWORD into four to future development
	BYTE				dwNetInterface;			// NSP
	BYTE				bTranMedia;				// 0:cable,1:wireless
	BYTE				bValid;					// Use bit to represent, The first bit:1:valid 0:invalid;The second bit:0:Disable DHCP 1:Enable DHCP;The third bit:0:Do not support DHCP 1:Support DHCP
	BYTE				bDefaultEth;			// To be the default network card or not.  1: default 0:non-default 
	char				byMACAddr[DH_MACADDR_LEN];	// MAC address , read-only., 
} DH_ETHERNET; 

// Remote host setup 
typedef struct 
{
	BYTE				byEnable;				// Enable connection 
	BYTE				byAssistant;            // Only for PPPoE server,0:on the cabled network; 1:on the wireless network
	WORD				wHostPort;				// Remote host Port 
	char				sHostIPAddr[DH_MAX_IPADDR_LEN];		// Remote host IP address  				
	char				sHostUser[DH_MAX_HOST_NAMELEN];		// Remote host User name   
	char				sHostPassword[DH_MAX_HOST_PSWLEN];	// Remote host Password   
} DH_REMOTE_HOST;

// Mail setup 
typedef struct 
{
	char				sMailIPAddr[DH_MAX_IPADDR_LEN];		// Email server IP
	WORD				wMailPort;							// Email server port 
	WORD				wReserved;							// Reserved
	char				sSenderAddr[DH_MAX_MAIL_ADDR_LEN];	// Send out address 
	char				sUserName[DH_MAX_NAME_LEN];			// User name 
	char				sUserPsw[DH_MAX_NAME_LEN];			// User password 
	char				sDestAddr[DH_MAX_MAIL_ADDR_LEN];	// Destination address 
	char				sCcAddr[DH_MAX_MAIL_ADDR_LEN];		// CC address 
	char				sBccAddr[DH_MAX_MAIL_ADDR_LEN];		// BCC address 
	char				sSubject[DH_MAX_MAIL_SUBJECT_LEN];	// Subject 
} DH_MAIL_CFG;

// Network configuration structure 
typedef struct
{ 
	DWORD				dwSize; 
	char				sDevName[DH_MAX_NAME_LEN];	// Device host name
	WORD				wTcpMaxConnectNum;		// TCP max connection amount
	WORD				wTcpPort;				// TCP listening port 
	WORD				wUdpPort;				// UDP listening port 
	WORD				wHttpPort;				// HTTP port number 
	WORD				wHttpsPort;				// HTTPS port number 
	WORD				wSslPort;				// SSL port number 
	DH_ETHERNET			stEtherNet[DH_MAX_ETHERNET_NUM];	// Ethernet port 

	DH_REMOTE_HOST		struAlarmHost;			// Alarm server 
	DH_REMOTE_HOST		struLogHost;			// Log server 
	DH_REMOTE_HOST		struSmtpHost;			// SMTP server 
	DH_REMOTE_HOST		struMultiCast;			// Multiple-cast group 
	DH_REMOTE_HOST		struNfs;				// NFS server
	DH_REMOTE_HOST		struPppoe;				// PPPoE server 
	char				sPppoeIP[DH_MAX_IPADDR_LEN]; // returned IP after PPPoE registration 
	DH_REMOTE_HOST		struDdns;				// DDNS server
	char				sDdnsHostName[DH_MAX_HOST_NAMELEN];	// DDNS host name
	DH_REMOTE_HOST		struDns;				// DNS server 
	DH_MAIL_CFG			struMail;				// Email setup 
} DHDEV_NET_CFG;

// Ethernet extended Configuration
typedef struct 
{
	char				sDevIPAddr[DH_MAX_IPADDR_LEN];	// DVR IP  address
	char				sDevIPMask[DH_MAX_IPADDR_LEN];	// DVR IP subnet mask
	char				sGatewayIP[DH_MAX_IPADDR_LEN];	// Gateway address

	/*
	 * 1:10Mbps full-duplex
	 * 2:10Mbps auto-duplex
	 * 3:10Mbps half-duplex
	 * 4:100Mbps full-duplex
	 * 5:100Mbps auto-duplex
	 * 6:100Mbps half-duplex
	 * 7:auto
	 */
	// Divide DWORD into four to future development
	BYTE				dwNetInterface;			// NSP
	BYTE				bTranMedia;				// 0:cable,1:wireless
	BYTE				bValid;					// Use bit to represent, The first bit:1:valid 0:invalid;The second bit:0:Disable DHCP 1:Enable DHCP;The third bit:0:Do not support DHCP 1:Support DHCP
	BYTE				bDefaultEth;			//To be the default network card or not.  1: default 0:non-default 
	char				byMACAddr[DH_MACADDR_LEN];	// MAC address , read-only.
	BYTE                bMode;                  // mode, 1:balance, 2:multi, 3:fault-toerant
	BYTE                bReserved1[3];          // reserved   
    char                szEthernetName[DH_MAX_NAME_LEN];    // Card name, read only
    BYTE                bReserved[12];                      // reserved    
} DH_ETHERNET_EX; 

// Network extended configuration structure
typedef struct
{ 
	DWORD				dwSize; 
	char				sDevName[DH_MAX_NAME_LEN];	// Device host name
	WORD				wTcpMaxConnectNum;		// TCP max connection amount
	WORD				wTcpPort;				// TCP listening port
	WORD				wUdpPort;				// UDP listening port 
	WORD				wHttpPort;				// HTTP port number
	WORD				wHttpsPort;				// HTTPS port number
	WORD				wSslPort;				// SSL port number
	int                 nEtherNetNum;           // Ethernet port number
	DH_ETHERNET_EX		stEtherNet[DH_MAX_ETHERNET_NUM_EX];	// Ethernet info
	
	DH_REMOTE_HOST		struAlarmHost;			// Alarm server
	DH_REMOTE_HOST		struLogHost;			// Log server
	DH_REMOTE_HOST		struSmtpHost;			// SMTP server
	DH_REMOTE_HOST		struMultiCast;			// Multiple-cast group
	DH_REMOTE_HOST		struNfs;				// NFS server
	DH_REMOTE_HOST		struPppoe;				// PPPoE server
	char				sPppoeIP[DH_MAX_IPADDR_LEN]; // returned IP after PPPoE registration
	DH_REMOTE_HOST		struDdns;				// DDNS server
	char				sDdnsHostName[DH_MAX_HOST_NAMELEN];	// DDNS host name
	DH_REMOTE_HOST		struDns;				// DNS server
	DH_MAIL_CFG			struMail;				// Email setup
	BYTE                bReserved[128];         // reserved
} DHDEV_NET_CFG_EX;

// ddns configuraiton structure 
typedef struct
{
	DWORD				dwId;					// ddns server id
	BOOL				bEnable;				// Enable. There is only one valid ddns server at one time.
	char				szServerType[DH_MAX_SERVER_TYPE_LEN];	// Server type. www.3322.org.
	char				szServerIp[DH_MAX_DOMAIN_NAME_LEN];		// Server IP or domain name 
	DWORD				dwServerPort;			// Server port 
	char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];	// DVR domain name such as jeckean.3322.org
	char				szUserName[DH_MAX_HOST_NAMELEN];		// User name
	char				szUserPsw[DH_MAX_HOST_PSWLEN];			// Password
	char				szAlias[DH_MAX_DDNS_ALIAS_LEN];			// Server alias 
	DWORD				dwAlivePeriod;							// DDNS alive period
	BYTE				ByMode;									// domain mode:0-manual,szDomainName enable; 1-default szDefaultDomainName enable
	char				szDefaultDomainName[DH_MAX_DEFAULT_DOMAIN_LEN];// default domain, real only
    BYTE                bReserved[3];                           // Text align
    char                szEmailUserName[DH_MAX_MAIL_NAME_LEN];	// Mail username
    char                reserved[128];
} DH_DDNS_SERVER_CFG;

typedef struct
{
	DWORD				dwSize;
	DWORD				dwDdnsServerNum;	
	DH_DDNS_SERVER_CFG	struDdnsServer[DH_MAX_DDNS_NUM];	
} DHDEV_MULTI_DDNS_CFG;

// Mail configuration structure 
typedef struct 
{
	char				sMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];	// Mail server address(IP and domain name )
	char				sSubMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];
	WORD				wMailPort;								// Mail server port 
	WORD				wSubMailPort;
	WORD				wReserved;								// Reserved 
	char				sSenderAddr[DH_MAX_MAIL_ADDR_LEN];		// From
	char				sUserName[DH_MAX_MAIL_NAME_LEN];		// User name
	char				sUserPsw[DH_MAX_MAIL_NAME_LEN];			// password
	char				sDestAddr[DH_MAX_MAIL_ADDR_LEN];		// To
	char				sCcAddr[DH_MAX_MAIL_ADDR_LEN];			// CC
	char				sBccAddr[DH_MAX_MAIL_ADDR_LEN];			// BCC
	char				sSubject[DH_MAX_MAIL_SUBJECT_LEN];		// Subject
	BYTE				bEnable;								// Enable 0:false,	1:true
	BYTE				bSSLEnable;								// SSL enable
	WORD				wSendInterval;							// Send interval,[0,3600]s
	BYTE				bAnonymous;								// Anonymous Options[0,1], 0:FALSE,1:TRUE.
	BYTE				bAttachEnable;							// Attach enable[0,1], 0:FALSE,1:TRUE.
	char				reserved[154];
} DHDEV_MAIL_CFG;

// DNS server setup 
typedef struct  
{
	char				szPrimaryIp[DH_MAX_IPADDR_LEN];
	char				szSecondaryIp[DH_MAX_IPADDR_LEN];
	char				reserved[256];
} DHDEV_DNS_CFG;

// Record download strategy setup 
typedef struct
{
	DWORD				dwSize;
	BOOL				bEnable;				// TRUE: high-speed download,FALSE:general download  
}DHDEV_DOWNLOAD_STRATEGY_CFG;

// Network transmission strategy setup 
typedef struct
{
	DWORD				dwSize;
	BOOL				bEnable;
	int					iStrategy;				// 0: video quality,1:fluency ,2: auto
}DHDEV_TRANSFER_STRATEGY_CFG;

// The corresponding parameter when setting log in
typedef struct  
{
	int					nWaittime;				// Waiting time(unit is ms), 0:default 5000ms.
	int					nConnectTime;			// Connection timeout value(Unit is ms), 0:default 1500ms.
	int					nConnectTryNum;			// Connection trial times, 0:default 1.
	int					nSubConnectSpaceTime;	// Sub-connection waiting time(Unit is ms), 0:default 10ms.
	int					nGetDevInfoTime;		// Access to device information timeout, 0:default 1000ms.
	int					nConnectBufSize;		// Each connected to receive data buffer size(Bytes), 0:default 250*1024
	int					nGetConnInfoTime;		// Access to sub-connect information timeout(Unit is ms), 0:default 1000ms.
	int                 nSearchRecordTime;      // Timeout value of search video (unit ms), default 3000ms
	int                 nsubDisconnetTime;      // dislink disconnect time,0:default 60000ms
	BYTE				byNetType;				// net type, 0-LAN, 1-WAN
	BYTE                byPlaybackBufSize;      // playback data from the receive buffer size(m),when value = 0,default 4M
    BYTE                bDetectDisconnTime;     // Pulse detect offline time(second) .When it is 0, the default setup is 60s, and the min time is 2s 
    BYTE                bKeepLifeInterval;      // Pulse send out interval(second). When it is 0, the default setup is 10s, the min internal is 2s. 
	int                 nPicBufSize;            // actual pictures of the receive buffer size(byte)when value = 0,default 2*1024*1024
	BYTE				bReserved[4];			// reserved
} NET_PARAM;

// Corresponding to CLIENT_SearchDevices
typedef struct 
{
	char				szIP[DH_MAX_IPADDR_LEN];				// IP
	int					nPort;													// Port
	char				szSubmask[DH_MAX_IPADDR_LEN];		// Subnet mask
	char				szGateway[DH_MAX_IPADDR_LEN];		// Gateway
	char				szMac[DH_MACADDR_LEN];					// MAC address
	char				szDeviceType[DH_DEV_TYPE_LEN];	// Device type
	BYTE        byManuFactory;				    			// manufactory
	BYTE        byIPVersion;                    // 4: IPv4, szXXX is in format with dot; 6:IPv6, szXXX is 128-bit *16 bytes) numerical format
	BYTE				bReserved[30];									// reserved
} DEVICE_NET_INFO;

// Corresponding to CLIENT_StartSearchDevices
typedef struct 
{
	int                 iIPVersion;                      // 4 for IPV4, 6 for IPV6
	char				szIP[64];		                 // IP IPV4 like"192.168.0.1" IPV6 like "2008::1/64"
	int				    nPort;		                     // port
	char				szSubmask[64];	                 // Subnet mask(IPV6 do not have subnet mask)
	char				szGateway[64];	                 // Gateway
	char				szMac[DH_MACADDR_LEN];           // MAC address
	char				szDeviceType[DH_DEV_TYPE_LEN];	 // Device type
	BYTE                byManuFactory;				     // device manufactory, see EM_IPC_TYPE
	BYTE                byDefinition;                    // 1-Standard definition 2-High definition
	bool                bDhcpEn;                         // Dhcp, true-open, false-close
	BYTE                byReserved1;                     // reserved
	char                verifyData[88];                  // ECC data 
	char                szSerialNo[DH_DEV_SERIALNO_LEN]; // serial no
	char                szDevSoftVersion[DH_MAX_URL_LEN];// soft version    
    char                szDetailType[DH_DEV_TYPE_LEN];   // device detail type
	char                szVendor[DH_MAX_STRING_LEN];     // OEM type
	char                szDevName[DH_MACHINE_NAME_NUM];  // device name
	char                szUserName[DH_USER_NAME_LENGTH_EX];  // user name for log in device(it need be filled when modify device ip)
	char                szPassWord[DH_USER_NAME_LENGTH_EX];  // pass word for log in device(it need be filled when modify device ip)
	unsigned short		nHttpPort;							 // HTTP server port
	WORD                wVideoInputCh;                       // count of video input channel
	WORD                wRemoteVideoInputCh;                 // count of remote video input
	WORD                wVideoOutputCh;                      // count of video output channel 
	WORD                wAlarmInputCh;                       // count of alarm input
	WORD                wAlarmOutputCh;                      // count of alarm output
	char                cReserved[244];
}DEVICE_NET_INFO_EX;

// Corresponding to CLIENT_SearchDevicesByIPs
typedef struct
{
	DWORD               dwSize;                          // struct size 
	int                 nIpNum;                          // the IPs number for search
	char                szIP[DH_MAX_SAERCH_IP_NUM][64];  // the IPs for search
}DEVICE_IP_SEARCH_INFO;

// struct SNMP config struct
typedef struct tagNET_DEVICE_SEARCH_PARAM
{
    DWORD       dwSize;
    BOOL        bUseDefault;
    WORD        wBroadcastLocalPort;
    WORD        wBroadcastRemotePort;
    WORD        wMulticastRemotePort;
}NET_DEVICE_SEARCH_PARAM;
typedef struct
{
	BOOL                bEnable;                                // SNMP enable
	int                 iSNMPPort;                              // SNMP port
	char                szReadCommon[DH_MAX_SNMP_COMMON_LEN];   // read common
	char                szWriteCommon[DH_MAX_SNMP_COMMON_LEN];  // write common
	char                szTrapServer[64];                       // trap address
	int                 iTrapPort;                              // trap port
	BYTE				bSNMPV1;								// SNMP V1 enable
	BYTE				bSNMPV2;								// SNMP V2 enable
	BYTE				bSNMPV3;								// SNMP V3 enable
	char                szReserve[125];
}DHDEV_NET_SNMP_CFG;

// ISCSI server
typedef struct
{
	char				szServerName[32];				// name
	union
	{ 
		BYTE	c[4];
		WORD	s[2];
		DWORD	l;
	}					stuIP;							// IP
	int					nPort;							// port
	char				szUserName[32];					// username
	char				szPassword[32];					// password
	BOOL				bAnonymous;						// anonymous
}DHDEV_ISCSI_SERVER;

// ISCSI config
typedef struct
{
	BOOL				bEnable;						// enable
	DHDEV_ISCSI_SERVER	stuServer;						// server
	char				szRemotePath[240];				// remote path
	BYTE				reserved[256];
}DHDEV_ISCSI_CFG;

//-------------------------------Alarm Property ---------------------------------

// PTZ Activation
typedef struct 
{
	int					iType;                          // 0-None,1-Preset,2-Tour,3-Pattern
	int					iValue;
} DH_PTZ_LINK, *LPDH_PTZ_LINK;

//Alarm activation structure 
typedef struct 
{
	/* Message process way. There can be several process ways.
	 * 0x00000001 -  Alarm upload
	 * 0x00000002 -  Activation alarm 
	 * 0x00000004 -  PTZ activation
	 * 0x00000008 -  Send out mail
	 * 0x00000010 -  Local tour
	 * 0x00000020 -  Local prompt
	 * 0x00000040 -  Alarm output
	 * 0x00000080 - Ftp upload
	 * 0x00000100 -  Buzzer 
	 * 0x00000200 -  Video prompt
	 * 0x00000400 -  Snapshot
	*/

	/* The process way current alarm supported. Use bit mask to represent */
	DWORD				dwActionMask;

	/* Use bit mask to represent. The parameters of detailed operation are in its correspond configuration */
	DWORD				dwActionFlag;
	
	/* The output channel the alarm activated. The output alarm activated. 1 means activate current output. */ 
	BYTE				byRelAlarmOut[DH_MAX_ALARMOUT_NUM];
	DWORD				dwDuration;				/*  Alarm duration time*/

	/* Activation record */
	BYTE				byRecordChannel[DH_MAX_VIDEO_IN_NUM]; /*  The record channel alarm activated. 1 means activate current channel. */
	DWORD				dwRecLatch;				/*  Record duration time */

	/* Snapshot channel  */
	BYTE				bySnap[DH_MAX_VIDEO_IN_NUM];
	/* Tour channel */
	BYTE				byTour[DH_MAX_VIDEO_IN_NUM];

	/* PTZ activation  */
	DH_PTZ_LINK			struPtzLink[DH_MAX_VIDEO_IN_NUM];
	DWORD				dwEventLatch;			/* The latch time after activation begins. Unit is second. The value ranges from 0 to 15. Default value is 0. */
	/* The wireless output channel alarm activated.The output alarm activated. 1 means activate current output.*/ 
	BYTE				byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM];
	BYTE				bMessageToNet;
	BYTE                bMMSEn;					/* SMS Alarm enabled */
	BYTE                bySnapshotTimes;		/* the number of sheets of drawings */
	BYTE				bMatrixEn;				/*enable matrix */
	DWORD				dwMatrix;				/*matrix mask */			
	BYTE				bLog;					/*enable log */
	BYTE				bSnapshotPeriod;		/*<Snapshot frame interval. System can snapshot regularly at the interval you specify here. The snapshot amount in a period of time also has relationship with the snapshot frame rate. 0 means there is no interval, system just snapshot continuously.*/
	BYTE                byEmailType;            /*<0,picture,1,record>*/
	BYTE                byEmailMaxLength;       /*<max record length,unit:MB>*/
	BYTE                byEmailMaxTime;         /*<max time length, unit:second>*/
	BYTE				byReserved[99];     
} DH_MSG_HANDLE;

// External alarm 
typedef struct
{
	BYTE				byAlarmType;			// Annunciator type,0: normal close,1:normal open 
	BYTE				byAlarmEn;				// Enable alarm 
	BYTE				byReserved[2];						
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT]; // NSP
	DH_MSG_HANDLE		struHandle;				// Process way 
} DH_ALARMIN_CFG, *LPDHDEV_ALARMIN_CFG; 

//Motion detection alarm 
typedef struct 
{
	BYTE				byMotionEn;				// Enable motion detection alarm 
	BYTE				byReserved;
	WORD				wSenseLevel;			// Sensitivity 
	WORD				wMotionRow;				// Row amount in motion detection zones
	WORD				wMotionCol;				// Column amount in motion detection zones 
	BYTE				byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // Detection zones .Max 32*32 zones.
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struHandle;				// Process way 
} DH_MOTION_DETECT_CFG;

// Video loss alarm 
typedef struct
{
	BYTE				byAlarmEn;				// Enable video loss alarm 
	BYTE				byReserved[3];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struHandle;				// Process way
} DH_VIDEO_LOST_CFG;

// Camera masking alarm 
typedef struct
{
	BYTE				byBlindEnable;						// Enable
	BYTE				byBlindLevel;						// Sensitivity 1-6
	BYTE				byReserved[2];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struHandle;							// Process way 
} DH_BLIND_CFG;

// HDD information(External alarm )
typedef struct 
{
	BYTE				byNoDiskEn;								// Alarm when there is no HDD
	BYTE				byReserved_1[3];
	DH_TSECT			stNDSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struNDHandle;							// Process way 

	BYTE				byLowCapEn;								// Alarm when HDD capacity is low 
	BYTE				byLowerLimit;							// Capacity threshold 0-99
	BYTE				byReserved_2[2];
	DH_TSECT			stLCSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struLCHandle;							// Process way 

	BYTE				byDiskErrEn;							// HDD malfunction alarm 
	BYTE				bDiskNum;
	BYTE				byReserved_3[2];
	DH_TSECT			stEDSect[DH_N_WEEKS][DH_N_REC_TSECT];	// NSP
	DH_MSG_HANDLE		struEDHandle;							// Process way 
} DH_DISK_ALARM_CFG;

typedef struct
{
	BYTE				byEnable;
	BYTE				byReserved[3];
	DH_MSG_HANDLE		struHandle;
} DH_NETBROKEN_ALARM_CFG;

// Alarm deployment 
typedef struct
{
	DWORD dwSize;
	DH_ALARMIN_CFG 		struLocalAlmIn[DH_MAX_ALARM_IN_NUM];
	DH_ALARMIN_CFG		struNetAlmIn[DH_MAX_ALARM_IN_NUM];
	DH_MOTION_DETECT_CFG struMotion[DH_MAX_VIDEO_IN_NUM];
	DH_VIDEO_LOST_CFG	struVideoLost[DH_MAX_VIDEO_IN_NUM];
	DH_BLIND_CFG		struBlind[DH_MAX_VIDEO_IN_NUM];
	DH_DISK_ALARM_CFG	struDiskAlarm;
	DH_NETBROKEN_ALARM_CFG	struNetBrokenAlarm;
} DHDEV_ALARM_SCHEDULE;

#define DECODER_OUT_SLOTS_MAX_NUM 		16
#define DECODER_IN_SLOTS_MAX_NUM 		16

// Alarm decoder configuration
typedef struct  
{
	DWORD				dwAddr;									// Alarm decoder address
	BOOL				bEnable;								// Alarm decoder enable
	DWORD				dwOutSlots[DECODER_OUT_SLOTS_MAX_NUM];	// Now only support 8
	int					nOutSlotNum;							// Effective number of array elements.
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	DH_MSG_HANDLE		struHandle[DECODER_IN_SLOTS_MAX_NUM];	// Now only support 8
	int					nMsgHandleNum;							// Effective number of array elements.
	BYTE				bReserved[120];
} DH_ALARMDEC_CFG;

// The setup of alarm upload
typedef struct  
{
	BYTE				byEnable;						// Enable upload
	BYTE				bReserverd;						// Reserved
	WORD				wHostPort;						// Alarm center listening port 
	char				sHostIPAddr[DH_MAX_IPADDR_LEN];	// Alarm center IP
	int					nByTimeEn;						// Enable scheduled upload.Use it to upload IP or domain name to the centre.
	int					nUploadDay;						/*  Set upload date 
														"Never = 0", "Everyday = 1", "Sunday = 2", 
														"Monday = 3", Tuesday = 4", "Wednesday = 5",
														"Thursday = 6", "Friday = 7", "Saturday = 8"*/	
	int					nUploadHour;					// Set upload time ,[0~23]o'clock
	DWORD				dwReserved[300]; 				// Reserved for future development 
} ALARMCENTER_UP_CFG;

// Panorama switch alarm configuration
typedef struct __DH_PANORAMA_SWITCH_CFG 
{
	BOOL				bEnable;				// Enabled
	int					nReserved[5];			// Reserved
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	DH_MSG_HANDLE		struHandle;				// Process way
} DH_PANORAMA_SWITCH_CFG;

typedef struct __ALARM_PANORAMA_SWITCH_CFG 
{
	int					nAlarmChnNum;			// Number of alarm channels
	DH_PANORAMA_SWITCH_CFG stuPanoramaSwitch[DH_MAX_VIDEO_IN_NUM];
} ALARM_PANORAMA_SWITCH_CFG;

// Lose focus alarm configuration
typedef struct __DH_LOST_FOCUS_CFG
{
	BOOL				bEnable;				// Enabled
	int					nReserved[5];			// Reserved
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	DH_MSG_HANDLE		struHandle;				// Process way
} DH_LOST_FOCUS_CFG;

typedef struct __ALARM_LOST_FOCUS_CFG 
{
	int					nAlarmChnNum;			// Number of alarm channels
	DH_LOST_FOCUS_CFG stuLostFocus[DH_MAX_VIDEO_IN_NUM];
} ALARM_LOST_FOCUS_CFG;

// IP collision detection alarm configuration
typedef struct __ALARM_IP_COLLISION_CFG
{
	BOOL				bEnable;				// Enable
	DH_MSG_HANDLE		struHandle;				// Alarm activation
	int                 nReserved[300];			// Reserved
} ALARM_IP_COLLISION_CFG;

// MACcollision detection configuration
typedef struct __ALARM_MAC_COLLISION_CFG
{
	BOOL				bEnable;				// Enable
	DH_MSG_HANDLE		struHandle;				// Alarm activation
	int                 nReserved[300];			// Reserved
} ALARM_MAC_COLLISION_CFG;

// 232/485 com card signal info configuration
typedef struct __COM_CARD_SIGNAL_INFO
{
	WORD                wCardStartPose;          // card number start location
	WORD                wCardLenth;              // card number length
	char                cStartCharacter[32];     // start string
	char                cEndCharacter[32];       // end string
	BYTE                byReserved[28];          // reserved
}COM_CARD_SIGNAL_INFO;

// 232/485 com card  linked configuration(when the info from the com fit the configuration, it will trigger the device snap picture)
typedef struct __COM_CARD_SIGNAL_LINK_CFG
{
	COM_CARD_SIGNAL_INFO  struCardInfo;          // card info
	DH_MSG_HANDLE         struHandle;            // event link
	BYTE                  byReserved[24];        // reserved
	
}COM_CARD_SIGNAL_LINK_CFG;

//------------------------------Multiple privacy mask zones--------------------------------

// Privacy mask information
typedef struct __VIDEO_COVER_ATTR
{
	DH_RECT				rcBlock;				// Privacy mask zone coordinates
	int					nColor;					// Privacy mask color
	BYTE				bBlockType;				// Mask type;0:Black block,1: mosaic
	BYTE				bEncode;				// Encode level cover mask;1:valid,0:invalid
	BYTE				bPriview;				// Preview mask; 1:valid,0:invalid
	char				reserved[29];			// Reserved 
} VIDEO_COVER_ATTR;

// Multiple privacy mask zones 
typedef struct __DHDEV_VIDEOCOVER_CFG 
{
	DWORD				dwSize;
	char				szChannelName[DH_CHAN_NAME_LEN]; // Read-only
	BYTE				bTotalBlocks;			// The mask zones supported
	BYTE				bCoverCount;			// The mask zones have been set 
	VIDEO_COVER_ATTR	CoverBlock[DH_MAX_VIDEO_COVER_NUM]; // The mask zones 
	char				reserved[30];			// Reserved 
}DHDEV_VIDEOCOVER_CFG;

// decode policy configuration
typedef struct __DHDEV_DECODEPOLICY_CFG 
{
	int					nMinTime;				// (read only):minimal delay time(ms)
	int					nMaxTime;				// (read only):maximal delay time(ms)
	int					nDeocdeBufTime;			// device decode delay time(ms)
	
	char				reserved[128];			// reserved
}DHDEV_DECODEPOLICY_CFG;

// Device relative configuration
typedef struct __DHDEV_MACHINE_CFG 
{
	char				szMachineName[DH_MACHINE_NAME_NUM];		// Device name or SN 
	char				szMachineAddress[DH_MACHINE_NAME_NUM];	// Device location
	char				reserved[128];							// reserved
}DHDEV_MACHINE_CFG;


////////////////////////////////IPC series ////////////////////////////////

// Set wireless network information 
typedef struct 
{
	int					nEnable;				// Enable wireless
	char				szSSID[36];				// SSID
	int					nLinkMode;				// connection mode;0:auto,1:adhoc,2:Infrastructure
	int					nEncryption;			// encrypt;0:off,2:WEP64bit,3:WEP128bit, 4:WPA-PSK-TKIP, 5: WPA-PSK-CCMP
	int					nKeyType;				// 0:Hex,1:ASCII
    int					nKeyID;					// Serial number
	union
	{
		char			szKeys[4][32];			// Four group passwords
		char			szWPAKeys[128];			// when nEncryption is 4 or 5, use szWPAKeys
	};
	int					nKeyFlag;
	BYTE                byConnectedFlag;        // 0: not connect, 1: connect 
	char				reserved[11];
} DHDEV_WLAN_INFO;

// Select to use one wireless device 
typedef struct  
{
	char				szSSID[36];
	int					nLinkMode;				// Connection mode;0:adhoc,1:Infrastructure
	int 				nEncryption;			// Encrypt;0:off,2:WEP64bit,3:WEP128bit
	char				reserved[48];
} DHDEV_WLAN_DEVICE;

// The searched wireless device list 
typedef struct  
{
	DWORD				dwSize;
	BYTE				bWlanDevCount;			// The wireless devices searched 
	DHDEV_WLAN_DEVICE	lstWlanDev[DH_MAX_WLANDEVICE_NUM];
	char				reserved[255];
} DHDEV_WLAN_DEVICE_LIST;

// wireless device expended configuration
typedef struct
{
	char                szSSID[36];                         // server id
	char                szMacAddr[18];                      // mac address 
	BYTE                byApConnected;                      // connect state 0: not connect,1: connected
	BYTE                byLinkMode;                         // connect mod 0:adhoc 1:Infrastructure;
	int                 nRSSIQuality;                       // rssi quality(dbm)
	unsigned int        unApMaxBitRate;                     // max transmit speed
	BYTE                byAuthMode;                         // attestation mod:0:OPEN;1:SHARED;2:WPA;3:WPA-PSK;4:WPA2;5:WPA2-PSK;
															// 6:WPA-NONE(only use in Adhoc mode),
															// 7-11 are mix mode,choose one of them can to be connected 
															// 7:WPA-PSK | WPA2-PSK; 8:WPA | WPA2; 9:WPA | WPA-PSK;
															// 10:WPA2 | WPA2-PSK; 11:WPA | WPA-PSK |WPA2 |WPA2-PSK //12: UnKnown
	BYTE                byEncrAlgr;                         // encrypt mod 0:off; 2:WEP64bit; 3:WEP128bit; 4:WEP; 5:TKIP; 6:AES(CCMP)
															// 7: TKIP+AES( mix Mode) 8: UnKnown
	BYTE                byLinkQuality;                      // link quality 0~100(%)
    BYTE                byReserved[129];                     // Reserved 
}DHDEV_WLAN_DEVICE_EX;

// The searched wireless device expended configuration list 
typedef struct  
{
	DWORD				dwSize;
	BYTE				bWlanDevCount;			// The wireless device number searched
	DHDEV_WLAN_DEVICE_EX  lstWlanDev[DH_MAX_WLANDEVICE_NUM_EX];
	char				reserved[255];
} DHDEV_WLAN_DEVICE_LIST_EX;

// Function Test
typedef struct
{
	int                 nResult;                  // 0:success,1:failure
	BYTE                reserved[32];
} DHDEV_FUNC_TEST;

// FTP server info
typedef struct
{
	char                szServerName[32];          // server name
	char                szIp[16];                  // IP address
	int                 nPort;                     // port number
	char                szUserName[32];            // user name
	char                szPassword[32];	           // pass word
	BOOL                bAnonymity;                // whether anonymity log in 
	BYTE                byReserved[256];           // reserved
}FTP_SERVER_CFG;

// ftp server connect test
typedef struct
{
	FTP_SERVER_CFG     stuFtpServerInfo;           // ftp server info(filled by user)
	DHDEV_FUNC_TEST    stuTestResult;              // ftp server connect state
	BYTE               byReserved[64];
}DHDEV_FTP_SERVER_TEST;

// DDNS domain info
typedef struct
{

	char				szServerType[DH_MAX_SERVER_TYPE_LEN];	//server type
	char				szServerIp[DH_MAX_DOMAIN_NAME_LEN];		// server ip or domain
	DWORD				dwServerPort;			// server port
	char				szDomainName[DH_MAX_DOMAIN_NAME_LEN];	// dvr domain,such as jeckean.3322.org
	char				szUserName[DH_MAX_HOST_NAMELEN];		// username
	char				szUserPsw[DH_MAX_HOST_PSWLEN];			// password
	BYTE                byReserved[256];           // reserved
}DDNS_DOMAIN_INFO;


// DDNS domain test
typedef struct
{
	DDNS_DOMAIN_INFO   stuDomainInfo;				// DDNS domain
	DHDEV_FUNC_TEST    stuTestResult;				// test result
	char			   szMemo[128];					// test result memo
	BYTE               byReserved[64];
}DHDEV_DDNS_DOMAIN_TEST;


// hard disk's basic information
typedef struct 
{
	BYTE                byModle[32];				// model
	BYTE                bySerialNumber[32];			// serial number
	BYTE                byFirmWare[32];				// firmware no
	int                 nAtaVersion;				// ATA protocol version no
	int                 nSmartNum ;					// smart information no
	INT64				Sectors;	
	int                 nStatus;					// disk state 0-normal 1-abnormal
	int                 nReserved[33]; 
} DHDEV_DEVICE_INFO;

//smart information of harddisk,there may be many items up to more than 30????
typedef struct
{
	BYTE				byId;						// ID
	BYTE				byCurrent;					// attribute values 
	BYTE				byWorst;					// maximum error value 
	BYTE				byThreshold;				// threshold value 
	char				szName[64];					// property name
	char				szRaw[8];					// actual value
	int					nPredict;					// state
	char				reserved[128];
} DHDEV_SMART_VALUE;

//search hard disk smart information
typedef struct
{
	BYTE               nDiskNum;       // disk number
	BYTE               byRaidNO;       // Raid sub disk, 0:single disk
	BYTE               byReserved[2];  
	DHDEV_DEVICE_INFO  deviceInfo;    
	DHDEV_SMART_VALUE  smartValue[MAX_SMART_VALUE_NUM];
} DHDEV_SMART_HARDDISK;

// submodule information
typedef struct
{
	char               szModuleName[64];			//  submodule name
	char               szHardWareVersion[32];		//  submodule HardWareVersion
	char               szSoftwareVersion[32];		//  submodule SoftWareVersion
	BYTE               reserved[128]; 
} DHDEV_SUBMODELE_VALUE;

// search submodule information
typedef struct
{
	int                    nSubModuleNum;							//  nSubModuleNum
	DHDEV_SUBMODELE_VALUE  stuSubmoduleValue[MAX_SUBMODULE_NUM];	// Submodule information
	BYTE				   bReserved[256];
} DHDEV_SUBMODULE_INFO;

// Query harddisk damage ability
typedef struct
{
	BYTE                bDiskDamageLevel[DH_MAX_DISK_NUM];  // every disk's damage level
	BYTE                bReserved[128];
} DHDEV_DISKDAMAGE_INFO;

// SYSLOG remote server ability
typedef struct 
{
	char				szServerIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];	//Server IP address
	int					nServerPort;								//Server port
	BYTE				bEnable;									//Server Enable
	BYTE				bReserved[255];								//Reserved bytes
}DHDEV_SYSLOG_REMOTE_SERVER;

// Video backup config parameter
typedef struct
{
	BYTE				backupVideoFormat;							//file type to backup, 0:dav, 1:asf
	BYTE				password[6];								//password
	BYTE				reversed[505];								//reserved
}DHDEV_BACKUP_VIDEO_FORMAT;


// Auto register config parameter
typedef struct  
{
	char				szServerIp[32];			// Registration server IP ; no use it,use szServerIpEx
	int					nServerPort;			// Port number 
	BYTE                byReserved[3];          // 
	BYTE                bServerIpExEn;          // Extend Registration server IP enable, 0-not enable, 1-enable
	char				szServerIpEx[60];       // Extend Registration server IP
} DHDEV_SERVER_INFO;

typedef struct  
{
	DWORD				dwSize;
	BYTE				bServerNum;				// The max IP amount supported
	DHDEV_SERVER_INFO	lstServer[DH_MAX_REGISTER_SERVER_NUM];
	BYTE				bEnable;				// Enable
	char				szDeviceID[32];			// Device ID
	char				reserved[94];
} DHDEV_REGISTER_SERVER;

// Camera property 
typedef struct __DHDEV_CAMERA_INFO
{
	BYTE				bBrightnessEn;			// Brightness adjustable;1:adjustable,0:can not be adjusted
	BYTE				bContrastEn;			// Contrast adjustable
	BYTE				bColorEn;				// Hue adjustable
	BYTE				bGainEn;				// Gain adjustable
	BYTE				bSaturationEn;			// Saturation adjustable
	BYTE				bBacklightEn;			// Backlight compensation adjustable
	BYTE				bExposureEn;			// Exposure option adjustable
	BYTE				bColorConvEn;			// Day/night switch 
	BYTE				bAttrEn;				// Property option; 1:Enable, 0:Disable
	BYTE				bMirrorEn;				// Mirror;1:support,0:do not support 
    BYTE				bFlipEn;				// Flip;1:support,0:do not support 
	BYTE				iWhiteBalance;			// White Balance 1 Support,0 :Do not support
	BYTE				iSignalFormatMask;		// Signal format mask,Bitwise:0-Inside(Internal input) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
	BYTE				bRotate90;				// 90-degree rotation 1:support,0:do not support 
    BYTE				bLimitedAutoExposure;   // Support the time limit with automatic exposure 1:support,0:do not support 
    BYTE				bCustomManualExposure;  // support user-defined manual exposure time 1:support,0:do not support
	BYTE				bFlashAdjustEn;			// Support the flash lamp adjust
	BYTE				bNightOptions;			// Support day and night change
	BYTE                iReferenceLevel;    	// Support electric reference setting
	BYTE                bExternalSyncInput;     // Support external sync Input
	unsigned short      usMaxExposureTime;      // Max exposure time, unit:ms         
	unsigned short      usMinExposureTime;      // Min exposure time, unit:ms
	BYTE                bWideDynamicRange;      // Wide dynamic range,0-present not support,2~n max supported range value
	BYTE                bDoubleShutter;         // Double Shutter
	BYTE				byExposureCompensation; // 1 support, 0 not support
	BYTE				bRev[109];				// reserved 
} DHDEV_CAMERA_INFO;

// Special configuration for night,will automatically switch to night configuration when low light
typedef struct __DHDEV_NIGHTOPTIONS 
{
	BYTE  bEnable;								// 0-Do not switch,1-Switch 
												// Roughly sunrise and sunset time, before sunrise or after sunset, will use a special configuration for night.
												// 00:00:00 ~23:59:59
	BYTE  bSunriseHour;
	BYTE  bSunriseMinute;
	BYTE  bSunriseSecond;
	BYTE  bSunsetHour;
	BYTE  bSunsetMinute;
	BYTE  bSunsetSecond;  
	BYTE  bWhiteBalance ;						// White balance  0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night 7: Custom
	BYTE  bGainRed;								// Red gain adjustment, white balance to "Custom" mode will effect 0~100
	BYTE  bGainBlue;							// Green gain adjustment, white balance to "Custom" mode will effect 0~100
	BYTE  bGainGreen;							// Blue gain adjustment, white balance to "Custom" mode will effect 0~100
	BYTE  bGain;								// 0~100
	BYTE  bGainAuto;							// 0-Without auto gain 1-Auto gain
	BYTE  bBrightnessThreshold ;				// Brightness value 0~100
	BYTE  ReferenceLevel;                       // electric value 0~100   
	BYTE  bExposureSpeed;						// Range depends on the device capability: 0-Auto Exposure  1~n-1-manual exposure level;  n-Auto Exposure with time limit;  n+1-manual exposure customized time (n means exposure level)
	float ExposureValue1;						// Lower limit of automatic exposure time or customized manual exposure time, in milliseconds, value 0.1ms ~ 80ms
	float ExposureValue2;						// Automatic exposure time limit, in milliseconds, value 0.1ms ~ 80ms
	BYTE  bAutoApertureEnable;                  // Auto Aperture Enable,1:open,0:close
	BYTE  bWideDynamicRange;                    // wide dynamic value, it depends on max support value
	WORD  wNightSyncValue;						// night sync 0~360
	WORD  wNightSyncValueMillValue;             // night sync mill value 0~999
	BYTE res[10];								// Reserve
} DHDEV_NIGHTOPTIONS;

// camera attribute configration
typedef struct __DHDEV_CAMERA_CFG 
{ 
	DWORD				dwSize;
	BYTE				bExposure;				// Exposure mode;1-9:Manual exposure level  ,0: Auto exposure 
	BYTE				bBacklight;				// Backlight compensation:3:High,2:Medium,1:Low,0:close
	BYTE				bAutoColor2BW;			// Day/night mode;2:Open,1:Auto,0:Close
	BYTE				bMirror;				// Mirror;1:Open,0:Close
	BYTE				bFlip;					// Flip;1:Open,0:Close  support;0 :do not support 
	BYTE				bLensEn;				// the capacity of Auto Iris function 1:support;0 :do not support
	BYTE				bLensFunction;			// Auto aperture function: 1:Enable aperture  ;0: Disable aperture  
	BYTE				bWhiteBalance;			// White Balance 0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night
	BYTE				bSignalFormat;			// Signal format 0-Inside(Internal input) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
	BYTE				bRotate90;				// 0-Not rotating,1-90 degrees clockwise,2-90 degrees counterclockwise
	BYTE                bReferenceLevel;        // electric value 0~100  
	BYTE                byReserve;              // Reserved
	float				ExposureValue1;			// Auto exposure or manual exposure limit custom time,Milliseconds(0.1ms~80ms)
	float				ExposureValue2;			// Auto exposure limit,Milliseconds(0.1ms~80ms)
	DHDEV_NIGHTOPTIONS	stuNightOptions;		// Configuration parameter options for night 
	BYTE				bGainRed;				// Red gain adjustment, effective when white balance to "Custom" mode,  0 ~ 100
	BYTE				bGainBlue;				// Green gain adjustment, effective when white balance to "Custom" mode,  0 ~ 100
	BYTE				bGainGreen;				// Blue gain adjustment, effective when white balance to "Custom" mode,  0 ~ 100
	BYTE				bFlashMode;				// Flash mode,0-close,1-always,2-auto 
	BYTE				bFlashValue;			// Flash work values,  0-0us, 1-64us, 2-128us,...15-960us
	BYTE				bFlashPole;				// Flash trigger mode 0 - low level 1 - high level
	BYTE                bExternalSyncPhase;     // External single input
	BYTE                bFlashInitValue;        // Flash brightness prevlue, 0~100
	WORD                wExternalSyncValue ;    // External value 0~360
	WORD                wExternalSyncValueMillValue; //  External SyncValue Mill Value0~999
	BYTE                bWideDynamicRange;           // wide dynamic range, it depends on max support value
	BYTE				byExposureCompensation;		// default compensation value,default is 7,range[0~14]
	char				bRev[54];				// Reserved
} DHDEV_CAMERA_CFG;

#define ALARM_MAX_NAME 64
// (wireless)IR alarm setup
typedef struct
{
	BOOL				bEnable;				// Enable alarm input
	char				szAlarmName[DH_MAX_ALARM_NAME];	// Alarm input name
	int					nAlarmInPattern;		// Annunciator input wave
	int					nAlarmOutPattern;		// Annunciator output wave
	char				szAlarmInAddress[DH_MAX_ALARM_NAME];// Alarm input address
	int					nSensorType;			// External device sensor type normal open or normal close 
	int					nDefendEfectTime;		// Deploy and cancel latch time. The alarm input becomes activated after the specified time.
	int					nDefendAreaType;		// Defend area 
	int					nAlarmSmoothTime;		// Alarm smooth time:system ignores the second alarm if one alarm inputs in two times. 
	char				reserved[128];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];
	DH_MSG_HANDLE		struHandle;				// Process way 
} DH_INFRARED_INFO;

// Wireless remote control setup 
typedef struct 
{
	BYTE				address[ALARM_MAX_NAME];// Remote control address
	BYTE				name[ALARM_MAX_NAME];	// Remote control name
	BYTE				reserved[32];			// Reserved string 
} DH_WI_CONFIG_ROBOT;

// Wireless alarm output setup 
typedef struct 
{
	BYTE				address[ALARM_MAX_NAME];// Alarm output address
	BYTE				name[ALARM_MAX_NAME];	// Alarm output name
	BYTE				reserved[32];			// Reserved string 
} DH_WI_CONFIG_ALARM_OUT;

typedef struct  
{
	DWORD				dwSize;
	BYTE				bAlarmInNum;			// Wireless alarm input amount 
	BYTE				bAlarmOutNum;			// Wireless alarm output amount 
	DH_WI_CONFIG_ALARM_OUT AlarmOutAddr[16];	// Alarm output address
	BYTE				bRobotNum;				// Remote control amount
	DH_WI_CONFIG_ROBOT RobotAddr[16];			// Remote control address 
	DH_INFRARED_INFO	InfraredAlarm[16];
	char				reserved[256];
} DH_INFRARED_CFG;

// New audio detection alarm information 
typedef struct
{
	int					channel;				// Alarm channel number
	int					alarmType;				// Alarm type;0:Volume value is too low ,1:Volume value is too high. 
	unsigned int		volume;					// Volume
	BYTE                byState;                // volume alarm state, 0: alarm appear, 1: alarm disappear
	char				reserved[255];
} NET_NEW_SOUND_ALARM_STATE;

typedef struct  
{
	int					channelcount;			// Alarm channel amount 
	NET_NEW_SOUND_ALARM_STATE SoundAlarmInfo[DH_MAX_ALARM_IN_NUM];
} DH_NEW_SOUND_ALARM_STATE;

// Snapshot function property structure 
typedef struct 
{
	int					nChannelNum;			// Channel amount 
	DWORD				dwVideoStandardMask;	// Resolution(Bit). Please refer to enumeration CAPTURE_SIZE						
	int					nFramesCount;			// Valid length of Frequency[128] array
	char				Frames[128];			// Frame rate(value) 
												// -25:1f/25s;-24:1f/24s;-23:1f/23s;-22:1f/23s
												// ?-?-
												// 0: invalid;1:1f/s;2:2f/s;3:13f/s
												// 4:4f/s;5:5f/s;17:17f/s;18:18f/s
												// 19:19f/s;20:20f/s
												// ?-?-
												// 25: 25f/s
	int					nSnapModeCount;			// valid length of SnapMode[16] array
	char				SnapMode[16];			// (value)0:activate scheduled snapshot,1:Manually activate snapshot
	int					nPicFormatCount;		// Valid length of Format[16] array 
	char 				PictureFormat[16];		// (Value)0:BMP format,1:JPG format
	int					nPicQualityCount;		// valid length of Quality[32] array
	char 				PictureQuality[32];		// value
												// 100:Image quality 100%;80:Image quality 80%;60:Image quality60%
												// 50:Image quality50%;30:Image quality30%;10:Image quality10%
	char 				nReserved[128];			// Reserved
} DH_QUERY_SNAP_INFO;

typedef struct 
{
	int					nChannelCount;			// Channel amount 
	DH_QUERY_SNAP_INFO  stuSnap[DH_MAX_CHANNUM];
} DH_SNAP_ATTR_EN;


/* IP Filtering configuration */
#define DH_IPIFILTER_NUM			200			// IP
#define DH_IPIFILTER_NUM_EX			512			// IP

// IP Information
typedef struct 
{
	DWORD				dwIPNum;				// IP count
	char				SZIP[DH_IPIFILTER_NUM][DH_MAX_IPADDR_LEN]; // IP
	char				byReserve[32];			// Reserved
} IPIFILTER_INFO;

// IP Filtering configuration
typedef struct
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwType;					// The current list type;0:White List 1:Blacklist(The device can enable only one type of list)
	IPIFILTER_INFO		BannedIP;				// Black list
	IPIFILTER_INFO		TrustIP;				// Trusted sites
	char				byReserve[256];			// Reserved
} DHDEV_IPIFILTER_CFG;

// IP Information extended
typedef struct 
{
	DWORD				dwIPNum;				// IP count
	char				SZIP[DH_IPIFILTER_NUM_EX][DH_MAX_IPADDR_LEN]; // IP
	char				byReserve[32];			// Reserved
} IPIFILTER_INFO_EX;

// IP Filtering extended configuration
typedef struct
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwType;					// The current list type;0:White List 1:Blacklist(The device can enable only one type of list) can only user one kind of device
	IPIFILTER_INFO_EX		BannedIP;			// Black list
	IPIFILTER_INFO_EX		TrustIP;			// Trusted sites
	char				byReserve[256];			// Reserved
} DHDEV_IPIFILTER_CFG_EX;

/* MAC filter configuration */
#define DH_MACFILTER_NUM			512			// MAC

// MAC info
typedef struct 
{
	DWORD				dwSize;					// struct size
	DWORD				dwMacNum;				// MAC count
	char				szMac[DH_MACFILTER_NUM][DH_MACADDR_LEN]; // MAC
} MACFILTER_INFO;
// MAC filter configuration
typedef struct
{
	DWORD					dwSize;				// struct size
	DWORD					dwEnable;			// enable
	DWORD					dwType;				// current list type,0:white list, 1:blacklist (The device can enable only one type of list) can only user one kind of device
	MACFILTER_INFO			stuBannedMac;		// black list Mac
	MACFILTER_INFO			stuTrustMac;		// white list Mac
} DHDEV_MACFILTER_CFG;

/* MAC,IP filter configuration */
#define DH_MACIPFILTER_NUM			512			// MAC,IP
// MAC, IP filter configuration info
typedef struct
{
	DWORD	dwSize;					// struct size
	char	szMac[DH_MACADDR_LEN];	// mac
	char	szIp[DH_MAX_IPADDR_LEN];// ip
}MACIP_INFO;

// MAC,IP filter configuration
typedef struct
{
	DWORD					dwSize;								// struct size
	DWORD					dwEnable;							// enable
	DWORD					dwType;								// The current list type;0:White List 1:Blacklist(The device can enable only one type of list) can only user one kind of device
	DWORD					dwBannedMacIpNum;					// black list MAC,IP count (MAC,IP one to one)
	MACIP_INFO				stuBannedMacIp[DH_MACIPFILTER_NUM];	// black list Mac,IP
	DWORD					dwTrustMacIpNum;			// white list MAC,IP count(MAC,IP one to one)
	MACIP_INFO				stuTrustMacIp[DH_MACIPFILTER_NUM];	// white list Mac,IP
} DHDEV_MACIPFILTER_CFG;
typedef struct
{
	int                nCardNum;                // card number
	char 	           cardInfo [DH_MAX_CARD_NUM][DH_MAX_CARDINFO_LEN]; // card info string 
	BYTE               byReserve[32];           // reserved
}DHDEV_NETCARD_CFG;

// RTSP configuration
typedef struct
{
	WORD               wPort;                  // port number(can't be the same as tcp or udp's port number)
	BYTE               byReserved[62];         // reserved
}DHDEV_RTSP_CFG;

// stream encrypt configuration
// encrypt key info
typedef struct _ENCRYPT_KEY_INFO
{
	BYTE        byEncryptEnable;       //  encrypt enable, 0: not encrypt, 1:encrypt
	BYTE        byReserved[3]; 
	union
	{
		BYTE    byDesKey[8];           // des key
		BYTE    by3DesKey[3][8];       // 3des key
		BYTE    byAesKey[32];          // aes key
		
	};
}ENCRYPT_KEY_INFO;

// encrypt algorithm
typedef struct _ALGO_PARAM_INFO
{
	WORD       wEncryptLenth;       // encrypt length, for example: wEncryptLenth = 128,the effictive encprypt key value only include byAesKey[0]~[15] in the  ENCRYPT_KEY_INFO struct
									// when the encrypt algorithm is AES,it only support 3 kind length such as 128,192,256
									// when the encrypt algorithm is DES,it has a fixed value 64
									// when the encrypt algorithm is DES,it means the encrypt key's number(2 or 3 encrypt key)
	BYTE       byAlgoWorkMode ;     // work mode, see EM_ENCRYPT_ALOG_WORKMODE 
	BYTE       reserved[13];        // reserved
}ALGO_PARAM_INFO;

// stream encrypt configuration
typedef struct _DHEDV_STREAM_ENCRYPT
{
    BYTE                    byEncrptAlgoType;        // encrypt algorithm type:00: AES,01:DES,02: 3DES
    BYTE                    byReserved1[3];
    ALGO_PARAM_INFO         stuEncrptAlgoparam;      // encrypt algorithm param
    ENCRYPT_KEY_INFO        stuEncryptKeys[32];      // each channel's encrypt key's info
	BYTE					byEncrptPlanEnable;		 // encrpt plan enable
	BYTE					byReserved3[3];
	NET_TIME				stuPreTime;				 // encrpt plan beginning time
	BYTE					reserved2[1360];
}DHEDV_STREAM_ENCRYPT;

// limit stream configuration
typedef struct _DHDEV_BIT_RATE
{
	DWORD                   nExpectCodeRate;          // limit stream (kps)
	BYTE                    byReserved[64];           // reserved
}DHDEV_LIMIT_BIT_RATE;
// custom configuration
typedef struct _DHDEV_CUSTOM_CFG
{
	char                   szData[1024];            // custom configuration information
	char                   reserved[3072];          // reserved
}DHDEV_CUSTOM_CFG;

/*audio talk configuration*/
typedef struct
{
	DWORD				dwSize;
	int					nCompression;			// Compression type,value,refer to DH_TALK_CODING_TYPE,please set the compression type according to the mode the device supports
	int					nMode;					// Encode mode, value, 0 means not support the compression type
												// Set the responding type according to compression type
												// like AMR, please refer to EM_ARM_ENCODE_MODE
	char				byReserve[256];			// Reserved
} DHDEV_TALK_ENCODE_CFG;

// According to the mobile function
// (Event triggers message)MMS Configuration Structure
typedef struct
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwReceiverNum;			// Receiver amount
	char				SZReceiver[DH_MMS_RECEIVER_NUM][32];	// Receiver,normally cellphone
    BYTE                byType;					// Message type 0:MMS;1:SMS
	char                SZTitle[32];			// Message title
	char				byReserve[223];			// Reserved
} DHDEV_MMS_CFG;

// (Message triggers wireless connection configuration)
typedef struct  
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwSenderNum;			// Sender amount
	char				SZSender[DH_MMS_SMSACTIVATION_NUM][32];	// Sender, normally the cellphone number
 	char				byReserve[256];			// Reserved
}DHDEV_SMSACTIVATION_CFG;

// (Dailing triggers the wireless connection)
typedef struct  
{
	DWORD				dwSize;
	DWORD				dwEnable;				// Enable
	DWORD				dwCallerNum;			// Sender amount
	char				SZCaller[DH_MMS_DIALINACTIVATION_NUM][32];	// Sender, normally the cellphone
 	char				byReserve[256];			// Reserved
}DHDEV_DIALINACTIVATION_CFG;
// Above is with the mobile phone functions


// Wireless network signal strength structure
typedef struct
{
	DWORD				dwSize;
	DWORD				dwTDSCDMA;				// TD-SCDMA strength,range:0-100
	DWORD				dwWCDMA;				// WCDMA strength,range:0-100
	DWORD				dwCDMA1x;				// CDMA1x strength,range:0-100
	DWORD				dwEDGE;					// EDGE strength,range:0-100
	DWORD				dwEVDO;					// EVDO strength,range:0-100
	int					nCurrentType;			// Current type
												// 0	The device can't support this
												// 1    TD_SCDMA
												// 2	WCDMA
												// 3	CDMA_1x
												// 4	EDGE
												// 5	EVDO
                                                    // 6 TD-LTE
    DWORD               dwTDLTE;                    // TD-LTE Strength¡ê?Range:0:100
	char				byReserve[248];			// Reserved
} DHDEV_WIRELESS_RSS_INFO;

typedef struct _DHDEV_SIP_CFG
{
	BOOL				bUnregOnBoot;			//Unregister on Reboot
	char				szAccoutName[64];		//Account Name
	char				szSIPServer[128];		//SIP Server
	char				szOutBoundProxy[128];	//Outbound Proxy
	DWORD				dwSIPUsrID;				//SIP User ID
	DWORD				dwAuthID;				//Authenticate ID
	char				szAuthPsw[64];			//Authenticate Password
	char				szSTUNServer[128];		//STUN Server
	DWORD				dwRegExp;				//Registration Expiration
	DWORD				dwLocalSIPPort;			//Local SIP Port
	DWORD				dwLocalRTPPort;			//Local RTP Port
	BOOL				bEnable;				// Enable
	char				szNotifyID[128];        // Notify ID
	NET_TIME			stuRegTime;             // register time, read only 
	BYTE				bReserved[868];		    //reserved
} DHDEV_SIP_CFG;

typedef struct _DHDEV_SIP_STATE
{
	int					nStatusNum;				//SIP state number 
	BYTE				byStatus[64];           //0:on line,1:off line,2:invalid sip,3:registering,4:talking
	BYTE				bReserved[64];		    //reserved
}DHDEV_SIP_STATE;

typedef struct _DHDEV_HARDKEY_STATE
{
	BOOL				bState;                 // 0:Hard Key disconnect, 1:Hard Key connect
	BYTE				bReserved[64];          // reserved
}DHDEV_HARDKEY_STATE;

typedef struct _DHDEV_ISCSI_PATHLIST
{
	int					nCount;
	char				szPaths[DH_MAX_ISCSI_PATH_NUM][MAX_PATH_STOR];	// remote path
} DHDEV_ISCSI_PATHLIST;

// wifi capability country
typedef struct _DHDEV_WIFI_ROUTE_CAP_COUNTRY
{
	char				szCountry[32];			// country
	int					nValidChnNum;			// valid channel number
	int					nValideChannels[32];	// valid channel array
	char				reserved[64];			// reserved
} DHDEV_WIFI_ROUTE_CAP_COUNTRY;

typedef struct _DHDEV_WIFI_ROUTE_CAP
{
	int					nCountryNum;				// country number
	DHDEV_WIFI_ROUTE_CAP_COUNTRY stuCountry[256];	// country config
	char				reserved[256];				// reserved
} DHDEV_WIFI_ROUTE_CAP;

//  monitor info
typedef struct _MONITOR_INFO
{
	int					nPresetObjectNum;        // preset object number
	int					nActualObjectNum;        // actual object number
	char				reserved[64]; 
}MONITOR_INFO;

typedef struct _DHDEV_MONITOR_INFO
{
	int					nChannelNumber;
	MONITOR_INFO		stMonitorInfo[64];			//  monitor info
	char				reserved[128];
}DHDEV_MONITOR_INFO;

//Multi Channel Preview Playback Segmentation Ability
typedef struct tagNET_MULTIPLAYBACK_SPLIT_CAP
{
    DWORD            dwSize;
    int              nSliptMode[DH_MAX_MULTIPLAYBACK_SPLIT_NUM]; // Support segmentation Mode  
    int              nModeNumber;       
}NET_MULTIPLAYBACK_SPLIT_CAP;

/***************************** PTZ preset configuration ***********************************/
typedef struct _POINTEANBLE
{
	BYTE				bPoint;					// Preset range[1,80], invalid setting is 0.
	BYTE				bEnable;				// Valid or not,0 invalid,1 valid
	BYTE				bReserved[2];
} POINTEANBLE;

typedef struct _POINTCFG
{
	char				szIP[DH_MAX_IPADDR_LEN];// ip
	int					nPort;					// Port	
	POINTEANBLE			stuPointEnable[80];		// Preset enable
	BYTE				bReserved[256];
}POINTCFG;

typedef struct _DHDEV_POINT_CFG
{
	int					nSupportNum;			//Read-only parameter, shall return to sdk when set, it means supported pre-set number
	POINTCFG			stuPointCfg[16];		// 2D config means point info.
	BYTE				bReserved[256];			// Reserved
}DHDEV_POINT_CFG;
////////////////////////////////Mobile DVR supported////////////////////////////////

// GPS information(Mobile device)
typedef struct _GPS_Info
{
    NET_TIME			revTime;				// position time 
	char				DvrSerial[50];			// Device serial number
    double				longitude;				// Longitude
    double				latidude;				// Latitude 
    double				height;					// Height(meter)
    double				angle;					// Angle(The north pole is the original point and clockwise is +)
    double				speed;					// Speed(Kilometer/hour)
    WORD				starCount;				// Starcount
    BOOL				antennaState;			// Antenna status(true=good,false =bad)
    BOOL				orientationState;		// Orientation status (true=position,false = no position )
} GPS_Info,*LPGPS_Info;

// alarm state info
typedef struct 
{
	int                nAlarmCount;             // alarm count
	int                nAlarmState[128];        // alarm state
	BYTE               byRserved[128];          // reserved
}ALARM_STATE_INFO;

// Snapshot parameter structure 
typedef struct _snap_param
{
	unsigned int		Channel;				// Snapshot channel
	unsigned int		Quality;				// Image quality:level 1 to level 6
	unsigned int		ImageSize;				// Video size;0:QCIF,1:CIF,2:D1
	unsigned int		mode;					// Snapshot mode;0:request one frame,1:send out requestion regularly,2: Request consecutively
	unsigned int		InterSnap;				// Time unit is second.If mode=1, it means send out requestion regularly. The time is valid.
	unsigned int		CmdSerial;				// Request serial number
	unsigned int		Reserved[4];
} SNAP_PARAMS, *LPSNAP_PARAMS;

// Snapshot function setup 
typedef struct 
{
	DWORD				dwSize;
	BYTE				bTimingEnable;				// Schedule snapshot button(The alarm snapshot button is in alarm activation configuration)
	BYTE                bPicIntervalHour;           // timing snapshot interval hour
	short	            PicTimeInterval;			// The time intervals of timing capture (s). At present, the capture device supports the largest time interval is 30 minutes 
	DH_VIDEOENC_OPT		struSnapEnc[SNAP_TYP_NUM]; // Snapshot encode setup. The resolution, video quality, frame rate setup and fram rate are all negative. It means the snapshot times in each second. 
} DHDEV_SNAP_CFG;

// snap function extern configuration
typedef struct 
{
	DWORD				dwSize;
	BYTE				bTimingEnable;				// timing diagram switch(in tach of the alarm configuration)
	BYTE                bPicIntervalHour;           // the number of hours interval
	short	            PicTimeInterval;			// time interval(s),the biggest capture device support interval 30min now                        
	DH_VIDEOENC_OPT		struSnapEnc[SNAP_TYP_NUM];  // snap encode configuration,support resolution ,image quality and frame rate setting,frame rate is negative,say for a second to grasp figure number
	DWORD               dwTrigPicIntervalSecond;    // 
	BYTE                byRserved[256];             // reserved
} DHDEV_SNAP_CFG_EX;
//wifi state of car device
typedef struct  
{
	char	szSSID[128];							//SSID
	BOOL	bEnable;								//If enable wifi function, 0:Disable 1:Enable
	int		nSafeType;								//Verify type
													//0:OPEN 
													//1:RESTRICTE
													//2:WEP
													//3:WPA
													//4:WPA2
													//5:WPA-PSK
													//6:WPA2-PSK
	int		nEncryprion;							//Encryption method
													//0:OPEN
													//1:TKIP
													//2:WEP
													//3:AES
													//4:NONE(without verify)
													//5:AUTO
	                                                //6:SHARED
	int		nStrength;								//AP site signal
	char	szHostIP[128];							//host address
	char	szHostNetmask[128];						//host mask
	char	szHostGateway[128];						//host gate  way
	int		nPriority;								//Priority,(1-32)
	int     nEnDHCP;                                //0:disable 1:enable(default value is 1)
	BYTE	bReserved[1016];
} DHDEV_VEHICLE_WIFI_STATE;

typedef struct
{
	char	szSSID[128];							//SSID
	int		nPriority;								//Priority,(1-32)
	int		nSafeType;								//Verify type
													//0:OPEN 
													//1:RESTRICTE
													//2:WEP
													//3:WPA
													//4:WPA2
													//5:WPA-PSK
													//6:WPA2-PSK
	int		nEncryprion;							//Encryption method
													//0:OPEN
													//1:TKIP
													//2:WEP
													//3:AES
													//4:NONE(No verify)
													//5:AUTO
	                                                //6:SHARED
	char	szKey[128];								//Connection key
	char	szHostIP[128];							//Host address
	char	szHostNetmask[128];						//Host mask
	char	szHostGateway[128];						//Host gateway
	int     nEnDHCP;                                //0:disable 1:enable(default value is 1)
	BYTE    byKeyIndex;                             //Verify index of WEP,0:no support,1-4 is index
	BYTE	bReserved[1019];
} DHDEV_VEHICLE_WIFI_CONFIG;
typedef struct
{
	char    szSSID[128];                            // SSID   
	BYTE    bReserved[256];                         // reserved
}WIFI_CONNECT;
// IP modify configuration
typedef struct __DHCTRL_IPMODIFY_PARAM
{
	int                 nStructSize;
	char				szRemoteIP[DH_MAX_IPADDR_OR_DOMAIN_LEN];		// device IP
	char				szSubmask[DH_MAX_IPADDR_LEN];	                // submask
	char				szGateway[DH_MAX_IPADDR_OR_DOMAIN_LEN];	        // gatway
	char				szMac[DH_MACADDR_LEN];			                // MAC addr
	char				szDeviceType[DH_DEV_TYPE_LEN];	                // device type
}DHCTRL_IPMODIFY_PARAM;

typedef struct 
{
	BOOL	bIsScan;								//0:Not scan wifi (Manually added), 1: scanned wifi
	char	szSSID[128];							//SSID
	int		nSafeType;								//Verify type
													//0:OPEN 
													//1:RESTRICTE
													//2:WEP
													//3:WPA
													//4:WPA2
													//5:WPA-PSK
													//6:WPA2-PSK
	int		nEncryprion;							//Encryption method
													//0:OPEN
													//1:TKIP
													//2:WEP
													//3:AES
													//4:NONE(No verify)	
													//5:AUTO
	                                                //6:SHARED
	char	szKey[128];								//Connection key
	int		nStrength;								//AP site signal
	int		nMaxBitRate;							//AP site maximum transmission rate, with units, read-only
	int		nIsCnnted;								//If success connect read-only
	int		nIsSaved;								//If save read-only
	int		nPriority;								//Priority,(1-32)
	char	szHostIP[128];							//Host address
	char	szHostNetmask[128];						//Host network mask
	char	szHostGateway[128];						//Host gateway
	int		nWifiFreq;								//Radio frequency, using channel logo
	int     nEnDHCP;                                //0:disable 1:enable(default value is 1)
	BYTE    byKeyIndex;                             //Verify index of WEP,0:no support,1-4 is index
	BYTE	bReserved[1019];
}DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG;

typedef struct 
{
	BOOL	bEnable;								//if enable wifi, 0:disable, 1:enable
	int		nWifiApNum;								// Effective number of structure:DHDEV_VEHICLE_WIFI_AP_CFG 
	DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG struWifiAp[64];//Single WIFI AP configration
	int	nReserved[512];								//reserved
}DHDEV_VEHICLE_WIFI_AP_CFG;

typedef struct  
{	
	BOOL   bEnable;									//to enable wift, 0:disable 1:enable
	int    nRetWifiApNum;							//get number of DHDEV_VEHICLE_WIFI_AP_CFG
	int    nMaxWifiApNum;							//apply number of DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG
	DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG* pWifiAp;		//a WIFI AP configuration
	int nReserved[512];								//reserved
}DHDEV_VEHICLE_WIFI_AP_CFG_EX;
// GPS log structure
typedef struct _DH_DEVICE_GPS_LOG_ITEM
{
	DHDEVTIME       stuDevTime;             // device time  
	DWORD		    dwLatidude;				// Longitude(0-180 degree)north Longitude 30.183382 = (30.183382 + 90) * 100000 = 120183382
	DWORD		    dwLongitude;			// Latitude(0-360 degree)east Latitude 120.178274 =(120.178274 + 180) * 100000 = 300178274
	DWORD           dwSpeed;                // speed,dwSpeed/1000*1.852km/h
	DWORD           dwHight;                // hight,m
	DWORD           dwAngle;                // direction,0~360,the north is it's origin, clockwise
	DHDEVTIME       stuGpsTime;             // GPS time 
	BYTE            bAntStatus; 		    // GPS antenna state,0 means good;!=0 meams there has some exception 
	BYTE            bOriStatus; 			// orientation state, != 0 means orientation sucess;
	BYTE            bSatCount; 				// satellite count
	BYTE            bGPSStatus; 			// GPS state,0:not orientation, 1:non differential position information 2:differential position information
	DWORD           dwTemp;                 // temperature(centigrade),if real value is 30.0 centigrade,this param will be valued as 30000
	DWORD           dwHumidity;             // humidity(%),if real value is 30.0%,this param will be valued as 30000
	BYTE            bReserved[24];          // reserved
    
}DH_DEVICE_GPS_LOG_ITEM;

// query GPS param
typedef struct _QUERY_GPS_LOG_PARAM
{
	NET_TIME			stuStartTime;			// start time
	NET_TIME			stuEndTime;				// end time
	int					nStartNum;				// start index,the first time to query an be valued with 0
	BYTE				bReserved[20];
} QUERY_GPS_LOG_PARAM;

typedef struct _GPS_TEMP_HUMIDITY_INFO
{
	double              dTemperature;          // temperature(centigrade),if real value is 30.0 centigrade,this param will be valued as 30000
	double              dHumidity;             // humidity(%),if real value is 30.0%,this param will be valued as 30000
	BYTE                bReserved[128];        // reserved
}GPS_TEMP_HUMIDITY_INFO;

// enclosure type
typedef enum
{
	ENCLOSURE_LIMITSPEED = 0x01,				// speed limit
	ENCLOSURE_DRIVEALLOW = 0x02,				// drive allow
	ENCLOSURE_FORBIDDRIVE = 0x04,				// forbind drive
	ENCLOSURE_LOADGOODS = 0x08,					// load goods
	ENCLOSURE_UPLOADGOODS = 0x10,				// upload goods
}ENCLOSURE_TYPE;

typedef enum
{
	 ENCLOSURE_ALARM_DRIVEIN ,	                 // drive in
	 ENCLOSURE_ALARM_DRIVEOUT,	                 // drive out
	 ENCLOSURE_ALARM_OVERSPEED,				     // over speed
	 ENCLOSURE_ALARM_SPEEDCLEAR,				 // speed clear
}ENCLOSURE_ALARM_TYPE;

typedef struct 
{
	DWORD				dwLongitude;			// longitude
    DWORD				dwLatidude;				// latidude
}GPS_POINT;

// enclosure config
typedef struct _DHDEV_ENCLOSURE_CFG
{
	UINT				unType;                 // mask
	BYTE				bRegion[8];             // front 4 bit means country, province, city, town
	UINT				unId;                   // rect id
	UINT				unSpeedLimit;           // speed limit(km/h)
	UINT				unPointNum;             // rect point number
	GPS_POINT			stPoints[128];			// rect point info
	char          		szStationName[DH_STATION_NAME_LEN];  //station name
	BYTE				reserved[32];           // reserved
}DHDEV_ENCLOSURE_CFG;

// enclosure version config
typedef struct _DHDEV_ENCLOSURE_VERSION_CFG
{
	UINT				unType;                 // type mask,such as LIMITSPEED | DRIVEALLOW
    UINT				unVersion[32];          // version
    int					nReserved;              // reserved 
}DHDEV_ENCLOSURE_VERSION_CFG;

// enclosure alarm info
typedef struct __ALARM_ENCLOSURE_INFO
{
	int					nTypeNumber;                    // type number
	BYTE				bType[16];						// type
	int					nAlarmTypeNumber;               // alarm type number
	BYTE				bAlarmType[16];                 // alarm type
	char				szDriverId[DH_VEHICLE_DRIVERNO_LEN];  // drive id
	UINT				unEnclosureId;      	        // enclosure id
	UINT				unLimitSpeed;	                // speed limit(km/h)
	UINT				unCurrentSpeed;                 // current speed
	NET_TIME			stAlarmTime;                    // alarm time
	DWORD				dwLongitude;					// longitude
	DWORD				dwLatidude;						// latidude
	BYTE          		bOffline;                       // 0-real time 1-tofill  
	BYTE				byReserved[119];                // reserved
}ALARM_ENCLOSURE_INFO;

// RAID state
#define DH_MAX_RAID_NUM  16
typedef struct __RAID_STATE_INFO
{
	char				szName[16];					// Raid name
	BYTE				byType;						// type 1:Jbod     2:Raid0      3:Raid1     4:Raid5
	BYTE				byStatus;					// status 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
	BYTE                byReserved[2];
	int					nCntMem;					// nMember number
	int					nMember[32];				// 1,2,3,.
	int					nCapacity;					// capacity(G)
	int					nRemainSpace;				// remain space(M)
	int					nTank;						// Tank 0:main,1:tank1,2:tank2 ...
	char				reserved[32];
}RAID_STATE_INFO;

typedef struct __ALARM_RAID_INFO
{
	int              nRaidNumber;                   // RAID number
	RAID_STATE_INFO  stuRaidInfo[DH_MAX_RAID_NUM];  // RAID info
	char             reserved[128];
}ALARM_RAID_INFO;
//////////////////////////////////ATM support//////////////////////////////////

typedef struct
{
	int					Offset;					// Symbol position bit Offset
	int					Length;					// Symbol position length
	char				Key[16];				// Symbol position value 
} DH_SNIFFER_FRAMEID;

typedef struct 
{
	int					Offset;					// Symbol position bit offset 
	int					Offset2;				// It is invalid now 
	int					Length;					// The symbol position length
	int					Length2;				// It is invalid now
	char				Title[12];  			// Title value 
	char                Key[12];                // Key value
} DH_SNIFFER_CONTENT;

// Network sniffer setup 
typedef struct 
{
	DH_SNIFFER_FRAMEID	snifferFrameId;			// Each FRAME ID option
	DH_SNIFFER_CONTENT	snifferContent[DH_SNIFFER_CONTENT_NUM];	// The corresponding four sniffers in each FRAME
} DH_SNIFFER_FRAME;

// Configuration structure of each sniffer 
typedef struct
{
	char				SnifferSrcIP[DH_MAX_IPADDR_LEN];	// Sniffer source address 	
	int					SnifferSrcPort;						// Sniffer source port 
	char				SnifferDestIP[DH_MAX_IPADDR_LEN];	// Sniffer destination address 
	int					SnifferDestPort;					// Sniffer destination port 
	char				reserved[28];						// Reserved string 
	DH_SNIFFER_FRAME	snifferFrame[DH_SNIFFER_FRAMEID_NUM];// 6 FRAME options 
	int					displayPosition;					// Display position 
	int					recdChannelMask;					// Channel mask
} DH_ATM_SNIFFER_CFG;

typedef struct  
{
	DWORD				dwSize;
	DH_ATM_SNIFFER_CFG	SnifferConfig[4];
	char				reserved[256];						// Reserved string 
} DHDEV_SNIFFER_CFG;

typedef DH_SNIFFER_FRAMEID DH_SNIFFER_FRAMEID_EX;
typedef DH_SNIFFER_CONTENT DH_SNIFFER_CONTENT_EX;

// Capture network configuration
typedef struct  
{
	DH_SNIFFER_FRAMEID	snifferFrameId;								// Each FRAME ID Options
	DH_SNIFFER_CONTENT	snifferContent[DH_SNIFFER_CONTENT_NUM_EX];	// Each FRAME Corresponding to the contents of capture	
} DH_SNIFFER_FRAME_EX;

// Capture each of the corresponding structure
typedef struct
{
	char				SnifferSrcIP[DH_MAX_IPADDR_LEN];					// Source address capture		
	int					SnifferSrcPort;										// Capture source port
	char				SnifferDestIP[DH_MAX_IPADDR_LEN];					// Destination address capture
	int					SnifferDestPort;									// Capture the target port
	DH_SNIFFER_FRAME_EX	snifferFrame[DH_SNIFFER_FRAMEID_NUM];				// 6 FRAME Options
	int					displayPosition;									// Display Position
	int					recdChannelMask;									// Channel mask
	BOOL				bDateScopeEnable;									// Data sources enable
	BOOL				bProtocolEnable;									// Protocol enable
	char				szProtocolName[DH_SNIFFER_PROTOCOL_SIZE];			// Protocol name
	int					nSnifferMode;										// Capture mode; 0:net,1:232.
	int					recdChannelMask1;									// Channel submask  32 ~ 63 channel
	char				reserved[252];
} DH_ATM_SNIFFER_CFG_EX;

// Atm trade type
#define ATM_MAX_TRADE_TYPE_NAME	64
#define ATM_MAX_TRADE_NUM		1024

typedef struct __DH_ATM_QUERY_TRADE   
{
	int					nTradeTypeNum;										// number of trade types
	int					nExceptionTypeNum;									// number of exception events
	char				szSupportTradeType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];    // trade events
	char				szSupportExceptionType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];// exception events
} DH_ATM_QUERY_TRADE, *LPDH_ATM_QUERY_TRADE;

/////////////////////////////////NVD support/////////////////////////////////
#define nEncoderID nDecoderID
#define byEncoderID byDecoderID

// Decoder information
typedef struct __DEV_DECODER_INFO 
{
	char			szDecType[64];			// type
	int				nMonitorNum;			// TV number
	int				nEncoderNum;			// Decoder channel number
	BYTE			szSplitMode[16];		// Supported by a number of TV screen partition
	BYTE            bMonitorEnable[16];		// TV enable
	BYTE            bTVTipDisplay;          // TV tip display enable 0:not support 1:support.
	BYTE            reserved1[3];
	BYTE            byLayoutEnable[48];     // every channel's tip display enable
    DWORD           dwLayoutEnMask[2];      // Each decoding channel displays overlay info enable mask, from low to high support 64 channels, while dwLayoutEnMask[0] is low 32 bit
	char			reserved[4];
} DEV_DECODER_INFO, *LPDEV_DECODER_INFO;

// Encoder information
#ifndef NANJINGDITIE_NVD
// device encoder infomation
typedef struct __DEV_ENCODER_INFO 
{
	char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR 
	WORD			wDevPort;							// Port of Front-end DVR
	BYTE			bDevChnEnable;                      // Decoder channel enable
	BYTE			byDecoderID;						// The corresponding channel number decoder
	char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
	char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
	int				nDevChannel;						// Channel Number
	int				nStreamType;						// Stream type; 0:Main Stream, 1:Sub-stream
	BYTE			byConnType;							// -1: auto, 0:TCP, 1:UDP, 2:Multicast
	BYTE			byWorkMode;							// 0:Direct Connect, 1:transmit
	WORD			wListenPort;						// Listening port services, for transmit
	DWORD			dwProtoType;						// Protocol type
														// 0:compatible with each other.
														// 1:private 2nd protocol
														// 2:private system integration protocol
														// 3:private DSS protocol
														// 4:private rtsp protocol
	char			szDevName[64];						// Front device name
	BYTE            byVideoInType;                      // video source type:0-SD,1-HD		
	char			szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN];// szDevIp extended, IP or domain name
	BYTE            bySnapMode;                         // snap mode(when nStreamType==2 effective) 0:That request a frame,1:Time to send a request
	BYTE            byManuFactory;						// The target device manufacturers,See the enum struct EM_IPC_TYPE
	BYTE            byDeviceType;                       // The target device's device type,0:IPC
	BYTE            byDecodePolicy;                     // The target device's decode policy
														// 0:LatencyLevel3 1:LatencyLevel2
														// 2:LatencyLevel1 3:MiddleLevel
														// 4:FluencyLevel3 5:FluencyLevel2
														// 6:FluencyLevel1
	BYTE            bReserved[3];                          // reserved
	DWORD           dwHttpPort;                         // http port 0-65535
	DWORD           dwRtspPort;                         // RTSP port 0-65535
	char			szChnName[32];						// remote channel name
	char			reserved[4];
} DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;

#else

// encoder info
typedef struct __DEV_ENCODER_INFO 
{
	char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR 
	WORD			wDevPort;							// Port of Front-end DVR
	BYTE			bDevChnEnable;                      // Decoder channel enable
	BYTE			byDecoderID;						// The corresponding channel number decoder
	char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
	char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
	int				nDevChannel;						// Channel Number
	int				nStreamType;						// Stream type; 0:Main Stream, 1:Sub-stream
	BYTE			byConnType;							// -1: auto, 0:TCP, 1:UDP, 2:Multicast
	BYTE			byWorkMode;							// 0:Direct Connect, 1:transmit
	WORD			wListenPort;						// Listening port services, for transmit
	DWORD			dwProtoType;						// Protocol type
														// 0:compatible with each other.
														// 1:private 2nd protocol
														// 2:private system integration protocol
														// 3:private DSS protocol
														// 4:private rtsp protocol
	char			szDevName[32];						// Front device name
	BYTE            byVideoInType;                      // video source type:0-SD,1-HD		
	char			szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN];// szDevIp extended, IP or domain name
	BYTE            bySnapMode;                         // snap mode(when nStreamType==2 effective) 0:That request a frame,1:Time to send a request
	BYTE            byManuFactory;						// The target device manufacturers,See the enum struct EM_IPC_TYPE
	BYTE            byDeviceType;                       // The target device's device type,0:IPC
	BYTE            byDecodePolicy;                     // The target device's decode policy
														// 0:LatencyLevel3 1:LatencyLevel2
														// 2:LatencyLevel1 3:MiddleLevel
														// 4:FluencyLevel3 5:FluencyLevel2
														// 6:FluencyLevel1
	BYTE            bReserved[3];                          // reserved
	DWORD           dwHttpPort;                         // http port 0-65535
	DWORD           dwRtspPort;                         // RTSP port 0-65535
	char			szChnName[32];						// remote channel name
	char			szMcastIP[DH_MAX_IPADDR_LEN];       // multicast address
	char            reserved[128];
} DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;

#endif

// decoder protocol rtsp url configuration
typedef struct __DHDEV_DECODER_URL_CFG
{
	DWORD			dwSize;
	char			szMainStreamUrl[MAX_PATH];			// main stream url
	char			szExtraStreamUrl[MAX_PATH];			// extra stream url
} DHDEV_DECODER_URL_CFG;

typedef enum tagDH_SPLIT_DISPLAY_TYPE
{
    DH_SPLIT_DISPLAY_TYPE_GENERAL=1,          // Common display types
    DH_SPLIT_DISPLAY_TYPE_PIP=2,              // PIP Display Type
} DH_SPLIT_DISPLAY_TYPE;

// CLIENT_CtrlDecTVScreen Interface parameters
typedef struct tagDH_CTRL_DECTV_SCREEN
{
    DWORD           dwSize;                             // The size of the structure
    int             nSplitType;                         // Split mode
    BYTE *          pEncoderChannel;                    // Display Channel, dwDisplayType = DH_SPLIT_DISPLAY_TYPE_GENERAL when Effect, the caller can not be less than the length of the allocated memory size nSplitType
    BYTE            byGroupNo;                          // Input channel group No, when dwDisplayType = DH_SPLIT_DISPLAY_TYPE_PIP said PIP display types are valid
    char            reserved[3];                        // Reserved
    DWORD           dwDisplayType;                      // Display type; see specific display DH_SPLIT_DISPLAY_TYPE (note each mode Content is determined by the "PicInPic", the contents of each mode is displayed by the old rules NVD decision (ie DisChn field decision). Compatible, without which an item, the default display for the general category Type, i.e., "General"
}DH_CTRL_DECTV_SCREEN;

// TV parameters 
typedef struct __DEV_DECODER_TV 
{
	int				nID;								// TV ID
	BOOL			bEnable;							// Enable, open or close
	int				nSplitType;							// Partition number
	DEV_ENCODER_INFO stuDevInfo[16];					// All encoder information
	BYTE			bySupportSplit[10];					// Split mode supported
    BYTE            byGroupNo;     						// Input channel group No, when dwDisplayType = DH_SPLIT_DISPLAY_TYPE_PIP said PIP display types are valid
    char			reserved[1];                        // Reserved bytes
    DWORD           dwDisplayType;                      // Display type; see specific display DH_SPLIT_DISPLAY_TYPE (note each mode 
                                                        // Content is determined by the "PicInPic", the contents of each mode is displayed by the old rules NVD decision (ie DisChn field decision). Compatible, without which an item, the default display for the general category 
                                                        // Type, i.e., "General")

} DEV_DECODER_TV, *LPDEV_DECODER_TV;

// Screen combination of information
typedef struct __DEC_COMBIN_INFO
{
	int				nCombinID;							// Combin ID
	int             nSplitType;							// Partition number
	BYTE            bDisChn[16];						// Display channel
	char			reserved[16];
} DEC_COMBIN_INFO, *LPDEC_COMBIN_INFO;

// Tour Information
#define DEC_COMBIN_NUM 			32						// the number of tour combination
typedef struct __DEC_TOUR_COMBIN 
{
	int				nTourTime;							// Tour Interval(s)
	int				nCombinNum;							// the number of combination
	BYTE			bCombinID[DEC_COMBIN_NUM];			// Combination Table
	char			reserved1[32];
	BYTE			bCombinState[DEC_COMBIN_NUM];		// Combination option state,0:close;1:open
	char			reserved2[32];
} DEC_TOUR_COMBIN, *LPDEC_TOUR_COMBIN;

// Decoder Playback type
typedef enum __DEC_PLAYBACK_MODE
{
	Dec_By_Device_File = 0,								// Front-end DVR--By File
	Dec_By_Device_Time,									// Front-end DVR--By Time
} DEC_PLAYBACK_MODE;

// Decoder Playback control type
typedef enum __DEC_CTRL_PLAYBACK_TYPE
{
	Dec_Playback_Seek = 0,								// Drag
	Dec_Playback_Play,									// Play
	Dec_Playback_Pause,									// Pause
	Dec_Playback_Stop,									// Stop
} DEC_CTRL_PLAYBACK_TYPE;

// tour ctrol type
typedef enum __DEC_CTRL_TOUR_TYPE
{
	Dec_Tour_Stop = 0,									// stop
	Dec_Tour_Start,										// start
	Dec_Tour_Pause,										// pause
	Dec_Tour_Resume,									// resume
} DEC_CTRL_TOUR_TYPE;

// Playback by file Conditions
typedef struct __DEC_PLAYBACK_FILE_PARAM 
{
	char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR
	WORD			wDevPort;							// Port of Front-end DVR
	BYTE			bDevChnEnable;                      // Decoder channel enable
	BYTE			byDecoderID;						// The corresponding channel number
	char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
	char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
	NET_RECORDFILE_INFO stuRecordInfo;					// Record file information
	char			reserved[12];
} DEC_PLAYBACK_FILE_PARAM, *LPDEC_PLAYBACK_FILE_PARAM;

// Playback by time Conditions
typedef struct __DEC_PLAYBACK_TIME_PARAM 
{
	char			szDevIp[DH_MAX_IPADDR_LEN];			// IP address of Front-end DVR
	WORD			wDevPort;							// Port of Front-end DVR
	BYTE			bDevChnEnable;                      // Decoder channel enable
	BYTE			byDecoderID;						// The corresponding channel number
	char			szDevUser[DH_USER_NAME_LENGTH_EX];	// User Name
	char			szDevPwd[DH_USER_PSW_LENGTH_EX];	// Password
	int				nChannelID;
	NET_TIME		startTime;
	NET_TIME		endTime;
	char			reserved[12];
} DEC_PLAYBACK_TIME_PARAM, *LPDEC_PLAYBACK_TIME_PARAM;

// Current decoding channel status(including channel status, decoding stream info and etc.)
typedef struct __DEV_DECCHANNEL_STATE
{
	BYTE			byDecoderID;						// Responding decoding channel number
	BYTE            byChnState;                         // Current decoding channel in opertion status:0 -free,1 -realtime monitoring,2 - playback 3 - Decode Tour
	BYTE			byFrame;                            // Current data frame rate
	BYTE            byReserved;                         // Reserved
	int				nChannelFLux;						// Decoding channel data amount
	int             nDecodeFlux;						// Decoding data amount
	char            szResolution[16];                   // Current data resolution
	char			reserved[256];
} DEV_DECCHANNEL_STATE, *LPDEV_DECCHANNEL_STATE;

// Device TV display info
typedef struct __DEV_VIDEOOUT_INFO
{
	DWORD				dwVideoStandardMask;			// NSP,video standard mask,according to the bit which shows video format(not support now)
	int					nVideoStandard;                 // NSP,current format(not support now,please use DHDEV_SYSTEM_ATTR_CFG by VideoStandard to read and config the video format)
	DWORD				dwImageSizeMask;				// Resolution mask,according the bit which shows video resolution
	int                 nImageSize;                     // Current resolution
	char				reserved[256];
}DEV_VIDEOOUT_INFO, *LPDEV_VIDEOOUT_INFO;

// TV adjust
typedef struct __DEV_TVADJUST_CFG
{
	int					nTop;							// top(0 - 100)
	int					nBotton;						// botton(0 - 100)
	int					nLeft;							// left(0 - 100)
	int                 nRight;							// right(0 - 100)
	int					reserved[32];
}DHDEV_TVADJUST_CFG, *LPDHDEV_TVADJUST_CFG;

// decoder tour configuration
typedef struct __DEV_DECODER_TOUR_SINGLE_CFG
{
	char		szIP[128];								// Front-end device's ip.Such as"10.7.5.21". Support retention of the domain name, end by '\0'.
	int			nPort;									// Front-end device's port.(0, 65535).
	int			nPlayChn;								// front-end device's Request channel [1, 16].
	int			nPlayType;								// front-end device's Stream type, 0:main; 1:sub.
	char		szUserName[32];							// front-end device's user name,end by '\0'.
	char		szPassword[32];							// front-end device's Password,end by '\0'.
	int			nInterval;								// Round tour interval [10, 120],s.
	DWORD		nManuFactory;							// device's factory(enum see IPC_TYPE)
	UINT		nHttpPport;								// device's http port
	UINT		nRtspPort;								// device's rtsp port
	BYTE		byServiceType;							// service type -1:auto,0:TCP;1:UDP;2:Multicast 
	BYTE		bReserved[51];							// reserved.
}DHDEV_DECODER_TOUR_SINGLE_CFG;

typedef struct __DEV_DECODER_TOUR_CFG
{
	int								nCfgNum;			// the number of Configure structures. The biggest support 32. Specific number of support inquiries through capacity.
	DHDEV_DECODER_TOUR_SINGLE_CFG	tourCfg[64];		// Polling configuration array, the effective number of structures by the members of the "nCfgNum" designation. Keep left to expand 32.
	BYTE							bReserved[256];		// reserved.
}DHDEV_DECODER_TOUR_CFG;

/////////////////////////////////intelligent support/////////////////////////////////
// picture info
typedef struct  
{
	DWORD                dwOffSet;                      // current picture file's offset in the binary file, byte
	DWORD                dwFileLenth;                   // current picture file's size, byte
	WORD                 wWidth;                        // picture width, pixel
	WORD                 wHeight;                       // picture high, pixel
    char*                pszFilePath;                   // File path
                                                        // User use this field need to apply for space for copy and storage
    BYTE            bIsDetected;						// When submit to the server, the algorithm has checked the image or not 
    BYTE            bReserved[11];						// 12<--16
}DH_PIC_INFO;

// Object corresponding to picture file information (including images path)
typedef struct tagDH_PIC_INFO_EXX
{
    DWORD           dwSize;
    char            szFilePath[DH_COMMON_STRING_256];   //In view of historical reasons, the member is valid when be set or to get
                                                        // File path
    DH_PIC_INFO     stuPicInfo;                         // picture information
}DH_PIC_INFO_EX2;


// Extension fields added int64, forced 4 byte alignment
#pragma pack(push)
#pragma pack(4)

// Struct of object info for video analysis 
typedef struct 
{
	int					nObjectID;						// Object ID,each ID represent a unique object
	char				szObjectType[128];				// Object type
	int					nConfidence;					// Confidence(0~255),a high value indicate a high confidence
	int					nAction;						// Object action:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
	DH_RECT				BoundingBox;					// BoundingBox
	DH_POINT			Center;							// The shape center of the object
	int					nPolygonNum;					// the number of culminations for the polygon
	DH_POINT			Contour[DH_MAX_POLYGON_NUM];	// a polygon that have a exactitude figure
	DWORD				rgbaMainColor;					// The main color of the object;the first byte indicate red value, as byte order as green, blue, transparence, for example:RGB(0,255,0),transparence = 0, rgbaMainColor = 0x00ff0000.
    char				szText[128];					// the interrelated text of object,such as number plate,container number
                                                        // "ObjectType"?a"Vehicle" or "Logo"¡ê¡§try to use Logo.Vehicle is used to be compatible with old product¡ê?means logo¡ê?support¡êo
                                                        // "Unknown" Unknown 
                                                        // "Audi" Audi
                                                        // "Honda" Honda
                                                        // "Buick" Buick
                                                        // "Volkswagen" Volkswagen
                                                        // "Toyota" Toyota
                                                        // "BMW" BMW
                                                        // "Peugeot" Peugeot
                                                        // "Ford" Ford
                                                        // "Mazda" Mazda
                                                        // "Nissan" Nissan
                                                        // "Hyundai" Hyundai
                                                        // "Suzuki" Suzuki
                                                        // "Citroen" Citroen
                                                        // "Benz" Benz
                                                        // "BYD" BYD
                                                        // "Geely" Geely
                                                        // "Lexus" Lexus
                                                        // "Chevrolet" Chevrolet
                                                        // "Chery" Chery
                                                        // "Kia" Kia
                                                        // "Charade" Charade
                                                        // "DF" DF
                                                        // "Naveco" Naveco
                                                        // "SGMW" SGMW
                                                        // "Jinbei" Jinbei

                                                        // "JAC" JAC
                                                        // "Emgrand" Emgrand
                                                        // "ChangAn" ChangAn
                                                        // "Great Wall" Great Wall
                                                        // "Skoda" Skoda
                                                        // "BaoJun" BaoJun
                                                        // "Subaru" Subaru
                                                        // "LandWind" LandWind
                                                        // "Luxgen" Luxgen
                                                        // "Renault" Renault
                                                        // "Mitsubishi" Mitsubishi
                                                        // "Roewe" Roewe
                                                        // "Cadillac" Cadillac
                                                        // "MG" MG
                                                        // "Zotye" Zotye
                                                        // "ZhongHua" ZhongHua
                                                        // "Foton" Foton
                                                        // "SongHuaJiang" SongHuaJiang
                                                        // "Opel" Opel
                                                        // "HongQi" HongQi
                                                        // "Fiat" Fiat
                                                        // "Jaguar" Jaguar
                                                        // "Volvo" Volvo
                                                        // "Acura" Acura
                                                        // "Porsche" Porsche

                                                        // "Jeep" Jeep
                                                        // "Bentley" Bentley
                                                        // "Bugatti" Bugatti
                                                        // "ChuanQi" ChuanQi
                                                        // "Daewoo" Daewoo
                                                        // "DongNan" DongNan
                                                        // "Ferrari" Ferrari
                                                        // "Fudi" Fudi
                                                        // "Huapu" Huapu
                                                        // "HawTai" HawTai
                                                        // "JMC" JMC
                                                        // "JingLong" JingLong
                                                        // "JoyLong" JoyLong
                                                        // "Karry" Karry"
                                                        // "Chrysler" Chrysler
                                                        // "Lamborghini" Lamborghini
                                                        // "RollsRoyce" RollsRoyce
                                                        // "Linian" Linian
                                                        // "LiFan" LiFan
                                                        // "LieBao" LieBao
                                                        // "Lincoln" Lincoln
                                                        // "LandRover" LandRover
                                                        // "Lotus" Lotus
                                                        // "Maserati" Maserati
                                                        // "Maybach" Maybach

                                                        // "Mclaren" Mclaren
                                                        // "Youngman" Youngman
                                                        // "Tesla" Tesla
                                                        // "Rely" Rely
                                                        // "Lsuzu" Lsuzu
                                                        // "Yiqi" Yiqi
                                                        // "Infiniti" Infiniti
                                                        // "YuTong" YuTong
                                                        // "AnKai" AnKai
                                                        // "Canghe" Canghe
                                                        // "HaiMa" HaiMa
                                                        // "Crown" Crown
                                                        // "HuangHai" HuangHai
                                                        // "JinLv" JinLv
                                                        // "JinNing" JinNing
                                                        // "KuBo" KuBo
                                                        // "Europestar" Europestar
                                                        // "MINI" MINI
                                                        // "Gleagle" Gleagle
                                                        // "ShiDai" ShiDai
                                                        // "ShuangHuan" ShuangHuan
                                                        // "TianYe" TianYe
                                                        // "WeiZi" WeiZi
                                                        // "Englon" Englon
                                                        // "ZhongTong" ZhongTong

                                                        // "Changan" Changan
                                                        // "Yuejin" Yuejin
                                                        // "Taurus" Taurus
                                                        // "Alto" Alto
                                                        // "Weiwang" Weiwang
                                                        // "Chenglong" Chenglong
                                                        // "Haige" Haige
                                                        // "Shaolin" Shaolin
                                                        // "Beifang" Beifang
                                                        // "Beijing" Beijing
                                                        // "Hafu" Hafu

	char                szObjectSubType[64];            // object sub type,different object type has different sub type:
														// Vehicle Category:"Unknown","Motor","Non-Motor","Bus","Bicycle","Motorcycle"
														// Plate Category:"Unknown","mal","Yellow","DoubleYellow","Police","Armed",
														// "Military","DoubleMilitary","SAR","Trainning"
														// "Personal" ,"Agri","Embassy","Moto","Tractor","Other"
														// HumanFace Category:"Normal","HideEye","HideNose","HideMouth"
	BYTE                byReserved1[3];
	bool                bPicEnble;                     // picture info enable
	DH_PIC_INFO         stPicInfo;                     // picture info
	bool				bShotFrame;						// is shot frame
	bool				bColor;							// rgbaMainColor is enable
	BYTE				byReserved2;
	BYTE                byTimeType;                     // ¡ê¡§Time indicates the type of detailed instructions¡ê?EM_TIME_TYP
    NET_TIME_EX			stuCurrentTime;					// in view of the video compression,current time(when object snap or reconfnition, the frame will be attached to the frame in a video or pictures,means the frame in the original video of the time)
	NET_TIME_EX			stuStartTime;					// strart time(object appearing for the first time)
	NET_TIME_EX			stuEndTime;						// end time(object appearing for the last time)
	DH_RECT				stuOriginalBoundingBox;			// original bounding box(absolute coordinates)
	DH_RECT             stuSignBoundingBox;             // sign bounding box coordinate
	DWORD				dwCurrentSequence;				// The current frame number (frames when grabbing the object)
	DWORD				dwBeginSequence;				// Start frame number (object appeared When the frame number¡ê?
	DWORD				dwEndSequence;					// The end of the frame number (when the object disappearing Frame number)
	INT64				nBeginFileOffset;				// At the beginning of the file offset, Unit: Word Section (when objects began to appear, the video frames in the original video file offset relative to the beginning of the file¡ê?
	INT64				nEndFileOffset;					// At the end of the file offset, Unit: Word Section (when the object disappeared, video frames in the original video file offset relative to the beginning of the file)
	BYTE                byColorSimilar[NET_COLOR_TYPE_MAX];// Object color similarity, the range :0-100, represents an array subscript Colors, see EM_COLOR_TYPE¡ê?
 	BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // When upper body color similarity (valid object type man ¡ê?
 	BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // Lower body color similarity when objects (object type human valid ¡ê?
    int                 nRelativeID;                        // ID of relative object
	char				szSubText[20];						// "ObjectType"is "Vehicle" or "Logo"¡ê? means a certain brand under LOGO¡ê?such as Audi A6L¡ê?since there are so many brands¡ê?SDK sends this field in real-time ,device filled as real.
    BYTE                byReserved[2];
} DH_MSG_OBJECT;

// intrusion direction
typedef enum tagEM_MSG_OBJ_PERSON_DIRECTION
{
    EM_MSG_OBJ_PERSON_DIRECTION_UNKOWN,         // unknown direction
    EM_MSG_OBJ_PERSON_DIRECTION_LEFT_TO_RIGHT,  // from left to right
    EM_MSG_OBJ_PERSON_DIRECTION_RIGHT_TO_LEFT   // from right ro left
}EM_MSG_OBJ_PERSON_DIRECTION;

// Video analysis object info expansion structure 
typedef struct tagDH_MSG_OBJECT_EX
{
    DWORD               dwSize;
    int                 nObjectID;                  // object ID, each ID means a exclusive object
    char                szObjectType[128];          // object  type 
    int                 nConfidence;                //  confidence coefficient (0~255)¡ê? value the bigger means  confidence coefficient the higher
    int                 nAction;                    // object  motion :1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                // box
    DH_POINT            Center;                     // object model center
    int                 nPolygonNum;                // polygon vertex number 
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];// relatively accurate outline the polygon  
    DWORD               rgbaMainColor;              // means plate, vehicle body and etc. object major color¡ê?by byte means ¡ê?are red, green, blue and transparency , such as:RGB value is (0,255,0), transparency is 0, its value is 0x00ff0000.
    char                szText[128];                // same as DH_MSG_OBJECT corresponding field
    char                szObjectSubType[64];        // object sub type ¡ê?according to different object  types ¡ê?may use the following sub type ¡êo
                                                    // same as DH_MSG_OBJECT field
    BYTE                byReserved1[3];
    bool                bPicEnble;                  // object corresponding to picture file info or not
    DH_PIC_INFO         stPicInfo;                  // object corresponding to picture info 
    bool                bShotFrame;                 // snapshot recognition result or not 
    bool                bColor;                     // object  color (rgbaMainColor) usable or not
    BYTE                bLowerBodyColor;            // lower color (rgbaLowerBodyColor) usable or not
    BYTE                byTimeType;                 // time means type ¡ê? see EM_TIME_TYPE note 
    NET_TIME_EX         stuCurrentTime;             // for video compression¡ê? current time stamp¡ê¡§object snapshot or recognition¡ê? attach this recognition frame in one vire frame or jpegpicture¡ê?this frame?¡¥s appearance time in original video¡ê?
    NET_TIME_EX         stuStartTime;               // start time stamp¡ê¡§object start appearance¡ê?
    NET_TIME_EX         stuEndTime;                 // end time stamp¡ê¡§object last aapearance¡ê?
    DH_RECT             stuOriginalBoundingBox;     // box(absolute coordinate)
    DH_RECT             stuSignBoundingBox;         // LGO coordinate box
    DWORD               dwCurrentSequence;          //  current frame no.¡ê¡§snapshot this object frame¡ê?
    DWORD               dwBeginSequence;            // start frame no.¡ê¡§object start appearance frame no.¡ê?
    DWORD               dwEndSequence;              // end frame no.¡ê¡§object disappearance frame no.¡ê?
    INT64               nBeginFileOffset;           // start file shift, unit: byte¡ê¡§object start appearance¡ê?video in original video file moves toward file origin¡ê?
    INT64               nEndFileOffset;             // End file shift, unit: byte¡ê¡§object disappearance¡ê?video in original video file moves toward file origin¡ê?
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // object  color similarity¡ê?take  value range ¡êo0-100¡ê?group subscript value represents certain color ¡ê? see EM_COLOR_TYPE
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // upper object  color  similarity (object  type as human is valid )
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // lower object  color  similarity (object  type as human is valid )
    int                 nRelativeID;                // related object ID
	char				szSubText[20];              // "ObjectType"is "Vehicle"or "Logo"¡ê? means LOGO lower brand¡ê?such as Audi A6L¡ê?since there are many brands¡ê?SDK shows this field in real-time,device filled as real.

	int					nPersonStature;	            // Intrusion staff height¡ê?unit cm
	EM_MSG_OBJ_PERSON_DIRECTION	emPersonDirection;  // Staff intrusion direction
    DWORD               rgbaLowerBodyColor;         // Use direction same as rgbaMainColor,object  type as human is valid 	
} DH_MSG_OBJECT_EX;


// Video analysis object info extension structure, extension version 2. 
typedef struct tagDH_MSG_OBJECT_EX2
{
    DWORD				dwSize;
    int                 nObjectID;                          // Object ID. Each ID presents one object. 
    char                szObjectType[128];                  // Object type 
    int                 nConfidence;                        // Confiidence(0-255). The higher the value is, the higher the confidence is. 
    int                 nAction;                            // Object operation. 1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                        // Surrounding rectangle 
    DH_POINT            Center;                             // Object size centre
    int                 nPolygonNum;                        // Top amount of the polygon
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];        // Polygon of generaly accurate frame 
    DWORD               rgbaMainColor;                      // The plate and the vehicle body main color. Use byte to present: red, green, blue and transparent. When RGB value is (0,255,0), transparent is 0, the value is 0x00ff0000.
    char                szText[128];                        // The same as the string of the DH_MSG_OBJECT
    char                szObjectSubType[64];                // Object sub-type. It has the following sub-tyes. 
															// The same as the string of the DH_MSG_OBJECT
    BYTE                byReserved1[3];
    bool                bPicEnble;                          // There is image file info of the corresponding object 
    DH_PIC_INFO         stPicInfo;                          // Image info of the object 
    bool                bShotFrame;                         // Has been snapped or not 
    bool                bColor;                             // Object color (rgbaMainColor) is usable or not. 
    BYTE                bLowerBodyColor;                    // The lower part color (rgbaLowerBodyColor) is usable or not 
    BYTE                byTimeType;                         // Time type. Please refer to EM_TIME_TYPE.
    NET_TIME_EX         stuCurrentTime;                     // For video synopsis. Current time stampl (When snap or recognize the object, use the recognition intelligent frame on one video frame or JPEG.  It is the appearing time of the frame on the original video. )
    NET_TIME_EX         stuStartTime;                       // Start time stamp(When the object first appear )
    NET_TIME_EX         stuEndTime;                         // End time (When the object last appear )
    DH_RECT             stuOriginalBoundingBox;             // Surrounding box(Absolute coordinates)
    DH_RECT             stuSignBoundingBox;                 // Vehicle symbol surrounding box 
    DWORD               dwCurrentSequence;                  // Current frame SN(Frame when snap the object )
    DWORD               dwBeginSequence;                    // Start frame SN (The frame SN when the object start appearing)
    DWORD               dwEndSequence;                      // End frame SN (The frame SN when the object disappering)
    INT64               nBeginFileOffset;                   // The file offset when start. Unit:byte. (When the object appearing, the video frame offset value comparing with the file start positon in the original video)
    INT64               nEndFileOffset;                     // The file offset when stop. Unit: byte. (When the object disappearing, the video frame offset value comparing with the file start position in the original video)
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // Object color similarity level. The valur ranges from 0 to 100. The underline value of the array represents one color. Plase refer to EM_COLOR_TYPE.
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // The top body color similarity leve; (When the object is the human)
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // The lower body color similarity leve; (When the object is the human)
    int                 nRelativeID;                        // Related object ID
    char				szSubText[20];						// When "ObjectType" is "Vehicle" or "Logo", it represents one car series under the card symbol such as Audio A6L. Since there are too many card series, SDK use the network to realize COM transmission (szSubText) to realize this function. 
    
    int					nPersonStature;						// Intrusion person height. Unit is cm. 
    EM_MSG_OBJ_PERSON_DIRECTION	emPersonDirection;			// Intrusion person direction 
    DWORD               rgbaLowerBodyColor;                 // The same usage as the rgbaMainColor, it is valid when the object type is human. 

    //Video synopsis extra info 
    int                 nSynopsisSpeed;                             // Synopsis speed threshold. There are ten levels (1 to 10). 5 means only reserve the object of speed higher than 5. It is a relative unit.  
                                                                    // When it is 0, the string is invalid.
    int                 nSynopsisSize;                              // Synopsis dimension threshold. There are ten levels (1 to 10). 3 means only reserve the object of speed higher than 3. It is a relative unit.  
                                                                    // When it is o, the string is invalid. 
    BOOL                bEnableDirection;                           // When it is True, filter the object moving direction.
                                                                    // When it is False, do not filter the object moving direction. 
    DH_POINT            stuSynopsisStartLocation;                   // Synopsis moving direction, start coordinates. The point coordinates [0,8192), it is valid when bEnableDirection is True. 
    DH_POINT            stuSynopsisEndLocation;                     // Synopsis moving direction, stop coordinates. The point coordinates [0,8192), it is valid when bEnableDirection is True. 
    BYTE                byReserved[2048];                           // Extension byte
} DH_MSG_OBJECT_EX2;
#pragma pack(pop)


// snapshot info
typedef struct
{
	short              snSpeed;                          // current car speed,km/h
	short              snCarLength;                      // current car length, dm
	float              fRedTime;                         // current red light time, s.ms
	float              fCapTime;                         // current car way snapshot time, s.ms 
	BYTE               bSigSequence;                     // current snapshot Sequence
	BYTE               bType;                            // current snapshot type
														 // 0: radar up speed limit;1: radar low speed limit;2: car detector up speed limit;3:car detector low speed limit
														 // 4: reverse;5: break red light;6: red light on;7: red light off;8: snapshot or traffic gate
	BYTE               bDirection;                       // breaking type :01:left turn;02:straight;03:right
	BYTE               bLightColor;                      // current car way traffic light state,0: green, 1: red, 2: yellow
	BYTE               bSnapFlag[16];                    // snap flag from device
}DH_SIG_CARWAY_INFO;

// Vehicle detector redundancy info
typedef struct
{
	BYTE                byRedundance[8];                // The vehicle detector generates the snap signal redundancy info
	BYTE                bReserved[120];                 // Reserved field
}DH_SIG_CARWAY_INFO_EX;


// car way info
typedef struct  
{
	BYTE                bCarWayID;                           // current car way id 
	BYTE                bReserve[2];                         // reserved
	BYTE                bSigCount;                           // being snapshotted
	DH_SIG_CARWAY_INFO  stuSigInfo[DH_MAX_SNAP_SIGNAL_NUM];  // the snapshot info	
	BYTE                bReserved[12];                       // reserved
}DH_CARWAY_INFO;

// event file info
typedef struct
{
	BYTE               bCount;                               // the file count in the current file's group
	BYTE               bIndex;                               // the index of the file in the group
	BYTE               bFileTag;                             // file tag, see the enum struct EM_EVENT_FILETAG
	BYTE               bFileType;                            // file type,0-normal 1-compose 2-cut picture
	NET_TIME_EX        stuFileTime;                          // file time
	DWORD              nGroupId;                             // the only id of one group file
}DH_EVENT_FILE_INFO;

// pic resolution 
typedef struct
{
	unsigned short   snWidth;    // width
 	unsigned short   snHight;    // hight
}DH_RESOLUTION_INFO;

//  color RGBA
typedef struct tagDH_COLOR_RGBA
{
    int	        nRed;           // red
    int         nGreen;         // green
    int         nBlue;          // blue
    int         nAlpha;         // transparent
} DH_COLOR_RGBA;

// person info
typedef struct tagFACERECOGNITION_PERSON_INFO
{
	char                szPersonName[DH_MAX_NAME_LEN];		// name                 
	WORD				wYear;								// birth year
	BYTE				byMonth;							// birth month
	BYTE				byDay;								// birth day
	char                szID[DH_MAX_PERSON_ID_LEN];			// the unicle ID for the person
	BYTE                bImportantRank;						// importance level,1~10,the higher value the higher level
	BYTE                bySex;								// sex, 0-man, 1-female
	WORD                wFacePicNum;						// picture number
	DH_PIC_INFO         szFacePicInfo[DH_MAX_PERSON_IMAGE_NUM]; // picture info
	BYTE                byType;                                         // Personnel types, see EM_PERSON_TYPE
	BYTE                byIDType;                                       // Document types, see EM_CERTIFICATE_TYPE
	BYTE                bReserved1[2];                                  // Byte alignment
	char                szProvince[DH_MAX_PROVINCE_NAME_LEN];           // province
	char                szCity[DH_MAX_CITY_NAME_LEN];                   // city
	char                szPersonNameEx[DH_MAX_PERSON_NAME_LEN];	        // Name, the name is too long due to the presence of 16 bytes can not be Storage problems, the increase in this parameter
    char                szUID[DH_MAX_PERSON_ID_LEN];                    // ÈËÔ±Î¨Ò»±êÊ¶·û,Ê×´ÎÓÉ·þÎñ¶ËÉú³É,Çø±ðÓÚID×Ö¶Î
                                                                        // ÐÞ¸Ä,É¾³ý²Ù×÷Ê±±ØÌî
    BYTE                bReserved[28];
}FACERECOGNITION_PERSON_INFO;

// cadidate person info
typedef struct tagCANDIDATE_INFO
{
	FACERECOGNITION_PERSON_INFO  stPersonInfo;            // person info
	BYTE                         bySimilarity;            // similarity
	BYTE                         byRange;                  // Range officer's database, see EM_FACE_DB_TYPE
	BYTE                         byReserved1[2];
	NET_TIME                     stTime;                  // When byRange historical database effectively, which means that the query time staff appeared
	char                         szAddress[MAX_PATH];     // When byRange historical database effectively, which means that people place a query appears
	BYTE                         byReserved[128];         // Reserved bytes
}CANDIDATE_INFO;



// calss type  
typedef enum tagEM_CLASS_TYPE        
{
	EM_CLASS_UNKNOWN                	= 0,         
    EM_CLASS_VIDEO_SYNOPSIS            	= 1,        
    EM_CLASS_TRAFFIV_GATE            	= 2,           
    EM_CLASS_ELECTRONIC_POLICE        	= 3,        
    EM_CLASS_SINGLE_PTZ_PARKING        	= 4,        
    EM_CLASS_PTZ_PARKINBG            	= 5,          
    EM_CLASS_TRAFFIC                	= 6,    // "Traffic"       
    EM_CLASS_NORMAL                    	= 7,    // "Normal"       
    EM_CLASS_PRISON                    	= 8,    // "Prison"       
    EM_CLASS_ATM                    	= 9,    // "ATM"       
    EM_CLASS_METRO                    	= 10,       
    EM_CLASS_FACE_DETECTION            	= 11,   // "FaceDetection"       
    EM_CLASS_FACE_RECOGNITION        	= 12,   // "FaceRecognition"       
    EM_CLASS_NUMBER_STAT            	= 13,   // "NumberStat"       
    EM_CLASS_HEAT_MAP                	= 14,   // "HeatMap"       
    EM_CLASS_VIDEO_DIAGNOSIS        	= 15,   // "VideoDiagnosis"       
    EM_CLASS_VIDEO_ENHANCE            	= 16,        
    EM_CLASS_SMOKEFIRE_DETECT        	= 17,          
    EM_CLASS_VEHICLE_ANALYSE        	= 18,   // "VehicleAnalyse"       
    EM_CLASS_PERSON_FEATURE            	= 19,          
} EM_CLASS_TYPE; 



// intelli event comm info
typedef struct tagEVENT_INTELLI_COMM_INFO
{
	EM_CLASS_TYPE		emClassType;								// class type
} EVENT_INTELLI_COMM_INFO;




// TrafficCar
typedef struct tagDEV_EVENT_TRAFFIC_TRAFFICCAR_INFO
{
	char               szPlateNumber[32];               // plate number
	char               szPlateType[32];                 // plate type
	char               szPlateColor[32];                // plate color, "Blue","Yellow", "White","Black"
	char               szVehicleColor[32];              // vehicle color, "White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
	int                nSpeed;                          // speed, Km/H
	char               szEvent[64];                     // trigger event type
	char               szViolationCode[32];             // violation code, see TrafficGlobal.ViolationCode
	char               szViolationDesc[64];             // violation describe
	int                nLowerSpeedLimit;                // lower speed limit
	int                nUpperSpeedLimit;                // upper speed limit
	int                nOverSpeedMargin;                // over speed margin, km/h 
	int                nUnderSpeedMargin;               // under speed margin, km/h 
	int                nLane;                           // lane	
	int                nVehicleSize;                    // vehicle size, see VideoAnalyseRule's describe
                                                            //  Bit 0:"Light-duty", small car
                                                            // Bit 1:"Medium", medium car
                                                            // Bit 2:"Oversize", large car
                                                            // Bit 3:"Minisize", mini car
                                                            // Bit 4:"Largesize", long car
	float              fVehicleLength;                  // vehicle length, m
	int                nSnapshotMode;                   // snap mode 0-normal,1-globle,2-near,4-snap on the same side,8-snap on the reverse side,16-plant picture
	char               szChannelName[32];               // channel name
	char               szMachineName[256];              // Machine name
	char               szMachineGroup[256];             // machine group
	char               szRoadwayNo[64];                 // road way number	
	char               szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION];   
																			// DrivingDirection: for example ["Approach", "Shanghai", "Hangzhou"]
													     					// "Approach" means driving direction,where the car is more near;"Leave"-means where if mor far to the car
														 					// the second and third param means the location of the driving direction
	char              *szDeviceAddress;                 // device address,OSD superimposed onto the image,from TrafficSnapshot.DeviceAddress,'\0'means end.
	char			   szVehicleSign[32];				// Vehicle identification, such as "Unknown" - unknown "Audi" - Audi, "Honda" - Honda ...
	DH_SIG_CARWAY_INFO_EX stuSigInfo;                   // Generated by the vehicle inspection device to capture the signal redundancy
	char			  *szMachineAddr;					// Equipment deployment locations
	float              fActualShutter;                  // Current picture exposure time, in milliseconds
	BYTE               byActualGain;                    // Current picture gain, ranging from 0 to 100
	BYTE			   byDirection;						// Lane Direction,0 - south to north 1- Southwest to northeast 2 - West to east, 3 - Northwest to southeast 4 - north to south 5 - northeast to southwest 6 - East to West 7 - Southeast to northwest 8 - Unknown
	BYTE			   byReserved[2];
	char*			   szDetailedAddress;                   // Address, as szDeviceAddress supplement¡ê?
    char               szDefendCode[DH_COMMON_STRING_64];   // waterproof  
    int                nTrafficBlackListID;                 // Link black list data recorddefualt main keyID, 0¡ê?invalid¡ê?> 0¡ê?black list data record
    DH_COLOR_RGBA      stuRGBA;                             // bofy color RGBA
    NET_TIME           stSnapTime;                          // snap time
    int                nRecNo;                              // Rec No
    char               szCustomParkNo[DH_COMMON_STRING_32 + 1]; // self defined parking space number¡ê¡§for parking¡ê?
    BYTE               byReserved1[3];
    int                nDeckNo;                             // Metal plate No. 
    int                nFreeDeckCount;                      // Free metal plate No.
    int                nFullDeckCount;                      // Occupized metal plate No. 
    int                nTotalDeckCount;                      // Total metal plate No. 
    char               szViolationName[64];                 // violation name
	unsigned int	   nWeight;								// Weight of car(kg)
    BYTE               bReserved[616];                      // Reserved bytes
}DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO;

// the describe of EVENT_IVS_CROSSLINEDETECTION's data
typedef struct tagDEV_EVENT_CROSSLINE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM];    // rule detect line
	int                 nDetectLineNum;                        // rule detect line's point number
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];      // object moveing track
	int                 nTrackLineNum;                         // object moveing track's point number
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bDirection;                     // direction, 0-left to right, 1-right to left
	BYTE                byReserved[1];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
    unsigned int        nOccurrenceCount;               // event trigger accumulated times
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
    BYTE                bReserved[604];	                // reserved
	
} DEV_EVENT_CROSSLINE_INFO;

// event type EVENT_IVS_CROSSLINEDETECTION_EX(warning line event )corresponding to  datadescriptioninfo 
typedef struct tagDEV_EVENT_CROSSLINE_INFO_EX 
{
    DWORD               dwSize;
    int                 nChannelID;                     // channel no.
    char                szName[128];                    // event name 
    char                bReserved1[4];                  // field align
    float				PTS;                            // time stamp(unit is ms)
    NET_TIME_EX         UTC;                            // event occurance time
    int                 nEventID;                       // event ID
    DH_MSG_OBJECT_EX    stuObject;                      // detection object 
    DH_EVENT_FILE_INFO  stuFileInfo;                    // event corresponding to file info 
    DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM]; // rule detection line
    int                 nDetectLineNum;                 // rule detection line top number
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];// object motion track
    int                 nTrackLineNum;                  // object motion track top number
    BYTE                bEventAction;                   // event  motion ¡ê?0 means pulse event ,1 means continuity event  start ,2 means  continuity  event end;
    BYTE                bDirection;                     // means  intrusion direction, 0- leto to right, 1- right to left
    BYTE                byReserved[1];
    BYTE                byImageIndex;                   // picture no., same one time(accurate to second)may have multiple pictures , start from 0  
    DWORD               dwSnapFlagMask;                 // snapshot mark(by bit)¡ê?see NET_RESERVED_COMMON
    int                 nSourceIndex;                   // event source device index,-1 means invalid data,-1 means invalid data
    char                szSourceDevice[MAX_PATH];       // event source device SN, field do not existor is null means local device 
    unsigned int        nOccurrenceCount;               // event trigger accumulated times
	int					nMsgObjArrayCount;              // detection object info number 
	DH_MSG_OBJECT_EX*	pMsgObjArray;                   // detection object info group indicator
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
} DEV_EVENT_CROSSLINE_INFO_EX;

// the describe of EVENT_IVS_CROSSREGIONDETECTION's data
typedef struct tagDEV_EVENT_CROSSREGION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved2[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // rule detect region
	int                 nDetectRegionNum;                          // rule detect region's point number
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];          // object moving track
	int                 nTrackLineNum;                             // object moving track's point number
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bDirection;                     // direction, 0-in, 1-out,2-apaer,3-leave
	BYTE                bActionType;                    // action type,0-appear 1-disappear 2-in area 3-cross area
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
    unsigned int        nOccurrenceCount;               // event trigger times
	BYTE				bReserved[536];					// reserved
	int                 nObjectNum;                     // Detect object amount
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// Detected object
	int                 nTrackNum;                      // Locus amount(Corresponding to the detected object amount.)
	DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];// Locus info(Corresponding to the detected object)
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;      // intelli comm info
} DEV_EVENT_CROSSREGION_INFO;

//Special zone type 
typedef enum tagEM_SPECIAL_REGION_TYPE
{
    EM_SPEICAL_REGION_UNKNOW = 0        , // Unknown
    EM_SPEICAL_REGION_HIGH_LIGHT        , // Extra high light:ATM keyboard pane
    EM_SPEICAL_REGION_REGULAR_BLINK     , // Regular flash:ATM insert card zone 
    EM_SPEICAL_REGION_IRREGULAR_BLINK   , // Irregular flash£»ATM screen 
}EM_SPECIAL_REGION_TYPE;

// the describe of EVENT_IVS_PASTEDETECTION's data
typedef struct tagDEV_EVENT_PASTE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	int                 nDetectRegionNum;				// rule detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // rule detect region
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
    EM_SPECIAL_REGION_TYPE  emSpecialRegion;			// Special zone type
    EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;         // intelli comm info
    BYTE                    bReserved[876];				// Reserved string. To be delevloped 
	
} DEV_EVENT_PASTE_INFO;

// the describe of EVENT_IVS_LEFTDETECTION's data
typedef struct tagDEV_EVENT_LEFT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;          // event trigger accumilated times
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[616];			  		// Reserved
	
} DEV_EVENT_LEFT_INFO;

// the describe of EVENT_IVS_PRESERVATION's data
typedef struct tagDEV_EVENT_PRESERVATION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // pintelli comm info
	BYTE				bReserved[616];			  		// Reserved
	
} DEV_EVENT_PRESERVATION_INFO;

// the describe of EVENT_IVS_STAYDETECTION's data
typedef struct tagDEV_EVENT_STAY_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[616];			  		// Reserved
	
} DEV_EVENT_STAY_INFO;

// the describe of EVENT_IVS_WANDERDETECTION's data
typedef struct tagDEV_EVENT_WANDER_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nObjectNum;                     // detected objects number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];	// detected objects
	int                 nTrackNum;                      // track number
	DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];// track info
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[752];					// reserved
	
} DEV_EVENT_WANDER_INFO;

// the describe of EVENT_IVS_MOVEDETECTION's data
typedef struct tagDEV_EVENT_MOVE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
	int                 nTrackLineNum;                  // Object trajectories vertices              
	DH_POINT            stuTrackLine[DH_MAX_TRACK_LINE_NUM]; // Object trajectories			
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;        // intelli comm info
	BYTE				bReserved[532];					 // Reserved bytes, leave extended
	 
} DEV_EVENT_MOVE_INFO;

// the describe of EVENT_IVS_TAILDETECTION's data
typedef struct tagDEV_EVENT_TAIL_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    //  detect region
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // intelli comm info
	BYTE				bReserved[616];					
	
} DEV_EVENT_TAIL_INFO;

// the describe of EVENT_IVS_RIOTERDETECTION's data
typedef struct tagDEV_EVENT_RIOTER_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nObjectNum;						// have being detected object number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// have being detected object list
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region

    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[620];					
	
} DEV_EVENT_RIOTERL_INFO;

// the describe of EVENT_IVS_FIGHTDETECTION's data
typedef struct tagDEV_EVENT_FIGHT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nObjectNum;						// have being detected object number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// have being detected object list
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
	
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[620];					
} DEV_EVENT_FIGHT_INFO;

// the describe of EVENT_IVS_FIREDETECTION's data
typedef struct tagDEV_EVENT_FIRE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// detect region point
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
	
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[616];					// Reserved
	
} DEV_EVENT_FIRE_INFO;

// Event type EVENT_IVS_GETOUTBEDDETECTION(event of getting out of bed in detention center) data block corresponding description information
typedef struct tagDEV_EVENT_GETOUTBED_INFO 
{
    // Public field
    int                 nChannelID;                         // Channel Id
    char                szName[128];                        // Event name
    char                bReserved1[4];                      // byte alignment
    double              PTS;                                // Timestamp(millisecond)
    NET_TIME_EX         UTC;                                // The event happen time
    int                 nEventID;                           // Event ID
    // Event correspomds to field
    DH_MSG_OBJECT       stuObject;                          // Object said the object information who get off the bed
    int                 nDetectRegionNum;                   // Number of vertex indetection region for rules
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The detection region for rules
    DH_EVENT_FILE_INFO  stuFileInfo;                        // Event correspomds to file information
    BYTE                bEventAction;                       // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end

    BYTE                byReserved[2];                      // Reserve bytes
    BYTE                byImageIndex;                       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // Reserve bytes,left to expand 
} DEV_EVENT_GETOUTBED_INFO;

// Event type EVENT_IVS_PATROLDETECTION(guard detection event) data block corresponding description information
typedef struct tagDEV_EVENT_PATROL_INFO 
{
    // Public field
    int                 nChannelID;                         // Channel Id
    char                szName[128];                        // Event name
    char                bReserved1[4];                      // byte alignment
    double              PTS;                                // Timestamp(millisecond)
    NET_TIME_EX         UTC;                                // the event happen time
    int                 nEventID;                           // Event ID
    // Event correspomds to field
    DH_MSG_OBJECT       stuObject;                          // Object said the information of patrolling object
    int                 nDetectRegionNum;                   // Number of vertex indetection region
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The detection region for rules
    DH_EVENT_FILE_INFO  stuFileInfo;                        // Event correspomds to file information
    BYTE                bEventAction;                       // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end    
    BYTE                byReserved[2];                      // Reserve bytes
    BYTE                byImageIndex;                       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // Reserve bytes,left to expand
} DEV_EVENT_PATROL_INFO;

// Event type EVENT_IVS_ONDUTYDETECTION(guard detection event) data block corresponding description information
typedef struct tagDEV_EVENT_ONDUTY_INFO
{
    // Public field
    int                 nChannelID;                         // Channel Id
    char                szName[128];                        // Event name
    char                bReserved1[4];                      // byte alignment
    double              PTS;                                // Timestamp(millisecond)
    NET_TIME_EX         UTC;                                // the event happen time
    int                 nEventID;                           // Event ID
    // Field corresponding to the event
    DH_MSG_OBJECT       stuObject;                          // Object said the information of patrolling object
    int                 nDetectRegionNum;                   // Number of vertex indetection region for rules
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // The detection region for rules
    DH_EVENT_FILE_INFO  stuFileInfo;                        // Event correspomds to file information
    BYTE                bEventAction;                       // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end
    
    BYTE                byReserved[2];                      // Reserve bytes,left to expand
    BYTE                byImageIndex;                       // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0    DWORD               dwSnapFlagMask;                     // flag(by bit),see NET_RESERVED_COMMON    
    DWORD               dwSnapFlagMask;                     // ¡Á£¤¨ª?¡À¨º??(¡ã¡ä??)¡ê???¨¬???NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // Reserve bytes,left to expand
} DEV_EVENT_ONDUTY_INFO;

// the describe of EVENT_IVS_FIREDETECTION's data
typedef struct tagDEV_EVENT_ELECTROSPARK_INFO 
{
	int					nChannelID;						// Channel Id
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	BYTE				bReserved[972];					// reserved
	
} DEV_EVENT_ELECTROSPARK_INFO;

// the describe of EVENT_IVS_SMOKEDETECTION's data
typedef struct tagDEV_EVENT_SMOKE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[964];					
	
} DEV_EVENT_SMOKE_INFO;

// the describe of EVENT_IVS_FLOWSTAT's data
typedef struct tagDEV_EVENT_FLOWSTAT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nNumberLeft;					// the number of person across from left
	int					nNumberRight;					// the number of person across from right
	int					nUpperLimit;					// upper limit
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
	BYTE				bReserved[972];					

} DEV_EVENT_FLOWSTAT_INFO;

// the describe of EVENT_IVS_NUMBERSTAT's data
typedef struct tagDEV_EVENT_NUMBERSTAT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved2[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nNumber;						// the number of object which is in the area
	int					nUpperLimit;					// upper limit
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                bReserved1[2];                  // 
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nEnteredNumber;                 // entered object number
	int                 nExitedNumber;                  // exited object number
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
  unsigned int    nOccurrenceCount;          // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[956];					// Reserved
} DEV_EVENT_NUMBERSTAT_INFO;

// the describe of EVENT_IVS_CROSSFENCEDETECTION's data
typedef struct tagDEV_EVENT_CROSSFENCEDETECTION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int					nUpstairsLinePointNumber;		               // Upstairs Line Point Number
	DH_POINT		    stuUpstairsLine[DH_MAX_DETECT_LINE_NUM];	   // Upstairs Line info
	int					nDownstairsLinePointNumber;		               // Downstairs Line Point Number
	DH_POINT		    stuDownstairsLine[DH_MAX_DETECT_LINE_NUM];     // Downstairs Line info
	int                 nTrackLineNum;                                 // track line point number                
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];              // track line info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bDirection;                     // direction, 0-left to right, 1-right to left
    BYTE                byReserved[1];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;              // event trigger accumilated times 
  EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // intelli comm info
	BYTE				bReserved[744];				// Reserved
} DEV_EVENT_CROSSFENCEDETECTION_INFO;

// the describe of EVENT_IVS_INREGIONDETECTION's data
typedef struct tagDEV_EVENT_INREGIONDETECTION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int                 nObjectNum;                     // have being detected objects number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];	// have being detected objects
	int                 nTrackNum;                      // track line number
	DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];// track lines info
	int                 nDetectRegionNum;				// detect regions number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect regions
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	BYTE				bReserved[1016];				// Reserved
	
} DEV_EVENT_INREGIONDETECTION_INFO;

// the describe of EVENT_IVS_TAKENAWAYDETECTION's data
typedef struct tagDEV_EVENT_TAKENAWAYDETECTION_INFO
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						//  have being detected object
	int                 nDetectRegionNum;				// detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;              // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[744];				  // Reserved
} DEV_EVENT_TAKENAWAYDETECTION_INFO;

// the describe of EVENT_IVS_VIDEOABNORMALDETECTION's data
typedef struct tagDEV_EVENT_VIDEOABNORMALDETECTION_INFO
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bType;                          // type, 0-video lost, 1-video freeze, 2-video blind, 3-camera moving, 4-too dark, 5-too light
    BYTE                byReserved[1];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;              // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[748];					// Reserved
} DEV_EVENT_VIDEOABNORMALDETECTION_INFO;

// the describe of EVENT_IVS_PARKINGDETECTION's data
typedef struct tagDEV_EVENT_PARKINGDETECTION_INFO
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int                 nDetectRegionNum;				// detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;              // event trigger accumilated times 
  	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;   // intelli comm info
	BYTE				bReserved[744];				  // Reserved 
} DEV_EVENT_PARKINGDETECTION_INFO;

// the describe of EVENT_IVS_ABNORMALRUNDETECTION's data
typedef struct tagDEV_EVENT_ABNORMALRUNDETECTION 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	double              dbSpeed;                        // speed ,km/h
	double              dbTriggerSpeed;                 // triggerSpeed,km/h
	int                 nDetectRegionNum;				// detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region info
	int                 nTrackLineNum;                         // track line point number              
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];      // track line info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bRunType;                       // type, 0-run fast, 1-sudden speedup, 2-sudden speed-down
    BYTE                byReserved[1];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;              // event trigger accumilated times 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelligent things info
    BYTE                bReserved[744];                             // Reserved bytes.
	
} DEV_EVENT_ABNORMALRUNDETECTION_INFO;

// the describe of EVENT_IVS_RETROGRADEDETECTION's data
typedef struct tagDEV_EVENT_RETROGRADEDETECTION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int                 nTrackLineNum;                           // track line point number                   
	DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];        // track line info
	int                 nDirectionPointNum;                      // direction point number
	DH_POINT            stuDirections[DH_MAX_DETECT_LINE_NUM];   // direction info
	int                 nDetectRegionNum;				         // detect region's point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];  // detect region info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
  unsigned int    nOccurrenceCount;              // event trigger accumilated times 
  EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // intelli comm info
	BYTE				bReserved[744];				  // Reserved 
} DEV_EVENT_RETROGRADEDETECTION_INFO;

// the describe of EVENT_IVS_FACERECOGNITION's data
typedef struct tagDEV_EVENT_FACERECOGNITION_INFO
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
    int                 nEventID;                       // event ID
	NET_TIME_EX			UTC;							// the event happen time
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int                 nCandidateNum;                  // candidate number
    CANDIDATE_INFO      stuCandidates[DH_MAX_CANDIDATE_NUM]; // candidate info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	BYTE				byReserved1[2];				    // reserved
	BOOL                bGlobalScenePic;                // The existence panorama
	DH_PIC_INFO         stuGlobalScenePicInfo;          // Panoramic Photos
    char                szSnapDevAddress[MAX_PATH];     // Snapshot current face aadevice address  
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelligent things info
    BYTE                bReserved[720];                             // Reserved bytes.
}DEV_EVENT_FACERECOGNITION_INFO;

// Event type EVENT_IVS_DENSITYDETECTION(Population amount detect) corresponding data block description info
typedef struct tagDEV_EVENT_DENSITYDETECTTION_INFO
{
	int					nChannelID;						// Channel No.
	char				szName[128];					// Event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	int					nObjectNum;						// Detected object amount
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];	// Detected object list
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
	BYTE                byReserved[2];                  // Reserved field
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				// Acme amount of the rule detect zone
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // Rule detect zone
	
    DWORD               dwSnapFlagMask;	                // Snap flag(by bit).please refer to NET_RESERVED_COMMON
	int                 nSourceIndex;                   // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];       // the source device's sign(exclusive),field said local device does not exist or is empty
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// intelligent things info
    BYTE                bReserved[748];                             // Reserved bytes.
}DEV_EVENT_DENSITYDETECTION_INFO;

// Event type  EVENT_IVS_QUEUEDETECTION(queue detection)corresponding data block description info
typedef struct tagDEV_EVENT_QUEUEDETECTION_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved2[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE				bReserved1[2];				    // reserved
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DH_POINT            stuDetectLine[2];               // detect line
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
    BYTE                bReserved[1012];                // reserved
}DEV_EVENT_QUEUEDETECTION_INFO;

// Event type EVENT_IVS_TRAFFICCONTROL(traffic control)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFICCONTROL_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	BYTE				bReserved[972];					// Reserved field. For extension use. 

} DEV_EVENT_TRAFFICCONTROL_INFO;

// the describe of EVENT_IVS_TRAFFICACCIDENT's data
typedef struct tagDEV_EVENT_TRAFFICACCIDENT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nObjectNum;						// have being detected object number
	DH_MSG_OBJECT		stuObjectIDs[DH_MAX_OBJECT_LIST];// have being detected object list
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	BYTE				bReserved[976];					// Reserved

} DEV_EVENT_TRAFFICACCIDENT_INFO;

#define DH_EVENT_MAX_CARD_NUM       16    // Incident reporting information includes the maximum number of cards
#define DH_EVENT_CARD_LEN           36    // Card Name Length
 
// Incidents reported to carry the card information
typedef struct tagEVENT_CARD_INFO
{
    char szCardNumber[DH_EVENT_CARD_LEN];     // Card number string
    BYTE bReserved[32];	                      // Reserved bytes, leave extended
}EVENT_CARD_INFO;

typedef enum tagEM_OPEN_STROBE_STATE
{
    NET_OPEN_STROBE_STATE_UNKOWN,                   // unknown
    NET_OPEN_STROBE_STATE_CLOSE,                    // close
    NET_OPEN_STROBE_STATE_AUTO,                     // auto open   
    NET_OPEN_STROBE_STATE_MANUAL,                   // manual open
}EM_OPEN_STROBE_STATE;

typedef enum tagEM_VEHICLE_DIRECTION
{
    NET_VEHICLE_DIRECTION_UNKOWN,                   // unknown 
    NET_VEHICLE_DIRECTION_HEAD,                     // head    
    NET_VEHICLE_DIRECTION_TAIL,                     // rear  
}EM_VEHICLE_DIRECTION;

//NTP status 
typedef enum tagEM_NTP_STATUS
{
    NET_NTP_STATUS_UNKNOWN = 0 ,
    NET_NTP_STATUS_DISABLE     , 
    NET_NTP_STATUS_SUCCESSFUL  , 
    NET_NTP_STATUS_FAILED      , 
}EM_NTP_STATUS;

#define COMMON_SEAT_MAX_NUMBER        8             // Max seat number

typedef enum tagEM_COMMON_SEAT_TYPE
{
    COMMON_SEAT_TYPE_UNKNOWN    = 0,                // unknown
    COMMON_SEAT_TYPE_MAIN       = 1,                // main seat
    COMMON_SEAT_TYPE_SLAVE      = 2,                // slave seat
}EM_COMMON_SEAT_TYPE;

// illegal state type of driver
typedef struct tagEVENT_COMM_STATUS                 
{
    BYTE bySmoking;                                 // smoking
    BYTE byCalling;                                 // calling
    char szReserved[14];                            // reversed
}EVENT_COMM_STATUS;

typedef enum tagNET_SAFEBELT_STATE
{
    SS_NUKNOW   = 0 ,				// Unknow
	SS_WITH_SAFE_BELT ,				// WithSafeBelt   
	SS_WITHOUT_SAFE_BELT ,			// WithoutSafeBelt 
}NET_SAFEBELT_STATE;

//sun shade state
typedef enum tagNET_SUNSHADE_STATE
{
    SS_NUKNOW_SUN_SHADE	= 0 ,		// Unknow
	SS_WITH_SUN_SHADE ,				// WithSunShade  
	SS_WITHOUT_SUN_SHADE ,			// WithoutSunShade
}NET_SUNSHADE_STATE;

// driver's illegal info
typedef struct tagEVENT_COMM_SEAT
{
    BOOL                    bEnable;                // whether seat info detected
    EM_COMMON_SEAT_TYPE     emSeatType;             // seat type
    EVENT_COMM_STATUS       stStatus;               // illegal state
	NET_SAFEBELT_STATE      emSafeBeltStatus;       // safe belt state
    NET_SUNSHADE_STATE      emSunShadeStatus;       // sun shade state
    char                    szReserved[24];         // reversed
}EVENT_COMM_SEAT;

typedef enum tagEM_COMM_ATTACHMENT_TYPE      
{       
	COMM_ATTACHMENT_TYPE_UNKNOWN    = 0,            // Unknown type       
	COMM_ATTACHMENT_TYPE_FURNITURE  = 1,            // Furniture       
	COMM_ATTACHMENT_TYPE_PENDANT    = 2,            // Pendant       
	COMM_ATTACHMENT_TYPE_TISSUEBOX  = 3,            // TissueBox       
	COMM_ATTACHMENT_TYPE_DANGER     = 4,            // Danger       
 }EM_COMM_ATTACHMENT_TYPE; 

// car attachment
typedef struct tagEVENT_COMM_ATTACHMENT
{
    EM_COMM_ATTACHMENT_TYPE     emAttachmentType;       // type
	NET_RECT                    stuRect;                // coordinate
	BYTE						bReserved[20];		    // reserved
}EVENT_COMM_ATTACHMENT;

typedef struct tagEVENT_COMM_INFO
{
    EM_NTP_STATUS				emNTPStatus;										//NTP time sync status 
    int							nDriversNum;										//driver info number
    DH_MSG_OBJECT_EX*			pstDriversInfo;										//driver info data 
    char*						pszFilePath;										//writing path for loacl disk or sd card, or write to default path if NULL
    char*						pszFTPPath;											//ftp path
    char*						pszVideoPath;										//ftp path for assocated video
    EVENT_COMM_SEAT				stCommSeat[COMMON_SEAT_MAX_NUMBER];					//Seat info
	int							nAttachmentNum;										// Car Attachment number
	EVENT_COMM_ATTACHMENT		stuAttachment[NET_MAX_ATTACHMENT_NUM];				// Car Attachment 
	int							nAnnualInspectionNum;								// Annual Inspection number
	NET_RECT					stuAnnualInspection[NET_MAX_ANNUUALINSPECTION_NUM];	// Annual Inspection 
    BYTE						bReserved[1100];									// reserved
    char						szCountry[20];										// Country
}EVENT_COMM_INFO;

//¡ê¡§Event Type EVENT_IVS_TRAFFICJUNCTION (transportation card traffic junctions old rule event / video port on the old electric alarm event rules) corresponding to the description of the data block¡ê?
//¡ê¡§Due to historical reasons, if you want to deal with bayonet event, DEV_EVENT_TRAFFICJUNCTION_INFO and EVENT_IVS_TRAFFICGATE be processed together to prevent police and video electrical coil electric alarm occurred while the case access platform¡ê?
// ¡ê¡§Also EVENT_IVS_TRAFFIC_TOLLGATE only support the new bayonet events¡ê?
typedef struct tagDEV_EVENT_TRAFFICJUNCTION_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
    BYTE                byMainSeatBelt;                 // main driver?¡¥s seat¡ê?safety belt ¡ê?1-fastened¡ê?2-unfastened
    BYTE                bySlaveSeatBelt;                // co-drvier?¡¥s seat¡ê?safety belt¡ê?1-fastened¡ê?2-unfastened
    BYTE                byVehicleDirection;             // Current snapshot is head or rear¡ê?see  EM_VEHICLE_DIRECTION
    BYTE                byOpenStrobeState;              // Open status¡ê?see EM_OPEN_STROBE_STATE 
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int					nLane;							// road number
	DWORD				dwBreakingRule;					// BreakingRule's mask,first byte: crash red light; 
	                                                    // secend byte:break the rule of driving road number; 
	                                                    // the third byte:converse; the forth byte:break rule to turn around;
														// the five byte:traffic jam; the six byte:traffic vacancy; 
														// the seven byte: Overline; defalt:trafficJunction                                                        
	NET_TIME_EX			RedLightUTC;					// the begin time of red light
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	int                 nSequence;                      // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;                         // car's speed (km/h)
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byDirection;                    // Intersection direction 1 - denotes the forward 2 - indicates the opposite
    BYTE                byLightState;                               // LightState means red light status:0 unknown,1 green,2 red,3 yellow
	BYTE                byReserved;                  // reserved
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	char                szRecordFile[DH_COMMON_STRING_128]; // Alarm corresponding original video file information
	BYTE				bReserved[340];				    // Reserved bytes, leave extended_
    int                 nTriggerType;                   // Trigger Type:0 vehicle inspection device¡ê?1 radar¡ê?2 video
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
	DWORD               dwRetCardNumber;                // Card Number
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];  // Card information
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFICJUNCTION_INFO;


// the describe of EVENT_IVS_TRAFFICGATE's data
// owing to history, if you want to deal with TRAFFICGATE,DEV_EVENT_TRAFFICJUNCTION_INFO?EVENT_IVS_TRAFFICGATE must be handle together;
// in addition: EVENT_IVS_TRAFFIC_TOLLGATE only support new tollgate event configuration
typedef struct tagDEV_EVENT_TRAFFICGATE_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
    BYTE                byOpenStrobeState;              // Open gateway status¡ê?see EM_OPEN_STROBE_STATE
	char                bReserved1[3];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	int					nLane;							// road number
	int					nSpeed;							// the car's actual rate(Km/h)
	int					nSpeedUpperLimit;				// rate upper limit(km/h)
	int					nSpeedLowerLimit;				// rate lower limit(km/h) 
	DWORD				dwBreakingRule;					// BreakingRule's mask,first byte: Retrograde; 
	                                                    // second byte:Overline; the third byte:Overspeed; 
														// the forth byte:UnderSpeed;the five byte: crash red light;the six byte:passing(trafficgate)
	                                                    // the seven byte: OverYellowLine; the eight byte: WrongRunningRoute; the nine byte: YellowVehicleInRoute; default: trafficgate
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	BYTE                szManualSnapNo[64];             // manual snap sequence string                 
	int                 nSequence;                      // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                byReserved[3];                  // reserved
	BYTE                szSnapFlag[16];                 // snap flag from device
	BYTE                bySnapMode;                     // snap mode,0-normal 1-globle 2-near 4-snap on the same side 8-snap on the reverse side 16-plant picture
	BYTE                byOverSpeedPercentage;          // over speed percentage
	BYTE                byUnderSpeedingPercentage;      // under speed percentage
	BYTE                byRedLightMargin;               // red light margin, s
	BYTE                byDriveDirection;               // drive direction,0-"Approach",where the car is more near,1-"Leave",means where if mor far to the car
	char                szRoadwayNo[32];                // road way number
	char                szViolationCode[16];            // violation code
	char                szViolationDesc[128];           // violation desc
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	char                szVehicleType[32];              // car type,"Motor", "Light-duty", "Medium", "Oversize", "Huge", "Other" 
	BYTE                byVehicleLenth;                 // car length, m
    BYTE                byLightState;                               // LightState means red light status:0 unknown,1 green,2 red,3 yellow
	BYTE                byReserved1;                 // reserved
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nOverSpeedMargin;               // over speed margin, km/h 
	int                 nUnderSpeedMargin;              // under speed margin, km/h 
	char                szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION]; //
                                                      	// "DrivingDirection" : ["Approach", "Shanghai", "Hangzhou"],
	                                                  	// "Approach" means driving direction,where the car is more near;"Leave"-means where if mor far to the car
	                                                  	// the second and third param means the location of the driving direction
	char                szMachineName[256];             // machine name
	char                szMachineAddress[256];          // machine address
	char                szMachineGroup[256];            // machine group
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_SIG_CARWAY_INFO_EX stuSigInfo;                   // The vehicle detector generates the snap signal redundancy info
	char                szFilePath[MAX_PATH];           // File path
	NET_TIME_EX			RedLightUTC;					// the begin time of red light
	char              * szDeviceAddress;                // device address,OSD superimposed onto the image,from TrafficSnapshot.DeviceAddress,'\0'means end.
	float               fActualShutter;                 // Current picture exposure time, in milliseconds
	BYTE                byActualGain;                   // Current picture gain, ranging from 0 to 1000
    BYTE                byDirection;                    // 0-S to N  1-SW to NE 2-W to E 3-NW to SE 4-N to S 5-NE to SW 6-E to W 7-SE to NW 8-Unknown
    BYTE                bReserve;                       // Reserved bytes, byte alignment
    BYTE                bRetCardNumber;                 // Card Number
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];// Card information
    char               szDefendCode[DH_COMMON_STRING_64];// Waterproof
    int                nTrafficBlackListID;             // Link to balcklist main keyID, 0¡ê?invalid¡ê?> 0¡ê?blacklist data record
    EVENT_COMM_INFO     stCommInfo;                     // public info 
    BYTE                bReserved[452];	                // Reserved bytes, leave extended
} DEV_EVENT_TRAFFICGATE_INFO;

//the describe of EVENT_TRAFFICSNAPSHOT's data
typedef struct tagDEV_EVENT_TRAFFICSNAPSHOT_INFO 
{
	int					nChannelID;						// ChannelId
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	BYTE                bReserv[3];                       // reserved 
	BYTE                bCarWayCount;                     // car way number being snapshotting
	DH_CARWAY_INFO      stuCarWayInfo[DH_MAX_CARWAY_NUM]; // car way info being snapshotting
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	BYTE				bReserved[344];		    		// Reserved 
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFICSNAPSHOT_INFO;

//the describe of EVENT_IVS_TRAFFIC_RUNREDLIGHT's data
typedef struct tagDEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;				              // the event happen time
	int					nEventID;			              // event ID
	int					nLane;				              // Corresponding Lane number
	DH_MSG_OBJECT		stuObject;	              	      // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // event file info
	int					nLightState;	              	  // state of traffic light 0:unknown 1:green 2:red 3:yellow
	int					nSpeed;			              	  // speed,km/h
	int                 nSequence;                        // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;					  // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;						// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;						// flag(by bit),see NET_RESERVED_COMMON
	NET_TIME_EX         stRedLightUTC;						// time of red light starting
	DH_RESOLUTION_INFO  stuResolution;						// picture resolution
	BYTE                byRedLightMargin;					// red light margin, s
    BYTE                byAlignment[3];						// Align string
    int                 nRedLightPeriod;                            // Red light period. The unit is ms. 
    BYTE                bReserved[968];                             // Reserved string 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
  EVENT_COMM_INFO   stCommInfo;                 // public info 
} DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO;

//Data description info of the event type EVENT_IVS_TRAFFIC_PEDESTRAINRUNREDLIGHT(trafic-pedestrian redlight running
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO
{
    int                 nChannelID;                                 // Channel No.
    char                szName[128];                                // Event name
    char                bReserved1[4];                              // Align string
    double              PTS;                                        // Time stamp (unit is ms)
    NET_TIME_EX         UTC;                                        // Event occurrence time 
    int                 nEventID;                                   // Event ID
    int                 nLane;                                      // Corresponding lane No. 
    DH_MSG_OBJECT       stuObject;                                  // Pedestrian info 
    DH_EVENT_FILE_INFO  stuFileInfo;                                // Corresponding file inof of the event  
    int                 nSequence;                                  // Snap SN. Such as 3,2,1,1 means stop snap. 0= abnormal stop. 
    BYTE                bEventAction;                               // Event operation. 0=pulse event. 1=continious event begin, 2=continuous event stop
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // Image SN. There can be several images at the same time (unit:second). Begins with 0. 
    DWORD               dwSnapFlagMask;                             // Snap mark (by byte).Please refer to  NET_RESERVED_COMMON 
    DH_RESOLUTION_INFO  stuResolution;                              // Corresponding image resolution 
    BYTE                bReserved[1024];                             // Reserved string 
    EVENT_COMM_INFO     stCommInfo;                                 // Public info 
}DEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO;

//Data description info of the event type EVENT_IVS_TRAFFIC_PASSNOTINORDER(trafic-pass not in order)
typedef struct tagDEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO
{
    int                 nChannelID;                                 // Channel No.
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[4];                              // Align string
    double              PTS;                                        // Time stamp (unit is ms)
    NET_TIME_EX         UTC;                                        // Event occurrence time 
    int                 nEventID;                                   // Event ID
    int                 nLane;                                      // Corresponding lane No. 
    DH_MSG_OBJECT       stuObject;                                  // plate info
    DH_MSG_OBJECT       stuVehicle;                                 // Vehicle info 
    DH_EVENT_FILE_INFO  stuFileInfo;                                // Corresponding file inof of the event  
    int                 nSequence;                                  // Snap SN. Such as 3,2,1,1 means stop snap. 0 - abnormal stop. 
    BYTE                bEventAction;                               // Event operation. 0-pulse event. 1-continious event begin, 2-continuous event stop
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // Image SN. There can be several images at the same time (unit:second). Begins with 0. 
    DWORD               dwSnapFlagMask;                             // Snap mark (by byte).Please refer to  NET_RESERVED_COMMON 
    DH_RESOLUTION_INFO  stuResolution;                              // Corresponding image resolution 
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // Traffic Car information
    EVENT_COMM_INFO     stCommInfo;                                 // Public info
    BYTE                bReserved[1024];                            // Reserved string
}DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO;

//the describe of EVENT_IVS_TRAFFIC_OVERLINE's data
typedef struct tagDEV_EVENT_TRAFFIC_OVERLINE_INFO
{
	int					nChannelID;			// channel ID
	char				szName[128];		// event name
	char                bReserved1[4];      // byte alignment
	double				PTS;				// PTS(ms)
	NET_TIME_EX			UTC;				// the event happen time
	int					nEventID;			// event ID
	int					nLane;				// Corresponding Lane number
	DH_MSG_OBJECT		stuObject;			// have being detected object
	DH_MSG_OBJECT       stuVehicle;         // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
	int                 nSequence;          // snap index,such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             // speed,km/h
	BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	    // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;      // picture resolution	
	BYTE				bReserved[1008];	// Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
  EVENT_COMM_INFO   stCommInfo;                 // public info 
} DEV_EVENT_TRAFFIC_OVERLINE_INFO;


//the describe of EVENT_IVS_TRAFFIC_RETROGRADE's data
typedef struct tagDEV_EVENT_TRAFFIC_RETROGRADE_INFO
{
	int					nChannelID;			// channel ID
	char				szName[128];		// event name
	char                bReserved1[4];      // byte alignment
	double				PTS;				// PTS(ms)
	NET_TIME_EX			UTC;				// the event happen time
	int					nEventID;			// event ID
	int					nLane;				// Corresponding Lane number
	DH_MSG_OBJECT		stuObject;			// have being detected object
	DH_MSG_OBJECT       stuVehicle;         // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
	int                 nSequence;          // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             // speed, km/h
	BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;        // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	     // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;       // picture resolution
	BOOL                bIsExistAlarmRecord;            // a corresponding alarm recording; false: no corresponding alarm recording
	DWORD               dwAlarmRecordSize;              // Video size
	char                szAlarmRecordPath[DH_COMMON_STRING_256]; // Video Path
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelli comm info
	BYTE				bReserved[652];	// Reserved bytes
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;    // Traffic vehicle info
	int                 nDetectNum;				  // Acme amount of the rule detect zone
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // Rule detect zone 
  EVENT_COMM_INFO   stCommInfo;                 // public info 
} DEV_EVENT_TRAFFIC_RETROGRADE_INFO;

//the describe of EVENT_IVS_TRAFFIC_TURNLEFT's data
typedef struct tagDEV_EVENT_TRAFFIC_TURNLEFT_INFO
{
	int					nChannelID;			// channel ID
	char				szName[128];		// event name
	char                bReserved1[4];      // byte alignment
	double				PTS;				// PTS(ms)
	NET_TIME_EX			UTC;				// the event happen time
	int					nEventID;			// event ID
	int					nLane;				// Corresponding Lane number
	DH_MSG_OBJECT		stuObject;			// have being detected object
	DH_MSG_OBJECT       stuVehicle;         // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
	int                 nSequence;          // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             // speed,km/h
	BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	    // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;      // picture resolution

	BYTE				bReserved[1008];	// Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
  EVENT_COMM_INFO   stCommInfo;                 // public info 
} DEV_EVENT_TRAFFIC_TURNLEFT_INFO;


//the describe of EVENT_IVS_TRAFFIC_TURNRIGHT's data
typedef struct tagDEV_EVENT_TRAFFIC_TURNRIGHT_INFO
{
	int					nChannelID;			// channel ID
	char				szName[128];		// event name
	char                bReserved1[4];      // byte alignment
	double				PTS;				// PTS(ms)
	NET_TIME_EX			UTC;				// the event happen time
	int					nEventID;			// event ID
	int					nLane;				// Corresponding Lane number
	DH_MSG_OBJECT		stuObject;			// have being detected object
	DH_MSG_OBJECT       stuVehicle;         // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;        // event file info
	int                 nSequence;          // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             // speed,km/h
	BYTE                bEventAction;		// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	    // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;      // picture resolution

	BYTE				bReserved[1008];	// Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
  EVENT_COMM_INFO   stCommInfo;                 // public info 
} DEV_EVENT_TRAFFIC_TURNRIGHT_INFO;

//the describe of EVENT_IVS_TRAFFIC_UTURN's data
typedef struct tagDEV_EVENT_TRAFFIC_UTURN_INFO 
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // the event happen time
	int					nEventID;					      // event ID
	int					nLane;							  // Corresponding Lane number
	DH_MSG_OBJECT		stuObject;						  // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
	int                 nSequence;                        // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int                 nSpeed;             			  // speed,km/h
	BYTE                bEventAction;		              // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
	
	BYTE                bReserved[1008];				  // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
  EVENT_COMM_INFO   stCommInfo;                 // public info 
}DEV_EVENT_TRAFFIC_UTURN_INFO;

//the describe of EVENT_IVS_TRAFFIC_OVERSPEED's data
typedef struct tagDEV_EVENT_TRAFFIC_OVERSPEED_INFO 
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // the event happen time
	int					nEventID;					      // event ID
	int					nLane;							  // Corresponding Lane number
	DH_MSG_OBJECT		stuObject;						  // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
    int                 nSpeed;                           // vehicle speed Unit:Km/h
	int					nSpeedUpperLimit;			      // Speed Up limit Unit:km/h
	int					nSpeedLowerLimit;				  // Speed Low limit Unit:km/h 
	int                 nSequence;                        // snap index:such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;		              // Event action,0 means pulse event,1 means continuous event's begin,2 means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
    char                szFilePath[MAX_PATH];             // Faile path
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // intelli comm info
	BYTE                bReserved[744];				      // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
  EVENT_COMM_INFO   stCommInfo;                 // public info 
}DEV_EVENT_TRAFFIC_OVERSPEED_INFO;

//the describe of EVENT_IVS_TRAFFIC_UNDERSPEED's data
typedef struct tagDEV_EVENT_TRAFFIC_UNDERSPEED_INFO 
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved2[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // the event happen time
	int					nEventID;					      // event ID
	int					nLane;							  // Corresponding Lane number
	DH_MSG_OBJECT		stuObject;						  // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // vehicle info
	DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
    int                 nSpeed;                           // vehicle speed Unit:Km/h
	int					nSpeedUpperLimit;			      // Speed Up limit Unit:km/h
	int					nSpeedLowerLimit;				  // Speed Low limit Unit:km/h 
	int                 nSequence;                        // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;		              // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                bReserved1[2];                    // reserved
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nUnderSpeedingPercentage;         // under speed percentage
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // ¹«¹²ÐÅÏ¢
	BYTE                bReserved[1000];				  // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
  EVENT_COMM_INFO   stCommInfo;                 // public info 
}DEV_EVENT_TRAFFIC_UNDERSPEED_INFO;

//the describe of EVENT_IVS_TRAFFIC_JAM_FORBID_INTO's data
typedef struct tagDEV_EVENT_ALARM_JAMFORBIDINTO_INFO
{
	int                 nChannelID;                         // channel ID
    char                szName[DH_EVENT_NAME_LEN];          // event name
    char                bReserved1[4];                      // byte alignment
    DWORD               PTS;                                // PTS(ms)
    NET_TIME_EX         UTC;                                // the event happen time
    int                 nEventID;                           // event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                        // event file info
	int					nMark;								// frame flag
	int					nSource;						  	// video source
	int					nSequence;						    // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int					nFrameSequence;						// the sequence of frame
	int					nLane;							    // Corresponding Lane number
	BYTE                byImageIndex;                   	// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DH_MSG_OBJECT       stuObject;                      	// have being detected object
	BYTE                bReserved[1024];				    // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // Traffic vehicle info
	EVENT_COMM_INFO     stCommInfo;                     	// public info 
    DH_MSG_OBJECT       stuVehicle;                         // Traffic vehicle info
    DH_RESOLUTION_INFO  stuResolution;                      // picture resolution
} DEV_EVENT_ALARM_JAMFORBIDINTO_INFO;

//analyse info
typedef struct tagEVENT_PIC_ANALYSE_INFO
{
	DH_MSG_OBJECT       stuObject;                                  // plate info
    DH_MSG_OBJECT       stuVehicle;                                 // vehicle info
	EVENT_COMM_INFO     stuCommInfo;                     			// public info 
    BYTE                bReserved[1024];                            // Reserved
}EVENT_PIC_ANAKYSE_INFO;

//the describe of DH_ALARM_TRAFFIC_PIC_ANALYSE's data
typedef struct tagDEV_ALARM_PIC_ANALYSE_INFO
{
    int						nIndex;                              
    char					szName[128];                                // event nament
    double					PTS;                                        // PTS(ms)
    NET_TIME_EX				UTC;                                        // the event happen time
    int						nEventID;                                   // event ID
    DH_MSG_OBJECT			stuObject;                                  // plate info
    DH_MSG_OBJECT			stuVehicle;                                 // vehicle info
    int						nGroupID;									// the only id of one group 
	int						nCountInGroup;								// the file count in the current file's group
	int						nIndexInGroup;								// the index of the file in the group
	char					szFilePath[MAX_PATH];						// the path of the file
	EVENT_COMM_INFO			stuCommInfo;                     			// public info 
	EVENT_PIC_ANAKYSE_INFO	stuAnalyseInfo;								// analyse info
	BYTE					bReserved[1024];							// Reserved 
} ALARM_PIC_ANALYSE_INFO;

//sex type of dectected human face
typedef enum tagEM_DEV_EVENT_FACEDETECT_SEX_TYPE
{
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN,                   // unknown
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_MAN,                       // male
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_WOMAN,                     // female
}EM_DEV_EVENT_FACEDETECT_SEX_TYPE;

//feature type of detected human face
typedef enum tagEM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
{
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_UNKNOWN,               // unknown
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_GLASSES,          // wearing glasses
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SMILE,                 // smile
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_ANGER,                 // anger
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SADNESS,               // sadness
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_DISGUST,               // disgust
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_FEAR,                  // fear
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SURPRISE,              // surprise
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NEUTRAL,               // neutral
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_LAUGH,                 // laugh
}EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE;

#define DH_MAX_FACEDETECT_FEATURE_NUM          32                      // max number of detected human face feature

// multi faces detect info
typedef struct tagNET_FACE_INFO
{
    int                 nObjectID;                          // object id
    char                szObjectType[128];                  // object type
    int                 nRelativeID;                        // if relative id is the same with other, means their are come from one big picture
    DH_RECT             BoundingBox;                        // bounding box
    DH_POINT            Center;                             // object center
} NET_FACE_INFO;

//the describe of EVENT_IVS_FACEDETECT's data
typedef struct tagDEV_EVENT_FACEDETECT_INFO 
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // the event happen time
	int					nEventID;					      // event ID
	DH_MSG_OBJECT		stuObject;						  // have being detected object
	DH_EVENT_FILE_INFO  stuFileInfo;					  // event file info
	BYTE                bEventAction;                     // Event action: 0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                reserved[2];                      // reserved
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nDetectRegionNum;				  // detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
    char                szSnapDevAddress[MAX_PATH];       // snapshot current face device address
    unsigned int        nOccurrenceCount;                 // event trigger accumilated times 
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;                         // sex type
    int        nAge;                                                // age, invalid if it is -1
    unsigned int        nFeatureValidNum;                           // invalid number in array emFeature
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emFeature[DH_MAX_FACEDETECT_FEATURE_NUM];   // human face features
    int                 nFacesNum;                                  // number of stuFaces
    NET_FACE_INFO       stuFaces[10];                               // when nFacesNum > 0, stuObject invalid
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                     	// public info 
    BYTE                bReserved[1020];                   // Reserved 
} DEV_EVENT_FACEDETECT_INFO;

// the describe of EVENT_IVS_TRAFFICJAM's data
typedef struct tagDEV_EVENT_TRAFFICJAM_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info              
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                bJamLenght;                     // Mean congestion length (percentage of total lane length) 0-100
	BYTE                reserved;                    // reserved
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	NET_TIME_EX         stuStartJamTime;				// the time of starting jam 
	int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop(this param work when bEventAction=2) 
	int                 nAlarmIntervalTime;             // interval time of alarm(s).(this is a continuous event,if the interval time of recieving next event go beyond this parm, we can judge that this event is over with exception)
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    int                 nJamRealLength;                 // means actual jam length, unit is meter
	BYTE				bReserved[1008];				// Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info	
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFICJAM_INFO;

// the describe of EVENT_IVS_TRAFFIC_PARKING's data
typedef struct tagDEV_EVENT_TRAFFIC_PARKING_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info               
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	BYTE                reserved[2];                    // Reserved bytes
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	NET_TIME_EX         stuStartParkingTime;            // the time of starting parking
	int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop(this param work when bEventAction=2) 
	int                 nAlarmIntervalTime;             // interval time of alarm(s) (this is a continuous event,if the interval time of recieving next event go beyond this parm, we can judge that this event is over with exception)
	int                 nParkingAllowedTime;            // the time of legal parking
	int                 nDetectRegionNum;				// detect region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // detect region point number
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BOOL                bIsExistAlarmRecord;            // true:corresponding alarm recording; false: no corresponding alarm recording
	DWORD               dwAlarmRecordSize;              // Video size
	char                szAlarmRecordPath[DH_COMMON_STRING_256]; // Video Path
    char                szFTPPath[DH_COMMON_STRING_256];// FTP path 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[400];				    // Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFIC_PARKING_INFO;

//the describe of EVENT_IVS_TRAFFIC_WRONGROUTE's data
typedef struct tagDEV_EVENT_TRAFFIC_WRONGROUTE_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info               
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];           
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BYTE				bReserved[1012];				// Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFIC_WRONGROUTE_INFO;

//the describe of EVENT_IVS_TRAFFIC_CROSSLANE's data
typedef struct tagDEV_EVENT_TRAFFIC_CROSSLANE_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info                 
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];       
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE                bReserved[1004];                            // Reserved bytes.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // traffic vehicle info
    EVENT_COMM_INFO     stCommInfo;                     // public info 
} DEV_EVENT_TRAFFIC_CROSSLANE_INFO;

//the describe of EVENT_IVS_TRAFFIC_OVERYELLOWLINE's data
typedef struct tagDEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO 
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info                 
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];  
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BOOL                bIsExistAlarmRecord;            // true:corresponding alarm recording; false: no corresponding alarm recording
	DWORD               dwAlarmRecordSize;              // Video size
	char                szAlarmRecordPath[DH_COMMON_STRING_256]; // Video Path
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE				bReserved[660];				// Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
	
	int                 nDetectNum;				                   // Acme amount of the rule detect zone 
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // Rule detect zone 	
    EVENT_COMM_INFO     stCommInfo;                                // public info 
} DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO;

//the describe of EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER's data
typedef struct tagDEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info                                
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];      
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // ½»Í¨³µÁ¾ÐÅÏ¢
    EVENT_COMM_INFO     stCommInfo;                     // public info 
	
} DEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO;

//the describe of EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE's data
typedef struct tagDEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// Corresponding Lane number
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info                                               
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];     
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	int                 nSpeed;                         // speed,km/h
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BYTE				bReserved[1016];				// Reserved 
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    EVENT_COMM_INFO     stCommInfo;                     // public info 
	
} DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO;


//the describe of EVENT_IVS_TRAFFIC_NOPASSING's data
typedef struct tagDEV_EVENT_TRAFFIC_NOPASSING_INFO
{
	int					nChannelID;						// channel ID
	char				szName[DH_EVENT_NAME_LEN];					// event name
    int                 nTriggerType;                   // Trigger Type, 0 vehicle inspection device, 1 radar, 2 video
	DWORD				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int                 UTCMS;                          // 
	int                 nMark;                          // 
	int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info  
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    BYTE                byReserved1[3];
    int                 nLane;                          // Corresponding lane number
    DH_MSG_OBJECT		stuObject;						// Object to be detected
    DH_MSG_OBJECT       stuVehicle;                     // car body information 
    int                 nFrameSequence;                 // Video analysis frame number
    int                 nSource;                        // Data source address of the video analysis
    BYTE				byReserved[1024];	            // Reserved bytes
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_NOPASSING_INFO;
typedef struct tagDH_TRAFFICFLOWSTAT
{
	char				szMachineAddress[256];			// same as DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineGroup
	char				szMachineName[256];				// same as DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineName
	char				szDrivingDirection[3][32];		// DrivingDirection "Approach" means driving direction,where the car is more near;"Leave"-means where if mor far to the car,the scend and third param means the location of the driving direction
	int					nLane;							// lane number
	NET_TIME_EX			UTC;							// Statistic time
	int					nPeriod;						// Statistic period, m
	int					nVehicles;						// passed vehicle number
	float				fAverageSpeed;					// average speed, km/h
	float				fAverageLength;					// average length, m
	float				fTimeOccupyRatio;				// time occupy ratio,
	float				fSpaceOccupyRatio;				// space occupy ratio,
	float				fSpaceHeadway;					// space between two cars,m
	float				fTimeHeadway;					// time between two cars, s
	float				fDensity;						// car density, every km
	int					nOverSpeedVehicles;				// over speed vehicle number
	int					nUnderSpeedVehicles;			// under speed vehicle number
	int					nLargeVehicles;					// big car number  
	int					nMediumVehicles;				// mid car number
	int					nSmallVehicles;					// small car number
	int					nMotoVehicles;					// moto car number
	int					nLongVehicles;					// long vehicle number
}DH_TRAFFICFLOWSTAT;
// the describe of EVENT_IVS_TRAFFIC_FLOWSTATE's data
typedef struct tagDEV_EVENT_TRAFFIC_FLOWSTAT_INFO
{
	char				szName[128];					// name
	double				PTS;							// time stamp(ms)
	NET_TIME_EX			UTC;							// occurrence time
	int					nEventID;						// event id
	int					nLaneCnt;						// channel number
	DH_TRAFFICFLOWSTAT	stTrafficFlowStats[DH_MAX_LANE_NUM];//traffic flow state info
	char				Reserved[4];					// byte alignment
}DEV_EVENT_TRAFFIC_FLOWSTAT_INFO;

//the describe of EVENT_IVS_TRAFFIC_MANUALSNAP's data
typedef struct tagDEV_EVENT_TRAFFIC_MANUALSNAP_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	int					nLane;							// lane number
	BYTE                szManualSnapNo[64];             // manual snap number 
	DH_MSG_OBJECT		stuObject;						// have being detected object
	DH_MSG_OBJECT       stuVehicle;                     // have being detected vehicle
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BYTE				bReserved[1016];				// 
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_MANUALSNAP_INFO;

//the describe of EVENT_IVS_TRAFFIC_STAY's data
typedef struct tagDEV_EVENT_TRAFFIC_STAY_INFO
{
	int					nChannelID;						// channel id
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// object info
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// lane number
	int					nSequence;						// snap index
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info  
	BYTE                bEventAction; 					// Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved0[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	BYTE                byReserved[1012];           
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_STAY_INFO;

//the describe of EVENT_IVS_TRAFFIC_VEHICLEINROUTE's data
typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO
{
	int					nChannelID;						// channel id
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// object info
	DH_MSG_OBJECT       stuVehicle;                     // vehicle info
	int					nLane;							// lane number
	int					nSequence;						// snap index
	int					nSpeed;							// speed
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;   // TrafficCar info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info            
	BYTE                bEventAction;                   // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved0[2];
    BYTE                byImageIndex;                   // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                // flag(by bit),see NET_RESERVED_COMMON
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
	BYTE                byReserved[1012];           
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO;

// the describe of EVENT_ALARM_LOCALALARM and EVENT_ALARM_MOTIONALARM's data
typedef struct tagDEV_EVENT_ALARM_INFO
{
	int					nChannelID;						// channel id
	char				szName[128];					// evnent name
	char				Reserved[4];					// byte alignment
	double				PTS;							// PTS(ms)
	NET_TIME_EX			UTC;							// the event happen time
	int					nEventID;						// evnet ID        
    
    DH_EVENT_FILE_INFO  stuFileInfo;                    // event file info            
}DEV_EVENT_ALARM_INFO;

// the describe of EVENT_ALARM_VIDEOBLIND's data
typedef struct tagDEV_EVENT_ALARM_VIDEOBLIND
{
    int					nChannelID;						// channel id
    char				szName[128];					// evnent name
    char				Reserved[4];					// byte alignment
    double				PTS;							// PTS(ms)
    NET_TIME_EX			UTC;							// the event happen time
    int					nEventID;						// evnet ID        
    
    NET_TIME_EX         stuTime;                        // Action happens time,accurate to seconds

    BYTE                byReserved2[512];			    // reserve text,for extension
}DEV_EVENT_ALARM_VIDEOBLIND;

// Alarm event type EVENT_ALARM_ANALOGALARM(analog alarm channel alarm),
typedef struct tagDEV_EVENT_ALARM_ANALOGALRM_INFO 
{
    int                 nChannelID;                                 // (video)channel no.
    char                szName[DH_COMMON_STRING_128];               // analog alarm channel name
    char                Reserved[4];                                // reserve text align	
    double              PTS;                                        // time stamp(unit is ms)
    NET_TIME_EX         UTC;                                        // event time
    int                 nEventID;                                   // event ID 
    DH_EVENT_FILE_INFO  stuFileInfo;                                // event corresponding file info   
    int                 nIndex;                                     // analog alarm channel no.
    NET_SENSE_METHOD    emSensor;                                   // sensor type
    int                 nStatus;                                    // data status, -1:unknown,0:normal,1:invalid data(over meansure),
                                                                    // 2:over threshold1,3:over threshold2,4:over threshold3,5: over threshold 4,
                                                                    // 6:below threshold 1,7: below threshold 2,8: below threshold 3,9: below threshold 4
    float               fValue;                                     // detector value
    NET_TIME            stuCollectTime;                             // data collection time(UTC)
    DWORD               dwSnapFlagMask;                             // snapshotmark(by bit)¡ê?see NET_RESERVED_COMMON
    BYTE                bEventAction;                               // event action¡ê?0 means impulse event,1 means continuous event start,2 means continuous event end;
    BYTE                byReserved2[1023];                          // reserve text,for extension
}DEV_EVENT_ALARM_ANALOGALRM_INFO;

//EVENT_ALARM_VEHICLEACC(ACC outage alarm)
typedef struct tagDEV_EVENT_ALARM_VEHICLEACC_INFO
{
	int					nChannelID;						// (Channel number)
	char				szName[DH_COMMON_STRING_128];	// (Event Name)
	char				Reserved[4];					// (Reserved byte alignment)
	double				PTS;							// (Timestamp (in milliseconds)
	NET_TIME_EX			UTC;							// (Time the event occurred)
	int					nEventID;						// (Event ID)   
	NET_GPS_STATUS_INFO stGPSStatusInfo;				// (GPS information)
	int					nACCStatus;						// (ACC status 0: Invalid (compatible with), 1: On, 2: Off)                                                                                 	
	BYTE                bEventAction;                   // (Event action, 0 represents the pulse event, an event starts, said persistent, 2 for persistent event ends;)
	BYTE				bConstantElectricStatus;		// (Often charged state 0: Invalid (compatible with), 1: Connection 2: Disconnect)						
	BYTE                bReserved[1022];                // (Reserved bytes, left extensions.)
}DEV_EVENT_ALARM_VEHICLEACC_INFO;


// alarm event type EVENT_ALARM_VEHICLE_TURNOVER(vehicle side turn) , EVENT_ALARM_VEHICLE_COLLISION(collision)
typedef struct tagDEV_EVENT_VEHICEL_ALARM_INFO
{
	int					nChannelID;						// (Channel number)
	char				szName[128];					// ( event name )
	char				Reserved[4];					// ¡ê¡§Reserved bytes, left extensions.)
	double				PTS;							// (Timestamp (in milliseconds))
	NET_TIME_EX			UTC;							// (Time for the event occurred )
	int					nEventID;						// (Event ID)
	NET_GPS_STATUS_INFO stGPSStatusInfo;				// (GPS information)
	DH_EVENT_FILE_INFO  stuFileInfo;                    // (Event corresponding to file information)
	BYTE                bEventAction;                   // (Event action, 0 represents the pulse event, 1 persistent event starts, 2 persistent event ends;)
	BYTE                byReserved[2];					// (With Byte alignment)
	BYTE				byImageIndex;					// (Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0¡ê?)
	DWORD               dwSnapFlagMask;                 // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                  // (Corresponding to the resolution of the picture¡ê?
	BYTE                bReserved[1024];                // (Reserved bytes, left extensions.)
}DEV_EVENT_VEHICEL_ALARM_INFO;

// the describe of  EVENT_IVS_PRISONERRISEDETECTION's data
typedef struct tagDEV_EVENT_PRISONERRISEDETECTION_INFO
{
	int					nChannelID;						  // channel id
	char				szName[128];					  // evnent name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // PTS(ms)
	NET_TIME_EX			UTC;						   	  // he event happen time
	int					nEventID;					      // evnet ID           
	DH_MSG_OBJECT		stuObject;						  // object info
	int                 nDetectRegionNum;				  // region point number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // region
	DH_EVENT_FILE_INFO  stuFileInfo;                      // event file info
	double				dInitialUTC;			  		  // UTC init time
	BYTE                bEventAction;                     // Event action,0 means pulse event,1 means continuous event's begin,2means continuous event's end;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                  // flag(by bit),see NET_RESERVED_COMMON
	int                 nSourceIndex;                     // the source device's index,-1 means data in invalid
	char                szSourceDevice[MAX_PATH];         // the source device's sign(exclusive),field said local device does not exist or is empty
    unsigned int        nOccurrenceCount;                 // event trigger accumilated times 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelligent things info
    BYTE                bReserved[744];                             // Reserved bytes.
}DEV_EVENT_PRISONERRISEDETECTION_INFO;

//Event type  EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY(Pedestal has higher priority at the  crosswalk) corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO
{
	int                 nChannelID;                       // Channel No.
	char                szName[128];                      // Event name
	char                bReserved1[4];                    // byte alignment
	double              PTS;                              // Time stamp(ms)
	NET_TIME_EX         UTC;                              // Event occurred time
	int                 nEventID;                         // Event ID
	DH_MSG_OBJECT       stuObject;                        // Detected object
	DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
	int                 nLane;                            // Corresponding lane No.
	double				dInitialUTC;			  		  // Event initial UTC time 	UTC is the second of the event UTC (1970-1-1 00:00:00)
	BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;     // The record of the database of the traffic vehicle 
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
	BYTE                bReserved[1024];                  // Reserved field for future extension.
    EVENT_COMM_INFO     stCommInfo;                       // public info 
}DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO;

//Event type  EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE(vehicle in bus route)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO
{
	int                 nChannelID;                       // channel ID
	char                szName[128];                      // event name
	char                bReserved1[4];                    // byte alignment
	double              PTS;                              // Time stamp(ms)
	NET_TIME_EX         UTC;                              // Event occurred time
	int                 nEventID;                         // Event ID
	DH_MSG_OBJECT       stuObject;                        // Detected object
	DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
	int                 nLane;                            // Corresponding lane No.
	int					nSequence;						  // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int					nSpeed;							  // speed km/h
	BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // The record of the database of the traffic vehicle 
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
	BYTE                bReserved[1020];                  // reserved
    EVENT_COMM_INFO     stCommInfo;                       // public info 
}DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO;

//Event type  EVENT_IVS_TRAFFIC_BACKING(traffic backing)corresponding data block description info
typedef struct tagDEV_EVENT_IVS_TRAFFIC_BACKING_INFO
{
	int                 nChannelID;                       // channel ID
	char                szName[128];                      // event name
	char                bReserved1[4];                    // byte alignment
	double              PTS;                              // Time stamp(ms)
	NET_TIME_EX         UTC;                              // Event occurred time
	int                 nEventID;                         // Event ID
	DH_MSG_OBJECT       stuObject;                        // Detected object
	DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
	int                 nLane;                            // Corresponding lane No.
	int					nSequence;						  // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	int					nSpeed;							  // speed km/h
	BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // The record of the database of the traffic vehicle 
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;       // intelli comm info
	BYTE                bReserved[1016];                  // reserved
    EVENT_COMM_INFO     stCommInfo;                       // public info 
}DEV_EVENT_IVS_TRAFFIC_BACKING_INFO;

//Event type EVENT_IVS_AUDIO_ABNORMALDETECTION(audio abnormal detection)corresponding data block description info
typedef struct tagDEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO
{
	int                 nChannelID;                       // channel ID
	char                szName[128];                      // event name
	char                bReserved1[4];                    // byte alignment
	double              PTS;                              // Time stamp(ms)
	NET_TIME_EX         UTC;                              // Event occurred time
	int                 nEventID;                         // Event ID
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event
	int                 nDecibel;                         // decubel
	int                 nFrequency;                       // frequency
	BYTE                bEventAction;                     // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;                   // Snap flag(by bit),please refer to NET_RESERVED_COMMON	
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
	BYTE                bReserved[1024];                  // reserved
}DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO;

//Event type  EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT(traffic run yellow light)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO
{
	int					nChannelID;						  // channel ID
	char				szName[128];					  // event name
	char                bReserved1[4];                    // byte alignment
	double				PTS;							  // Time stamp(ms)
	NET_TIME_EX			UTC;				              // Event occurred time
	int					nEventID;			              // Event ID
	int					nLane;				              // Corresponding lane No.
	DH_MSG_OBJECT		stuObject;	              	      // have being detected object
	DH_MSG_OBJECT       stuVehicle;                       // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                      // The corresponding file info of the event 
	int					nLightState;	              	  // state of traffic light 0:unknown 1:green 2:red 3:yellow
	int					nSpeed;			              	  // speed km/h
	int                 nSequence;                        // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;					  // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    DWORD               dwSnapFlagMask;	                  // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	NET_TIME_EX         stYellowLightUTC;                 // begin time of yellow light
	unsigned int        nYellowLightPeriod;               // yellow light period time (s)
	DH_RESOLUTION_INFO  stuResolution;                    // picture resolution
 	BYTE                byRedLightMargin;                 // time interval(s)
	char                szSourceDevice[MAX_PATH];         // the source device's sign(exclusive),field said local device does not exist or is empty
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;       // Traffic vehicle info
	BYTE				bReserved[1024];	              // reserved
    EVENT_COMM_INFO     stCommInfo;                       // public info 
} DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO;

//Event type  EVENT_IVS_LEAVEDETECTION(leave check)corresponding data block description info
typedef struct tagDEV_EVENT_IVS_LEAVE_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	int                 nDetectRegionNum;				// Rule Detect Area Top Number
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    //Rule Detect Area
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelligent things info
	BYTE                bReserved[1022];                            // Reserved bytes.
} DEV_EVENT_IVS_LEAVE_INFO;

//Event type  EVENT_IVS_CLIMBDETECTION(climb check)corresponding data block description info
typedef struct tagDEV_EVENT_IVS_CLIMB_INFO
{
	int					nChannelID;						// channel ID
	char				szName[128];					// event name
	char                bReserved1[4];                  // byte alignment
	double				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// event ID
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	int                 nDetectLineNum;                        // Acme amount of the rule detect zone
	DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM];    // Rule detect zone 
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    unsigned int        nOccurrenceCount;               // event trigger accumilated times 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelligent things info
    BYTE                bReserved[1018];                            // Reserved bytes.
}DEV_EVENT_IVS_CLIMB_INFO;

//EVENT_IVS_MULTISCENESWITCH Event Type EVENT_IVS_MULTISCENESWITCH (multi-scene change event) corresponding to the description of the data block
typedef struct tagDEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO
{
	int					nChannelID;						// (Channel number)
	char				szName[128];					// (Event name)
	char                bReserved1[4];                  // 
	double				PTS;							// (Timestamp (in milliseconds))
	NET_TIME_EX			UTC;							// (Time for the event occurred )
	int					nEventID;						// (Event ID)
	BYTE                bEventAction;                   // (Event action, 0 represents the pulse event, 1 persistent event starts, 2 persistent event ends;)
	BYTE				bReserved[1027];	            // (Reserved bytes)
} DEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO;

//Event type  EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX(parking on yellow)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO
{
	int					nChannelID;						// channel ID 
	char				szName[128];					// event name
	char                bReserved1[8];                  // byte alignment
	DWORD				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	int					nLane;							// Corresponding lane No.
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_MSG_OBJECT       stuVehicle;                     // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event

	int					nInterval1;						// the first and second time interval(s)
	int					nInterval2;						// 3rd and 2nd delay time, unit is second
	int					nFollowTime;					// follow time,if a car and a car before entering the pornographic websites,is less than this value,just as with car to enter, to enter the case if the parkingis not illegal

	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;	                // Snap flag(by bit),please refer to NET_RESERVED_COMMON		
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
	BYTE				bReserved[1024];	            // reserved
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO;

//Parking lot info
typedef struct tagDEV_TRAFFIC_PARKING_INFO
{
    int           nFeaturePicAreaPointNum;                  // Feature image point number 
    DH_POINT      stFeaturePicArea[DH_MAX_POLYGON_NUM];     // Feature image info
    BYTE          bReserved[572];                           // Reserved string 
}DEV_TRAFFIC_PARKING_INFO;


//Event type  EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING(parking space parking)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO
{
	int					nChannelID;						// channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
	char                bReserved1[8];                  // byte alignment
	DWORD				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	int					nLane;							// Corresponding lane No.
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_MSG_OBJECT       stuVehicle;                     // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	
	int                 nSequence;                      // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;	                // Snap flag(by bit),please refer to NET_RESERVED_COMMON	
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
	int                 nParkingSpaceStatus;           // parking space status¡ê?0-free¡ê?1-not free¡ê?2-on line
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // Í£³µ³¡ÐÅÏ¢
    BYTE                bReserved[380];                        // ±£Áô×Ö½Ú 
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO;

//Event type  EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING(parking space no parking)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO
{
	int					nChannelID;						// channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
	char                bReserved1[8];                  // byte alignment
	DWORD				PTS;							// Time stamp(ms)
	NET_TIME_EX			UTC;							// Event occurred time
	int					nEventID;						// Event ID
	int					nLane;							// Corresponding lane No.
	DH_MSG_OBJECT		stuObject;						// Detected object
	DH_MSG_OBJECT       stuVehicle;                     // Vehicle body info
	DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
	
	int                 nSequence;                       // snap index: such as 3,2,1,1 means the last one,0 means there has some exception and snap stop
	BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                     // Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
	DWORD               dwSnapFlagMask;	                // Snap flag(by bit),please refer to NET_RESERVED_COMMON	
	DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;     // Traffic vehicle info
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // Í£³µ³¡ÐÅÏ¢
    BYTE                bReserved[384];                            // ±£Áô×Ö½Ú
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO;

// EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE Corresponding data block description
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO
{
	int					nChannelID;						// ¡ê¡§Channel number¡ê?
    char                szName[DH_EVENT_NAME_LEN];      // ¡ê¡§Event name¡ê?
	DWORD				PTS;							// ¡ê¡§Timestamp (in milliseconds)¡ê?
	NET_TIME_EX			UTC;							// ¡ê¡§The time of events¡ê?
	int					nEventID;						// (Event ID)
	int					nLane;							// (Corresponding lane number)
	DH_MSG_OBJECT		stuObject;						// ( object detected)
	DH_MSG_OBJECT       stuVehicle;                     // (Car Body Information)
	DH_EVENT_FILE_INFO  stuFileInfo;                    // ¡ê¡§Event corresponding to file information¡ê?
	
	int                 nSequence;                      // ¡ê¡§Means??capture serial number, such as 3,2,1,1 capture end, 0 indicates abnormal end¡ê?
	BYTE                byEventAction;                  // ¡ê¡§Event action, 0 represents the pulse event, 1 means persistent event starts, 2 means persistent event ends;...¡ê?
	BYTE				byImageIndex;					// (Serial chip, the same time (accurate to seconds) may have multiple images, starting from 0)
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;	                // (Grab flag (bit), see specific NET_RESERVED_COMMON)
	DH_RESOLUTION_INFO  stuResolution;                  // (the resolution of relative picture)
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // (Transportation Vehicle Information)
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // Í£³µ³¡ÐÅÏ¢
    BYTE                byReserved[384];                           // ±£Áô×Ö½Ú
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO;

//Event type  EVENT_IVS_TRAFFIC_PEDESTRAIN(pedestrain)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAIN_INFO
{
    int                 nChannelID;                     // channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
    char                bReserved1[8];                  // byte alignment
    DWORD               PTS;                            // Time stamp(ms)
    NET_TIME_EX         UTC;                            // Event occurred time
    int                 nEventID;                       // Event ID
    DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
    DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    DWORD               dwSnapFlagMask;                 // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout" 
    BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                bReserved2[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    int                 nLane;                          // Corresponding lane No.
    DH_MSG_OBJECT       stuObject;                      // Detected object
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // intelli comm info
    BYTE                bReserved[1020];                // reserved
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO;

//Event type  EVENT_IVS_TRAFFIC_THROW(throw)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_THROW_INFO
{
    int                 nChannelID;                     // channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
    char                bReserved1[8];                  // byte alignment
    DWORD               PTS;                            // Time stamp(ms)
    NET_TIME_EX         UTC;                            // Event occurred time
    int                 nEventID;                       // Event ID
    DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
    DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    DWORD               dwSnapFlagMask;                 // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout" 
    BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                bReserved2[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    int                 nLane;                          // Corresponding lane No.
    DH_MSG_OBJECT       stuObject;                      // Detected object
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // intelligent things info
    BYTE                bReserved[1020];                            // Reserved bytes.
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_THROW_INFO;

//Event type  EVENT_IVS_TRAFFIC_IDLE(idle)corresponding data block description info
typedef struct tagDEV_EVENT_TRAFFIC_IDLE_INFO
{
    int                 nChannelID;                     // channel ID
    char                szName[DH_EVENT_NAME_LEN];      // event name
    char                bReserved1[8];                  // byte alignment
    DWORD               PTS;                            // Time stamp(ms)
    NET_TIME_EX         UTC;                            // Event occurred time
    int                 nEventID;                       // Event ID
    DH_EVENT_FILE_INFO  stuFileInfo;                    // The corresponding file info of the event
    DH_RESOLUTION_INFO  stuResolution;                  // picture resolution
    DWORD               dwSnapFlagMask;                 // Snap flag(by bit)0 bit:"*",1 bit:"Timing",2 bit:"Manual",3 bit:"Marked",4 bit:"Event",5 bit:"Mosaic",6 bit:"Cutout" 
    BYTE                bEventAction;                   // Event operation.0=pulse event,1=begin of the durative event,2=end of the durative event;
    BYTE                bReserved2[2];
	BYTE				byImageIndex;					// Serial number of the picture, in the same time (accurate to seconds) may have multiple images, starting from 0
    int                 nLane;                          // Corresponding lane No.
    BYTE                bReserved[1024];                // reserved
    EVENT_COMM_INFO     stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_IDLE_INFO;

#define MAX_DRIVING_DIR_NUM          16                             //  lane direction max quantity

// direction
typedef enum tagNET_FLOWSTAT_DIRECTION
{
	DRIVING_DIR_UNKNOW = 0 ,		// (Before compatible)
	DRIVING_DIR_APPROACH ,			// (Uplink, the vehicle away from the device deployment point is getting closer)
	DRIVING_DIR_LEAVE ,				// (Go down, that the vehicle is farther away from  equipment deployment point)
}NET_FLOWSTAT_DIRECTION;

// road direction
typedef enum tagNET_ROAD_DIRECTION
{
    ROAD_DIR_UNKNOW,             // unknown  
    ROAD_DIR_TURNLEFT,           // left turn 
    ROAD_DIR_TURNRIGHT,          // right turn
    ROAD_DIR_STRAIGHT,           // direction
    ROAD_DIR_UTURU,              // u turn
    ROAD_DIR_NUM,    
}NET_ROAD_DIRECTION;

//Vehicle flow statistics lane direction information
typedef struct tagNET_TRAFFIC_FLOWSTAT_INFO_DIR
{
	NET_FLOWSTAT_DIRECTION		emDrivingDir;							//(Driving direction)
	char						szUpGoing[FLOWSTAT_ADDR_NAME];			//(Uplink locations)
	char						szDownGoing[FLOWSTAT_ADDR_NAME];		//(Go down location)
	BYTE						reserved[32];							//(Reserved bytes)
	
}NET_TRAFFIC_FLOWSTAT_INFO_DIR;

//road jam status
typedef enum tagNET_TRAFFIC_JAM_STATUS
{
    JAM_STATUS_UNKNOW  =0 ,  // unknown 
    JAM_STATUS_CLEAR      ,  //clear
    JAM_STATUS_JAMMED     ,  //jammed
}NET_TRAFFIC_JAM_STATUS;

typedef struct tagNET_TRAFFIC_FLOW_STATE 
{
	int								nLane;				// (Lane number)
	DWORD							dwState;			// (State value)
														// (1 - heavy traffic)
														// (2-heavy traffic recovery)
														// (3-normal)
														// (4 - Flow is too  little)
														// (5-Traffic too low recovery)
	DWORD							dwFlow;				// (Flow value, units: vehicles)
	DWORD							dwPeriod;			// (Corresponding statistical time of the flow value )
	NET_TRAFFIC_FLOWSTAT_INFO_DIR	stTrafficFlowDir;	// (Lane direction information)
	int					            nVehicles;			// (Total number of passing vehicles)
	float				            fAverageSpeed;		// (Average speed, unit km / h)
	float				            fAverageLength;		// (The average vehicle length, unit meters)
	float				            fTimeOccupyRatio;	// (Share of the time , i.e., The ratio of the sum time for the vehicle passing the cross-section  in  the unit  time and per unit time )
	float				            fSpaceOccupyRatio;	// (Share of the space ,is the result that the average driving distance intervals vehicle is divided the sum of the length of the vehicle measured by the percentage 
	float			            	fSpaceHeadway;		// (Headway, the distance between adjacent vehicles in m / vehicle)
	float				            fTimeHeadway;		// (Headway in seconds / vehicle)
	float				            fDensity;			// (Vehicle density, the number of vehicles per kilometer, unit vehicles / km)
	int					            nOverSpeedVehicles;	// (The number of Speeding vehicles)
	int					            nUnderSpeedVehicles;// (The number of low speeding vehicles)
	int				            	nLargeVehicles;		// (Carts traffic (9 m <car length <12 m), vehicle / unit time)
	int				            	nMediumVehicles;	// (Medium car Traffic 6 m ??<car length <9 meters), vehicle / unit time
	int				            	nSmallVehicles;		// (Car Traffic 4 m ??<car length <6 meters), vehicle / unit time
	int				            	nMotoVehicles;		// (Motorized traffic (mini-car, car length <4 m), vehicle / unit time¡ê?
	int				            	nLongVehicles;		// (long traffic (car length> = 12 m), vehicle / unit time¡ê?
	int                             nVolume;            // (Traffic, vehicles / unit time, the number of vehicles which pass through the lane, the road and other vehicles, caculated in one hour)
	int                             nFlowRate;          // (Flow rate of the car, Vehicles / hour, equivalent hours for Vehicle through the lane, a section or a section of the road)
	int                             nBackOfQueue;       // (Queue length, unit: m, distance from the signalized intersection stop line between the upstream end of the line vehicle)
	int                             nTravelTime;        // (Travel time, unit: second, a road vehicle used by a certain time. Including all parking delays)
	int                             nDelay;             // (Delay unit: seconds, extra travel time for the driver, passenger or pedestrian spend)
    BYTE                            byDirection[MAX_DRIVING_DIR_NUM]; // lane direction¡ê?see NET_ROAD_DIRECTION
    BYTE                            byDirectionNum;                 // lane direction quantity
    BYTE                            reserved1[3];       // text align
    NET_TRAFFIC_JAM_STATUS          emJamState;         // road jam status
    //  Traffic statisitcs according to vehicle type
    int                             nPassengerCarVehicles;                      // Passenger vehicle statistics amount (amount/hour)
    int                             nLargeTruckVehicles;                        // Large truck statistics amount 
    int                             nMidTruckVehicles;                          // Medium truck statistics amount (amount/hour)
    int                             nSaloonCarVehicles;                         // Car statistics amount (amount/hour)
    int                             nMicrobusVehicles;                          // Minivan statistics amount (amount/hour)
    int                             nMicroTruckVehicles;                        // Small van statistics amount (amount/hour)
    int                             nTricycleVehicles;                          // Tricycle statistics amount (amount/hour)
    int                             nMotorcycleVehicles;                        // Motor statistics amount (amount/hour)
    int                             nPasserbyVehicles;                          // Pedestrian statistics amount (amount/hour)
    BYTE                            reserved[816];                              // Reserved string 
}NET_TRAFFIC_FLOW_STATE;
 
// EVENT_IVS_TRAFFIC_FLOWSTATE (Corresponding data block description)
typedef struct tagDEV_EVENT_TRAFFIC_FLOW_STATE
{
    int                 nChannelID;                     // (Channel number) 
    char                szName[DH_EVENT_NAME_LEN];      // (Event name)
    char                bReserved1[8];                  // (Byte alignment)
    DWORD               PTS;                            // (Timestamp (in milliseconds))
    NET_TIME_EX         UTC;                            // (Time for the event occurred)
    int                 nEventID;                       // (Event ID)
	int					nSequence;						// (No.)
	int					nStateNum;						// (the number of traffic state)
	NET_TRAFFIC_FLOW_STATE stuStates[DH_MAX_LANE_NUM];	// (Flow state, each lane corresponding to an element in the array)
    BYTE                bReserved[1024];                // (Reserved bytes)
}DEV_EVENT_TRAFFIC_FLOW_STATE;

// EVENT_IVS_VIDEOSTATIC(Corresponding to data block description) 
typedef struct tagDEV_EVENT_ALARM_VIDEOSTATIC_INFO 
{
    int                 nChannelID;                                 // Channel number
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[8];                              // Byte alignment
    DWORD               PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                        // Time for the event occurred
    int                 nEventID;                                   // Event ID
    EM_ALARM_VIDEO_STATIC_MODE  emMode;                             // the mode 
    BYTE                bEventAction;                               // Even action
    BYTE                bReserved[1027];                            // Reserved bytes
}DEV_EVENT_ALARM_VIDEOSTATIC_INFO;

// EVENT_IVS_VIDEOTIMINGCorresponding to data block description) 
typedef struct tagDEV_EVENT_ALARM_VIDEOTIMING_INFO 
{
    int                 nChannelID;                                 // Channel number
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[8];                              // Byte alignment
    DWORD               PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                        // Time for the event occurred
    int                 nEventID;                                   // Event ID
    BYTE                bEventAction;                               // the mode 
    BYTE                bReserved[1027];                            // Reserved bytes
}DEV_EVENT_ALARM_VIDEOTIMING_INFO;


//event source information
typedef struct tagDEV_SRC_INFO
{
    char           szSrcEvent[DH_COMMON_STRING_32];// source event
    NET_TIME_EX    stSrcTime;                      // the time of source event
    int            iSrcChannel;                    // the channel of source event
    BYTE           reserved[512];                  // Reserved bytes
}DEV_SRC_INFO;

//EVENT_IVS_LINKSD(Corresponding to data block description)
typedef struct tagDEV_EVENT_LINK_SD
{
    // common fields
    int                 nChannelID;                         // Channel number
    char                szName[DH_EVENT_NAME_LEN];          // Event name
    char                bReserved1[8];                      // Byte alignment
    DWORD               PTS;                                // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                // Time for the event occurred
    int                 nEventID;                           // Event ID

    // event fields
    DEV_SRC_INFO       *pstSrcInfo;                         // event source information
    NET_TIME_EX         stStartTime;                        // The start time of the preset
    NET_TIME_EX         stEndTime;                          // The end time of the preset
    int                 iPresetID;                          // The preset ID
    BYTE                reserved[512];                      // Reserved bytes
}DEV_EVENT_LINK_SD;

typedef enum tagEM_CITIZENIDCARD_SEX_TYPE
{
    EM_CITIZENIDCARD_SEX_TYPE_UNKNOWN,						// Unknown 
        EM_CITIZENIDCARD_SEX_TYPE_MALE,						// Male
        EM_CITIZENIDCARD_SEX_TYPE_FEMALE,					// Female
        EM_CITIZENIDCARD_SEX_TYPE_UNTOLD,					// Untold
}EM_CITIZENIDCARD_SEX_TYPE;

// Media file search criteria
typedef struct tagDEV_EVENT_ALARM_CITIZENIDCARD_INFO
{
    int                 nChannelID;                                 // Channel No.
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[8];                              // Align type 
    DWORD               PTS;                                        // Time stamp (unit:ms)
    NET_TIME_EX         UTC;                                        // Event occurrence time 
    int                 nEventID;                                   // Event ID
    ///////////////////////////////The above are the public string//////////////////////////////
    int                 nGroupID;                                   // nGroupID event group ID. The nGroupID is the same for the snap process of the same object 
    int                 nCountInGroup;                              // nCountInGroup snap amount of one event group 
    int                 nIndexInGroup;                              // IndexInGroup snap SN of one event group 
    char                szCitizen[DH_COMMON_STRING_64];             // Name
    EM_CITIZENIDCARD_SEX_TYPE   emSex;                              // Gender 
    int                 nEthnicity;                                 // Nationality 
    // 0 invalid data 
    // 1 Han
    // 2 Mongolian
    // 3 Hui
    // 4 Tibetan
    // 5 Uygur
    // 6 Miao
    // 7 Yi
    // 8 Zhuang
    // 9 Bouyei
    // 10 Korean
    // 11 Manchu
    // 12 Dong
    // 13 Yao
    // 14 Bai
    // 15 Tujia
    // 16 Hani
    // 17 Kazak
    // 18 Dai
    // 19 Li
    // 20 Lisu
    // 21 Va
    // 22 She
    // 23 Gaoshan
    // 24 Lahu
    // 25 Shui
    // 26 Dongxiang
    // 27 Naxi
    // 28 Jingpo
    // 29 Kirgiz
    // 30 Tu
    // 31 Daur
    // 32 Mulam
    // 33 Qoiang
    // 34 Blang
    // 35 Salar
    // 36 Maonan
    // 37 Gelo
    // 38 Xibe
    // 39 Achang
    // 40 Pumi
    // 41 Tajik
    // 42 Nu
    // 43 Ozbek
    // 44 Russian
    // 45 Ewenkl
    // 46 Deang
    // 47 Bonan
    // 48 Yugur
    // 49 Jing
    // 50 Tatar
    // 51 Drung
    // 52 Oroqen
    // 53 Hezhen
    // 54 Moinba
    // 55 Lhoba
    // 56 Jino
    NET_TIME            stuBirth;                                   // Birth date 
    char                szAddress[DH_COMMON_STRING_256];            // Address
    char                szNumber[DH_COMMON_STRING_64];              // ID
    char                szAuthority[DH_COMMON_STRING_256];          // Issued authority 
    NET_TIME            stuStart;                                   // Start date 
    BOOL                bLongTimeValidFlag;                         // When the value is TRUE, the stop date menas always valid, at this time, the  stuEnd is null. 
    // When the value is FALSE, refer to stuEnd value for stop date.
    NET_TIME            stuEnd;                                     // Stop date, it is valid when bLongTimeValidFlag is FALSE.
    char                szReversed[1024];                           // Reserved string 
}DEV_EVENT_ALARM_CITIZENIDCARD_INFO;

// Corresponding data description info of event type EVENT_IVS_PICINFO (image info event) 
typedef struct tagDEV_EVENT_ALARM_PIC_INFO 
{
    int                 nChannelID;                                 // Channel No.
    char                szName[DH_EVENT_NAME_LEN];                  // Event name 
    char                bReserved1[8];                              // Align byte 
    DWORD               PTS;                                        // Time stamp (Unit:ms)
    NET_TIME_EX         UTC;                                        // Event occurrence time (Not for mobile device )
    int                 nEventID;                                   // Event ID
	///////////////////////////////Comon information above //////////////////////////////
	NET_TIME_EX         stuTime;                                    // Event occurrence time (Device time, it may not be utc time).
    DWORD               dwEventType;                                // Event  type
    DWORD               dwSpeed;                                    // Speed. Unit is km/h.
	DWORD               dwSpeedHighLine;                            // Speed limit (max speed)on highway. Unit is km/h.
    DWORD               dwDisk;                                     // Disk No.
    DWORD               dwCluster;                                  // Cluster No.
    DWORD               dwPartition;                                // Partition No.	
    char                szSnapAddr[DH_COMMON_STRING_128];           // Snap position. Valid 64-byte 
    char                szPicID[DH_COMMON_STRING_32];               // Image only ID
    char                szPlate[DH_COMMON_STRING_16];               // Plate 
    char                szReversed[2000];                           // Reserved string 
}DEV_EVENT_ALARM_PIC_INFO;

//Event EVENT_IVS_NETPALYCHECK(Corresponding to data block description)
typedef struct tagDEV_EVENT_ALARM_NETPLAYCHECK_INFO
{
	int                 nChannelID;                                 // Channel number
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[8];                              // Byte alignment
    DWORD               PTS;                                        // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                        // Time for the event occurred
    int                 nEventID;                                   // Event ID
    ///////////////////////////////Comon information above//////////////////////////////
	NET_TIME_EX         stuTime;                                    // Event occurrence time (Device time, it may not utc).
	char				szIdentityCard[DH_COMMON_STRING_32];		//Identity Card
	char				szNetBarName[DH_COMMON_STRING_32];			//Internet Bar Name
	char				szNetBarID[DH_COMMON_STRING_32];			//Internet Bar ID
	char				szNetBarAddr[DH_COMMON_STRING_64];			//Network bar address 
}DEV_EVENT_ALARM_NETPLAYCHECK_INFO;

//Corresponding to data block description of event type EVENT_IVS_SNAPBYTIME(snap by time event) 
typedef struct tagDEV_EVENT_SNAPBYTIME
{
	int                 nChannelID;                                 // Channel number
    char                szName[DH_EVENT_NAME_LEN];                  // Event name
    char                bReserved1[4];                              // Byte alignment
    double              PTS;                                       // Timestamp (in milliseconds)
    NET_TIME_EX         UTC;                                        // Time for the event occurred
    int                 nEventID;                                   // Event ID
    ///////////////////////////////Comon information above, In addition to other fields outside the nChannelID is to set aside public space//////////////////////////////
    NET_TIME_EX         stuSnapTime;                                // snap time
    char                szReversed[2048];                           // Reserved string 
}DEV_EVENT_SNAPBYTIME;

// mediaÎÄ¼þ²éÑ¯Ìõ¼þ
typedef enum __EM_FILE_QUERY_TYPE
{
	DH_FILE_QUERY_TRAFFICCAR,							// Vehicle information 
	DH_FILE_QUERY_ATM,									// ATM information
	DH_FILE_QUERY_ATMTXN,								// ATM transaction information 
	DH_FILE_QUERY_FACE,  								// Face info
    DH_FILE_QUERY_FILE,                                 // file info, corresponding to NET_IN_MEDIA_QUERY_FILE and NET_OUT_MEDIAFILE_FILE
	DH_FILE_QUERY_TRAFFICCAR_EX,						// Transportation vehicle information, expand DH_FILE_QUERY_TRAFFICCAR, support more fields
    DH_FILE_QUERY_FACE_DETECTION,                       // face recognition event info MEDIAFILE_FACE_DETECTION_PARAM  and MEDIAFILE_FACE_DETECTION_INFO
} EM_FILE_QUERY_TYPE;

typedef enum _EM_RECORD_SNAP_FLAG_TYPE
{
    FLAG_TYPE_TIMING ,                  //Schele
    FLAG_TYPE_MANUAL ,                  //Manual
    FLAG_TYPE_MARKED ,                  //Important
    FLAG_TYPE_EVENT  ,                  //Event
    FLAG_TYPE_MOSAIC ,                  //Combined
    FLAG_TYPE_CUTOUT ,                  //Cut
    FLAG_TYPE_LEAVE_WORD ,              //Message
    FLAG_TYPE_TALKBACK_LOCAL_SIDE ,     //Talk Local
    FLAG_TYPE_TALKBACK_REMOTE_SIDE ,    //Talk Remote
    FLAG_TYPE_SYNOPSIS_VIDEO ,          //Compressed Video
    FLAG_TYPE_ORIGINAL_VIDEO ,          //Original Video
    FLAG_TYPE_PRE_ORIGINAL_VIDEO ,      //Processed
    FLAG_TYPE_BLACK_PLATE ,             //Blacklist Picture
    FLAG_TYPE_ORIGINAL_PIC ,            //Original Picture
    FLAG_TYPE_CARD,                     //card no. record
    FLAG_TYPE_MAX = 128, 
}EM_RECORD_SNAP_FLAG_TYPE;

// ATM trsaction type
typedef enum
{
    ATM_TRADE_ALL,                      // all types
    ATM_TRADE_ENQUIRY,                  // search
    ATM_TRADE_WITHDRAW,                 // withdraw
    ATM_TRADE_MODIFY_PASSWORD,          // change password
    ATM_TRADE_TRANSFER,                 // transfer
    ATM_TRADE_DEPOSIT,                  // deposit
    ATM_TRADE_CARDLESS_ENQUIRY,         // search without card
    ATM_TRADE_CARDLESS_DEPOSIT,         // deposit without card
    ATM_TRADE_OTHER,                    // other
}EM_ATM_TRADE_TYPE;

// card no. record info
typedef struct
{
    DWORD               dwSize;
    int                 nType;          // type, 0-Card, 1-Field
    char                szCardNo[DH_MAX_CARD_INFO_LEN]; // card no.
    EM_ATM_TRADE_TYPE   emTradeType;    // transaction type
    char                szAmount[DH_COMMON_STRING_64]; // transaction amount, nullstring means no limit amount
int                 nError;         // error code, 0-all errors, 1-retain cash, 2-retain card
    int                 nFieldCount;    // domain quantity, by domain search is valid
    char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256];   // domain info, by domain search is valid
}NET_RECORD_CARD_INFO;

#define MAX_IVS_EVENT_NUM    256

// record info, corresponde to CLIENT_FindFileEx, search condition
// support paths search in curent
typedef struct  
{
    DWORD               dwSize;                 // size 
    char*               szDirs;                 // working directory list,can inquire multiple directory at a atime,separated by ";",example "/mnt/dvr/sda0;/mnt/dvr/sda1",if szDirs==null or szDirs == "" ,means search all
    int					nMediaType;		        // file info,0:any type,1:search jpg image,2:search dav
    int                 nChannelID;             // Channel start from 0¡ê?-1 means search all channel
    NET_TIME            stuStartTime;           // start time	
    NET_TIME            stuEndTime;             // end time
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // Event type list, see intelligent analysis event type
    int                 nEventCount;            // event total
    BYTE                byVideoStream;          // video stream 0-unknown  1-main 2-sub 1 3-sub 2 4- sub 3 
    BYTE                bReserved[3];           // aligh text
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // Record or snapshot file mark, not set mark to search all files
    int                 nFalgCount;             // total mark
    NET_RECORD_CARD_INFO stuCardInfo;           // card no. record info, emFalgLists including card no. video is valid
}NET_IN_MEDIA_QUERY_FILE;

// record info, corresponde to CLIENT_FindFileEx, search result
typedef struct 
{
    char szKey[DH_COMMON_STRING_64]   ;      // Abstract name 
    char szValue[DH_COMMON_STRING_512] ;    // Abstract contents 
    BYTE bReserved[256];                     // Reserved string    
}NET_FILE_SUMMARY_INFO;
//  record infomation corresponding to DH_FILE_QUERY_FILE command when use CLIENT_FindFileEx interface
typedef struct  
{
    DWORD               dwSize;                 // size
    int					nChannelID;				// channel ID,from 0,-1 means search all
    NET_TIME			stuStartTime;			// start time
    NET_TIME			stuEndTime;				// end time
    unsigned int		nFileSize;				// size of file
    BYTE				byFileType;				// file type 1:jpg, 2: dav
    BYTE                byDriveNo;              // drive no.
    BYTE                byPartition;            // zone no.
    BYTE                byVideoStream;          // video stream 0-unknown  1-main 2-sub 1 3-sub 4-sub 
    unsigned int        nCluster;               // cluster
	char				szFilePath[MAX_PATH];	// FilePath
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // Link event list,see event intelligent analysis event type
    int                 nEventCount;            //event total
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // record or snapshot file mark 
    int                 nFalgCount;             //mark total
    unsigned int        nDriveNo;               // disk driver number
    char szSynopsisPicPath[DH_COMMON_STRING_512];              // Snap file path when pre-process the file
    int                 nSynopsisMaxTime;                      // Video synopsis max time. Unit is second. 
    int                 nSynopsisMinTime;                      // Video synopsis min time. Unit is second. 
    int                     nFileSummaryNum;                                // ÎÄ¼þÕªÒªÐÅÏ¢Êý
    NET_FILE_SUMMARY_INFO   stFileSummaryInfo[MAX_FILE_SUMMARY_NUM];        // ÎÄ¼þÕªÒªÐÅÏ¢    
}NET_OUT_MEDIA_QUERY_FILE;

//The corresponding search criteria of  DH_MEDIA_QUERY_TRAFFICCARtypedef struct  
typedef struct
{
	int					nChannelID;						// The channel number begins with 0. -1 is to search information of all channels .
	NET_TIME			StartTime;						// Start time 	
	NET_TIME			EndTime;						// End time 
	int					nMediaType;						// File type:0=search any type.1=search jpg file
	int					nEventType;						// Event type,please refer to Intelligent Analytics Event Type. 0 means search any event. 
	char				szPlateNumber[32];				// Vehicle plate. "\0" is to search any plate number.
	int					nSpeedUpperLimit;				// The searched vehicle speed range. Max speed unit is km/h
	int					nSpeedLowerLimit;				// The searched vehicle speed range. Min speed unit is km/h
	BOOL				bSpeedLimit;					// Search according to the speed or not.  TRUE: search according to the speed.nSpeedUpperLimit and nSpeedLowerLimit is valid.
    DWORD				dwBreakingRule;					// Illegal type:
														// When event type is EVENT_IVS_TRAFFICGATE
														//		bit1: Retrograde;   bit2: Overline; 
														//		bit3: Overspend; 	bit4:Under speed; 
														//		bit5: RunRedLight;
														// When event type is EVENT_IVS_TRAFFICJUNCTION
														//		bit1: RunRedLight;  bit2: WrongLan;  
														//		bit3: Retrograde; 	bit4:UTurn;
														//	    bit5: Overline;
	char                szPlateType[32];                // plate type,"Unknown" ,"Normal" ,"Yellow" ,"DoubleYellow" ,"Police" "Armed" 
	char                szPlateColor[16];               // plate color, "Blue","Yellow", "White","Black"
	char				szVehicleColor[16];		        // vehicle color:"White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
	char				szVehicleSize[16];		        // vehicle type:"Light-duty";"Medium"; "Oversize"
	int                 nGroupID;                       // id of event group(it works when >= 0)
	short               byLane;                         // lane number(it works when >= 0)
	BYTE				byFileFlag;						// file flag, 0xFF-use nFileFlagEx, 0-all record, 1-timing file, 2-manual, 3-event, 4-important, 5-mosaic
	BYTE				byRandomAccess;                 // The need for random jumps in the query process, 0 - no need 1 - need
	int					nFileFlagEx;					// file flag, bit0-timing, bit1-manual, bit2-event, bit3-important, bit4-mosaic, 0xFFFFFFFF-all
	int					nDirection;				        // direction(to the direction of car)	0-north 1-northeast 2-east 3-southeast 4-south 5-southwest 6-west 7-northwest 8-unknown -1-all directions
	char*               szDirs;                         // working directory list,can inquire multiple directory at a atime,separated by ";",example "/mnt/dvr/sda0;/mnt/dvr/sda1",if szDirs==null or szDirs == "" ,means search all
	int*                pEventTypes;                    // Check the event type to be an array of pointers, event type, see "intelligent analysis event type", if the query is NULL considered all events (buffer required to apply by the user)
	int                 nEventTypeNum;                  // Event Type array size
	char*				pszDeviceAddress;               // Device address, NULL indicates that the field does not work
	char*				pszMachineAddress;				// Machine deployment locations, NULL indicates that the field does not work
	char*				pszVehicleSign;					// Vehicle identification, such as "Unknown" - unknown, "Audi" - Audi, "Honda" - Honda ... NULL indicates that the field does not work
	int					bReserved[32];					// Reserved field for future extension.
} MEDIA_QUERY_TRAFFICCAR_PARAM;


// The media file information searched by DH_MEDIA_QUERY_TRAFFICCAR
typedef struct
{
    unsigned int		ch;						// Channel number
    char				szFilePath[128];		// File path 
    unsigned int		size;					// File length 
    NET_TIME			starttime;				// Start time
    NET_TIME			endtime;				// End time
    unsigned int		nWorkDirSN;				// Working directory serial number									
	BYTE				nFileType;				// File type.  1:jpg file
	BYTE                bHint;					// File location index
	BYTE                bDriveNo;               // drive number
	BYTE                bReserved2;
	unsigned int        nCluster;               // cluster number
	BYTE				byPictureType;			// flags
	BYTE                bReserved[3];           // Reserved field for future extension. 

	//The following contents is the vehicle information 
	char				szPlateNumber[32];		// Vehicle plate number
	char				szPlateType[32];		// Plate type: "Unknown" =Unknown; "Normal"=Blue and black plate. "Yellow"=Yellow plate. "DoubleYellow"=Double-layer yellow plate 
												// "Police"=Police plate ; "Armed"= =Military police plate; "Military"=Army plate; "DoubleMilitary"=Army double-layer 
												// "SAR" =HK SAR or Macao SAR plate; "Trainning" =rehearsal plate; "Personal"=Personal plate; "Agri"=Agricultural plate
												// "Embassy"=Embassy plate; "Moto"=Moto plate ; "Tractor"=Tractor plate; "Other"=Other plate 
	char				szPlateColor[16];		// Plate color:"Blue","Yellow", "White","Black"
	char				szVehicleColor[16];		// Vehicle color:"White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
	int					nSpeed;					// Speed. The unit is Km/H
	int					nEventsNum;				// Activation event amount 
	int					nEvents[32];			// Activation event list. The number refers to the corresponding event. Please refer to Intelligent Analytics Event Type.		
	DWORD				dwBreakingRule;			// Detailed offense type subnet mask. The first bit means redlight offense, the second bit is illegal straight/left-turn/right-turn driving. 
	                                            // The third bit is the wrong way driving; the four bit is illegal U-turn. Otherwise default value is intersection accident. 
	char				szVehicleSize[16];		// Vehicle type:"Light-duty"=small;"Medium"=medium; "Oversize"=large
	char				szChannelName[DH_CHAN_NAME_LEN];// Local or remote channel name
	char				szMachineName[DH_MAX_NAME_LEN];	// Local or remote device name
	int					nSpeedUpperLimit;	    // up limit of speed, km/h
	int					nSpeedLowerLimit;		// lower limit of speed km/h	
	int                 nGroupID;               // id of event group
	BYTE                byCountInGroup;         // total count of the event group
	BYTE                byIndexInGroup;         // the index of this event
	BYTE                byLane;                 // lane number
	BYTE                bReserved1[21];			// reserved
    NET_TIME            stSnapTime;             // snap time
	int					nDirection;				// direction,MEDIA_QUERY_TRAFFICCAR_PARAM
	char                szMachineAddress[MAX_PATH]; // machine address
} MEDIAFILE_TRAFFICCAR_INFO, *LPMEDIAFILE_TRAFFICCAR_INFO;

// DH_MEDIA_QUERY_TRAFFICCAR_EX Corresponding query
typedef struct tagMEDIA_QUERY_TRAFFICCAR_PARAM_EX
{
	DWORD				dwSize;
	MEDIA_QUERY_TRAFFICCAR_PARAM stuParam;	        	// The basic query parameters
} MEDIA_QUERY_TRAFFICCAR_PARAM_EX;

// DH_MEDIA_QUERY_TRAFFICCAR_EX Check out the file information
typedef struct tagMEDIAFILE_TRAFFICCAR_INFO_EX
{
	DWORD				dwSize;
	MEDIAFILE_TRAFFICCAR_INFO stuInfo;			        // Basic Information
	char				szDeviceAddr[DH_COMMON_STRING_256];	// Device Address
	char				szVehicleSign[DH_COMMON_STRING_32];	// Vehicle identification, such as "Unknown" - unknown, "Audi" - Audi, "Honda" - Honda ..
    char                szCustomParkNo[DH_COMMON_STRING_64];    // self defined parking space number¡ê¡§for parking¡ê?
} MEDIAFILE_TRAFFICCAR_INFO_EX;

// FINDNEXT Find input parameter
typedef struct __NET_FINDNEXT_RESERVED
{
	DWORD               dwSize;                 // Structure size
	
	unsigned int        nBeginNumber;           // Search begin number, start from begin number, 0<=beginNumber<= totalCount-1
}NET_FINDNEXT_RESERVED;

// Enquiry jump condition
typedef struct __NET_FINDING_JUMP_OPTION_INFO
{
	DWORD           dwSize;
	int             nOffset;                            // Query results offset relative to the first query results position offset current query
}NET_FINDING_JUMP_OPTION_INFO;

// DH_FILE_QUERY_FACE Corresponding face recognition service search parameter
typedef struct __MEDIAFILE_FACERECOGNITION_PARAM
{
	DWORD               dwSize;                 // Structure size

	// Search filter criteria
   	NET_TIME			stStartTime;			       // start time 
    NET_TIME			stEndTime;				       // closing time
	char                szMachineAddress[MAX_PATH];    // Place to support fuzzy matching
	int                 nAlarmType;                    // To query the type of alarm, see EM_FACERECOGNITION_ALARM_TYPE
    BOOL                abPersonInfo;                   // staff info is valid or not
    FACERECOGNITION_PERSON_INFO stPersonInfo;           // staff info
    int                 nChannelId;                     // channel no.  
    int                 nGroupIdNum;                    // staff group  
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID 
}MEDIAFILE_FACERECOGNITION_PARAM;

typedef struct  tagDH_PIC_INFO_EX
{
	DWORD                dwSize;                        // structure size
	DWORD                dwFileLenth;                   // file size,unit:bite
	char                 szFilePath[MAX_PATH];          // file path   
}DH_PIC_INFO_EX;

typedef struct __NET_CANDIDAT_PIC_PATHS
{
	DWORD                dwSize;                        // structure size
	int                  nFileCount;                    // actual file amount
	DH_PIC_INFO_EX       stFiles[DH_MAX_PERSON_IMAGE_NUM];// file information
}NET_CANDIDAT_PIC_PATHS;

// corresponding facial recognition service  DH_FILE_QUERY_FACE FINDNEXT search returned parameter
typedef struct __MEDIAFILE_FACERECOGNITION_INFO
{
	DWORD               dwSize;                                   // Structure size
	BOOL                bGlobalScenePic;                          // The existence panorama
	DH_PIC_INFO_EX      stGlobalScenePic;                         // Panoramic image file path
	DH_MSG_OBJECT		stuObject;						          // the target face object information
	DH_PIC_INFO_EX      stObjectPic;                              // the target face file path
	int                 nCandidateNum;                            // Face Matching the current number of candidates
    CANDIDATE_INFO      stuCandidates[DH_MAX_CANDIDATE_NUM];      // Face candidates to match this informatio
	NET_CANDIDAT_PIC_PATHS stuCandidatesPic[DH_MAX_CANDIDATE_NUM];// The current face matching candidates to the image file path
	NET_TIME            stTime;                                   // time for an alarm
	char                szAddress[MAX_PATH];                      // Place for an alarm
    int                 nChannelId;                               // channel no.   
}MEDIAFILE_FACERECOGNITION_INFO; 

typedef enum __EM_FACEPIC_TYPE
{
    NET_FACEPIC_TYPE_UNKOWN,            // unknown type
    NET_FACEPIC_TYPE_GLOBAL_SENCE,      // face full size picture
    NET_FACEPIC_TYPE_SMALL,             // face small pictrure
}EM_FACEPIC_TYPE;

#define  NET_MAX_FRAMESEQUENCE_NUM     2
#define  NET_MAX_TIMESTAMP_NUM         2

typedef struct __MEDIAFILE_FACE_DETECTION_DETAIL_PARAM
{
    DWORD               dwSize;
    DWORD               dwObjectId;                     // object ID
    DWORD               dwFrameSequence;                // frame no.
    NET_TIME_EX         stTime;                         // time
}MEDIAFILE_FACE_DETECTION_DETAIL_PARAM;
 
// DH_FILE_QUERY_FACE_DETECTION corresponding face recognition service search parameter
typedef struct __MEDIAFILE_FACE_DETECTION_PARAM
{
    DWORD               dwSize;                         //  structure size
    
    // search filter
    int                 nChannelID;                     // channel no.
    NET_TIME            stuStartTime;                   // start time
    NET_TIME            stuEndTime;                     // end time
    EM_FACEPIC_TYPE     emPicType;                      // picture type¡ê?see  EM_FACEPIC_TYPE
    BOOL                bDetailEnable;                  // if has detailed info
    MEDIAFILE_FACE_DETECTION_DETAIL_PARAM stuDetail;    // parameter detailed info

}MEDIAFILE_FACE_DETECTION_PARAM;

// DH_FILE_QUERY_FACE_DETECTIONcorresponding face recognition service FINDNEXT search return parameter
typedef struct __MEDIAFILE_FACE_DETECTION_INFO
{
    DWORD               dwSize;                                     //  structure size

    unsigned int        ch;                                         // channel no.
    char                szFilePath[128];                            // file path
    unsigned int        size;                                       // file length
    NET_TIME            starttime;                                  // start time
    NET_TIME            endtime;                                    // end time
    unsigned int        nWorkDirSN;                                 // working directory no.                                    
    BYTE                nFileType;                                  // file type  1¡êojpg picture
    BYTE                bHint;                                      // file positioning index
    BYTE                bDriveNo;                                   // disk no.
    BYTE                byPictureType;                              // picture type, 0-normal, 1-combined, 2-cut
    unsigned int        nCluster;                                   // cluster no.
    
    EM_FACEPIC_TYPE     emPicType;                                  // picture type¡ê?see EM_FACE_PIC_TYPE
    DWORD               dwObjectId;                                 // object ID
    DWORD               dwFrameSequence[NET_MAX_FRAMESEQUENCE_NUM]; // frame no.,group has two elements¡ê?one means small picture¡ê?two means large picture
    int                 nFrameSequenceNum;                          // frame no.quantity 
    NET_TIME_EX         stTimes[NET_MAX_TIMESTAMP_NUM];             // time¡ê?group has two elements¡ê?one means small picture¡ê?two means large picture
    int                 nTimeStampNum;
    int                 nPicIndex;                                  // Picture number in the cluster
                                                                    // For packaged multiple images in the same cluster,provides indexed mode to position pictures
}MEDIAFILE_FACE_DETECTION_INFO;

// query video synopsis param
typedef struct __MEDIA_QUERY_VIDEOSYNOPSIS_PARAM
{
	DWORD               dwSize;
	NET_TIME			StartTime;						// start time	
	NET_TIME			EndTime;						// end time
	int					nMediaType;						// file type,0:arbitrariness,1:image,2:record
	int                 nQueryType;                     // query type,1:source video file 2:reduce video file
}MEDIA_QUERY_VIDEOSYNOPSIS_PARAM;

typedef struct __MEDIAFILE_VIDEOSYNOPSIS_INFO
{
    char				szFilePath[128];		// file path
    unsigned int		size;					// file size
    NET_TIME			starttime;				// start time
    NET_TIME			endtime;				// end time
    unsigned int		nWorkDirSN;				// worl dir serial number						
	BYTE				nFileType;				// file type  1:jpg
	BYTE                bHint;					// index file location
	BYTE                bDriveNo;               // drive no.
	BYTE                bReserved2;
	unsigned int        nCluster;               // cluster
	BYTE				byPictureType;			// picture type, 0-normal, 1-synthesis, 2-cutout
	BYTE                bReserved[3];           // reserved

	// video source file info
	int                nTaskID;                 // task ID
	char               szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; //video synopsis state
	int                nProgress;               // sorresponding state
	int                nObjectNum;              // object num

	// video synopsis file info
	int                nDurationTime;          // duration time (s)
}MEDIAFILE_VIDEOSYNOPSIS_INFO;
// correlate with NET_IN_SNAPSHOT, flash control,array,each element corresponding to a flash light configuration
typedef struct __NET_FLASHCONTROL
{
	DWORD				dwSize;					// struct size
	int					nMode;					// work mode 0-no flash,1-always flash,2-auto flash
}NET_FLASHCONTROL;

// Capture client type
typedef enum tagSNAP_CLIENT_TYPE
{
    SNAP_CLIENT_TYPE_COMMON,               // Corresponding to "Common" type, the default type
    SNAP_CLIENT_TYPE_PARKINGSPACE,         // Correspondence "ParkingSpace" type, parking
}SNAP_CLIENT_TYPE;

#define DH_MAX_USER_DEFINE_INFO        1024

// when nTriggerType==2, client snap info
typedef struct _NET_CLIENT_SNAP_INFO
{
	DWORD				dwSize;					// struct info 
	unsigned int        nFrameSequence;         // frame sequence
	double              PTS;                    // pts,64 bit
	char				szUserDefinedInfo[DH_MAX_USER_DEFINE_INFO];	// String, custom client, "\ 0" at the end
	SNAP_CLIENT_TYPE    emSNAP_CLIENT_TYPE;     // Client Type
	DWORD               dwRetCardNumber;        // card amount
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];  // card information
}NET_CLIENT_SNAP_INFO;

// CLIENT_TrafficSnapByNetwork's input param
typedef struct __NET_IN_SNAPSHOT
{
	DWORD				dwSize;					// struct size
	int					nTriggerType;			// trigger type	0-unknown 1-zhongmeng net trigger
	int					nLaneID;				// lane id
	int					nGroupID;				// group id
	int					nGrabTimes;				// picture number
	int					nStartPicNum;			// the start picture id
	int					nDirection;				// road direction 0-north 1-east north 2-east 3-east south 4-south 5-west south 6-west 7-west north 8-unknown
	int					nGrabWaitTime;			// pGrabWaitTime group member number
	DWORD*				pGrabWaitTime;			// interval time between two picture
	int					nLowerSpeedLimit;		// lower speed limit, km/h
	int					nUpperSpeedLimit;		// upper speed limit, km/h
	int					nSpeed;					// speed, km/h
	int					nViolationNo;			// violation number 0-not transgress
												// 1-black shit
												// 2-over speed not over 50% 
												// 3-over speed between 50% and 100% 
												// 4-over speed over 100% 
												// 5-retrograde
												// 6-run red
												// 7-under speed
												// 8-no passing,wrong route
	int					nRedLightTime;			// red light time,s
	int					nFlashControl;			// pFlashControl group member number
	NET_FLASHCONTROL*   pFlashControl;			// flash control
	DWORD				dwUser;					// user data
	NET_CLIENT_SNAP_INFO stClientInfo;          // the incoming snap parameter
}NET_IN_SNAPSHOT;

// CLIENT_TrafficSnapByNetwork's output param
typedef struct __NET_OUT_SNAPSHOT
{
	DWORD				dwSize;					// structure size
}NET_OUT_SNAPSHOT;

// interface(CLIENT_TrafficForceLightState)input parameter
typedef struct __NET_IN_FORCELIGHTSTATE
{
	DWORD				dwSize;					// struct size
	unsigned int        nDirection;             // 0 bit:"Straight",1 bit:"TurnLeft",2 bit:"TurnRight",3 bit:"U-Turn"
}NET_IN_FORCELIGHTSTATE;

// interface (CLIENT_TrafficForceLightState)output parameter
typedef struct __NET_OUT_FORCELIGHTSTATE
{
	DWORD				dwSize;					// struct size
}NET_OUT_FORCELIGHTSTATE;
// CLIENT_StartTrafficFluxStat's callback function
typedef int  (CALLBACK *fFluxStatDataCallBack)(LLONG lFluxStatHandle, DWORD dwEventType, void* pEventInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);

// CLIENT_StartTrafficFluxStat's input param
typedef struct __NET_IN_TRAFFICFLUXSTAT
{
	DWORD				dwSize;					// structure size
	fFluxStatDataCallBack		cbData;			// callback function pointer
	LDWORD				dwUser;					// user data
}NET_IN_TRAFFICFLUXSTAT;

// CLIENT_StartTrafficFluxStat's output param
typedef struct __NET_OUT_TRAFFICFLUXSTAT
{
	DWORD				dwSize;					// structure size	
}NET_OUT_TRAFFICFLUXSTAT;

// CLIENT_StartFindFluxStat's input param
typedef struct __NET_IN_TRAFFICSTARTFINDSTAT
{
	DWORD				dwSize;					// structure size
	NET_TIME			stStartTime;			// start time, temporarily  
	NET_TIME			stEndTime;				// end time, temporarily 
	int					nWaittime;				// the time to wait result
}NET_IN_TRAFFICSTARTFINDSTAT;

// CLIENT_StartFindFluxStat's output param
typedef struct __NET_OUT_TRAFFICSTARTFINDSTAT
{
	DWORD				dwSize;					// structure size
	DWORD               dwTotalCount;           // The total amount that matched current search criteria                 
}NET_OUT_TRAFFICSTARTFINDSTAT;

// CLIENT_DoFindFluxStat's input param
typedef struct __NET_IN_TRAFFICDOFINDSTAT
{
	DWORD				dwSize;					// structure size
	unsigned int		nCount;					// the number of flow Statistic for query
	int					nWaittime;				// the time to wait result
}NET_IN_TRAFFICDOFINDSTAT;

typedef struct
{
	DWORD				dwSize;					// structure size

	int					nStatInfo;				// the number of statistic info
	DH_TRAFFICFLOWSTAT *pStatInfo;				// the statistic pointer
}DH_TRAFFICFLOWSTAT_OUT;

// CLIENT_DoFindFluxStat's out param
typedef struct __NET_OUT_TRAFFICDOFINDSTAT
{
	DWORD				dwSize;					// structure size
	
	DH_TRAFFICFLOWSTAT_OUT stStatInfo;			// the statistic pointer
}NET_OUT_TRAFFICDOFINDSTAT;

// interface(CLIENT_StartFindNumberStat)'s input param
typedef struct __NET_IN_FINDNUMBERSTAT
{
	DWORD				dwSize;					// size
	int                 nChannelID;             // channel ID
	NET_TIME			stStartTime;			// start time
	NET_TIME			stEndTime;				// end time
	int                 nGranularityType;       // granularity type, 0:minute,1:hour,2:day,3:week,4:month,5:quarter,6:year
	int					nWaittime;				// wait time
}NET_IN_FINDNUMBERSTAT;

// CLIENT_StartFindNumberStat's output param
typedef struct __NET_OUT_FINDNUMBERSTAT
{
	DWORD				dwSize;					 
	DWORD               dwTotalCount;           // total count
}NET_OUT_FINDNUMBERSTAT;

// CLIENT_DoFindNumberStat's input param
typedef struct __NET_IN_DOFINDNUMBERSTAT
{
	DWORD				dwSize;					 
	unsigned int        nBeginNumber;           // [0, totalCount-1]
	unsigned int		nCount;					// count
	int					nWaittime;				// wait time
}NET_IN_DOFINDNUMBERSTAT;

typedef struct __DH_NUMBERSTAT
{
	DWORD    dwSize;
	int      nChannelID;                           // channel id
	char     szRuleName[DH_CHAN_NAME_LEN];         // rule name
	NET_TIME stuStartTime;                         // start time
	NET_TIME stuEndTime;                           // end time
    int      nEnteredSubTotal;                     // entered total
	int      nExitedSubtotal;                      // entered total
    int      nAvgInside;                           // average number inside
	int      nMaxInside;                           // max number inside
    int      nEnteredWithHelmet;                   //people enter with helmet count
    int      nEnteredWithoutHelmet;                //people enter without helmet count
    int      nExitedWithHelmet;                    //people exit with helmet count
    int      nExitedWithoutHelmet;                 //people exit without helmet count
}DH_NUMBERSTAT;

// CLIENT_DoFindNumberStat's ouput param
typedef struct __NET_OUT_DOFINDNUMBERSTAT
{
	DWORD				dwSize;					             
	int                 nCount;                              // count
	DH_NUMBERSTAT       *pstuNumberStat;                     // state array
    int                 nBufferLen;                          
}NET_OUT_DOFINDNUMBERSTAT;

// video statistical subtotal
typedef struct tagNET_VIDEOSTAT_SUBTOTAL 
{
    int                 nTotal;                         // count since device operation
    int                 nHour;                          // count in the last hour
    int                 nToday;                         // count for today
    char                reserved[256];
} NET_VIDEOSTAT_SUBTOTAL;

// video statistical summary
typedef struct tagNET_VIDEOSTAT_SUMMARY
{
    int                     nChannelID;                 // channel ID
    char                    szRuleName[32];             // rule name
    NET_TIME_EX             stuTime;                    // time of this statistics
    NET_VIDEOSTAT_SUBTOTAL  stuEnteredSubtotal;         // subtotal for the entered
    NET_VIDEOSTAT_SUBTOTAL  stuExitedSubtotal;          // subtotal for the exited
    char                    reserved[512];
} NET_VIDEOSTAT_SUMMARY;

// video statistical summary callback function type, lAttachHandle is the return value of CLIENT_AttachVideoStatSummary
typedef void (CALLBACK *fVideoStatSumCallBack) (LLONG lAttachHandle, NET_VIDEOSTAT_SUMMARY* pBuf, DWORD dwBufLen, LDWORD dwUser);

// input param for CLIENT_AttachVideoStatSummary
typedef struct tagNET_IN_ATTACH_VIDEOSTAT_SUM
{
    DWORD                   dwSize;
    int                     nChannel;                    // video channel ID       
    fVideoStatSumCallBack   cbVideoStatSum;              // video statistical summary callback
    DWORD                   dwUser;                      // user data             
} NET_IN_ATTACH_VIDEOSTAT_SUM;

// output param for CLIENT_AttachVideoStatSummary
typedef struct tagNET_OUT_ATTACH_VIDEOSTAT_SUM
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_VIDEOSTAT_SUM;

//// intelligent traffic detector

// CLIENT_GetParkingSpaceStatus's input param
typedef struct tagNET_IN_GET_PARKINGSPACE_STATUS
{
	DWORD                dwSize;                         // struct size
	DWORD                dwWaitTime;                     // wait time
	int                  nChannelID;                     // channel ID
	int *                pLaneID;                        // range[0,255], pLaneID==NULL means all parking space, the max number is DH_PRODUCTION_DEFNITION.nMaxRoadWays
	int                  nLaneCount;                     // apply to sizeof(int)*nLaneCount memory
} NET_IN_GET_PARKINGSPACE_STATUS;

typedef struct tagNET_LANE_PARKINGSPACE_STATUS
{
	DWORD                dwSize;                         // struct size
	int                  nLaneID;                        // lane ID
	unsigned int         nPictureId;                     // picture ID,get picture data
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;      // traffic car info
} NET_LANE_PARKINGSPACE_STATUS;

// CLIENT_GetParkingSpaceStatus's output param
typedef struct tagNET_OUT_GET_PARKINGSPACE_STATUS
{
	DWORD                dwSize;                         // struct size
	NET_LANE_PARKINGSPACE_STATUS* pStatus;               // status
	int                  nMaxStatus;                     // need apply to sizeof(NET_LANE_PARKINGSPACE_STATUS)*nMaxStatus, and nMaxStatus == DH_PRODUCTION_DEFNITION.nMaxRoadWays memory
	int                  nRetStatus;                     // actual returns status number of parking spaces
} NET_OUT_GET_PARKINGSPACE_STATUS;

// CLIENT_AttachParkingSpaceData's input param
typedef struct tagNET_CB_PARKINGSPACE_DATA
{
	DWORD                dwSize;                         // struct size
	void*                pPicBuffer;                     // image binary data
	unsigned int         nPicLength;                     // picture length
} NET_CB_PARKINGSPACE_DATA;

// CLIENT_AttachParkingSpaceData callback function , pBuf is json and image data info , nBufLen is pBuf length,for forwarding services
typedef int (CALLBACK *fNotifySnapData)(LLONG lParkingHandle, NET_CB_PARKINGSPACE_DATA* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachParkingSpaceData's input param
typedef struct tagNET_IN_ATTACH_PARKINGSPACE
{
	DWORD                dwSize;                         // struct size
	DWORD                dwWaitTime;                     // wait time
	int                  nChannelID;                     // channel ID
	unsigned int         nPictureId;                     // picture ID, can look for NET_LANE_PARKINGSPACE_STATUS.nPictureId
	
	fNotifySnapData      cbNotifySnapData;               // callback function
	LDWORD               dwUser;                         // user-defined parameters
} NET_IN_ATTACH_PARKINGSPACE;


//NET_CAR_PASS_INFOS related enumerated type
typedef enum tagNET_CAR_SIZE
{
    CAR_SIZE_UNKNOWN  = 0 ,     //unknown
    CAR_SIZE_SAMLL        ,     //small car
    CAR_SIZE_BIG          ,     //big car 
}NET_CAR_SIZE;

typedef enum tagNET_CAR_ACTION
{
    CAR_ACTION_UNKNOWN = 0 , 
    CAR_ACTION_ENTER       ,  //Enter the detection area
    CAR_ACTION_LEAVE       ,  //Leave the detection area
}NET_CAR_ACTION;


//CLIENT_AttachCarPassInfo callback function returns the structure of the car pass information typedef struct tagNET_CAR_PASS_INFO
typedef struct tagNET_CAR_PASS_INFO
{
     DWORD                dwSize; 
       
     DWORD                nID;                              // Car ID
     DWORD                nLaneNumber;                      // Start from0,for example, if there is 3 lane, the number of the lane is 0 1 2 respectively
     DWORD                nRoadwayNumber;                   // Custom lane number, User configurable lane number, the current value in the range of 1-16
     DWORD                nSpeed;                           // Car speed (km/h)
     NET_CAR_SIZE         emCarSize;                        // Car size type
     NET_CAR_ACTION       emCarAction;                      // Car action type
     NET_TIME_EX          stuTime;                          // Action happens time,accurate to seconds
}NET_CAR_PASS_INFO;

// Port CLIENT_AttachCarPassInfo callback function
// nInfoNum the number of car pass information
// pstuCarPassInfos the array of car pass information number
typedef int (CALLBACK *fNotifyCarPassInfo)(LLONG lCarPassHandle, NET_CAR_PASS_INFO* pstuCarPassInfos,  int nInfoNum ,   LDWORD dwUser);

// Port CLIENT_AttachCarPassInfo input parameter
typedef struct tagNET_IN_ATTACH_CAR_PASS_INFO
{
    DWORD                dwSize;                         // he size of the structure is too small,should be assigned
    int                  nChannelID;                     // Channel ID

    fNotifyCarPassInfo   cbNotifyCarPassInfo;            // Callback function, when thereis a car information,a callback to the top
    LDWORD               dwUser;                         // User-defined parameters
}NET_IN_ATTACH_CAR_PASS_INFO;

//Port CLIENT_AttachCarPassInfo output parameter
typedef struct tagNET_OUT_ATTACH_CAR_PASS_INFO
{
    DWORD       dwSize;         // The size of the structure is too small,should be assigned
}NET_OUT_ATTACH_CAR_PASS_INFO;

// CLIENT_AttachParkingSpaceData's output param
typedef struct tagNET_OUT_ATTACH_PARKINGSPACE
{
	DWORD                dwSize;                         // struct size
} NET_OUT_ATTACH_PARKINGSPACE;

// CLIENT_DetachParkingSpaceData's input param
typedef struct tagNET_IN_DETACH_PARKINGSPACE
{
	DWORD                dwSize;                         // struct size
	DWORD                dwWaitTime;                     // wait time
	LLONG                lParkingHandle;                 // CLIENT_AttachParkingSpaceData return handle
} NET_IN_DETACH_PARKINGSPACE;
// CLIENT_DetachParkingSpaceData's output param
typedef struct tagNET_OUT_DETACH_PARKINGSPACE
{
	DWORD                dwSize;                         // struct size
} NET_OUT_DETACH_PARKINGSPACE;

// Batch download file

// Download progress callback function prototypes¡ê? nError Indicates that an error occurred during the download of¡ê?1-insufficient buffer¡ê?2-parity errof of return data¡ê?3-failed to download current file¡ê?4-failed to create corresponding storage file
// When download according to the file,ID setting by the User is dwFileID, When download according to the conditions,ID setting by the User is dwConditionID                    
typedef void (CALLBACK *fMultiFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);

//Ways to download file
typedef enum tagEM_DOWNLOAD_FILE_TYPE
{
   EM_DOWNLOAD_BY_FILENAME = 0      ,       //Download according to file name
   EM_DOWNLOAD_BY_CONDITION         ,       //Download according to query conditions
}EM_DOWNLOAD_FILE_TYPE;

//Download time type
typedef enum tagEM_DOWNLOAD_TIME_TYPE
{
    EM_DOWNLOAD_TIME_SNAP = 0       ,         //¡Á£¤??¨º¡À??
    EM_DOWNLOAD_TIME_STORAGE        ,         //Storage time
}EM_DOWNLOAD_TIME_TYPE;

//Download data type
typedef enum tagEM_DOWNLOAD_DATA_TYPE
{
    EM_DOWNLOAD_DATA_RECORD = 0 ,               //Record
    EM_DOWNLOAD_DATA_PICTURE ,                  //Picture
}EM_DOWNLOAD_DATA_TYPE;

// CLIENT_DownLoadMultiFile  port parameter
typedef struct tagNET_DOWNLOADFILE_INFO
{
	DWORD               dwSize;
	DWORD               dwFileID;                       // Document ID, assigned by the user
	int                 nFileSize;                      // Query to the file size
	char                szSourceFilePath[MAX_PATH];     // Query to the file path
	char                szSavedFileName[MAX_PATH];      // Save the file path
}NET_DOWNLOADFILE_INFO;

typedef struct tagNET_DOWNLOAD_CONDITION_INFO
{
    DWORD                   dwSize;
    DWORD                   dwConditionID;                  // Condition ID, assign by the User
    int                     nChannel;                       // Channel ID
    NET_TIME                stuStartTime;                   // Start time
    NET_TIME                stuEndTime;                     // End time
    EM_DOWNLOAD_TIME_TYPE   emTimeType;                     // Time type
    EM_DOWNLOAD_DATA_TYPE   emDataType;                     // Data type 
    char                    szSavedFileName[MAX_PATH];      //Save the file path
}NET_DOWNLOAD_CONDITION_INFO;

typedef struct tagNET_IN_DOWNLOAD_MULTI_FILE
{
	DWORD               dwSize;
    // Download according to file name
    int                 nFileCount;                     // The number of files to be downloaded
	NET_DOWNLOADFILE_INFO* pFileInfos;                  // File information to be downloaded
    
	fMultiFileDownLoadPosCB cbPosCallBack;              // Progress callback function
	LDWORD              dwUserData;                     // User data
    EM_DOWNLOAD_FILE_TYPE           emDownloadType;             // Download ways
    //Download according to query conditions
    int                             nConditionCount;             // Number of download conditions,emDownloadType is EM_DOWNLOAD_BY_CONDITION valid
    NET_DOWNLOAD_CONDITION_INFO*    pConditionInfos;             // Download conditions,emDownloadType is EM_DOWNLOAD_BY_CONDITION valid      
}NET_IN_DOWNLOAD_MULTI_FILE;

typedef struct tagNET_OUT_DOWNLOAD_MULTI_FILE
{
	DWORD               dwSize;
	LLONG               lDownLoadHandle;                // Download the handle
}NET_OUT_DOWNLOAD_MULTI_FILE;

typedef struct __NET_VIDEOANALYSE_STATE
{
	DWORD              dwSize;
	DWORD              dwProgress;                   // Analysis of progress¡ê?0-100
	char               szState[DH_COMMON_STRING_64]; // Channel Status,Running"¡êoRun¡ê?"Stop"¡êoStop¡ê?"NoStart"¡êoNot started¡ê?"Failed"¡êofailed ¡ê?"Successed"¡êosuccessed
	char               szFailedCode[DH_COMMON_STRING_64]; // Error code
}NET_VIDEOANALYSE_STATE;

//Real-time video analysis progress status callbacks
typedef int (CALLBACK *fVideoAnalyseState)(LLONG lAttachHandle, NET_VIDEOANALYSE_STATE* pAnalyseStateInfos, LDWORD dwUser, void* pReserved);

// CLIENT_AttachVideoAnalyseState  Interface input parameters
typedef struct __NET_IN_ATTACH_VIDEOANALYSE_STATE 
{
	DWORD              dwSize;
	int                nChannleId;            // Channel number
	fVideoAnalyseState cbVideoAnalyseState;   // Video analysis status callback function
	LDWORD             dwUser;                //User Information
}NET_IN_ATTACH_VIDEOANALYSE_STATE;

// CLIENT_AttachVideoAnalyseState  Interface output parameters
typedef struct __NET_OUT_ATTACH_VIDEOANALYSE_STATE 
{
	DWORD              dwSize;
	LLONG              lAttachHandle;         // Analysis of the progress of the analysis progress handle that uniquely identifies a particular channel
}NET_OUT_ATTACH_VIDEOANALYSE_STATE;

// Bidirectional talk status 
typedef enum tagEM_TALK_STATE
{
    EM_TALK_STATE_UNKNOWN,                 // Unknown 
    EM_TALK_STATE_INVITING,                // Caller 
    EM_TALK_STATE_RINGING,                 // Callee
    EM_TALK_STATE_ANSWER,                  // Answer
    EM_TALK_STATE_REFUSE,                  // Refuse
    EM_TALK_STATE_HANGUP,                  // Hang up 
    EM_TALK_STATE_BUSYING,                 // Busy
    EM_TALK_STATE_CANCEL,                  // Cancel calling 
} EM_TALK_STATE;

#define NET_CALL_NUM_MAX           128         // Max communication No. amount 

// Bidirectional talk status of call function CLIENT_AttachTalkState
typedef struct tagNET_TALK_STATE
{
    DWORD                dwSize; 
    char                 szCallID[DH_COMMON_STRING_64];  // Call unique symbole
    int                  nAudioPort;                     // Audio port 
    int                  nVideoPort;                     // Video port 
	char                 szMediaAddr[DH_MAX_IPADDR_LEN]; // Getting stream address 
    EM_TALK_STATE        emState;                        // Status 
    int                  nNumberCount;                   // Call No. amount 
    char                 szNumbers[NET_CALL_NUM_MAX][DH_COMMON_STRING_32]; // Call No. list 
} NET_TALK_STATE;

// Call function of  CLIENT_AttachTalkState 
typedef void (CALLBACK *fNotifyTalkState)(LLONG lAttachHandle, NET_TALK_STATE* pstuState, int nLen, LDWORD dwUser);

// Input parameters of CLIENT_AttachTalkState 
typedef struct tagNET_IN_ATTACH_TALK_STATE
{
    DWORD                dwSize;                         // Structure size, must have a value 
    int                  nChnId;                         // Channel No. It is to mark bidirectional talk unit. 
    fNotifyTalkState     cbCallBack;                     // Call function. Call the upper-level when there is bidirectional talk in process. 
    LDWORD               dwUser;                         // Customized paramters 
}NET_IN_ATTACH_TALK_STATE;

// Output parameters of the CLIENT_AttachTalkState
typedef struct tagNET_OUT_ATTACH_TALK_STATE
{
    DWORD       dwSize;                                  // Structure size. Must have a value
    char        szCallID[DH_COMMON_STRING_64];           // Call unique mark 
}NET_OUT_ATTACH_TALK_STATE;

///////////////////////////////// IVS server video analysis module /////////////////////////////////
// Video analysis  report result detect type definition
#define NET_DIAGNOSIS_DITHER                    "VideoDitherDetection"                       // Video vibration detect  Corresponding structure body(NET_VIDEO_DITHER_DETECTIONRESULT)
#define NET_DIAGNOSIS_STRIATION                 "VideoStriationDetection"                    // Video stria detect  Corresponding structure body(NET_VIDEO_STRIATION_DETECTIONRESULT)
#define NET_DIAGNOSIS_LOSS                      "VideoLossDetection"                         // Video loss detect  Corresponding structure body(NET_VIDEO_LOSS_DETECTIONRESULT)
#define NET_DIAGNOSIS_COVER                     "VideoCoverDetection"                        // Camera masking detect Corresponding structure body(NET_VIDEO_COVER_DETECTIONRESULT)
#define NET_DIAGNOSIS_FROZEN                    "VideoFrozenDetection"                       // Video freeze detect Corresponding structure body(NET_VIDEO_FROZEN_DETECTIONRESULT)
#define NET_DIAGNOSIS_BRIGHTNESS                "VideoBrightnessDetection"                   // Video brightness abnormal detect Corresponding structure body(NET_VIDEO_BRIGHTNESS_DETECTIONRESULT)
#define NET_DIAGNOSIS_CONTRAST                  "VideoContrastDetection"                     // Video contrast abnormal detect  Corresponding structure body(NET_VIDEO_CONTRAST_DETECTIONRESULT)
#define NET_DIAGNOSIS_UNBALANCE                 "VideoUnbalanceDetection"                    // Video color cast detect Corresponding structure body(NET_VIDEO_UNBALANCE_DETECTIONRESULT)
#define NET_DIAGNOSIS_NOISE                     "VideoNoiseDetection"                        // Video noise detect Corresponding structure body(NET_VIDEO_NOISE_DETECTIONRESULT)
#define NET_DIAGNOSIS_BLUR                      "VideoBlurDetection"                         // Video blur detect Corresponding structure body(NET_VIDEO_BLUR_DETECTIONRESULT)
#define NET_DIAGNOSIS_SCENECHANGE               "VideoSceneChangeDetection"                  // Video scene change detect Corresponding structure body(NET_VIDEO_SCENECHANGE_DETECTIONRESULT)

typedef enum tagNET_STATE_TYPE
{
	NET_EM_STATE_ERR,        // Others
	NET_EM_STATE_NORMAL,     // "Normal"  
	NET_EM_STATE_WARNING,    // "Warning" 
	NET_EM_STATE_ABNORMAL,   // "Abnormal" 
}NET_STATE_TYPE;
// video stream type
typedef enum tagNET_STREAM_TYPE
{
	NET_EM_STREAM_ERR,                   // Others
	NET_EM_STREAM_MAIN,					// "Main"-Main stream
	NET_EM_STREAM_EXTRA_1,				// "Extra1"-Extra stream 1
	NET_EM_STREAM_EXTRA_2,				// "Extra2"-Extra stream 2
	NET_EM_STREAM_EXTRA_3,				// "Extra3"-Extra stream 3
	NET_EM_STREAM_SNAPSHOT,				// "Snapshot"-Snap bit stream
	NET_EM_STREAM_OBJECT,				// "Object"-Object stream
	NET_EM_STREAM_AUTO,                 // "Auto"
	NET_EM_STREAM_PREVIEW,              // "Preview"
	NET_EM_STREAM_NONE,					// No video stream (audio only)
}NET_STREAM_TYPE;
// Video diagnosis type
typedef enum tagNET_VIDEODIAGNOSIS_RESULT_TYPE
{
	NET_EM_ROTATION   ,					// "Rotation"	-Video analysis of polling
	NET_EM_REAL		  ,					// "Real" -Real-time video analysis
	NET_EM_NR_UNKNOW  ,					// Undefined
}NET_VIDEODIAGNOSIS_RESULT_TYPE;
//Video causes of diagnostic error
typedef enum tagNET_VIDEODIAGNOSIS_FAIL_TYPE
{
	NET_EM_NO_ERROR				 ,			// Diagnostic success
	NET_EM_DISCONNECT			 ,			// "Disconnect"				- End devices can be connected
	NET_EM_CH_NOT_EXIST			 ,			// "ChannelNotExist"		- Channel does not exist
	NET_EM_LOGIN_OVER_TIME		 ,			// "LoginOverTime"			- Login Timeout
	NET_EM_NO_VIDEO				 ,			// "NoVideo"				- No video successful login
	NET_EM_NO_RIGHT				 ,			// "NoRight"				- No operating authority
	NET_EM_PLATFROM_LOGIN_FAILED ,			// "PlatformLoginFailed"	- Login failed platform
	NET_EM_PLATFROM_DISCONNECT 	 ,			// "PlatformDisconnect"		- Disconnect platform
	NET_EM_GET_STREAM_OVER_TIME  ,			// "GetStreamOverTime"		- Get stream timeout
    NET_EM_GET_NO_ENOUGH_STREAM  ,          // "NoEnoughStream"         - no enought stream
    NET_EM_DECODE_STREAM_FAILED  ,          // "DecodeStreamFailed"     - decode stream failed
    NET_EM_GET_OFF_LINE          ,          // "OffLine"                - device offline
	NET_EM_NF_UNKNOW			 ,			// Other reasons, as detailed in the structure described in the reason for the failure 
}NET_VIDEODIAGNOSIS_FAIL_TYPE;

// General long character ended with '\0'
typedef struct tagNET_ARRAY
{
	DWORD                dwSize;                         // Current structure body size 
	char*                pArray;                         // Buffer zone. Now the min value is 260 byte.Caller shall apply for the memory. The filling in data shall ended with '\0'.
	DWORD                dwArrayLen;                     // Buffer space length
}NET_ARRAY;

// Video analysis result report general data
typedef struct tagNET_VIDEODIAGNOSIS_COMMON_INFO
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nDiagnosisID;                   // Detect channel
	NET_ARRAY            stProject;                      // Project name
	NET_ARRAY            stTask;                         // Task name
	NET_ARRAY            stProfile;                      // Parameter list name
	NET_ARRAY            stDeviceID;                     // Device unique ID
	NET_TIME             stStartTime;                    // Start time
	NET_TIME             stEndTime;                      // End time
	int                  nVideoChannelID;                // Video channel No. The channel of the front-end device such as DVR,IPC.
	NET_STREAM_TYPE      emVideoStream;                  // Video bit stream
	NET_VIDEODIAGNOSIS_RESULT_TYPE	emResultType;					// Diagnosis type
	BOOL							bCollectivityState;             // Diagnostic results
	NET_VIDEODIAGNOSIS_FAIL_TYPE	emFailedCause;					// Reasons for failure
	char                            szFailedCode[DH_COMMON_STRING_64]; // Describe the reason for the failure
    char                            szResultAddress[DH_COMMON_STRING_128];  // Diagnosis result storage address
    int                             nFrameRate;                             // Frame Rate(kb/s)  update by day
    int                             nFrameWidth;                            // Frame Width       update by day
    int                             nFrameHeight;                           // Frame Height      update by day
}NET_VIDEODIAGNOSIS_COMMON_INFO;

// The result of detect type (NET_DIAGNOSIS_DITHER)  Video vibration detect -- Video change,wind or vibration,rotation including the PTZ movement.
typedef struct tagNET_VIDEO_DITHER_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status  Usually smaller than is normal. Larger than is abnormal and the value in the middle is warning. 
	int                  nDuration;                      // Status lasts time  Detect item last time. It is null right now. 
}NET_VIDEO_DITHER_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_STRIATION) Video stria detect  -- There is abnormal stria on the camera resulting from the interference.
typedef struct tagNET_VIDEO_STRIATION_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_STRIATION_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_LOSS) Video loss detect  -- Result from power failure or disconnection.
typedef struct tagNET_VIDEO_LOSS_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_LOSS_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_COVER) Camera masking detect -- The camera masking occurred
typedef struct tagNET_VIDEO_COVER_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_COVER_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_FROZEN) Video freeze detect -- The video idles for specified time is regarded as freeze.
typedef struct tagNET_VIDEO_FROZEN_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_FROZEN_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_BRIGHTNESS) Video brightness abnormal detect --The following contents are some camera improper setup detect.
typedef struct tagNET_VIDEO_BRIGHTNESS_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_BRIGHTNESS_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_CONTRAST) Video contrast abnormal detect
typedef struct tagNET_VIDEO_CONTRAST_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_CONTRAST_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_UNBALANCE) Video color cast detect
typedef struct tagNET_VIDEO_UNBALANCE_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_UNBALANCE_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_NOISE) Video noise detect
typedef struct tagNET_VIDEO_NOISE_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_NOISE_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_BLUR) Video blur detect
typedef struct tagNET_VIDEO_BLUR_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_BLUR_DETECTIONRESULT;

// The result of detect type (NET_DIAGNOSIS_SCENECHANGE) Video scene change detect
typedef struct tagNET_VIDEO_SCENECHANGE_DETECTIONRESULT
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nValue;                         // Detect result value 
	NET_STATE_TYPE       emState;                        // Detect result status
	int                  nDuration;                      // Status lasts time
}NET_VIDEO_SCENECHANGE_DETECTIONRESULT;

typedef struct tagNET_DIAGNOSIS_RESULT_HEADER
{
	DWORD                dwSize;                         // Current structure body size 
	
	char                 szDiagnosisType[MAX_PATH];      // Analysis type. Please refer to dhnetsdk.h for "video analysis report result type definition"  such as NET_DIAGNOSIS_DITHER
	int                  nDiagnosisTypeLen;              // The structure body size of current analysis type
}NET_DIAGNOSIS_RESULT_HEADER;

// cbVideoDiagnosis Call parameter type
typedef struct tagNET_REAL_DIAGNOSIS_RESULT
{
	DWORD                dwSize;                         // Current structure body size 
	
    NET_VIDEODIAGNOSIS_COMMON_INFO* pstDiagnosisCommonInfo;  //Video analysisi general info
	
	int					 nTypeCount;					 // Analysis result data analysis type amount
	void*                pDiagnosisResult;               // The analysis result data for once. The format is as NET_DIAGNOSIS_RESULT_HEADER+analysis type1+NET_DIAGNOSIS_RESULT_HEADER+analysis type 2+...
	DWORD                dwBufSize;                      // Buffer length
}NET_REAL_DIAGNOSIS_RESULT;

// Video analysis result report call function
typedef int (CALLBACK *fRealVideoDiagnosis)(LLONG lDiagnosisHandle, NET_REAL_DIAGNOSIS_RESULT* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);

//The input parameter of interface  CLIENT_StartVideoDiagnosis
typedef struct tagNET_IN_VIDEODIAGNOSIS
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nDiagnosisID;                   // Video analysis ID begins with 0
	DWORD                dwWaitTime;                     // Interface time out waiting time
	
	fRealVideoDiagnosis  cbVideoDiagnosis;               // Video analysis result call function.
	LDWORD                dwUser;                         // User customized parameter
}NET_IN_VIDEODIAGNOSIS;

// The output parameter of interface CLIENT_StartVideoDiagnosis 
typedef struct tagNET_OUT_ATTACH_REALDIAGNOSIS
{
	DWORD                dwSize;                         // Current structure body size 
	LLONG                 lDiagnosisHandle;               // Subscribe handle
}NET_OUT_VIDEODIAGNOSIS;

// The input parameter of interface CLIENT_StartFindDiagnosisResult 
typedef struct tagNET_IN_FIND_DIAGNOSIS
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nDiagnosisID;                   // Video analysis ID begins with 0
	DWORD                dwWaitTime;                     // Interface time out waiting time
	
	NET_ARRAY            stuDeviceID;                    // Device unique ID.pArray:NULL means does not search by device ID.
	NET_TIME             stuStartTime;                   // Start time
	NET_TIME             stuEndTime;                     // End time
	int                  nVideoChannel;                  // Video channel No.,-1: All channel No.
	int                  nTypeCount;                     // Analysis type amount.0:Do not use analysis type to search.
	NET_ARRAY*           pstDiagnosisTypes;              // Analysis type array. It is the analysis type to be searched. 
	char                 szProjectName[MAX_PATH];        // Project name
} NET_IN_FIND_DIAGNOSIS;

// The output parameter of interface CLIENT_StartFindDiagnosisResult
typedef struct tagNET_OUT_FIND_DIAGNOSIS
{
	DWORD                dwSize;                         // Current structure body size 
	LLONG                 lFindHandle;                    // Search handle
	DWORD                dwTotalCount;                   // The total amount that matched the criteria
}NET_OUT_FIND_DIAGNOSIS;

// The input parameter of interface CLIENT_DoFindDiagnosisResult 
typedef struct tagNET_IN_DIAGNOSIS_INFO
{
	DWORD                dwSize;                         // Current structure body size 
	int                  nDiagnosisID;                   // Video analysis ID begins with 0
	DWORD                dwWaitTime;                     // Interface time out waiting time
	
	int                  nFindCount;                     // The video analysis result amount of each search
	int                  nBeginNumber;                   // Search initial SN 0<=beginNumber<= totalCount-1
}NET_IN_DIAGNOSIS_INFO;

// CLIENT_StartRealTimeProject Interface input parameters
typedef struct tagNET_IN_START_RT_PROJECT_INFO
{
	DWORD                dwSize;                         // This structure size
	char*                pszProjectInfo;                 // Real-time schedule information by calling dhconfigsdk.dll get the package in the interface CLIENT_PacketData
                            	                         // Package command corresponding CFG_CMD_VIDEODIAGNOSIS_REALPROJECT                      
}NET_IN_START_RT_PROJECT_INFO;

// CLIENT_StartRealTimeProject Interface output parameters
typedef struct tagNET_OUT_START_RT_PROJECT_INFO
{
	DWORD                dwSize;                         // This structure size
}NET_OUT_START_RT_PROJECT_INFO;

// CLIENT_StopRealTimeProject Interface output parameters
typedef struct tagNET_IN_STOP_RT_PROJECT_INFO
{
	DWORD                dwSize;                         // This structure size
	char*                 pszProjectNames;               // Program name to the name of the separator && as the example¡êoProject1&&Project2   
}NET_IN_STOP_RT_PROJECT_INFO; 

// CLIENT_StopRealTimeProject Interface output parameters
typedef struct tagNET_OUT_STOP_RT_PROJECT_INFO
{
	DWORD                dwSize;                         // This structure size
}NET_OUT_STOP_RT_PROJECT_INFO;

// carport light info
typedef struct tagNET_CARPORTLIGHT_INFO
{
	DWORD               dwSize;  
	NET_CARPORTLIGHT_TYPE emType;                        // carport type
	NET_CARPORTLIGHT_MODE emMode;                        // light way
}NET_CARPORTLIGHT_INFO;

// carpor light status
typedef struct tagNET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         // struct size 
	int                  nLightNum;                      // light num
	NET_CARPORTLIGHT_INFO stuLights[DH_MAX_CARPORTLIGHT_NUM]; // light info,don't repeat
	int                  nFiringTime;                   // firing time(s)
	int                  nHoldTime;                     // hold time(s), -1 means keep,0 auto control
}NET_CARPORTLIGHT_STATUS;

// CLIENT_GetCarPortLightStatus's interface input
typedef struct tagNET_IN_GET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         // struct size 
	int                  nChannelId;                     // channel ID
}NET_IN_GET_CARPORTLIGHT_STATUS;

// CLIENT_GetCarPortLightStatus's interface output
typedef struct tagNET_OUT_GET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         //struct size 
	NET_CARPORTLIGHT_STATUS stuLightStatus;              //light status
}NET_OUT_GET_CARPORTLIGHT_STATUS;

// CLIENT_SetCarPortLightStatus's interface input
typedef struct tagNET_IN_SET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         // struct size 
	int                  nChannelId;
	NET_CARPORTLIGHT_STATUS stuLightStatus;              // light status
}NET_IN_SET_CARPORTLIGHT_STATUS;

// CLIENT_SetCarPortLightStatus's interface output
typedef struct tagNET_OUT_SET_CARPORTLIGHT_STATUS
{
	DWORD                dwSize;                         // struct size 
	
}NET_OUT_SET_CARPORTLIGHT_STATUS;
typedef struct tagNET_DEV_VIDEODIAGNOSIS_MULTI_INFO
{
	DWORD                dwSize;                         // Current structure body size 
	
    NET_VIDEODIAGNOSIS_COMMON_INFO*          pstDiagnosisCommonInfo;  //Video analysis general info. You need to allocate the following pointer of the structure body.
	
	BOOL                 abDither;						 // It is to stand for current analysis item is valid or not in this result.
	NET_VIDEO_DITHER_DETECTIONRESULT*        pstDither;  //  Video vibration detect
	
	BOOL                 abStration;
	NET_VIDEO_STRIATION_DETECTIONRESULT*     pstStration;// Video stria detect
	
	BOOL                 abLoss;
	NET_VIDEO_LOSS_DETECTIONRESULT*          pstLoss;    // Video loss detect 
	
	BOOL                 abCover;
	NET_VIDEO_COVER_DETECTIONRESULT*         pstCover;   // Camera masking detect
	
	BOOL                 abFrozen;
	NET_VIDEO_FROZEN_DETECTIONRESULT*        pstFrozen;  // Video freeze detect
	
	BOOL                 abBrightness;
	NET_VIDEO_BRIGHTNESS_DETECTIONRESULT*    pstBrightness;// Video brightness abnormal detect 
	
	BOOL                 abContrast;
	NET_VIDEO_CONTRAST_DETECTIONRESULT*      pstContrast;//Video contrast abnormal detect 
	
	BOOL                 abUnbalance;
	NET_VIDEO_UNBALANCE_DETECTIONRESULT*     pstUnbalance;//  Video color cast detect
	
	BOOL                 abNoise;
	NET_VIDEO_NOISE_DETECTIONRESULT*         pstNoise;   //Video noise detect 
	
	BOOL                 abBlur;
	NET_VIDEO_BLUR_DETECTIONRESULT*          pstBlur;    // Video blur detect
	
	BOOL                 abSceneChange;
	NET_VIDEO_SCENECHANGE_DETECTIONRESULT*   pstSceneChange;// Video scene change detect 
}NET_VIDEODIAGNOSIS_RESULT_INFO;

// The output parameter of interface CLIENT_DoFindDiagnosisResult
typedef struct tagNET_OUT_DIAGNOSIS_INFO
{
	DWORD                dwSize;                         // Current structure body size 
	
	int                  nInputNum;                      // The amount of the NET_DEV_RESULT_VIDEODIAGNOSIS_INFO you allocate
	int                  nReturnNum;                     // Returned amount
	NET_VIDEODIAGNOSIS_RESULT_INFO*  pstDiagnosisResult; // Result data You need to allocate the pointer of the structure body
}NET_OUT_DIAGNOSIS_INFO;

///////////////////////////////// master-slave device control module////////////////////////////
///////////////////////////////// CLIENT_OperateMasterSlaveDevice /////////////////////////////////
#define        MASTERSLAVE_CMD_START                   "masterSlaveTracker.start"                   // start
#define        MASTERSLAVE_CMD_STOP                    "masterSlaveTracker.stop"                    // stop
#define        MASTERSLAVE_CMD_MANUALTRACK             "masterSlaveTracker.manualSelectObjectTrack" // manual select object
#define        MASTERSLAVE_CMD_POINTTRACK              "masterSlaveTracker.selectPointTrack"        // points tracking
#define        MASTERSLAVE_CMD_GETCALIBPOINTS          "masterSlaveTracker.getCalibratePoints"      // get calibrate points
#define        MASTERSLAVE_CMD_CALIBRATE               "masterSlaveTracker.calibrate"               // save calibrate points
#define        MASTERSLAVE_CMD_ADDCALIBPOINT           "masterSlaveTracker.addCalibratePoint"       // add calibrate points
#define        MASTERSLAVE_CMD_REMOVECALIBPOINT        "masterSlaveTracker.removeCalibratePoint"    // remove calibrate points
#define        MASTERSLAVE_CMD_MARKMAXZOOM             "masterSlaveTracker.markSceneMaxZoom"        // mark scene max zoom

// master-slave device pair points
typedef struct __NET_MS_PAIRPOINTS
{
	int                nStructSize;
    DH_POINT           stMasterPoint;    // master point,range[0,8192]
    DH_POINT           stSlavePoint;     // slave point,range[0,8192]
}NET_MS_PAIRPOINTS;
//MASTERSLAVE_CMD_START
typedef struct __NET_IN_MS_START
{
	int                nStructSize;
}NET_IN_MS_START;

//MASTERSLAVE_CMD_START
typedef struct __NET_OUT_MS_START
{
	int                nStructSize;
}NET_OUT_MS_START;

//MASTERSLAVE_CMD_STOP
typedef struct __NET_IN_MS_STOP
{
	int                nStructSize;
}NET_IN_MS_STOP;

//MASTERSLAVE_CMD_STOP
typedef struct __NET_OUT_MS_STOP
{
	int                nStructSize;
}NET_OUT_MS_STOP;

//MASTERSLAVE_CMD_MANUALTRACK
typedef struct __NET_IN_MS_MANUALTRACK
{
	int                nStructSize;
	DWORD              dwObject;          // -1 any position of the entire region, >=0 specify the object(can be obtained from the device to return to intelligent frame)
}NET_IN_MS_MANUALTRACK;

//MASTERSLAVE_CMD_MANUALTRACK
typedef struct __NET_OUT_MS_MANUALTRACK
{
	int                nStructSize;
}NET_OUT_MS_MANUALTRACK;

//MASTERSLAVE_CMD_POINTTRACK
typedef struct __NET_IN_MS_POINTTRACK
{
	int                nStructSize;
	DH_POINT           stTrackerPoint;    // Tracker point,range[0,8192]
}NET_IN_MS_POINTTRACK;

//MASTERSLAVE_CMD_POINTTRACK
typedef struct __NET_OUT_MS_POINTTRACK
{
	int                nStructSize;
}NET_OUT_MS_POINTTRACK;

//MASTERSLAVE_CMD_GETCALIBPOINTS
typedef struct __NET_IN_MS_GETCALIBPOINTS
{
	int                nStructSize;
}NET_IN_MS_GETCALIBPOINTS;

//MASTERSLAVE_CMD_GETCALIBPOINTS
typedef struct __NET_OUT_MS_GETCALIBPOINTS
{
	int                        nStructSize;
	int                        nPointsNum;                           // practicality points num
	NET_MS_PAIRPOINTS          stPairPoints[MAX_CALIBPOINTS_NUM];    // pair points
}NET_OUT_MS_GETCALIBPOINTS;

//MASTERSLAVE_CMD_CALIBRATE
typedef struct __NET_IN_MS_CALIBRATE
{
	int                nStructSize;
}NET_IN_MS_CALIBRATE;

//MASTERSLAVE_CMD_CALIBRATE
typedef struct __NET_OUT_MS_CALIBRATE
{
	int                nStructSize;      
}NET_OUT_MS_CALIBRATE;

//MASTERSLAVE_CMD_ADDCALIBPOINT
typedef struct __NET_IN_MS_ADDCALIBPOINT
{
	int                        nStructSize;
	BOOL                       bSlavePointEn;        // enable, TURE able;FASLE disable
	NET_MS_PAIRPOINTS          stPairPoints;         // master-slave camera pair point
}NET_IN_MS_ADDCALIBPOINT;

//MASTERSLAVE_CMD_ADDCALIBPOINT
typedef struct __NET_OUT_MS_ADDCALIBPOINT
{
	int                nStructSize;
	DH_POINT           stPoint;      // slave point
}NET_OUT_MS_ADDCALIBPOINT;


//MASTERSLAVE_CMD_REMOVECALIBPOINT
typedef struct __NET_IN_MS_REMOVECALIBPOINT
{
	int                nStructSize;
	DH_POINT           stPoint;      // master point
}NET_IN_MS_REMOVECALIBPOINT;

//MASTERSLAVE_CMD_REMOVECALIBPOINT
typedef struct __NET_OUT_MS_REMOVECALIBPOINT
{
	int                nStructSize;      
}NET_OUT_MS_REMOVECALIBPOINT;

//MASTERSLAVE_CMD_MARKMAXZOOM
typedef struct __NET_IN_MS_MARKMAXZOOM
{
	int                nStructSize; 
}NET_IN_MS_MARKMAXZOOM;

//MASTERSLAVE_CMD_MARKMAXZOOM
typedef struct __NET_OUT_MS_MARKMAXZOOM
{
	int                nStructSize; 
}NET_OUT_MS_MARKMAXZOOM;

///////////////////////////////// CLIENT_OperateCommDevice Interface parameters defined /////////////////////////////////
#define		COMMDEV_GET_EXTERNLDATA							"devComm.getExternalData"		//get serial external data for 3rd party general data

#define        MAX_EXTERN_DATA_LEN                2048

//COMMDEV_GET_EXTERNLDATA Input parameters
typedef struct __COMMDEV_IN_GET_EXTERNDATA
{
    DWORD        dwSize;

}COMMDEV_IN_GET_EXTERNDATA;

//COMMDEV_GET_EXTERNLDATA Output parameters
typedef struct __COMMDEV_OUT_GET_EXTERNDATA
{
	DWORD		dwSize;
	char		szGetData[MAX_EXTERN_DATA_LEN];				//External serial devices to collect data (data format based on custom projects)
}COMMDEV_OUT_GET_EXTERNDATA;


/////////////////////////////////CLIENT_OperateVideoAnalyseDevice Interface parameter /////////////////////////////////
#define     NET_SET_MODULESTATE                         "devVideoAnalyse.setModuleState"                        // Set module status
#define		NET_TEST_WITH_SCREENPOINTS					"devVideoAnalyse.testCalibrateWithScreenPoints"			// Detect depth of the field according to the coordinates on the screen. It is the actual distance between these two points. Please complete the parameter setup before you test.
#define		NET_TEST_WITH_METRICLENGTH					"devVideoAnalyse.testCalibrateWithMetricLength"		    // Detect parameter of depth of the field according to actual lenght,start point,and direction coordinates.
#define		NET_GET_INTERNALOPTIONS						"devVideoAnalyse.getInternalOptions"					// Get internal option
#define		NET_TUNE_INTERNALOPTIONS					"devVideoAnalyse.tuneInternalOptions"					// Debug internal item
#define		NET_RESET_INTERNALOPTIONS					"devVideoAnalyse.resetInternalOptions"					// Reset all debug internal item
#define     NET_SET_PTZ_PRESET_STATUS                   "devVideoAnalyse.setPtzPresetStatus"                    // get preset info

// Line type
typedef enum tagNET_EM_LINETYPE
{
	NET_EM_HORIZONTAL,
	NET_EM_VERTICAL,
}NET_EM_LINETYPE;

// PTZ preset status type
typedef enum tagEM_DH_PTZ_PRESET_STATUS
{
    EM_DH_PTZ_PRESET_STATUS_UNKNOWN,        // unknown
    EM_DH_PTZ_PRESET_STATUS_REACH,          // preset reach the point
    EM_DH_PTZ_PRESET_STATUS_UNREACH,        // preset do not reach the point yet
}EM_DH_PTZ_PRESET_STATUS;

//PTZ positioning information alarm
typedef struct
{
	int     nChannelID;             // Channel number
	int     nPTZPan;                // Horizontal movement of the head position, effective range: [0,3600]
	int     nPTZTilt;               // PTZ vertical position, the effective range: [-1800,1800]
	int     nPTZZoom;               // PTZ iris position changes, effective range: [0,128]
	BYTE    bState;                 // PTZ motion, 0 - Unknown 1 - Movement 2 - Idle
	BYTE    bAction;                // PTZ movement, 0 - preset 1 - line scan 2 - Cruise 3 - patrol track 4 - horizontal rotation
	BYTE    bFocusState;            // PTZ focus state, 0 - unknown 1 - state of motion 2 - Idle
	BYTE    bEffectiveInTimeSection; //In the period of validity of the preset state
									 //If the current is preset reported preset period of time, compared with one, otherwise 0
	int     nPtzActionID;           // Cruise ID number
	DWORD   dwPresetID;             // PTZ preset number where
	float   fFocusPosition;         // Focus position
	BYTE	bZoomState;				// ZOOM PTZ status, 0 - Unknown,1-ZOOM, 2 - Idle
	BYTE	bReserved[3];			// Alignment
	DWORD   dwSequence;             // Packet sequence number, used to verify whether the loss
	DWORD   dwUTC;                  // Corresponding UTC (1970-1-1 00:00:00) seconds.
    EM_DH_PTZ_PRESET_STATUS emPresetStatus; // preset status
	int     reserved[248];          // Reserved field
}DH_PTZ_LOCATION_INFO;

// NET_SET_PTZ_PRESET_STATUS
typedef struct __NET_IN_PTZ_PRESET_STATUS
{
    DWORD                    dwSize;
    DH_PTZ_LOCATION_INFO     stPTZStatus;
}NET_IN_PTZ_PRESET_STATUS;

typedef struct __NET_OUT_PTZ_PRESET_STATUS
{
    DWORD    dwSize;
}NET_OUT_PTZ_PRESET_STATUS;

// NET_TEST_WITH_SCREENPOINTS
typedef struct __NET_IN_CALIBRATE_BY_POINTS
{
	DWORD               dwSize;                 // Current structure body size 
	DH_POINT            stStartPoint;           // Start point of the line 	 The point of the line is within [0,8191].
	DH_POINT            stEndPoint;             // End point 	The point of the line is within [0,8191]
	NET_EM_LINETYPE     emType;                 // Line type	em_Horizontal("Horizontal")  em_Vertical("Vertical")
}NET_IN_CALIBRATE_BY_POINTS;

typedef struct __NET_OUT_CALIBRATE_BY_POINTS
{
	DWORD               dwSize;                 // Current structure body size 	
	double              dlength;                // The actual length between these two points. Unit is meter.
}NET_OUT_CALIBRATE_BY_POINTS;

// NET_TEST_WITH_METRICLENGTH
typedef struct __NET_IN_CALIBRATE_BY_LENGTH
{
	DWORD               dwSize;                 // Current structure body size 
	double				nLength;				// The actual length between these two points. Unit is meter.
	DH_POINT			stStartPoint;			// Start point of the line	The point of the line is within [0,8191]
	DH_POINT			stDirection;			// Line direction coordinates	For vertical line ony. The point of the line is within [0,8191]
	NET_EM_LINETYPE		emType;					// Line type	em_Horizontal("Horizontal")  em_Vertical("Vertical")				
}NET_IN_CALIBRATE_BY_LENGTH;

typedef struct __NET_OUT_CALIBRATE_BY_LENGTH
{
	DWORD               dwSize;                 // Current structure body size 
	DH_POINT			stEndPoint;				// Coordinates of the end of the line on the screen. 	The point of the line is within[0,8191]	
}NET_OUT_CALIBRATE_BY_LENGTH;

typedef struct __NET_INTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
	int					nIndex;					// Item SN
	NET_ARRAY           stKey;				    // Option name. 256 bytes including'\0'. Encryption data
	int					nValue;					// Option value
	int					nMinValue;				// Min value
	int					nMaxValue;				// Max value
}NET_INTERNAL_OPTION;

// Debug internal option NET_GET_INTERNALOPTIONS
typedef struct __NET_IN_GETINTERNAL_OPTIONS
{
	DWORD               dwSize;                 // Current structure body size
}NET_IN_GETINTERNAL_OPTIONS;

typedef struct __NET_OUT_GETINTERNAL_OPTIONS
{
	DWORD               dwSize;                 // Current structure body size 
	
	int					nTotalOptionNum;		// Option amount. Max value search capability.
	int					nReturnOptionNum;		// returned actual option amount.
	NET_INTERNAL_OPTION* pstInternalOption;	    // Option list. Caller shall allocate the address.
}NET_OUT_GETINTERNAL_OPTIONS;

// NET_TUNE_INTERNALOPTIONS
typedef struct __NET_IN_TUNEINTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
	int					nOptionCount;	    	// Option amount
	NET_INTERNAL_OPTION* pstInternalOption;	    // Option list. The amount stands for the capability.
}NET_IN_TUNEINTERNAL_OPTION;

typedef struct __NET_OUT_TUNEINTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
}NET_OUT_TUNEINTERNAL_OPTION;

// NET_RESET_INTERNALOPTIONS
typedef struct __NET_IN_RESETINTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
}NET_IN_RESETINTERNAL_OPTION;

typedef struct __NET_OUT_RESETINTERNAL_OPTION
{
	DWORD               dwSize;                 // Current structure body size 
}NET_OUT_RESETINTERNAL_OPTION;

// NET_SET_MODULESTATE
typedef enum tagNET_EM_MODULESTATE
{
	NET_EM_MODULESTATE_OK,
	NET_EM_MODULESTATE_PAUSE,
}NET_EM_MODULESTATE;
typedef struct __NET_IN_SETMODULESTATE
{
	DWORD				dwSize;					// Current structure body size 
	NET_EM_MODULESTATE  emState;				// 0-Normal work.1-Pause. Need to rebuild background when you switch to the normal video since it may change.
	int                 nIndex;                 // Model SN.	-1 stands for all modules.
}NET_IN_SETMODULESTATE;

typedef struct __NET_OUT_SETMODULESTATE
{
	DWORD				dwSize;					// Current structure body size
}NET_OUT_SETMODULESTATE;

/////////////////////////////////CLIENT_DeleteDevConfig Interface parameter/////////////////////////////////
/*
 * CLIENT_DeleteDevConfig Input and output parameter
 */

typedef enum tagNET_EM_CONFIGOPTION
{
	NET_EM_CONFIGOPTION_OK,
	NET_EM_CONFIGOPTION_NEEDRESTART,
	NET_EM_CONFIGOPTION_NEEDREBOOT=2,
	NET_EM_CONFIGOPTION_WRITEFILEERROR=4,
	NET_EM_CONFIGOPTION_CAPSNOTSUPPORT=8,
	NET_EM_CONFIGOPTION_VALIDATEFAILED=16,
}NET_EM_CONFIGOPTION;

typedef struct tagNET_IN_DELETECFG
{
	DWORD         dwSize;						// Structure body size
	char*         szCommand;                    // Configuration command
}NET_IN_DELETECFG;

typedef struct tagNET_OUT_DELETECFG
{
	DWORD         dwSize;                       // Structure body size
    int           nError;                       // The error code device returns
    int           nRestart;                     // Device reboot or not
	DWORD         dwOptionMask;                 // Option. Please refer to enumeration NET_EM_CONFIGOPTION
}NET_OUT_DELETECFG;

/////////////////////////////////CLIENT_GetMemberNames interface parameter/////////////////////////////////
/*
 * CLIENT_GetMemberNames Input and output parameter
 */
typedef struct tagNET_IN_MEMBERNAME
{
	DWORD         dwSize;                       // Structure body size
	char*         szCommand;                    // Configuration command
}NET_IN_MEMBERNAME;

typedef struct tagNET_OUT_MEMBERNAME
{
	DWORD         dwSize;                       // Structure body size 
	int           nError;                       // The error code device returns
    int           nRestart;                     // Device reboot or not	
	int           nTotalNameCount;              // Name amount. Fromt the capability set. Caller fill in.
	int           nRetNameCount;                // The returned actual name amount
	NET_ARRAY*    pstNames;                     // Name array. The caller apply for the memory. The amount is nTotalNameCount.
}NET_OUT_MEMBERNAME;

////////////////////////////////////video compression//////////////////////////////////////
// staff type
typedef enum tagNET_EM_STAFF_TYPE
{
	NET_EM_STAFF_TYPE_ERR,
	NET_EM_STAFF_TYPE_HORIZONTAL,                       // "Horizontal" 
	NET_EM_STAFF_TYPE_VERTICAL,                         // "Vertical" 
	NET_EM_STAFF_TYPE_ANY,                              // "Any" 
	NET_EM_STAFF_TYPE_CROSS,                            // "Cross" 
}NET_EM_STAFF_TYPE;

// region type
typedef enum tagNET_EM_CALIBRATEAREA_TYPE
{
	NET_EM_CALIBRATEAREA_TYPE_ERR,
	NET_EM_CALIBRATEAREA_TYPE_GROUD,		            // "Groud" 
	NET_EM_CALIBRATEAREA_TYPE_HORIZONTAL,	            // "Horizontal" 		
	NET_EM_CALIBRATEAREA_TYPE_VERTICAL,		            // "Vertical" 
	NET_EM_CALIBRATEAREA_TYPE_ANY,			            // "Any"
}NET_EM_CALIBRATEAREA_TYPE;

// The concentrated output data subtype
typedef enum tagNET_EM_OUTPUT_SUB_TYPE
{
	NET_EM_OUTPUT_SUB_TYPE_ERR,
	NET_EM_OUTPUT_SUB_TYPE_NORMAL,                      // Normal playback speed (the parent type is concentrated Video valid)
	NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS,                    //Concentrated by the playback speed (parent type is effective when concentrated video), quick release in the absence of an object, the object appears when playing at normal speed
}NET_EM_OUTPUT_SUB_TYPE;

// staff info
typedef struct tagNET_STAFF_INFO
{
	DH_POINT	        stuStartLocation;	            // start location
	DH_POINT	        stuEndLocation;		            // end location
	float			    nLenth;				            // length(m)
	NET_EM_STAFF_TYPE	emType;			                // type
}NET_STAFF_INFO;

// calibration area,common scenario use
typedef struct tagNET_CALIBRATEAREA_INFO
{
	int				    nLinePoint;					    // horizontal line point
	DH_POINT	        stuLine[DH_MAX_POLYLINE_NUM];	// horizontal line
	float			    fLenth;						    // lenth
	DH_POLY_POINTS	    stuArea;					    // area
	int				    nStaffNum;					    // number of vertical line
	NET_STAFF_INFO	    stuStaffs[DH_MAX_STAFF_NUM];    // vertical line         
	NET_EM_CALIBRATEAREA_TYPE emType;			        // area type
}NET_CALIBRATEAREA_INFO;

typedef struct tagNET_LOCALFILE_INFO
{
	DWORD			    dwSize;
	char			    szFilePath[MAX_PATH];	        // file path
}NET_LOCALFILE_INFO;

typedef struct tagNET_REMOTEFILE_INFO
{
	DWORD			    dwSize;
	char			    szIP[MAX_PATH];	                // the remote device IP
	unsigned int	    nPort;				            // the remote device  port
	char			    szName[DH_MAX_NAME_LEN];        // the remote device  userName
	char			    szPassword[DH_MAX_NAME_LEN];    // the remote device  password
	BYTE			    byProtocolType;			        // the remote device protocol type,2-the second generation of private 3-the third generation of private
	BYTE			    byReserved[3];			        // byte alignment
	char			    szFilePath[MAX_PATH];           // file path,when byProtocolType == 3 effective.
	int				    nStartCluster;		  	        // start cluster,when byProtocolType == 2 effective.
	int				    nDriverNo;				        // driver no.when byProtocolType == 2 effective.
	
}NET_REMOTEFILE_INFO;

// file path info
typedef struct tagNET_FILEPATH_INFO
{
	DWORD				dwSize;
	BOOL				bFileType;			            // TRUE: local server's file; FALSE: remote device's file
	NET_LOCALFILE_INFO	stuLocalFile;		            // local file, when bFileType==TRUE effective
	NET_REMOTEFILE_INFO	stuRemoteFile;		            // remote file, when bFileType==FALSE effective
}NET_FILEPATH_INFO;

// global param info
typedef struct tagNET_GLOBAL_INFO
{
	DWORD			    dwSize;
	char			    szSceneType[DH_MAX_NAME_LEN];	// scene type,only support "Normal"
	int				    nStaffNum;						// staff num
	NET_STAFF_INFO	    stuStaffs[DH_MAX_STAFF_NUM];	// staffs
	int				    nCalibrateAreaNum;				// number of calibrate area
	NET_CALIBRATEAREA_INFO stuCalibrateArea[DH_MAX_CALIBRATEBOX_NUM]; // calibrate area(if the filed does not exist,return the entire tegion)
	int				    nJitter;		                // vidicon jitter, range[0-100],the value of static camera shake,the more powerful shake,the bigger the value.
	BOOL			    bDejitter;		                // if start to wobble
}NET_GLOBAL_INFO;

// module info
typedef struct tagNET_MODULE_INFO
{
	DWORD			    dwSize;							// size
	BYTE			    bSensitivity;					// sensitivity,range[1-10],the lower the value the sensitivity.
	BYTE			    bReserved[3];
	int				    nDetectRegionPoint;				// detect region point
	DH_POINT		    stuDetectRegion[DH_MAX_POLYGON_NUM]; // detect region
	int				    nExcludeRegionNum;				// number of exclude region 
	DH_POLY_POINTS	    stuExcludeRegion[DH_MAX_EXCLUDEREGION_NUM];	// exclude region
}NET_MODULE_INFO;

// object filter info
typedef struct tagNET_OBJFILTER_INFO
{
	DWORD		        dwSize;						    // size
	NET_TIME	        stuStartTime;				    // start time
	NET_TIME	        stuEndTime;					    // end time
	char		        szObjectType[DH_MAX_NAME_LEN];	// object type, support for the following:
											            //"Unknown", "Human", "Vehicle",
											            //"Fire", "Smoke", "Plate", "HumanFace", "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "Entity"
	char		        szObjectSubType[64];		    // object sub type,support for the following:
											            // Vehicle Category:"Unknown"  "Motor" "Non-Motor" "Bus""Bicycle"  "Motorcycle" 
											            // Plate Category: "Unknown" "Normal" "Yellow" "DoubleYellow" "Police" Armed" 
											            // "Military" "DoubleMilitary" "SAR" "Trainning" 
											            // "Personal" "Agri" "Embassy" "Moto" "Tractor" "Other"
											            // HumanFace Category:"Normal" "HideEye" "HideNose" "HideMouth" 
	DWORD		        dwRGBMainColor[DH_MAX_COLOR_NUM];	// main color,object to the person,said the upper part of the color,in bytes,is red,green,blue and diaphaneity,example:RGB value is(0,255,0),when diaphaneity = 0, the value = 0x00ff0000
	DWORD		        dwLowerBodyColor[DH_MAX_COLOR_NUM];	// object to the person,said the lower half of the color,in bytes,is red,green,blue and diaphaneity,example:RGB value is(0,255,0),when diaphaneity = 0, the value = 0x00ff0000
	int			        nMinSize;					    // min siez, m
	int			        nMaxSize;					    // max size, m
	int			        nMinSpeed;					    // min speed km/h
	int			        nMaxSpeed;					    // max speed km/h
	DWORD		        dwRGBMainColorNum;			    // object is the person,dwRGBMainColor effective number of colors
	DWORD		        dwLowerBodyColorNum;		    // object is the person, and bRGBMainColor==true,is the lower half of the effective color
	BOOL		        bRGBMainColor;				    // true-dwRGBMainColor the upper part of the color,dwLowerBodyColor the lower half of the color; false-dwRGBMainColor means main color,dwLowerBodyColor nullity
}NET_OBJFILTER_INFO;

// param of rule
typedef struct tagNET_VIDEOSYNOPSISRULE_INFO
{
	DWORD				dwSize;				            // struct size
	BYTE				byOutputType;		            // out tyope,1-snapshot;2-condensatal video;3-snapshot with video
	BYTE				byDensity;			            // density, 1-10, the more value,the density higher
	bool				bShowTime;			            // show time
	bool				bShowBox;			            // show object box
	bool				bEnableRecordResult;            // the result recoded or not
    BYTE                byTime;                         // Length after video synposis, unit is minute
    BYTE                byReserved[2];
	NET_OBJFILTER_INFO	stuFilter[MAX_OBJFILTER_NUM];   // fileter info
	DWORD				dwObjFilterNum;		            // number of filter

	// NET_OUT_QUERY_VIDEOSYNOPSIS , CFG_CMD_ANALYSERULE transfer dhconfigsdk.dll get CLIENT_ParseData
	// NET_IN_ADD_VIDEOSYNOPSIS ,CFG_CMD_ANALYSERULEtransfer  dhconfigsdk.dll get CLIENT_PacketData
	char*		        szAnalyseRuleInfo;				// JSON rule info
	int                 nBufferLen;                     // NET_OUT_QUERY_VIDEOSYNOPSIS,apply szAnalyseRuleInfo length
	BOOL				bCustomResolution;				// Custom resolution enabled, TRUE-resolution is determined by emResolution, FALSE-concentrate production based on the original video resolution video
	CAPTURE_SIZE		emResolution;					// Resolution, bCustomResolution is TRUE only valid
	BOOL				bEnableMaxUsedCPU;				// Are maximize occupy CPU resource requirements
	BOOL				bEnableSmoothBorder;			// Target is smooth border
	NET_EM_OUTPUT_SUB_TYPE emOutputSubType;             // After concentrating the output data sub-type, see NET_EM_OUTPUT_SUB_TYPE
	int					nExtractFrameRate;				// Video frame rate pumping concentrated 1-32, the value, the higher the pumping rate of the frame, the client presents the faster playback
														// This field is concentrated only in the output data sub-type (emOutputSubType) is valid NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS
	//Video synposis extra info 
    int                 nSynopsisSpeed;                     // Synposis speed threshold. The level ranges from 1 to 10. 5 means only reserve the object of speed higher than 5. It is a relative unit.
                                                            // Current string is null if it is o. 
    int                 nSynopsisSize;                      // Synposis dimensions threshold. There are ten levels (1 to 10). 3 means only reserve the object of speed higher than 3. It is a relative unit.
                                                            // Current string is null if it is o. 
    BOOL                bEnableDirection;                   // When it is True,  filter the object moving direction. 
                                                            // When it is False, do not filter the object moving direction. 
    DH_POINT            stuSynopsisStartLocation;           // Synopsis moving direction, start coordinates. The point coordinates [0,8192), it is valid when bEnableDirection is True. 
    DH_POINT            stuSynopsisEndLocation;             // Synopsis moving direction, stop coordinates. The point coordinates [0,8192), it is valid when bEnableDirection is True. 
}NET_VIDEOSYNOPSISRULE_INFO;

// add video synopsis input param
typedef struct tagNET_IN_ADD_VIDEOSYNOPSIS
{
	DWORD			    dwSize;			                // size
	NET_FILEPATH_INFO*	pFilePathInfo;	                // file path info
	DWORD				dwFileCount;	                // effective number of files
	NET_GLOBAL_INFO		stuGlobalInfo;	                // global info
	NET_MODULE_INFO		stuModuleInfo;	                // module info
	NET_VIDEOSYNOPSISRULE_INFO	stuRuleInfo;	        // rule info
	unsigned int		nWaitTime;		                // wait time(ms)
}NET_IN_ADD_VIDEOSYNOPSIS;

// add video synopsis output param
typedef struct tagNET_OUT_ADD_VIDEOSYNOPSIS
{
	DWORD	            dwSize;			                // size
	DWORD*	            pnTaskID;		                // TaskID array,users are assigned space.
	DWORD	            nTaskIDCount;	                // count of TaskID
}NET_OUT_ADD_VIDEOSYNOPSIS;

// pause video synopsis input param
typedef struct tagNET_IN_PRE_HANDLE_VIDEOSYNOPSIS
{
    DWORD                   dwSize;                         // The structure size
    NET_FILEPATH_INFO*      pFilePathInfo;                  // File position info. Space allocated by the user 
    DWORD                   dwFileCount;                    // Valid file amount. 
    unsigned int            nWaitTime;                      // Waiting time out, unit is ms. 
}NET_IN_PRE_HANDLE_VIDEOSYNOPSIS;

// Video synopsis pre-process task outputs parameters 	
typedef struct tagNET_OUT_PRE_HANDLE_VIDEOSYNOPSIS
{
    DWORD               dwSize;                             // Structure size 
    DWORD*              pnTaskID;                           // TaskID array. Space allocated by user. It is corresponding to the added task file. 0=failed to add the corresponding task. 
    DWORD               nTaskIDCount;                       // TaskID amount 
}NET_OUT_PRE_HANDLE_VIDEOSYNOPSIS;

// Input parameters when implement the video synopsis task 
typedef struct tagNET_IN_RUN_VIDEOSYNOPSIS_TASK
{
    DWORD                       dwSize;                     // Structure size 
    DWORD                       nTaskID;                    // Task ID. CLIENT_PreHandleVideoSynopsisTask output function and then return 
    NET_GLOBAL_INFO             stuGlobalInfo;              // Global info 
    NET_MODULE_INFO             stuModuleInfo;              // Module info 
    NET_VIDEOSYNOPSISRULE_INFO  stuRuleInfo;                // Rule info 
    unsigned int                nWaitTime;                  // Waiting time out. Unit is ms
}NET_IN_RUN_VIDEOSYNOPSIS_TASK;

//  Output parameters when implementing the video synopsis task 
typedef struct tagNET_OUT_RUN_VIDEOSYNOPSIS_TASK
{
    DWORD               dwSize;                             // Structure size 
    DWORD               nPlayID;                            // Playback ID,0=interface failed, otherwise input CLIENT_PlayBackBySynopsisFile to playback video
    DWORD               nTime;                              // Video synopsis time. Unit:second. 
}NET_OUT_RUN_VIDEOSYNOPSIS_TASK;

// ÔÝÍ£ÊÓÆµÅ¨ËõÈÎÎñÊäÈë²ÎÊý
typedef struct tagNET_IN_PAUSE_VIDEOSYNOPSIS
{
	DWORD	            dwSize;			                // size 
	BOOL                bPause;                         // TRUE-pause  FALSE-resume 
	DWORD*	            pnTaskID;		                // TaskID array,users are assigned space.
	DWORD	            nTaskIDCount;	                // count of TaskID
	DWORD	            nWaitTime;		                // wait time(ms)
}NET_IN_PAUSE_VIDEOSYNOPSIS;

//  remove video synopsis input param
typedef enum tagNET_SYNOPSIS_REMOVE_TYPE
{
    EM_SYNOPSIS_REMOVE_UNKNOW =0 , // Unknown 
    EM_SYNOPSIS_REMOVE_PRETASK   , // Pre-process task 
    EM_SYNOPSIS_REMOVE_SYNO      , // Video synopsis task 
}NET_SYNOPSIS_REMOVE_TYPE;

// Input parameters when deleting video synopsis task 
typedef struct tagNET_IN_REMOVE_VIDEOSYNOPSIS
{
	DWORD	            dwSize;			                // size
	DWORD*	            pnTaskID;		                // TaskID array,users are assigned space.
	DWORD	            nTaskIDCount;	                // count of TaskID
	DWORD	            nWaitTime;		                // wait time(ms)
    NET_SYNOPSIS_REMOVE_TYPE    emRemoveType;			// Task type to be deleted 
}NET_IN_REMOVE_VIDEOSYNOPSIS;

// return objece info of video synopsis
typedef struct tagNET_REAL_SYNOPSIS_OBJECT_INFO
{
	DWORD               dwSize;
	
	DWORD               dwTaskID;                       // task ID
    DH_MSG_OBJECT_EX2   stuObjectInfo;                  // Object detailed info 
}NET_REAL_SYNOPSIS_OBJECT_INFO;

typedef struct tagNET_REAL_SYNOPSIS_STATE_INFO
{
	DWORD               dwSize;
	
	DWORD               dwTaskID;                       // task ID   
	int                 nObjectNum;                     // number of object
	int                 nTaolProgress;                  // progress of condensation,0~100
	char                szState[DH_MAX_SYNOPSIS_STATE_NAME]; // state of condensation,"Downloading"  "Synopsising"
                                                        // "DownloadFailed""DownloadSucceeded"
	                                                  	// "SynopsisFailed" ,"Succeeded" 
		                                                // "DownloadPause" ,"SynopsisPause" 
	int           nProgressOfCurrentState;              //  progress of current state,0~100
	char				szFailedCode[DH_MAX_STRING_LEN];// Failure code¡ê?szState="SynopsisFailed"Effective
														// "OutOfMemory" Out of memory;
														// "TooMany_TargetInVideo"  Too many goals the entire video;
														// "InvalidFilePointer" File pointer is invalid;
														// "InvalidFilePath" File path is invalid;
														// "CreateDirectoryFailed"  Create a folder path fails;
														// "WriteDataFailed" Intermediate file failed to write Tube
														// "DataSizeTooLarge" Tube file is too large
														// "Detect_Nothing" Scene without moving target
														// "OpenDataFailed" Failed to open the intermediate file
														// "InvalidSynopsisBackgroud" Invalid concentrated background
														// "ColorRetrieval" Wrong color retrieve configuration
														// "UnsupportRuleType" Unsupported rule type
														// "RuleNumberExceedLimit" Number of rules overrun
														// "NoFunctionCfgInfo" But did not specify the configuration information corresponding function
														// "FunctionNumberExceedLimit" The number of feature quantity of each rule overrun
														// "PointsExceedLimit" Point line or area overrun
														// "BadFunctionType" Error function type
														// "RulePointNumber" Points rule error
														// "MaskRegionNumberExceedLimit" Shielded area overrun quantity
														// "CameraSceneSwitch" Cameras scene change
														// "TooManyTargeInFrame" Excessive number of single-frame target
														// "InalidSynopsisDesity" Concentrated density invalid
														// "ExtrackColorFeatureFailed" Failed to extract color features
														// "JpegEncodeFrameFailed" Jpeg encoder failure
														// "JpegParamRestFailed" Jpeg encoding parameters fail reset
														// "JpegDecodeFrameFailed" Jpeg decoding failure
														// "RetrieveObjectIdInvalid" Retrieving Target ID is invalid
														// "RetrieveImageInvalid" Invalid image retrieval
														// "NetworkAnomaly" DISH Network anomaly map
														// "ObjectNumberLimit" Limit the number of goals over analysis
														// "CreateChannelFailed" Create a channel failure
														// "ReadUGFileFailed" Read UG file failed
														// "GetSynopsisInfoFailed" Failed to obtain concentrated Video
														// "ObjectNumberExceedLimit" The number of targets in the scene over the limit
														// "RebuildBackgroudFailed" Background reconstruction failure
														// "NotExistMiddleFile" Intermediate file does not exist
														// "NotExistSourceFile" Original file does not exist
														// "NotDog" No dongle
														// "NotEnoughFreeDisk" Disk space is not enough
														// "StartDecodeFail" Start decoding failure
														// "DecodeTimeOut" Decoding wait timeout
														// "EncodeTimeOut" Coding wait timeout
														// "ExactTimeOut" Extract snapshots wait timeout
														// "ReadMidlleFileFail" Failed to read the intermediate file
														// "ExactPictureFail" Failed to extract pictures
     char szPicPath[DH_COMMON_STRING_512];              // The snap image file path get by pre-process file.  
                                                        // Support HTTP URL means :http://www.dahuate.com/1.jpg
                                                        // Support FTP URL means: "ftp://ftp.dahuate.com/1.jpg"
                                                        // Server local path  
                                                        // a)"C:/pic/1.jpg" 
                                                        // b)"/mnt//2010/8/11/dav/15:40:50.jpg"
    int         nMaxTime;                               //Supported video synopsis max time. Unit is second. 
    int         nMinTime;                               //Supported video synopsis min time. Unit is second. 
}NET_REAL_SYNOPSIS_STATE_INFO;

//callback function of synopsis video info
typedef int (CALLBACK *fVideoSynopsisObjData)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_OBJECT_INFO* pSynopsisObjectInfo, void* pBuf, int nBufLen, LDWORD dwUser, void* pReserved);

//callback function of synopsis video state
typedef int (CALLBACK *fVideoSynopsisState)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_STATE_INFO* pSynopsisStateInfos, int nInfoCount, LDWORD dwUser, void* pReserved);



// CLIENT_RealLoadObjectData's interface define
typedef struct tagNET_IN_REALLOAD_OBJECTDATA
{
	DWORD               dwSize;                         // size
	
	int                 nTaskIDNum;                     // number of taskID
	DWORD               *pTaskIDs;                      // material taskID
	BOOL                bNeedPicFile;                   // need download corresponding to the picture 
	int                 nWaitTime;                      // wait time(ms)
	fVideoSynopsisObjData cbVideoSynopsisObjData;       // callback function's pointer
	LDWORD         dwUser;
}NET_IN_REALLOAD_OBJECTDATA;

typedef struct tagNET_OUT_REALLOAD_OBJECTDATA
{
	DWORD               dwSize;                         // size

	LLONG               lRealLoadHandle;                // return subscriptal handle
}NET_OUT_REALLOAD_OBJECTDATA;

// CLIENT_StopLoadObjectData's interface define
typedef struct tagNET_IN_STOPLOAD_OBJECTDATA
{
	DWORD               dwSize;

	int                 nTackIDNum;                     // number of tackID
	DWORD               *pTaskIDs;                      // specific taskID  
}NET_IN_STOPLOAD_OBJECTDATA;

// CLIENT_RealLoadSynopsisState's interface define
typedef struct tagNET_IN_REALLAOD_SYNOPSISSTATE
{
	DWORD               dwSize;                         // size
	
	int                 nTaskIDNum;                     // number of taskID
	DWORD               *pTaskIDs;                      // specific taskID  
	int                 nWaitTime;                      // wait time(ms)
	fVideoSynopsisState cbVideoSynopsisState;           // callback function's pointer
	LDWORD         dwUser;
}NET_IN_REALLAOD_SYNOPSISSTATE;

typedef struct tagNET_OUT_REALLOAD_SYNOPSISSTATE
{
	DWORD               dwSize;                         // size
	
	LLONG               lRealLoadHandle;                // return subscriptal handle
}NET_OUT_REALLOAD_SYNOPSISSTATE;

// CLIENT_StopLoadSynopsisState's interface define
typedef struct tagNET_IN_STOPLOAD_SYNOPSISSTATE
{
	DWORD               dwSize;
	
	int                 nTackIDNum;                     // number of taskID
	DWORD               *pTaskIDs;                      // specific taskID    
}NET_IN_STOPLOAD_SYNOPSISSTATE;

// type of video synopsis's query
typedef enum tagEM_VIDEOSYNOPSIS_QUERY_TYPE
{
	EM_VIDEOSYNOPSIS_TASK,	                            // task info
	EM_VIDEOSYNOPSIS_OBJ,	                            // snapshot
}EM_VIDEOSYNOPSIS_QUERY_TYPE;

// query the task of video synopsis infomation
typedef struct tagNET_QUERY_VSTASK_INFO
{
	DWORD	            dwSize;			                // size
	DWORD	            dwTaskID;		                // taskID,when value = 0,query all task
}NET_QUERY_VSTASK_INFO;

// query conditions of video objects in the task infomation
typedef struct tagNET_QUERY_VSOBJECT_INFO
{
	DWORD			    dwSize;			                // size
	DWORD*			    pdwTaskID;                		// taskID,when value = -1,query all task
	DWORD			    dwTaskIDCount;                	// count of taskID
	DH_MSG_OBJECT	    stuObjInfo;	                	// object info,when objectID!=0,query all
}NET_QUERY_VSOBJECT_INFO;

//--CLIENT_QueryVideoSynopsisInfo's interface input define
typedef struct tagNET_IN_QUERY_VIDEOSYNOPSIS
{
	DWORD	            dwSize;							// size
	EM_VIDEOSYNOPSIS_QUERY_TYPE emQueryType;            // query type
	DWORD	            dwCount;						// count of query
	DWORD	            dwBeginNumber;					// begin number
	void*	            pQueryInfo;						// information query condition
											            // when emQueryType==EM_VIDEOSYNOPSIS_TASK, corresponding to NET_QUERY_VSTASK_INFO
											            // when emQueryType==EM_VIDEOSYNOPSIS_OBJ, corresponding to NET_QUERY_VSOBJECT_INFO

	DWORD	            dwWaitTime;						// wait time(ms)
}NET_IN_QUERY_VIDEOSYNOPSIS;

// query to the task of each synopsis video information
typedef struct tagNET_VSTASK_INFO
{
	DWORD		        dwSize;			                // size
	DWORD				dwTaskID;		                // task ID
	NET_MODULE_INFO		stuModuleInfo;                	// module info
	NET_VIDEOSYNOPSISRULE_INFO	stuRuleInfo;           	// info of task rule
	NET_GLOBAL_INFO		stuGlobalInfo;	                // global param
	NET_TIME			stuCreateTime;	                // create time
	char				szCurrState[DH_MAX_SYNOPSIS_STATE_NAME];  // current state,"Downloading" "Synopsising" 
																  // "DownloadFailed" "DownloadSucceeded" 
																  // "SynopsisFailed" "Succeeded" 
																  // "DownloadPause" "SynopsisPause" 
	char				szCreateUser[DH_MAX_NAME_LEN];	// the creator
	int					nProgressOfCurrentState;		// progress of current state [0~100]
	char				szLocalFilePath[MAX_PATH];		// local file path
	int					nObjectNum;						// number of object
	NET_FILEPATH_INFO	stuVideoSourceFilePath;			// path of video source file
	NET_FILEPATH_INFO	stuSynopsisVideoFilePath;		// path of synopsis video file
	char                szFailedCode[DH_MAX_STRING_LEN];// Concentrated video failed error code¡ê?szCurrState when "SynopsisFailed" Effective
                                                        // "OutOfMemory" Out of memory;
                                                        // "TooMany_TargetInVideo"  Too many goals the entire video;
                                                        // "InvalidFilePointer" File pointer is invalid;
                                                        // "InvalidFilePath" File path is invalid;
                                                        // "CreateDirectoryFailed"  Create a folder path fails;
                                                        // "WriteDataFailed" Intermediate file failed to write Tube
                                                        // "DataSizeTooLarge" Tube file is too large
                                                        // "Detect_Nothing" Scene without moving target
                                                        // "OpenDataFailed" Failed to open the intermediate file
                                                        // "InvalidSynopsisBackgroud" Invalid concentrated background
                                                        // "ColorRetrieval" Wrong color retrieve configuration
                                                        // "UnsupportRuleType" Unsupported rule type
                                                        // "RuleNumberExceedLimit" Number of rules overrun
                                                        // "NoFunctionCfgInfo" But did not specify the configuration information corresponding function
                                                        // "FunctionNumberExceedLimit" The number of feature quantity of each rule overrun
                                                        // "PointsExceedLimit" Point line or area overrun
                                                        // "BadFunctionType" Error function type
                                                        // "RulePointNumber" Points rule error
                                                        // "MaskRegionNumberExceedLimit" Shielded area overrun quantity
                                                        // "CameraSceneSwitch" Cameras scene change
                                                        // "TooManyTargeInFrame" Excessive number of single-frame target
                                                        // "InalidSynopsisDesity" Concentrated density invalid
                                                        // "ExtrackColorFeatureFailed" Failed to extract color features
                                                        // "JpegEncodeFrameFailed" Jpeg encoder failure
                                                        // "JpegParamRestFailed" Jpeg encoding parameters fail reset
                                                        // "JpegDecodeFrameFailed" Jpeg decoding failure
                                                        // "RetrieveObjectIdInvalid" Retrieving Target ID is invalid
                                                        // "RetrieveImageInvalid" RetrieveImageInvalid
                                                        // "NetworkAnomaly" NetworkAnomaly
                                                        // "ObjectNumberLimit" bjectNumberLimit
                                                        // "CreateChannelFailed" CreateChannelFailed
                                                        // "ReadUGFileFailed" ReadUGFileFailed
                                                        // "GetSynopsisInfoFailed" GetSynopsisInfoFailed
                                                        // "ObjectNumberExceedLimit" ObjectNumberExceedLimit
                                                        // "RebuildBackgroudFailed" RebuildBackgroudFailed
                                                        // "NotExistMiddleFile" NotExistMiddleFile
                                                        // "NotExistSourceFile" NotExistSourceFile
                                                        // "NotDog" NotDog
                                                        // "NotEnoughFreeDisk" NotEnoughFreeDisk
                                                        // "StartDecodeFail"StartDecodeFail
                                                        // "DecodeTimeOut" DecodeTimeOut
                                                        // "EncodeTimeOut" EncodeTimeOut
                                                        // "ExactTimeOut" ExactTimeOut
                                                        // "ReadMidlleFileFail" ReadMidlleFileFail
                                                        // "ExactPictureFail" ExactPictureFail
}NET_VSTASK_INFO;

// each object in the synopsis video task info
typedef struct tagNET_VSOBJECT_INFO
{
	DWORD				dwSize;			                // size 
	DWORD				dwTaskID;		                // task ID
	DH_MSG_OBJECT		stuObjInfo;		                // object info
	NET_FILEPATH_INFO	stuFilePathInfo;                // file info
	DWORD				dwFileLength;	                // file length
}NET_VSOBJECT_INFO;

//--CLIENT_QueryVideoSynopsisInfo's interface output define
typedef struct tagNET_OUT_QUERY_VIDEOSYNOPSIS
{
	DWORD	            dwSize;			                // size
	DWORD	            dwTotalCount;	                // total count
	DWORD            	dwFoundCount;	                // found count
	void*	            pResult;                		// return result info
					                		            // if emQueryType==EM_VIDEOSYNOPSIS_TASK,corresponding to NET_VSTASK_INFO
							                            // if emQueryType==EM_VIDEOSYNOPSIS_OBJ,corresponding to NET_VSOBJECT_INFO
	DWORD	            dwMaxCount;		                // hope tp get the number
}NET_OUT_QUERY_VIDEOSYNOPSIS;

// CLIENT_FindSynopsisFile's interface define 
// query type of file
typedef enum tagNET_EM_QUERY_SYNOPSIS_FILE
{
	DH_FILE_QUERY_VIDEO,                                // normal record file info,corresponding to:NET_SYNOPSIS_QUERY_VIDEO_PARAM, return result:NET_SYNOPSISFILE_VIDEO_INFO
	DH_FILE_QUERY_SYNOPSISVIDEO,                        // synopsis video file,corresponding to:NET_QUERY_SYNOPSISVIDEO_PARAM,return result:NET_QUERY_SYNOPSISVIDEO_INFO
}NET_EM_QUERY_SYNOPSIS_FILE;

typedef struct __NET_SYNOPSIS_QUERY_VIDEO_PARAM
{
	DWORD               dwSize;
	DWORD				dwQueryMask;					// query type mask, according to from low to high,the first bit is period of time, the second is file path 
	NET_TIME			stuStartTime;					// start time
	NET_TIME			stuEndTime;						// end time
	char				szFilePath[DH_MAX_SYNOPSIS_QUERY_FILE_COUNT][MAX_PATH];	// file path
	DWORD				dwFileCount;					// file count
}NET_SYNOPSIS_QUERY_VIDEO_PARAM;

typedef struct  
{
	DWORD               dwSize;
	int                 nTaskId;                        // taskID
	DWORD               dwOutPutTypeMask;               // output type in current,the first bit is snapshot,the second bit is synopsis video 
	char                szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; // current state
}NET_VIDEOSYNOPSIS_TASK_INFO;

// DH_FILE_QUERY_VIDEO return video file info
typedef struct
{
	DWORD               dwSize;
    unsigned int		nchannelId;						// channel ID
    char				szFilePath[MAX_PATH];		    // file path
    unsigned int		nFileLenth;					    // file lenth(byte)
    NET_TIME			stuStarttime;				    // start time 
    NET_TIME			stuEndtime;				        // end time
    unsigned int		nWorkDirSN;				        // work dir SN	
	unsigned int        nCluster;                       // cluster				
	BYTE                bHint;					        // hint
	BYTE                bDriveNo;                       // drive no.
	BYTE                bReserved[18];                  // reserved
	
	int                 nTaskInfoNum;                   // task info number
	NET_VIDEOSYNOPSIS_TASK_INFO stuTaskInfo[16];        // video synopsis task info
    char szSynopsisPicPath[DH_COMMON_STRING_512];       // The snap image file path get by pre-process file.  
    int                 nSynopsisMaxTime;               // Supported video synopsis max time. Unit is second. 
    int                 nSynopsisMinTime;               // Supported video synopsis min time. Unit is second. 
}NET_SYNOPSISFILE_VIDEO_INFO;

// DH_FILE_QUERY_SYNOPSISVIDEO synopsis viedo file query param
typedef struct __NET_QUERY_SYNOPSISVIDEO_PARAM
{
	DWORD               dwSize;
	int                 nTaskID;                        // taskID
}NET_QUERY_SYNOPSISVIDEO_PARAM;

// DH_FILE_QUERY_SYNOPSISVIDEO query result
typedef struct __NET_QUERY_SYNOPSISVIDEO_INFO
{
	DWORD               dwSize;
    char				szFilePath[MAX_PATH];        	// file path
    unsigned int		nFileLenth;					    // file lenth
	int                 nDurationTime;                  // duration time(s)
}NET_QUERY_SYNOPSISVIDEO_INFO;

// CLIENT_FindSynopsisFile's interface param
typedef struct tagNET_IN_FIND_SYNOPSISFILE
{
	DWORD               dwSize;                          
	NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // query's type
	void*               pQueryCondition;                // query's type
	int                 nWaitTime;                      // wait time(ms)
}NET_IN_FIND_SYNOPSISFILE;

typedef struct tagNET_OUT_FIND_SYNOPSISFILE
{
	DWORD               dwSize;
	LLONG               lFindHandle;                    // find handle         
}NET_OUT_FIND_SYNOPSISFILE;

// CLIENT_FindNextSynopsisFile's interface param
typedef struct tagNET_IN_FINDNEXT_SYNOPSISFILE
{
	DWORD               dwSize;
    int                 nFileCount;                     // count of file
	NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // query's type
	void*               pSynopsisFileInfo;              // info of file buf
	int                 nMaxlen;                        // size of buf
	int                 nWaitTime;                      // wait time(ms)
}NET_IN_FINDNEXT_SYNOPSISFILE;

typedef struct tagNET_OUT_FINDNEXT_SYNOPSISFILE
{
	DWORD               dwSize;
	int                 nRetFileCount;                  // the actual return information artucle number,return<nFileCount(input param) corresponding period of the finished file query
}NET_OUT_FINDNEXT_SYNOPSISFILE;

// download progress's callback,nError means downloading appear error,1 - cashe is insufficient,2-data validation error,3.download failed,4,create file failed
typedef void (CALLBACK *fSynopsisFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwFileID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);

// CLIENT_DownLoadSynosisFile's interface param
typedef  NET_DOWNLOADFILE_INFO NET_SYNOPSIS_DOWNLOADFILE_INFO;

typedef struct tagNET_IN_DOWNLOAD_SYNOPSISFILE
{
	DWORD               dwSize;
    int                 nFileCount;                     // count of file
	NET_SYNOPSIS_DOWNLOADFILE_INFO* pFileInfos;         // file info
	fSynopsisFileDownLoadPosCB cbPosCallBack;           // post of callback function
	LDWORD              dwUserData;                     // user's data
	int                 nWaitTime;                      // wait time(ms)
}NET_IN_DOWNLOAD_SYNOPSISFILE;

typedef struct tagNET_OUT_DOWNLOAD_SYNOPSISFILE
{
	DWORD               dwSize;
	LLONG               lDownLoadHandle;                // handle of download
}NET_OUT_DOWNLOAD_SYNOPSISFILE;

// path of file's info 
typedef struct	tagNET_SET_FILEPATH_INFO
{
	DWORD		        dwSize;
	char		        szFilePath[MAX_PATH];	        // can be a folder ,can be the file,current server only supports the dav format file
}NET_SET_FILEPATH_INFO;

// CLIENT_SetFilePathInfo()interface input param
typedef struct tagNET_IN_SET_FILEPATHINFO
{
	DWORD		        dwSize;
	DWORD		        dwCount;		                // count of added file
	void*	        	pFilePathInfo;                	// look for NET_SET_FILEPATH_INFO
	DWORD		        dwWaitTime;		                // wait time(ms)
}NET_IN_SET_FILEPATHINFO;


// fAddFileStateCB param
typedef struct tagNET_CB_ADDFILESTATE
{
	DWORD		        dwSize;
	const char*         szFileName;                     // file name
	const char*         szState;                        // analyse file's state, "Successed" ; "Failed" ;
}NET_CB_ADDFILESTATE;

// burning device callback function, pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAddFileStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_ADDFILESTATE* pBuf,  int nBufLen, LDWORD dwUser);

// CLIENT_AttacAddFileState()interface input param
typedef struct tagNET_IN_ADDFILE_STATE
{
	DWORD		        dwSize;
	fAddFileStateCB     cbAttachState;                 // listenint to increase callback file state
	LDWORD              dwUser;                        // user's data
}NET_IN_ADDFILE_STATE;
typedef struct tagNET_OUT_ADDFILE_STATE
{
	DWORD		        dwSize;
}NET_OUT_ADDFILE_STATE;

///////////////////////////////////Face recognition module related structures///////////////////////////////////////
typedef struct tagNET_UID_CHAR
{
    char szUID[DH_MAX_PERSON_ID_LEN];  //UID contents 
}NET_UID_CHAR;

// CLIENT_OperateFaceRecognitionDBInterface input parameters
typedef struct __NET_IN_OPERATE_FACERECONGNITIONDB
{
	DWORD             dwSize;
	EM_OPERATE_FACERECONGNITIONDB_TYPE emOperateType;  // Type of operation
	FACERECOGNITION_PERSON_INFO        stPersonInfo;   // Personnel information

	// Picture binary data
    DWORD            nUIDNum;							// UID amount              
    NET_UID_CHAR     *stuUIDs;							// Person unique mark. Generated by the client if it is the first time. Different from the ID string. 
	char                *pBuffer;						// Buffer address
	int                 nBufferLen;						// Buffer data length
}NET_IN_OPERATE_FACERECONGNITIONDB;

// CLIENT_OperateFaceRecognitionDB port output parameter
typedef struct __NET_OUT_OPERATE_FACERECONGNITIONDB
{
    DWORD               dwSize;
}NET_OUT_OPERATE_FACERECONGNITIONDB;

typedef struct __NET_FACE_MATCH_OPTIONS
{
	DWORD               dwSize;
	unsigned int        nMatchImportant;               // Important level 1 to 10 staff, the higher the number the more important (check important level greater than or equal to this level of staff)
	EM_FACE_COMPARE_MODE emMode;                       // Face comparison mode, see EM_FACE_COMPARE_MODE
	int                 nAreaNum;                      // Face the number of regional
	EM_FACE_AREA_TYPE   szAreas[MAX_FACE_AREA_NUM];    // Regional groupings of people face is NET_FACE_COMPARE_MODE_AREA effective when emMode
	int                 nAccuracy;                     // Recognition accuracy (ranging from 1 to 10, with the value increases, the detection accuracy is improved, the detection rate of decline. Minimum value of 1 indicates the detection speed priority, the maximum is 10, said detection accuracy preferred. Temporarily valid only for face detection)
	int                 nSimilarity;                   // Similarity (must be greater than the degree of acquaintance before the report; expressed as a percentage, from 1 to 100)
	int                 nMaxCandidate;                 // Reported the largest number of candidate (based on similarity to sort candidates to take the maximum number of similarity report)
	
}NET_FACE_MATCH_OPTIONS;

typedef struct __NET_FACE_FILTER_CONDTION
{
	DWORD               dwSize;
	NET_TIME			stStartTime;			       // Start time
    NET_TIME			stEndTime;				       // End Time
	char                szMachineAddress[MAX_PATH];    // Place to support fuzzy matching
	int                 nRangeNum;                     // The actual number of database
	BYTE                szRange[MAX_FACE_DB_NUM];      // To query the database type, see EM_FACE_DB_TYPE
	EM_FACERECOGNITION_FACE_TYPE emFaceType;           // Face to query types, see EM_FACERECOGNITION
    int                 nGroupIdNum;                   // staff group  
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID 
}NET_FACE_FILTER_CONDTION;
// CLIENT_StartFindFaceRecognitionInterface input parameters
typedef struct __NET_IN_STARTFIND_FACERECONGNITION
{
	DWORD               dwSize;
	BOOL                bPersonEnable;                 // Personnel information query is valid
	FACERECOGNITION_PERSON_INFO stPerson;              // Personnel information query
	NET_FACE_MATCH_OPTIONS stMatchOptions;             // Face Matching Options
	NET_FACE_FILTER_CONDTION stFilterInfo;             // Query filters
  
	// Picture binary data
	char                *pBuffer;                      // Buffer address
	int                 nBufferLen;                    //Buffer data length

    int                 nChannelID;                    // Channel ID        
}NET_IN_STARTFIND_FACERECONGNITION;

// CLIENT_StartFindFaceRecognitionInterface output parameters
typedef struct __NET_OUT_STARTFIND_FACERECONGNITION
{
	DWORD               dwSize;
	int                 nTotalCount;                   // Record number of returns that match the query criteria
	LLONG               lFindHandle;                   // Query handle
    int                 nToken;                        // The search token received 
}NET_OUT_STARTFIND_FACERECONGNITION;

#define MAX_FIND_COUNT  20

// CLIENT_DoFindFaceRecognition Interface input parameters
typedef struct __NET_IN_DOFIND_FACERECONGNITION
{
	DWORD               dwSize;
	LLONG               lFindHandle;                   // Query handle
	int                 nBeginNum;                     // Queries starting serial number
	int                 nCount;                        // The current number of records you want to search for
}NET_IN_DOFIND_FACERECONGNITION;

// CLIENT_DoFindFaceRecognitionInterface output parameters
typedef struct __NET_OUT_FINDNEXT_FACERECONGNITION
{
	DWORD               dwSize;
	int                 nCadidateNum;                  // The actual number of candidate information structure returned
	CANDIDATE_INFO      stCadidateInfo[MAX_FIND_COUNT];// An array of candidate information
	
	// Picture binary data
	char                *pBuffer;                      // Buffer address
	int                 nBufferLen;                    // Buffer data length
}NET_OUT_DOFIND_FACERECONGNITION;

// CLIENT_DetectFaceInterface input parameters
typedef struct __NET_IN_DETECT_FACE
{
	DWORD               dwSize; 
	DH_PIC_INFO         stPicInfo;                     // Big picture information

	// Picture binary data
	char                *pBuffer;                      // Buffer address
	int                 nBufferLen;                    // Buffer data length
}NET_IN_DETECT_FACE;

// CLIENT_DetectFaceInterface output parameters
typedef struct __NET_OUT_DETECT_FACE
{
	DWORD               dwSize; 
	DH_PIC_INFO         *pPicInfo;                     // The detected face image information from the user space applications
	int                 nMaxPicNum;                    // The maximum number of face image information
	int                 nRetPicNum;                    // The actual number of returning faces pictures
	
	// Picture binary data
	char                *pBuffer;                      // Buffer address, the user application space to store the detected face image data
	int                 nBufferLen;                    // Buffer data length
}NET_OUT_DETECT_FACE;

// staff group operation enumeration
typedef enum tagEM_OPERATE_FACERECONGNITION_GROUP_TYPE
{
  NET_FACERECONGNITION_GROUP_UNKOWN,
  NET_FACERECONGNITION_GROUP_ADD,           // add staff group info 
  NET_FACERECONGNITION_GROUP_MODIFY,         // modify staff group info  
  NET_FACERECONGNITION_GROUP_DELETE,         // delete staff group info 
}EM_OPERATE_FACERECONGNITION_GROUP_TYPE;

// staff group info 
typedef struct tagNET_FACERECONGNITION_GROUP_INFO
{
  DWORD        dwSize;
  EM_FACE_DB_TYPE   emFaceDBType;         // staff group type ¡ê? see  EM_FACE_DB_TYPE
  char        szGroupId[DH_COMMON_STRING_64];// staff group ID¡ê?SN(cannot modify, invalid when adding operation)
  char        szGroupName[DH_COMMON_STRING_128]; // staff operation name 
  char        szGroupRemarks[DH_COMMON_STRING_256]; // staff group note info 
  int         nGroupSize;          //  current group staff number
}NET_FACERECONGNITION_GROUP_INFO;

// add staff group info 
typedef struct tagNET_ADD_FACERECONGNITION_GROUP_INFO
{
  DWORD        dwSize;
  NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;   // staff group info 
}NET_ADD_FACERECONGNITION_GROUP_INFO;

// delete staff group info 
typedef struct tagNET_DELETE_FACERECONGNITION_GROUP_INFO
{
  DWORD        dwSize;
  char        szGroupId[DH_COMMON_STRING_64];// staff group ID¡ê?SN staff
}NET_DELETE_FACERECONGNITION_GROUP_INFO;

// modify staff group info 
typedef struct tagNET_MODIFY_FACERECONGNITION_GROUP_INFO
{
  DWORD        dwSize;
  NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;   // staff group info 
}NET_MODIFY_FACERECONGNITION_GROUP_INFO;

// CLIENT_OperateFaceRecognitionGroup port input parameter
typedef struct tagNET_IN_OPERATE_FACERECONGNITION_GROUP
{
  DWORD        dwSize;
  EM_OPERATE_FACERECONGNITION_GROUP_TYPE emOperateType; // operation type 
  void        *pOPerateInfo;         // operation info 
}NET_IN_OPERATE_FACERECONGNITION_GROUP;  

// CLIENT_OperateFaceRecognitionGroup port output parameter
typedef struct tagNET_OUT_OPERATE_FACERECONGNITION_GROUP
{
  DWORD        dwSize;
  char        szGroupId[DH_COMMON_STRING_64]; // new record staff group ID¡ê?SN staff
}NET_OUT_OPERATE_FACERECONGNITION_GROUP;  

// CLIENT_FindGroupInfo port input parameter
typedef struct tagNET_IN_FIND_GROUP_INFO  
{
  DWORD        dwSize;
  char        szGroupId[DH_COMMON_STRING_64];// staff ID¡ê?SN staff, as null means search all staff group info 
}NET_IN_FIND_GROUP_INFO;

// CLIENT_FindGroupInfo port output parameter
typedef struct tagNET_OUT_FIND_GROUP_INFO  
{
  DWORD        dwSize;
  NET_FACERECONGNITION_GROUP_INFO *pGroupInfos;   // staff group info ¡ê?apply space by user
  int         nMaxGroupNum;         //  current applied group size
  int         nRetGroupNum;         // device returned staff group number 
}NET_OUT_FIND_GROUP_INFO;


// CLIENT_SetGroupInfoForChannel port input parameter
typedef struct tagNET_IN_SET_GROUPINFO_FOR_CHANNEL
{
  DWORD        dwSize;
  int         nChannelID;          // channel no.
  int         nGroupIdNum;          // staff group  
  char        szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // staff group ID 
}NET_IN_SET_GROUPINFO_FOR_CHANNEL;
// CLIENT_SetGroupInfoForChannel port output parameter
typedef struct tagNET_OUT_SET_GROUPINFO_FOR_CHANNEL
{
  DWORD        dwSize;
}NET_OUT_SET_GROUPINFO_FOR_CHANNEL;

typedef struct tagNET_CB_FACE_FIND_STATE
{
    DWORD               dwSize;     
    int                 nToken;         //Video synopsis task database main key ID 
    int                 nProgress;      //Normal value: 0-100. 1=Searched token does not exist (When subscribe a search that does not exist or already finished)
    int                 nCurrentCount;  //The human face amount that match current criteria
}NET_CB_FACE_FIND_STATE;
typedef void (CALLBACK *fFaceFindState)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_FACE_FIND_STATE* pstStates, int nStateNum, LDWORD dwUser);

//CLIENT_AttachFaceFindState interface parameter in
typedef struct tagNET_IN_FACE_FIND_STATE
{
    DWORD           dwSize;             //Structure size. Must fill in. 
    int             nTokenNum;          //Search token. 0=subscribe all searched tasks.
    int            *nTokens;            //Search token
    fFaceFindState  cbFaceFindState;    //Call function 
    LDWORD          dwUser;             //User data 
}NET_IN_FACE_FIND_STATE;
// CLIENT_AttachFaceFindState interface parameter in
 typedef struct  tagNET_OUT_FACE_FIND_STATE
 {
    DWORD           dwSize;
 }NET_OUT_FACE_FIND_STATE;
// CLIENT_FaceRecognitionSetSearchImageInfo 
typedef struct tagNET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
{
    DWORD               dwSize;
    int                 nChannel;                           // Channel ID
    char                szFilePath[DH_COMMON_STRING_256];   // File path
}NET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;
// CLIENT_FaceRecognitionSetSearchImageInfo 
typedef struct tagNET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
{
    DWORD                dwSize;
}NET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;
//////////////////////////////// burn the upload////////////////////////////////

// fBurnCheckCallBack Parameter
typedef struct tagNET_CB_BURN_CHECK_STATE
{
	DWORD		        dwSize;
	const char*         szType;							// Message Type
														// "Checking": Check in
														// "CheckResult": CheckResult
	BOOL				bCheckResult;					// Calibration results for "CheckResult", TRUE-success, FALSE-failure
	BYTE				byProgress;						// Calibration schedule for "Checking", the percentage of 0 to 100
	BYTE				reserved[3];
} NET_CB_BURN_CHECK_STATE;

// Burn verification callback function prototype, lAttachHandle return value is CLIENT_AttachBurnCheckState
typedef void (CALLBACK *fBurnCheckCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURN_CHECK_STATE* pstState, void* reserved, LDWORD dwUser);

// CLIENT_AttachBurnCheckState Input parameter interface (monitor burn parity status)
typedef struct tagNET_IN_ATTACH_BURN_CHECK 
{
	DWORD				dwSize;
	fBurnCheckCallBack  cbBurnCheck;					// Burn verification callback
	LDWORD              dwUser;							// User data
} NET_IN_ATTACH_BURN_CHECK;

// CLIENT_AttachBurnCheckState Output parameters of the interface (listening burning parity status)
typedef struct tagNET_OUT_ATTACH_BURN_CHECK
{
    DWORD            dwSize;
} NET_OUT_ATTACH_BURN_CHECK;

///////////////////////////////// logical device /////////////////////////////////

typedef struct tagNET_CB_CAMERASTATE
{
	DWORD		        dwSize;
	int                 nChannel;             // channel
	CONNECT_STATE       emConnectState;       // state of connect
}NET_CB_CAMERASTATE;

// CLIENT_AttachCameraState()callback function, pBuf->dwSize == nBufLen
typedef void (CALLBACK *fCameraStateCallBack) (LLONG lLoginID, LLONG lAttachHandle, const NET_CB_CAMERASTATE *pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachCameraState()input param
typedef struct tagNET_IN_CAMERASTATE
{
	DWORD		        dwSize;
	int *               pChannels;             // observation of the channel, if the value = -1,is boservate all channel
	int                 nChannels;             // length of pChannels pointer
    fCameraStateCallBack cbCamera;             // state of callback function
	LDWORD				dwUser;                // user's data
}NET_IN_CAMERASTATE;
typedef struct tagNET_OUT_CAMERASTATE
{
	DWORD		        dwSize;
}NET_OUT_CAMERASTATE;

////////////////////////////////Special version/////////////////////////////////

// Activate device to snapshot overlay card number information 
typedef struct __NET_SNAP_COMMANDINFO 
{
	char				szCardInfo[16];			// Card information
	char				reserved[64];			// Reserved 
} NET_SNAP_COMMANDINFO, LPNET_SNAP_COMMANDINFO;

typedef struct
{
	int					nChannelNum;			// Channel number 
	char				szUseType[32];			// Channel type 
	DWORD				dwStreamSize;			// Stream size(Unit:kb/s)
	char				reserved[32];			// Reserved 
} DHDEV_USE_CHANNEL_STATE;

typedef struct 
{
	char				szUserName[32];			// User name 
	char				szUserGroup[32];		// User group 
	NET_TIME			time;					// Log in time
	int					nOpenedChannelNum;		// Enabled channel amount 
	DHDEV_USE_CHANNEL_STATE	channelInfo[DH_MAX_CHANNUM];
	char                szIpAddress[DH_MAX_IPADDR_LEN_EX];  // ip
    char                reserved[24];
} DHDEV_USER_NET_INFO;

// Network running status information 
typedef	struct 
{
	int					nUserCount;				// User amount
	DHDEV_USER_NET_INFO	stuUserInfo[32];
	char				reserved[256];
}DHDEV_TOTAL_NET_STATE;

typedef struct
{
    char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip
	char                szUserGroup[32];                 // User Group
	char                szUserName[32];                  // User Name
	char                reserved[64];
}DHDEV_USER_REJECT_INFO;

// Reject User
typedef struct
{ 
	int                       nUserCount;				// User Account
	DHDEV_USER_REJECT_INFO    stuUserInfo[10];     
	char				      reserved[256];
}DHDEV_REJECT_USER;

typedef struct
{
	char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip
	char                szUserGroup[32];                 // User Group
	char                szUserName[32];                  // User Name
	int                 nForbiddenTime;                  // Forbidden Time
	char                reserved[64];
}DHDEV_USER_SHIELD_INFO;

// Shield User
typedef struct
{ 
	int                       nUserCount;          // User Account
	DHDEV_USER_SHIELD_INFO    stuUserInfo[10];     
	char				      reserved[256];
}DHDEV_SHIELD_USER;

// longitude latitude
typedef struct
{//  longitude first,then latitude
	char                chPreLogi;        // preflag of longitude:N(north),S(south),W(west),E(east)
	char                chPreLati;        // preflag of latitude:N(north),S(south),W(west),E(east)
	BYTE                reserved[6];      // 
	double              dbLongitude;      // longitude
	double              dbLatitude;       // latitude
}DHDEV_LONGI_LATI;

// NAVIGATION OR SMS
typedef struct
{
	char                szPhoneNum[DH_MAX_PHONE_NO_LEN];    // phone no
	NET_TIME            stMsgTime;                          // time of sending message
	char                szMsgType[DH_MAX_MSGTYPE_LEN];      // type:Navigation message-Navigation,short message--SMS
	char                szSmsContext[DH_MAX_MSG_LEN];       // message to send

	DHDEV_LONGI_LATI    stLogiLati;                         // longitude
	unsigned int        uFlag;                              // 01:marking true longitude
	char                szNavigationType[16];               // TNC,TXZ
	char                szAddress[32];                      // address
	char                szNavigationMode[32];               // mode
	DHDEV_LONGI_LATI    stPassLogiLati[5];                  // passing
	DHDEV_LONGI_LATI    stNoPassLogiLati[5];                // no passing
	BYTE				reserved[256];
}DHDEV_NAVIGATION_SMSS;

// Image watermark setup 
typedef struct __DHDEV_WATERMAKE_CFG 
{
	DWORD				dwSize;
	int					nEnable;				// Enable 
	int					nStream;				// Bit stream(1~n)0- All bit streams
	int					nKey;					// Data type(1- text,2- image )
	char				szLetterData[DH_MAX_WATERMAKE_LETTER];	// text
	char				szData[DH_MAX_WATERMAKE_DATA]; // Image data
	BYTE				bReserved[512];			// Reserved
} DHDEV_WATERMAKE_CFG;

// Storage position set structure.  Each channel set separately.Each channel can set several storage types including local,portableand remote storage.
typedef struct 
{
	DWORD				dwSize;
	DWORD				dwLocalMask;			// Local storage mask. Use bit to represent.
												// The first bit:system pre-record. The second bit:scheduled record. The third bit:motion detection record.
												// The fourth bit:alarm record. The fifth bit:card record. The sixth bit:manual record.
	DWORD				dwMobileMask;			// Moving storage mask. Storage mask such as local storage mask.
	int					RemoteType;				// Remote storage type 0: Ftp  1: Smb 
	DWORD				dwRemoteMask;			// Remote storage mask.  Storage mask such as local storage mask.
	DWORD				dwRemoteSecondSelLocal;	// Local storage mask when remote is abnormal
	DWORD				dwRemoteSecondSelMobile;// Moving storage mask when remote is abnormal.
	char				SubRemotePath[MAX_PATH_STOR]; // Remote path. Its length is 240
	DWORD				dwFunctionMask;			// Function shield bit. Use bit to represent bit0 = 1:Shield sanpshot event activate storage position function.
	DWORD				dwAutoSyncMask;			// If synchronous mask; after remote storage network recovery, the local storage data will automatically synchronized to the remote storage.
	BYTE				bAutoSyncRange;			// the time for synchronous from the network synchronous time. In hour. 0:all data  1:data in one hour n:data in n hours
	char				reserved[119];
} DH_STORAGE_STATION_CFG;

#define MAX_ALARM_DECODER_NUM 16
typedef struct  
{
	DWORD				dwAlarmDecoder;			// Now it supports max 8 alarm input ports. Reserved 8 bits for future development.
	BYTE				bDecoderIndex;			// It means it is from which alarm decoder.
	BYTE				bReserved[3];
} ALARM_DECODER;

// Alarm decoder alarm 
typedef struct
{
	int					nAlarmDecoderNum;
	ALARM_DECODER		stuAlarmDecoder[MAX_ALARM_DECODER_NUM];
	BYTE				bReserved[32];
} ALARM_DECODER_ALARM;

//DSP alarm
typedef struct  
{
	BOOL				bError;			//0,DSP normal 1,DSP abnormal
	DWORD				dwErrorMask;	//Bit shows,Nor 0 shows havening this error,0 shows no.(Now alarm has only 1 bit valid)
										//bit		DSP alarm
										//1			DSP downloading failure 
										//2			DSP error
										//3			Format not correct 
										//4			Resolution not support
										//5			Data format not support
										//6			Can't find I frame
	DWORD               dwDecChnnelMask;//Bit shows,alarm decoding channel number,dwErrorMask is DSP fault,incorrect format,incorrect resolution,data format not support
	DWORD               dwDecChnnelMask1;//Bit shows,33-64 is alarm of decoding channel, dwErrorMask is DSP mistake,format is wrong, effective when not support resolution or data format
	BYTE				bReserved[24];
} DSP_ALARM;

// Fiber-optic alarm
typedef struct  
{
	int		nFDDINum;
	BYTE	bAlarm[256];
} ALARM_FDDI_ALARM;

#define ALARM_PTZ_LOCATION_INFO DH_PTZ_LOCATION_INFO

// New audio detection alarm setup 
typedef struct
{
	BOOL				bEnable;				// Enable alarm input 
	int					Volume_min;				// Min volume
	int					Volume_max;				// Max volume
	char				reserved[128];	
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	
	DH_MSG_HANDLE		struHandle;				// Process way 
} DH_AUDIO_DETECT_INFO;

typedef struct  
{
	DWORD				dwSize;
	int					AlarmNum;
	DH_AUDIO_DETECT_INFO AudioDetectAlarm[DH_MAX_AUDIO_IN_NUM];
	char				reserved[256];
} DH_AUDIO_DETECT_CFG;

typedef struct
{
	BOOL				bTourEnable;			// Enable tour
	int					nTourPeriod;			// Tour interval. Unit is second. The value ranges from 5 to 300 
	DWORD				dwChannelMask;			// Tour channel. Use mas bit to represent.
	char				reserved[64];
}DH_VIDEOGROUP_CFG;

// Local matrix control strategy setup 
typedef struct
{
	DWORD				dwSize;
	int					nMatrixNum;				// Matrix amount(Read only )
	DH_VIDEOGROUP_CFG	struVideoGroup[DH_MATRIX_MAXOUT];
	char				reserved[32];
} DHDEV_VIDEO_MATRIX_CFG;   

// WEB path setup 
typedef struct 
{
	DWORD				dwSize;
	BOOL				bSnapEnable;					// Snapshot or not
	int					iSnapInterval;					// Snapshot interval
	char				szHostIp[DH_MAX_IPADDR_LEN];	// HTTP host IP
	WORD				wHostPort;
	int					iMsgInterval;					// Message sending out interval
	char				szUrlState[DH_MAX_URL_LEN];		// Status message upload URL
	char				szUrlImage[DH_MAX_URL_LEN];		// Image upload Url
	char				szDevId[DH_MAX_DEV_ID_LEN];		// Device web serial number
	BYTE				byReserved[2];
} DHDEV_URL_CFG;

// OEM search 
typedef struct  
{
	char				szVendor[DH_MAX_STRING_LEN];
	char				szType[DH_MAX_STRING_LEN];
	char				reserved[128];
} DHDEV_OEM_INFO;


//Video OSD
typedef struct 
{ 
	DWORD	rgbaFrontground;		// Object front view. Use bit to represent:red,green, blue and transparency.
	DWORD	rgbaBackground;			// Object background. Use bit to represent:red,green, blue and transparency
	RECT	rcRelativePos;			// Position. The proportion of border distance and whole length *8191
	BOOL	bPreviewBlend;			// Enable preview overlay	
	BOOL	bEncodeBlend;			// Enable encode overlay
	BYTE    bReserved[4];           // Reserved 
} DH_DVR_VIDEO_WIDGET;

typedef struct 
{
	DH_DVR_VIDEO_WIDGET	StOSD_POS; 								// OSD position and background color.
	char 				SzOSD_Name[DH_VIDEO_OSD_NAME_NUM]; 		// OSD name 
}DH_DVR_VIDEOITEM;
 
// OSD information in each channel
typedef struct 
{
	DWORD 				dwSize;
	DH_DVR_VIDEOITEM 	StOSDTitleOpt [DH_VIDEO_CUSTOM_OSD_NUM];// Each channel OSD information
	BYTE    			bReserved[16];							// Reserved
} DH_DVR_VIDEOOSD_CFG;

// CDMA/GPRS Configuration
// Time structure															    
typedef struct 
{
	BYTE				bEnable;					// Time period enable,1 shows this time period valid,0 shows invalid.
	BYTE				bBeginHour;
	BYTE				bBeginMin;
	BYTE				bBeginSec;
	BYTE				bEndHour;
	BYTE				bEndMin;
	BYTE				bEndSec;
	BYTE    			bReserved;					//Reserved
} DH_3G_TIMESECT, *LPDH_3G_TIMESECT;

typedef struct 
{
	DWORD 				dwSize;
	BOOL				bEnable;					// Wireless module enable
	DWORD               dwTypeMask;                 // Network type mask;Use bit to represent,The first bit:Automatic selection
													// The second bit:TD-SCDMA network;The third bit:WCDMA network;
													// The fourth bit:CDMA 1.x network;The fifth bit:GPRS network;The sixth bit:EVDO network
													// The seventh bit:EVDO network;The eighth bit:WIFI network;
	DWORD               dwNetType;                  // Types of wireless networks,EM_GPRSCDMA_NETWORK_TYPE
	char				szAPN[128];					// Access Point Name
	char				szDialNum[128];				// Dial-up number
	char				szUserName[128];			// Dial-up user name
	char				szPWD[128];					// Dial-up Password
	
	/* Read-only part */
	BOOL				iAccessStat;				// Wireless network registration status
    char				szDevIP[16];				// dial-up IP of Front-end equipment  
	char				szSubNetMask [16];			// Dial-up mask of Front-end equipment
	char				szGateWay[16];				// Dial-up Gateway of Front-end equipment

	int                 iKeepLive;					// Keep-alive time
	DH_3G_TIMESECT		stSect[DH_N_WEEKS][DH_N_TSECT];// 3G dial period,valid time period,start dialing;beyond this period,shut the dial.
	BYTE                byActivate;                  //Whether need to be active by voice or message
	
	BYTE                bySimStat;                    //SIM(UIM) State: 1, 0 (read-only data) be occupied the 1 byte
	char                szIdentify[128];               // identify mode
	bool                bPPPEnable;                    // PPP Dial-up,0- cut down ppp connect,1-ppp dial-up
	BYTE                bPPPState;                     // PPP Dial-up statr(real only),see EM_MOBILE_PPP_STATE
	BYTE                bNetCardState;                 // net card state(read only),see EM_3GMOBILE_STATE
	char				szPhyCardNo[32];			  // physics card no.
	char				Reserved[4];				   // reserved
	BYTE				byPinShow;					// PIN show or not(read only), 0-don't support 1-show, 2-don't show
	BYTE				byPinEnable;				// PIN setting enable(read only), 0-disable, 1-enable
	BYTE				byPinCount;					// the rest of pin setting number(read only), 0~3
	//-------------------------------the following fields in setting up effective after dwSize------------------------------------
	char				szPinNo[16];				// value of PIN, a combination of letters or numbers
} DHDEV_CDMAGPRS_CFG;

// The length of the video package configuration
typedef struct  
{
	DWORD 				dwSize;
	int					nType;						// 0:by time,1:by size
	int					nValue;						// nType = 0:(minutes),nType = 1:(KB)
	char				Reserved[128];				// Reserved
} DHDEV_RECORD_PACKET_CFG;

// (Directional)register the server information
typedef struct __DEV_AUTOREGISTER_INFO 
{
	LONG			lConnectionID;					// Connection ID
	char			szServerIp[DH_MAX_IPADDR_LEN];	// Server IP
	int				nPort;							// Port:0- 65535
	int             nState;                         // Server status:0-Registration failure;1-Registration success; 2-Connection failed
	char			reserved[16];
} DEV_AUTOREGISTER_INFO;

typedef struct __DEV_SERVER_AUTOREGISTER 
{
	DWORD					dwSize;
	int						nRegisterSeverCount;									// Number of registered servers
	DEV_AUTOREGISTER_INFO	stuDevRegisterSeverInfo[DH_CONTROL_AUTO_REGISTER_NUM];	// Server information
	char					reserved[256];
} DEV_SERVER_AUTOREGISTER, *LPDEV_SERVER_AUTOREGISTER;

// Upload burning annex
typedef struct
{
	DWORD				dwSize;		
	char				szSourFile[MAX_PATH_STOR];	// Source file path
	int					nFileSize;					// Source file size,If less than or equal to 0, sdk to calculate file size.
	char				szBurnFile[MAX_PATH_STOR];	// After burning the file name
	BYTE				bReserved[64];
} DHDEV_BURNFILE_TRANS_CFG;

// Update file upload
typedef struct
{
	char                 szFile[MAX_PATH_STOR];      // Update file path
	int                  nFileSize;                  // Update file size  
	BYTE                 byChannelId;                // Channel No.
	BYTE                 byManufactryType;           // Manufacturer type    Please refer to EM_IPC_TYPE
	
	BYTE                 byReserved[126];            // Reserved      
}DHDEV_UPGRADE_FILE_INFO;

// upload black-white list
typedef struct  
{
	char                 szFile[MAX_PATH_STOR];     // path of file
	int                  nFileSize;                 // size of upgrade file
	BYTE                 byFileType;                // type of file.0-black list,1-white list 
	BYTE                 byAction;                  // action,0-overload,1-additional

	BYTE                 byReserved[126];           // reserved
}DHDEV_BLACKWHITE_LIST_INFO;

// download black-white list
typedef struct
{
	char                 szFile[MAX_PATH_STOR];     // path of file
	BYTE                 byFileType;                // type of file,0-black list,1-white of list
	BYTE                 byReserved[127];           // reserved
}DHDEV_LOAD_BLACKWHITE_LIST_INFO;
// Zhengzhou EC_U video data overlay enabling configuration
typedef struct 
{
	BOOL				bEnable;					// Enable
	int					nPort;						// Port
	BYTE				bReserved[64];
}DHDEV_OSD_ENABLE_CFG;

// about vehicle configuration
typedef struct	
{
	BOOL				bAutoBootEnable;				//auto boot enable
	DWORD				dwAutoBootTime;					//auto boot time, Unit is second. The value ranges from 0 to 82800.
	BOOL				bAutoShutDownEnable;			//auto shut down enable
	DWORD				dwAutoShutDownTime;				//auto shut down time ,  Unit is second. The value ranges from 0 to 82800.
	DWORD				dwShutDownDelayTime;			//shut down delay time, Unit is second.
	BYTE				bEventNoDisk;					//1,(Ignore); 2,(Reboot)
	BYTE				bWifiEnable;					//If support car wifi module.
	BYTE				bUpperSpeedEnable;				//if use over speed verdict
	BYTE				bLowerSpeedEnable;				//if use low speed verdict
	DWORD				dwUpperSpeedValue;				//Over speed area(1,1000).km/hour.
	DWORD               dwLowerSpeedValue;              //Low speed area(1,1000).km/hour.
    DWORD               dwUpperSpeedDelayTime;          //Upper Speed Delay Time
	DWORD               dwLowerSpeedDelayTime;          //Lower Speed Delay Time
	DWORD               dwAlarmMaskEnable;              //Search/set OSD alarm information enable, every bit present one external alarm channel, 0:close;1:open
	BOOL                bSpeedOverAlarmRecordEnable;    // Over Speed Alarm Record Enable
	BOOL                bSpeedLowAlarmRecordEnable;     // Low Speed Alarm Record Enable
	BYTE				bReserved[480];					//reserved byte.
} DHDEV_ABOUT_VEHICLE_CFG;

// atm: query overlay ability information
typedef struct  
{
	DWORD				dwDataSource;					//1:Network, 2:Comm, 3:Network&Comm
	char				szProtocol[32][33];				//protocol name
	BYTE				bReserved[256];
} DHDEV_ATM_OVERLAY_GENERAL;
 
// atm: overlay configuration
typedef struct 
{
	DWORD				dwDataSource;					// 1:Network, 2:Comm
	char				szProtocol[33];					// protocol name, from DHDEV_ATM_OVERLAY_GENERAL
	BYTE				bReserved_1[3];
	DWORD				dwChannelMask;					// channel mask
	BYTE				bMode;							// 1:Preview, 2:Encode, 3:Preview&Encode
	BYTE				bLocation;						// 1:LeftTop, 2:LeftBottom, 3:RightTop, 4:RightBottom
	BYTE                bReserved_3[2];
	int                 nLatchTime;                     // display latch time on overlay, instruct the video's close latch time, 0~65535
	BYTE                bReserved_4[3];
	BYTE                bRecordSrcKeyNum;               // key number
	int                 nRecordSrcKey[32];              // key of channels 
	BYTE				bReserved_2[120];
} DHDEV_ATM_OVERLAY_CONFIG;

// atm:overlay set configuration
typedef struct 
{
	DWORD               dwSize;                         // size
	DWORD				dwDataSource;					// 1:Net, 2:Com, 3:Com422
	char				szProtocol[33];					// protocol name
	BYTE				bReserved_1[3];
	DWORD				dwChannelMask[8];				// overlay channel,the mask means: dwChannelMask[0] is channel 1,so on
	BYTE				bMode;							// 1:Preview(preview), 2:Encode(encode), 3:Preview&Encode(preview and encode)
	BYTE				bLocation;						// 1:LeftTop, 2:LeftBottom , 3:RightTop , 4:RightBottom 
	BYTE                bReserved_3[2];           
	int                 nLatchTime;                     // latch time,0~65535s
	BYTE                bReserved_4[3];
	BYTE                bRecordSrcKeyNum;               // number of key word
	int                 nRecordSrcKey[256];             // key word
} DHDEV_ATM_OVERLAY_CONFIG_EX;
#define DH_MAX_BACKUPDEV_NUM			16
#define DH_MAX_BACKUP_NAME				32

// backup device list
typedef struct 
{
	int					nBackupDevNum;												// number of backup devices
	char				szBackupDevNames[DH_MAX_BACKUPDEV_NUM][DH_MAX_BACKUP_NAME]; // backup device name
} DHDEV_BACKUP_LIST, *LPDHDEV_BACKUP_LIST;

// backup device type
typedef enum __BACKUP_TYPE
{
	BT_DHFS = 0,							// dvr file system
	BT_DISK,								// floating disk
	BT_CDRW									// CD
} DHDEV_BACKUP_TYPE;	

// backup device interface
typedef enum __BACKUP_BUS
{
	BB_USB = 0,								// usb
	BB_1394,								// 1394
	BB_IDE,									// ide
	BB_ESATA,								// esata
} DHDEV_BACKUP_BUS;	

typedef struct 
{
	char				szName[32];						// name
	BYTE				byType;							// see BACKUP_TYPE
	BYTE				byBus;							// see BACKUP_BUS
	UINT				nCapability;					// total capability(kBytes)
	UINT				nRemain;						// remain capability(kBytes)
	char				szDirectory[128];				// Remote Directory
} DHDEV_BACKUP_INFO, *LPDHDEV_BACKUP_INFO;

typedef struct 
{
	char				szName[32];						// name 
	UINT				nCapability;					// total capability(kBytes)
	UINT				nRemain;						// remain capability(kBytes)
} DHDEV_BACKUP_FEEDBACK, *LPDHDEV_BACKUP_FEEDBACK;

#define  DH_MAX_BACKUPRECORD_NUM 1024

typedef struct  
{
	char				szDeviceName[DH_MAX_BACKUP_NAME];			//name
	int					nRecordNum;									//number of records
	NET_RECORDFILE_INFO	stuRecordInfo[DH_MAX_BACKUPRECORD_NUM];		//record information
} BACKUP_RECORD, *LPBACKUP_RECORD;

// multiplay input param
typedef struct
{
	int                 iChannelID;      // channel id
	DH_RealPlayType     realplayType;    // real play type
	char                reserve[32];
}DHDEV_IN_MULTIPLAY_PARAM;

// multiplay output param
typedef struct
{
	int                 iChannelID;      // channel id
	LLONG                lRealHandle;     // real play handle
	char                reserve[32];
}DHDEV_OUT_MULTIPLAY_PARAM;
/////////////////////////////////Embedded platform/////////////////////////////////

// Platform embedded setup - U China Network Communication(CNC)
typedef struct
{
    BOOL				bChnEn;
    char				szChnId[DH_INTERVIDEO_UCOM_CHANID];
} DH_INTERVIDEO_UCOM_CHN_CFG;

typedef struct
{
	DWORD				dwSize;
	BOOL				bFuncEnable;			// Enable connection
	BOOL				bAliveEnable;			// Enable alive
	DWORD				dwAlivePeriod;			// Alive period. Unit is second. The value ranges from 0 to 3600.
	char				szServerIp[DH_MAX_IPADDR_LEN];			// CMS IP
	WORD				wServerPort;							// CMS Port
    char				szRegPwd[DH_INTERVIDEO_UCOM_REGPSW];	// Registration password 
	char				szDeviceId[DH_INTERVIDEO_UCOM_DEVID];	// Device id
	char				szUserName[DH_INTERVIDEO_UCOM_USERNAME];
	char				szPassWord[DH_INTERVIDEO_UCOM_USERPSW];
    DH_INTERVIDEO_UCOM_CHN_CFG  struChnInfo[DH_MAX_CHANNUM];	// Channel id,en
} DHDEV_INTERVIDEO_UCOM_CFG;

//  Platform embedded setup - Alcatel
typedef struct
{
	DWORD				dwSize;
    unsigned short		usCompanyID[2];			// Company ID,Value. the different three party service company. Now use the first array considering the four bytes in line.
    char				szDeviceNO[32];			// Strings including '\0' are 32 bytes.
    char				szVSName[32];			// Front-end device name. Strings including '\0' are 16 bytes.
    char				szVapPath[32];			// VAP path
    unsigned short		usTcpPort;				// TCP port,value:value ranges from 1 to 65535 
    unsigned short		usUdpPort;				// UDP port,Value:Value ranges from 1 to 65535
    bool				bCsEnable[4];			// Enable central server symbol. Value:true=enable,false=disable.Now only use the first array considering the four bytes in line.
    char				szCsIP[16];				// Central server IP address.Strings including '\0' are 16 bytes.
    unsigned short		usCsPort[2];			// Central server port. Value ranges from 1 to 65535.Now only use the first array considering the four bytes in line.
    bool				bHsEnable[4];			// Enable pulse server symbol. Value:true-enable,false=disable.Now only use the first array considering the four bytes in line.
    char				szHsIP[16];				// Pulse server IP address. Strings including '\0' are 16 bytes.
    unsigned short		usHsPort[2];			// Pulse server port. Value ranges from 1 to 65535.Now only use the first array considering the four bytes in line
    int					iHsIntervalTime;		// Pulse server interval. Value(unit is second)
    bool				bRsEnable[4];			// Enable registration server symbol. Value:,true=enable,false=disable.Now only use the first array considering the four bytes in line. 
    char				szRsIP[16];				// Registration server IP address. Strings including '\0' are 16 bytes.
    unsigned short		usRsPort[2];			// Registration server port. Value. The value ranges from 1 to 65535.Now use the first array considering the four bytes in line
    int					iRsAgedTime;			// Registration server valid duration. Value(unit is hour)
    char				szAuthorizeServerIp[16];// IP Authorization server IP
    unsigned short		usAuthorizePort[2];		// Authorization server port. Now only use the first array considering the four bytes in line
    char				szAuthorizeUsername[32];// Authorization server account
    char				szAuthorizePassword[36];// Authorization server password
    
    char				szIpACS[16];			// ACS( auto registration server) IP
    unsigned short		usPortACS[2];			// ACS Port,Now only use the first array considering the four bytes in line. 
    char				szUsernameACS[32];		// ACS user name
    char				szPasswordACS[36];		// ACS password
    bool				bVideoMonitorEnabled[4];// DVS regularly uploads front-end video monitor message or not.Value:true=enable,false=disable
    int					iVideoMonitorInterval;	// Upload interval(minute)
    
    char				szCoordinateGPS[64];	// GPS coordinates
    char				szPosition[32];			// Device position
    char				szConnPass[36];			// Device connection bit 
} DHDEV_INTERVIDEO_BELL_CFG;

//  Platform embedded setup - ZTE Netview
typedef struct  
{
	DWORD				dwSize;
	unsigned short		nSevPort;								// Server port. Value. The value ranges from 1 to 65535
    char				szSevIp[DH_INTERVIDEO_NSS_IP];			// Server IP address,string,including '\0' end symbol, there are total 32byte.
    char				szDevSerial[DH_INTERVIDEO_NSS_SERIAL];	// Front-end device serial number, string including '\0' end symbol, there are total 32byte.
    char				szUserName[DH_INTERVIDEO_NSS_USER];
    char				szPwd[DH_INTERVIDEO_NSS_PWD];
} DHDEV_INTERVIDEO_NSS_CFG;

// Platform embedded setup - AMP
typedef struct  
{
	char               szDevSerial[DH_INTERVIDEO_AMP_DEVICESERIAL];                  // Front Device Serial num(encoder serial num), read only	
	char               szDevName[DH_INTERVIDEO_AMP_DEVICENAME];                      // Front Device Name(encoder name), read only
	char               szRegUserName[DH_INTERVIDEO_AMP_USER];                        // Server Name
	char               szRegPwd[DH_INTERVIDEO_AMP_PWD];                              // Server Password
	BYTE			   bReserved[128];
} DHDEV_INTERVIDEO_AMP_CFG;  
////////////////////////////////HDVR special use//////////////////////////////////
// Alarm relay structure
typedef struct 
{
	/* Message triggered methods,multiple methods,including
	 * 0x00000001 - alarm upload
	 * 0x00000002 - triggering recording
	 * 0x00000004 - PTZ movement
	 * 0x00000008 - sending email
	 * 0x00000010 - local tour
	 * 0x00000020 - local tips
	 * 0x00000040 - alarm output
	 * 0x00000080 - ftp upload
	 * 0x00000100 - buzzer
	 * 0x00000200 - voice tips 
	 * 0x00000400 - snapshot
	*/

	/* Current alarm supporting methods, shown by bit mask */
	DWORD				dwActionMask;

	/* Triggering action,shown by bit mask,concrete action parameter is shows in the configuration */
	DWORD				dwActionFlag;
	
	/* Triggering alarm output channel,1 means triggering this output */ 
	BYTE				byRelAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
	DWORD				dwDuration;				/* Alarm lasting period */

	/* Triggering recording */
	BYTE				byRecordChannel[DH_MAX_VIDEO_IN_NUM_EX]; /* Record channel triggered by alarm,1 means triggering this channel */
	DWORD				dwRecLatch;				/* Recording period */

	/* Snapshot channel */
	BYTE				bySnap[DH_MAX_VIDEO_IN_NUM_EX];
	/* Tour channel */
	BYTE				byTour[DH_MAX_VIDEO_IN_NUM_EX];

	/* PTZ movement */
	DH_PTZ_LINK			struPtzLink[DH_MAX_VIDEO_IN_NUM_EX];
	DWORD				dwEventLatch;			/* Event delay time, s for unit,range is 0~15,default is 0 */
	/* Alarm trigerring wireless output,alarm output,1 for trigerring output */ 
	BYTE				byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
	BYTE				bMessageToNet;
	BYTE                bMMSEn;                /*Message triggering alarm enabling*/
	BYTE                bySnapshotTimes;       /* the number of sheets of drawings */
	BYTE				bMatrixEn;				/*!< Matrix output enable */
	DWORD				dwMatrix;				/*!< Matrix mask */			
	BYTE				bLog;					/*!< Log enable,only used in WTN motion detection */
	BYTE				bSnapshotPeriod;		/*!<Snapshot frame interval. System can snapshot regularly at the interval you specify here. The snapshot amount in a period of time also has relationship with the snapshot frame rate. 0 means there is no interval, system just snapshot continuously.*/
	BYTE				byTour2[DH_MAX_VIDEO_IN_NUM_EX];/* Tour channel 32-63*/
	BYTE                byEmailType;             /*<0,picture,1,record>*/
	BYTE                byEmailMaxLength;        /*<max record length,unit:MB>*/
	BYTE                byEmailMaxTime;          /*<max time length, unit:second>*/
	BYTE				byReserved[475];   
} DH_MSG_HANDLE_EX;

// External alarm expansion
typedef struct
{
	BYTE				byAlarmType;			// Alarm type,0:normal closed,1:normal open
	BYTE				byAlarmEn;				// Alarm enable
	BYTE				byReserved[2];						
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
	DH_MSG_HANDLE_EX	struHandle;				// Handle method
} DH_ALARMIN_CFG_EX, *LPDHDEV_ALARMIN_CFG_EX; 

// Motion detection alarm
typedef struct 
{
	BYTE				byMotionEn;				// Motion detection alarm enabling
	BYTE				byReserved;
	WORD				wSenseLevel;			// Sensitivity
	WORD				wMotionRow;				// Motion detection area rows
	WORD				wMotionCol;				// Motion detection area lines
	BYTE				byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // Motion detection area,most 32*32
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
	DH_MSG_HANDLE_EX		struHandle;				//Handle method
} DH_MOTION_DETECT_CFG_EX;

// fire alarm
typedef struct
{
	BOOL                byFireEn;              // enable
	DH_MSG_HANDLE_EX    struHandle;            // handler
	BYTE                byReserved[128];
}DHDEV_FIRE_ALARM_CFG;

// Static detection alarm

typedef struct 
{
	BYTE				byStaticEn;				// Static detection alarm enabling
	BYTE				byLatch;                // detect delay (old struct)
	WORD				wSenseLevel;			// Sensitivity
	WORD				wStaticRow;				// Static detection area rows
	WORD				wStaticCol;				// Static detection area lines
	BYTE				byDetected[DH_STATIC_ROW][DH_STATIC_COL]; // Static detection area,most 32*32
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
	DH_MSG_HANDLE_EX		struHandle;				//Handle method
	int                 nLatch;                 // detect delay (new struct)
	BYTE                bReserved[64];          // reserved
} DH_STATIC_DETECT_CFG_EX;

// ACC power off configuration
typedef struct _DHDEV_ACC_POWEROFF_CFG
{
	BOOL                bEnable;               // ACC power off configuration enable
	int                 nDelayTime;            // ACC power off delay time(m)
	DH_MSG_HANDLE_EX    struHandle;            // handle method
	BYTE                Reserved[128];         // reserved
}DHDEV_ACC_POWEROFF_CFG;

// explosion proof alarm configuration
typedef struct _DHDEV_EXPLOSION_PROOF_CFG
{
	BOOL                bEnable;               // explosion proof alarm configuration enable
	DH_MSG_HANDLE_EX    struHandle;            // handle method
	BYTE                Reserved[128];         // reserved
}DHDEV_EXPLOSION_PROOF_CFG;

// Raid evnet config
typedef struct _DHDEV_RAID_EVENT_CFG
{
	BOOL                bEnable;               // enable
	DH_MSG_HANDLE_EX    struHandle;            // handle
	BYTE                Reserved[128];         // 
}DHDEV_RAID_EVENT_CFG;

// Video loss alarm
typedef struct
{
	BYTE				byAlarmEn;				// Video loss alarm enabling
	BYTE				byReserved[3];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
	DH_MSG_HANDLE_EX	struHandle;				// Handle method
} DH_VIDEO_LOST_CFG_EX;

// Camera masking alarm
typedef struct
{
	BYTE				byBlindEnable;			// Enable
	BYTE				byBlindLevel;			// Sensitivity 1-6
	BYTE				byReserved[2];
	DH_TSECT			stSect[DH_N_WEEKS][DH_N_REC_TSECT];	//NSP
	DH_MSG_HANDLE_EX	struHandle;				// Handle method
} DH_BLIND_CFG_EX;

// HDD info(alarm)
typedef struct 
{
	BYTE				byNoDiskEn;				// No HDD alarm
	BYTE				byReserved_1[3];
	DH_TSECT			stNDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
	DH_MSG_HANDLE_EX	struNDHandle;			// Handle method
	
	BYTE				byLowCapEn;				// Low capacity alarm
	BYTE				byLowerLimit;			// Lower limit,0-99
	BYTE				byReserved_2[2];
	DH_TSECT			stLCSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
	DH_MSG_HANDLE_EX	struLCHandle;			// Handle method
	
	BYTE				byDiskErrEn;			// HDD error alarm
	BYTE				bDiskNum;
	BYTE				byReserved_3[2];
	DH_TSECT			stEDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
	DH_MSG_HANDLE_EX	struEDHandle;			// Handle method
} DH_DISK_ALARM_CFG_EX;

typedef struct
{
	BYTE				byEnable;
	BYTE				byReserved[3];
	DH_MSG_HANDLE_EX	struHandle;
} DH_NETBROKEN_ALARM_CFG_EX;

// Front encoder configuration parameter
typedef struct __DEV_ENCODER_CFG 
{
	int					nChannels;				// Digital channel number
	DEV_ENCODER_INFO	stuDevInfo[32];			// Digital channel info
	BYTE				byHDAbility;			// The max high definition video amount the digital channel supported. (0 means it does not support high definition setup.)
												// If it supports high definition setup, the high definition channel ranges from 0 to N-1. If your high definition channel number is more than N, the save operation may fail. 
	BYTE				bTVAdjust;				// TV adjust. 0:not support, 1:support.
	BYTE				bDecodeTour;			// Decode tour. 0:not support, greater than zero: it means the maximal number supported.
	BYTE				bRemotePTZCtl;			// Remote PTZ control. 0:not support, 1:support.
	char				reserved[12];
} DEV_ENCODER_CFG, *LPDEV_ENCODER_CFG;

// front end access configuratiion parameter expansion
typedef struct __DEV_ENCODER_CFG_EX 
{
	int					nChannels;				// number of channel
	DEV_ENCODER_INFO	stuDevInfo[128];	    // the front end of the every digital channel encoder information
	BYTE				byHDAbility;			// maximum number of hd video(0 means not support)

	BYTE				bTVAdjust;				// support TV adjust,0:not support,1:support.
	BYTE				bDecodeTour;			// support tour or not, 0:not support, >0:the current number of device support
	BYTE				bRemotePTZCtl;			// support remote PTZ control
	char				reserved[256];
} DEV_ENCODER_CFG_EX, *LPDEV_ENCODER_CFG_EX;
// Controller
typedef struct tagDHCONFIG_CONTROLER{
	DH_COMM_PROP        struComm;	                     // Com attribution
	BYTE                bLightGroup[DH_MAX_LIGHT_NUM];   // Controlled light group,light number start from 1,such as[1,3,8,0?-0]present control light number 1,3,8 light
	BYTE	            bDeviceAddr;	                 // Controller address
	BYTE                bComPortType;                    // Com Type 0:485 COM, 1:232 COM
	BYTE                bReserved[6];		             // Reserved
} DH_CONFIG_CONTROLER;

// Light control config
typedef struct __DHDEV_LIGHTCONTROL_CFG
{
	DH_CONFIG_CONTROLER    struControlers[DH_MAX_CONTROLER_NUM]; // Control config
	BYTE                   bControlerNum;                        // Effective controller number
	BYTE                   bReserved[1023];                      // Reserved
} DHDEV_LIGHTCONTROL_CFG, *LPDHDEV_LIGHTCONTROL_CFG;

// 3G Flow info config
typedef struct
{
	int                 nStrategy;       // strategy, 0: charged by flow every month 1:charged by time every month
	int                 nUpLimit;        // up limit, by flow: MB, by time: h
	int                 nreserved[22];   // reserved
}DHDEV_3GFLOW_INFO_CFG;

// IPv6 config
typedef struct 
{
	char               szLinkAddr[44];	 // link address: string length = 44;(every host has an exclusive link address, read only)
	char               szHostIP[40]; 	 // host IP
	DWORD              dwPreFix;		 // net prefix, 1-128
	char               szGateWay[40];	 // gateway
	BOOL               bAutoGet;		 // enable of auto get ip 
	char               szPrimaryDns[40]; // primary DNS
	char               szSecondDns[40];	 // second DNS
    char               cReserved[256];   // reserved
}DHDEV_IPV6_CFG;

//Emergency storage configuration
typedef struct __DEV_URGENCY_RECORD_CFG
{
	DWORD dwSize;           // Structure body size
	BOOL bEnable;           // Enable or not. 1=enable.0=disable
	UINT nMaxRecordTime;    // Max record time. Unit is second.
}DHDEV_URGENCY_RECORD_CFG;

// Lift running parameter configuration
typedef struct __DEV_ELEVATOR_ATTRI_CFG
{
	DWORD dwSize;           // Structure body size
	UINT   nMAXFloorNum;     //Max floor. Min is 2.
	UINT   nFloorDelayTime;  //Stay verification time ranges from 5-60. It regards as stop current floor if keep this time period.
	UINT   nIntervalTime;    //The max time for the lift to go up/down a floor. It regars the lift is malfunction if the time is out of the threshold. The lift stopsa between two floors.
}DHDEV_ELEVATOR_ATTRI_CFG;

// Virtual camera status search
typedef struct tagDHDEV_VIRTUALCAMERA_STATE_INFO
{
	DWORD              nStructSize;                  // Structure body size
	int                nChannelID;                   // Channel No.
	CONNECT_STATE      emConnectState;               // Connection status
	UINT               uiPOEPort;                    // The PoE port the virtual camera connected to. 0=It is not a PoE connection.
	char               szDeviceName[64];             // Device name
	char               szDeviceType[128];            // Device type
	char               szSystemType[128];            // system type
	char               szSerialNo[DH_SERIALNO_LEN];  // serial no
	int                nVideoInput;                  // video input number
	int                nAudioInput;                  // audio input number
	int                nAlarmOutput;                 // alarm output number
}DHDEV_VIRTUALCAMERA_STATE_INFO;

// Device working video/loop mode status info and etc search 
typedef struct tagDHDEV_TRAFFICWORKSTATE_INFO
{
	DWORD                nStructSize;      // Structure body size
	int                  nChannelID;       // Channel No.
	DH_TRAFFIC_SNAP_MODE emSnapMode;       // Snap mode
}DHDEV_TRAFFICWORKSTATE_INFO;

// Local Alarm Event (DH_ALARM_ALARM_EX Update
typedef struct tagALARM_ALARM_INFO_EX2
{
    DWORD		dwSize;
    int			nChannelID;             // Channel ID
    int			nAction;				// 0=Start 1=Stop 
    NET_TIME	stuTime;				// Alarm Event Begin Time
    NET_SENSE_METHOD emSenseType;		// The Sensor's Type
    DH_MSG_HANDLE_EX stuEventHandler;   // Handle method
}ALARM_ALARM_INFO_EX2;

/////////////////////////////////ITS picture subscription interface parameter/////////////////////////////////
typedef struct RESERVED_DATA_INTEL_BOX
{
	DWORD  dwEventCount;	 //Event count
	DWORD* dwPtrEventType;	 //Point to continuous value of event type, user should request and fr
    DWORD  dwInternalTime;      // picture upload interval time¡ê?unit¡êos
	BYTE   bReserved[1020];	 //Reserved
}ReservedDataIntelBox;

#define RESERVED_TYPE_FOR_INTEL_BOX 0x00000001
typedef struct RESERVED_PARA
{
	DWORD 	dwType;	//pData's type
					//when [dwType] is RESERVED_TYPE_FOR_INTEL_BOX, pData is address of type ReservedDataIntelBox					
					//when [dwType] is ...,[pData] is ...
	void*	pData;	//data
}ReservedPara;
#define RESERVED_TYPE_FOR_COMMON   0x00000010
typedef struct tagNET_RESERVED_COMMON
{
	DWORD            dwStructSize;
	ReservedDataIntelBox* pIntelBox;    // include RESERVED_TYPE_FOR_INTEL_BOX
	DWORD            dwSnapFlagMask;	// snap flags(by bit),0bit:"*",1bit:"Timing",2bit:"Manual",3bit:"Marked",4bit:"Event",5bit:"Mosaic",6bit:"Cutout"
}NET_RESERVED_COMMON;

#define RESERVED_TYPE_FOR_PATH  0x00000100
// picture path type
typedef enum tagNET_PICTURE_PATH_TYPE
{
    NET_PATH_LOCAL_PATH     ,   // writing path for loacl disk or sd card
    NET_PATH_FTP_PATH       ,   // ftp path
    NET_PATH_VIDEO_PATH     ,   // ftp path for assocated video
}NET_PICTURE_PATH_TYPE;

#define MAX_PIC_PATH_NUM        16
typedef struct tagNET_RESERVED_PATH
{
    int                     nMaxPathNum;                        //picture path count, device will use default path if 0
    NET_PICTURE_PATH_TYPE   emPictruePaths[MAX_PIC_PATH_NUM];   //picture path type
}NET_RESERVED_PATH;

/////////////////////////////////Intelligent speed dome control interface parameter/////////////////////////////////
// Scene structure info
typedef struct 
{
	DWORD       dwSize;
	int         nScene;			//Scene SN
}DHDEV_INTELLI_SCENE_INFO;

// Scene margin limit position info
typedef struct 
{
	DWORD       dwSize;
	int         nScene;			//Scene SN
	int         nType;			//0:Top margin limit;1:Bottom margin limit;2:Left margin;3:Right margin
}DHDEV_INTELLI_SCENELIMIT_INFO;

// Manually track object structure body info
typedef struct
{
	DWORD       dwSize;
	int         nObjectID;		// Object ID -1 = Set the intelligent frame upload the position of any object out of the frame in the Web >=0: select the intelligent frame to send the object in the frame. 
	RECT        stuBound;		// Rectangle range. The coordinates of the point is within [0,8192].
}DHDEV_INTELLI_TRACKOBJECT_INFO;

typedef enum __TRACKCONTROL_TYPE
{
	DH_TRACK_MARKSCENE,				// Specified scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENE_INFO
		DH_TRACK_GOTOSCENE,			// Go to scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENE_INFO
		DH_TRACK_MARKSCENELIMIT,	// The margin limit position of the specified scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENELIMIT_INFO
		DH_TRACK_GOTOSCENELIMIT,	// Go to the marin limit position of the scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENELIMIT_INFO
		DH_TRACK_MARKSCENEMAXZOOM,	// The max track rate in the specified scene. Corresponding to the structure body of the DHDEV_INTELLI_SCENE_INFO
		DH_TRACK_OBJECT,			// The tracking object in the selected scene. Corresponding to the structure body of the DHDEV_INTELLI_TRACKOBJECT_INFO
		DH_TRACK_START,				// Begin intelligent track. No need to specify parameter information.
		DH_TRACK_STOP,				// Stop intelligent track. No need to specify parameter information.
		DH_TRACK_TYPE_NUM,
}DH_TRACKCONTROL_TYPE;

//Intelligent speed dome control input parameter
typedef struct tagNET_IN_CONTROL_INTELLITRACKER
{
    DWORD       dwSize;
    int         nChannelID;            // Channel ID
    DH_TRACKCONTROL_TYPE emCtrlType;   // Control type
    void*       pCtrlInfo;             // The corresponding inform structure pointer of the control type. Please refer to DH_TRACKCONTROL_TYPE for definition.
    int         nMaxLen;               // Structure body size of the control information
	int         nWaittime;             // Wait time out time
}NET_IN_CONTROL_INTELLITRACKER;

//Intelligent speed dome control output parameter
typedef struct tagNET_OUT_CONTROL_INTELLITRACKER
{
    DWORD       dwSize;
}NET_OUT_CONTROL_INTELLITRACKER;

/////////////////////////////////Video Analysis Interface Parameters//////////////////////////////
#define MAX_TEMPLATEIMAGE_NUM               32                      // Limitation of valid images quantities.
 
//Get the inputs of video analyses target
 typedef struct tagNET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE
{
    DWORD               dwSize;
    int                 nChannelID;                                 // channel ID
char                szRule[DH_COMMON_STRING_128];               // The correspondence rule of template image
 }NET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE;

//Get the outputs of video analyses target
typedef struct tagNET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE
{
    DWORD               dwSize;
    unsigned int        nImageNum;                                  // The number of valid images
    DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // Image information
char*               pBuffer;                                    //The pointer of image buffer, applied by users
    int                 nBufLen;                                    // The size of image buffer, filled in by users
int                 nRetLen;                                    // Get the length of the image data, no need to fill in by user, which can be used to decide whether the buffer is enough.
 
}NET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE;

//Setup the input parameters of video analyses target
typedef struct tagNET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE
{
    DWORD               dwSize;
    int                 nChannelID;                                 // Channel ID
    char                szRule[DH_COMMON_STRING_128];               // The correspondence rule of template image
    unsigned int        nImageNum;                                  // The number of valid images

    DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // Image information
char*               pBuffer;                                    // The pointer of image buffer
    int                 nBufLen;                                    // Image buffer size
}NET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE;

//Setup the output parameters of video analyses target
typedef struct tagNET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE
{
    DWORD       dwSize;
}NET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE;

/////////////////////////////////Abandoned Type/////////////////////////////////

// Search device working status channel information. Corresponding interfaces have been abandoned. Do not user.
typedef struct
{
	BYTE				byRecordStatic;			// Channel is recording or not. ;0: does not record,1: manual record,2:auto record  
	BYTE				bySignalStatic;			// Connected signal status ;0:normal,1:signal loss  
	BYTE				byHardwareStatic;		// Channel hardware status;0:normal ,1:abnormal such as DSP is down , 
	char				reserve;
	DWORD				dwBitRate;				// Actual bit rate
	DWORD				dwLinkNum;				// The client-end connected amount 
	DWORD				dwClientIP[DH_MAX_LINK];// Client-end IP address 
} NET_DEV_CHANNELSTATE, *LPNET_DEV_CHANNELSTATE;

// Search device working status. The corresponding interfaces have been abandoned. Please do not use
typedef struct
{
	DWORD				dwDeviceStatic;			// Device status;0x00:normal ,0x01:CPU occupation is too high ,0x02:hardware error 
	NET_DEV_DISKSTATE	stHardDiskStatic[DH_MAX_DISKNUM]; 
	NET_DEV_CHANNELSTATE stChanStatic[DH_MAX_CHANNUM];	// Channel status
	BYTE				byAlarmInStatic[DH_MAX_ALARMIN];// Alarm port status;0:no alarm,1: alarm
	BYTE				byAlarmOutStatic[DH_MAX_ALARMOUT]; // Alarm output port status;0:no alarm,1:alarm  
	DWORD				dwLocalDisplay;			// Local display status  ;0:normal,1:abnormal 
} NET_DEV_WORKSTATE, *LPNET_DEV_WORKSTATE;

// Protocol information
typedef struct 
{
	char				protocolname[12];		// Protocol name
	unsigned int		baudbase;				// Baud rate
	unsigned char		databits;				// Data bit
	unsigned char		stopbits;				// Stop bit
	unsigned char		parity;					// Pairty bit 
	unsigned char		reserve;
} PROTOCOL_INFO, *LPPROTOCOL_INFO;

// Audio talk parameter setup
typedef struct 
{
	// Audio input parameter
	BYTE				byInFormatTag;			// Encode type such as PCM
	BYTE				byInChannels;			// Track amount
	WORD				wInBitsPerSample;		// Sampling depth 				
	DWORD				dwInSamplesPerSec;		// Sampling rate 

	// Audio output parameter
	BYTE				byOutFormatTag;			// Encode type such as PCM
	BYTE				byOutChannels;			// Track amount
	WORD				wOutBitsPerSample;		// Sampling depth 		
	DWORD				dwOutSamplesPerSec;		// Sampling rate
} DHDEV_TALK_CFG, *LPDHDEV_TALK_CFG;

/////////////////////////////////// Matrix ///////////////////////////////////////

#define DH_MATRIX_INTERFACE_LEN		16		// Signal interface name length
#define DH_MATRIX_MAX_CARDS			128		// Matrix sub card max amount
#define DH_SPLIT_PIP_BASE			1000	// The basic value of the PIP split mode
#define	DH_MAX_SPLIT_MODE_NUM		64		// Max split matrix amount
#define DH_MATRIX_MAX_CHANNEL_IN	1500	// Matrix max input channel amount
#define DH_MATRIX_MAX_CHANNEL_OUT	256		// Matrix max output channel amount
#define DH_DEVICE_NAME_LEN			64		// Device name length
#define DH_MAX_CPU_NUM				16		// Max CPU amount
#define DH_MAX_FAN_NUM				16		// Max fan amount
#define DH_MAX_POWER_NUM			16		// Max power amount
#define DH_MAX_BATTERY_NUM          16      // Max battery quantity
#define DH_MAX_TEMPERATURE_NUM      256		// Max temperature sensor amount 
#define DH_MAX_ISCSI_NAME_LEN		128		// ISCSI Name length
#define DH_VERSION_LEN				64		// Version info length
#define DH_MAX_STORAGE_PARTITION_NUM 32		//  Storage partition max number
#define DH_STORAGE_MOUNT_LEN		64		// Mount length
#define DH_STORAGE_FILE_SYSTEM_LEN	16		// File system name length
#define DH_MAX_MEMBER_PER_RAID		32		// RAID max members
#define DH_DEV_ID_LEN_EX			128		// Device ID max length
#define DH_MAX_BLOCK_NUM			32		// max number of block
#define DH_MAX_SPLIT_WINDOW			128		// max number of split window
#define DH_FILE_TYPE_LEN			64		// length of file type
#define DH_DEV_ID_LEN				128		// length of device ID
#define DH_DEV_NAME_LEN				128		// max length of device name  
#define DH_TSCHE_DAY_NUM			8		// schedule the first dimension size, means days
#define DH_TSCHE_SEC_NUM			6		// schedule the second dimension size, means time
#define    DH_SPLIT_INPUT_NUM       256     // Judicial device level 2 switch level 1 split supported input channel

#define DH_DEVICE_ID_LOCAL		"Local"		// local device ID
#define DH_DEVICE_ID_REMOTE		"Remote"	// remote device ID
#define DH_DEVICE_ID_UNIQUE		"Unique"	// unique ID

// Split mode
typedef enum tagDH_SPLIT_MODE
{
	DH_SPLIT_1 = 1,							// 1-window
	DH_SPLIT_2 = 2, 						// 2-window
	DH_SPLIT_4 = 4, 						// 4-window
	DH_SPLIT_6 = 6, 						// 6-window
	DH_SPLIT_8 = 8, 						// 8-window
	DH_SPLIT_9 = 9, 						// 9-window
	DH_SPLIT_12 = 12, 						// 12-window
	DH_SPLIT_16 = 16, 						// 16-window
	DH_SPLIT_20 = 20, 						// 20-window
	DH_SPLIT_25 = 25, 						// 25-window
	DH_SPLIT_36 = 36, 						// 36-window
	DH_SPLIT_64 = 64, 						// 64-window
	DH_SPLIT_144 = 144, 					// 144-window
	DH_PIP_1 = DH_SPLIT_PIP_BASE + 1,		// PIP mode.1-full screen+1-small window
	DH_PIP_3 = DH_SPLIT_PIP_BASE + 3,		// PIP mode.1-full screen+3-small window
	DH_SPLIT_FREE = DH_SPLIT_PIP_BASE * 2,	// free open window mode,are free to create,close, window position related to the z axis
	DH_COMPOSITE_SPLIT_1 = DH_SPLIT_PIP_BASE * 3 + 1,	// integration of a split screen
	DH_COMPOSITE_SPLIT_4 = DH_SPLIT_PIP_BASE * 3 + 4,	// fusion of four split screen
} DH_SPLIT_MODE;

#define DH_PROTOCOL_DAHUA2 DH_PROTOCOL_PRIVATE2
#define DH_PROTOCOL_DAHUA3 DH_PROTOCOL_PRIVATE3

// Device protocol type
typedef enum tagDH_DEVICE_PROTOCOL
{
	DH_PROTOCOL_PRIVATE2,						// private 2nd protocol
	DH_PROTOCOL_PRIVATE3,						// private 3rd protocol
	DH_PROTOCOL_ONVIF,						// Onvif	
	DH_PROTOCOL_VNC,						// virtual network computer
    DH_PROTOCOL_TS,                         // Standard TS
    
	DH_PROTOCOL_PRIVATE = 100,              // private protocol of private        
	DH_PROTOCOL_AEBELL,                     // aebell
	DH_PROTOCOL_PANASONIC,                  // panasonic       
	DH_PROTOCOL_SONY,                       // sony   
	DH_PROTOCOL_DYNACOLOR,                  // Dynacolor        
	DH_PROTOCOL_TCWS,						// tcsw        
	DH_PROTOCOL_SAMSUNG,                    // sansung        
	DH_PROTOCOL_YOKO,                       // YOKO        
	DH_PROTOCOL_AXIS,                       // axis        
	DH_PROTOCOL_SANYO,						// sanyo       		
	DH_PROTOCOL_BOSH,						// Bosch		
	DH_PROTOCOL_PECLO,						// Peclo		
	DH_PROTOCOL_PROVIDEO,					// Provideo		
	DH_PROTOCOL_ACTI,						// ACTi		
	DH_PROTOCOL_VIVOTEK,					// Vivotek		
	DH_PROTOCOL_ARECONT,					// Arecont        
	DH_PROTOCOL_PRIVATEEH,			        // PrivateEH	        
	DH_PROTOCOL_IMATEK,					    // IMatek        
	DH_PROTOCOL_SHANY,                      // Shany        
	DH_PROTOCOL_VIDEOTREC,                  // videotrec        
	DH_PROTOCOL_URA,						// Ura        
	DH_PROTOCOL_BITICINO,                   // Bticino         
	DH_PROTOCOL_ONVIF2,                     // Onvif's protocol type, same to DH_PROTOCOL_ONVIF    
	DH_PROTOCOL_SHEPHERD,                   // shepherd        
	DH_PROTOCOL_YAAN,                       // yaan      
	DH_PROTOCOL_AIRPOINT,					// Airpop        
	DH_PROTOCOL_TYCO,                       // TYCO        
	DH_PROTOCOL_XUNMEI,                     // xunmei      
	DH_PROTOCOL_HIKVISION,                  // hikvision        
	DH_PROTOCOL_LG,                         // LG        
	DH_PROTOCOL_AOQIMAN,					// aoqiman       
	DH_PROTOCOL_BAOKANG,                    // baokang            
	DH_PROTOCOL_WATCHNET,                   // Watchnet        
	DH_PROTOCOL_XVISION,                    // Xvision        
	DH_PROTOCOL_FUSITSU,                    // fusitsu        
	DH_PROTOCOL_CANON,						// Canon		
	DH_PROTOCOL_GE,							// GE		
	DH_PROTOCOL_Basler,						// basler		
	DH_PROTOCOL_Patro,						// patro	    
	DH_PROTOCOL_CPKNC,						// CPPLUS K series		
	DH_PROTOCOL_CPRNC,						// CPPLUS R series		
	DH_PROTOCOL_CPUNC,						// CPPLUS U series		
	DH_PROTOCOL_CPPLUS,						// CPPLUS IPC		
	DH_PROTOCOL_XunmeiS,					// xunmeis,protocal is Onvif		
	DH_PROTOCOL_GDDW,						// GDDW		
	DH_PROTOCOL_PSIA,                       // PSIA        
	DH_PROTOCOL_GB2818,                     // GB2818	        
	DH_PROTOCOL_GDYX,                       // GDYX        
	DH_PROTOCOL_OTHER,                      // others   
} DH_DEVICE_PROTOCOL;

// Split mode info
typedef struct tagDH_SPLIT_MODE_INFO
{
	DWORD				dwSize;
	DH_SPLIT_MODE		emSplitMode;			// Split mode
	int					nGroupID;				// Group SN
    DWORD               dwDisplayType;          // display type¡ê?seeDH_SPLIT_DISPLAY_TYPE¡ê¡§under each mode in note , displayed content depends on "PicInPic", each mode displayed content by NVD old rule¡ê¡§as depending on DisChntext¡ê?. Compatible¡ê?no this item¡ê?default is normal display type as"General"¡ê?
} DH_SPLIT_MODE_INFO;

// Split capability
typedef struct tagDH_SPLIT_CAPS 
{
	DWORD				dwSize;
	int					nModeCount;				// The split amount supported
	DH_SPLIT_MODE		emSplitMode[DH_MAX_SPLIT_MODE_NUM];	// The split mode supported
	int				    nMaxSourceCount;		// Max display source allocation amount
	int					nFreeWindowCount;		// count of free window support
	BOOL				bCollectionSupported;	// support collection
    DWORD               dwDisplayType;                          // mask means multiple display types¡ê?see DH_SPLIT_DISPLAY_TYPE¡ê¡§under each mode in note , displayed content depends on "PicInPic", each mode displayed content by NVD old rule¡ê¡§as depending on DisChntext?¡êCompatible¡ê?no this item¡ê?default is normal display type as"General"¡ê?
    int                 nPIPModeCount;                          // PIP support split mode quantity
    DH_SPLIT_MODE       emPIPSplitMode[DH_MAX_SPLIT_MODE_NUM];  // PIP supported split mode
    int                 nInputChannels[DH_SPLIT_INPUT_NUM];     // supported input channel
    int                 nInputChannelCount;                     // supported input channel quantity, 0 means no input channel limit
    int                 nBootModeCount;                         // enable split mode quantity
    DH_SPLIT_MODE       emBootMode[DH_MAX_SPLIT_MODE_NUM];      // support enable default video split mode
} DH_SPLIT_CAPS;

// even the authentication information
typedef struct tagDH_CASCADE_AUTHENTICATOR
{
	DWORD				dwSize;
	char				szUser[DH_NEW_USER_NAME_LENGTH];		// user name
	char				szPwd[DH_NEW_USER_PSW_LENGTH];			// passwd
	char				szSerialNo[DH_SERIALNO_LEN];			// serial no.
} DH_CASCADE_AUTHENTICATOR;

typedef enum tagEM_SRC_PUSHSTREAM_TYPE
{   
    EM_SRC_PUSHSTREAM_AUTO,        // device automatic recognition according to bit stream head£¬default
    EM_SRC_PUSHSTREAM_HIKVISION,   // Hikvision private bit stream
    EM_SRC_PUSHSTREAM_PS,          // PS
    EM_SRC_PUSHSTREAM_TS,          // TS
    EM_SRC_PUSHSTREAM_SVAC,        // SVAC
}EM_SRC_PUSHSTREAM_TYPE;

// Display source
typedef struct tagDH_SPLIT_SOURCE
{
	DWORD				dwSize;
	BOOL			    bEnable;						    // Enable
	char			    szIp[DH_MAX_IPADDR_LEN];		    // IP, null means there is no setup.
	char			    szUser[DH_USER_NAME_LENGTH];	    // User name
	char			    szPwd[DH_USER_PSW_LENGTH];	    	// Password
	int			    	nPort;							    // Port
	int				    nChannelID;						    // Channel No.
	int				    nStreamType;					    // Video bit stream. -1-auto, 0-main stream, 1-extra stream 1, 2-extra stream 2, 3-extra stream 3
	int				    nDefinition;					    // Definition, 0-standard definition, 1-high definition
	DH_DEVICE_PROTOCOL  emProtocol;							// Protocol type
	char			    szDevName[DH_DEVICE_NAME_LEN];		// Device name
	int					nVideoChannel;						// Video input channel amount
	int					nAudioChannel;						// Audio input channel amount
	// For decoder only
	BOOL				bDecoder;							// Decoder or not.
	BYTE				byConnType;							// 0:TCP;1:UDP;2:multicast
	BYTE				byWorkMode;							// 0:connect directly; 1:transfer 
	WORD				wListenPort;						// isten port, valid with transfer; when byConnType is multicast, it is multiport
	char				szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN];// szDevIp extension, front DVR Ip address (enter domain name)
	BYTE				bySnapMode;                         //  snapshot mode (valid when nStreamType==4) 0: request for single frame, 1: sechdule sending request
	BYTE				byManuFactory;						// Target device manufacturer. Refer to EM_IPC_TYPE for detailed information.
	BYTE				byDeviceType;                       //  target device type, 0:IPC
	BYTE				byDecodePolicy;                     // target device decode policy, 0:compatible with previous  
															// 1:real time level high 2: real time level medium
															// 3: real time level low 4: default level 
															// 5: fluency level high 6: fluency level medium
															// 7: fluency level low
	DWORD				dwHttpPort;                         // Http port number, 0-65535
	DWORD				dwRtspPort;                         // Rtsp port number, 0-65535
	char				szChnName[DH_DEVICE_NAME_LEN];		// Remote channel name, modifiable only when name read is not vacant
	char				szMcastIP[DH_MAX_IPADDR_LEN];       // Multicast IP address. Valid only when byConnType is multicast
	char				szDeviceID[DH_DEV_ID_LEN_EX];		// device ID, ""-null, "Local"  "Remote"
	BOOL				bRemoteChannel;						// is remote channel or not(read only)
	unsigned int		nRemoteChannelID;					// remote channel ID (read only), effective when bRemoteChannel=TRUE
	char				szDevClass[DH_DEV_TYPE_LEN];		// type of device, such as IPC, DVR, NVR and so on
	char				szDevType[DH_DEV_TYPE_LEN];			// device specific type, such as IPC-HF3300
	char				szMainStreamUrl[MAX_PATH];			// main stream url, effective when byManuFactory =D H_IPC_OTHER
	char				szExtraStreamUrl[MAX_PATH];			// extra stream url, effective when byManuFactory =D H_IPC_OTHER
	int					nUniqueChannel;						// unique channel ID, read only
	DH_CASCADE_AUTHENTICATOR stuCascadeAuth;				// ssascade authemyication, effective when device ID = "Local/Cascade/SerialNo",  SerialNo is device seral no.
    int                 nHint;                              // 0-normal video source, 1- alarm video source
    int                 nOptionalMainUrlCount;              // back main stream address quantity
    char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // backup main stream address list
    int                 nOptionalExtraUrlCount;             // backup sub stream address quantity
    char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // backup sub stream address list
    //--------------------------------------------------------------------------------------
    //protocol follow-up add field
    int                 nInterval;                          // tour time intertval	unit¡êosecond
    char                szUserEx[DH_NEW_USER_NAME_LENGTH];  // user name
    char                szPwdEx[DH_NEW_USER_PSW_LENGTH];    // password
    EM_SRC_PUSHSTREAM_TYPE  emPushStream;                   // type of pushstream,effective when byConnType is TCP-Push or UDP-Push 
} DH_SPLIT_SOURCE;

// Video output capability set
typedef struct tagDH_VIDEO_OUT_CAPS 
{
	DWORD				dwSize;
	BOOL				bColor;							// Support color output setup or not
	BOOL				bMargin;						// Support margin setup or not
	int					nLayers;						// The max layers supported at the same time
	BOOL				bPowerMode;						// Support power control or not.
	int					bSplitMode;						// The video split mode supported. 0-1-window. 1-'#' mode(inclduing 1-window).2-Any mode
    unsigned int        nBackground;                    // support background mode, by bit, 0-color, 1-picture
    BOOL                bBindOutput;                    // If support output screen resoluton binding setup
    BOOL                bAudioSupport;                          // Support audio output or not
    DWORD               dwAudioMode;                            // The support audio mode, by bit, bit0-main controller output, bit1-daughter card output
} DH_VIDEO_OUT_CAPS;

// Color BCSH
typedef struct tagDH_COLOR_BCSH 
{
	int					nBirghtness;					// Brightness
	int					nContrast;						// Contrast
	int			        nSaturation;					// Saturation
	int					nHue;						    // Hue
} DH_COLOR_BCSH;

// Dimensions
typedef struct tagDH_SIZE 
{
	int					nWidth;							// Width
	int					nHeight;						// Height
} DH_SIZE;

// mode of hot plug
typedef struct tagDH_HOT_PLUG_MODE
{
	DWORD				dwSize;
	int					nMode;							// mode of hot plug, 0-hot plug, 1-force output mode
} DH_HOT_PLUG_MODE;
// Video output option 
typedef struct tagDH_VIDEO_OUT_OPT
{
	DWORD				dwSize;
	DH_RECT*			pstuMargin;						// Margin range
	DH_COLOR_BCSH*		pstuColor;						// Output color
	DH_COLOR_RGBA*		pstuBackground;					// Background color
	DH_SIZE*			pstuSize;						// Output dimensions
	DH_HOT_PLUG_MODE*	pstuHotPlugMode;				// mode of hot plug
} DH_VIDEO_OUT_OPT;

#define NET_VIDEOANALYSE_SCENES (32)
#define NET_VIDEOANALYSE_RULES (64)
// intelligent analysis
typedef struct tagNET_PD_VIDEOANALYSE
{
    BOOL                bSupport;                   // ÊÇ·ñÖ§³ÖÖÇÄÜ·ÖÎö
    char                szSupportScenes[NET_VIDEOANALYSE_SCENES][DH_COMMON_STRING_64];   // Ö§³ÖµÄ³¡¾°
    char                SupportRules[NET_VIDEOANALYSE_RULES][DH_COMMON_STRING_64];       // Ö§³ÖµÄ¹æÔò
} NET_PD_VIDEOANALYSE;
// product definition
typedef struct tagDH_PRODUCTION_DEFNITION
{
	DWORD				dwSize;
	int					nVideoInChannel;				// Video input channel amount
	int					nVideoOutChannel;				// Video output channel amount
	int					nRemoteDecChannel;				// Remote decode channel amount
	char				szDevType[DH_DEV_TYPE_LEN];		// Device type
	char				szVendor[DH_MAX_NAME_LEN];		// OEM customer
	int					nOEMVersion;					// OEM version
	int					nMajorVerion;					// Main version No.
	int					nMinorVersion;					// SUb version No.
	int					nRevision;						// Revision version
	char				szWebVerion[DH_MAX_NAME_LEN];	// Web version
	char				szDefLanguage[DH_MAX_NAME_LEN];	// Default setup
	NET_TIME			stuBuildDateTime;				// Release time. Unit is second.
	int					nAudioInChannel;				// Audio input channel amount
	int					nAudioOutChannel;				// Audio output channel amount
	BOOL				bGeneralRecord;					// Support schedule storage or not.
	BOOL				bLocalStore;					// Support local storage or not.
	BOOL				bRemoteStore;					// Support network storage or not.
	BOOL				bLocalurgentStore;				// Support emergency local storage or not.
	BOOL				bRealtimeCompress;				// Support real-time compression storage or not.
	DWORD				dwVideoStandards;				// The video format supported. bit0-PAL, bit1-NTSC
	int					nDefVideoStandard;				// Default video format, 0-PAL, 1-NTSC
	int					nMaxExtraStream;				// Max extra stream channel amount
	int					nRemoteRecordChannel;			// Remote record channel amount
	int					nRemoteSnapChannel;				// Remote snap channel amount
	int					nRemoteVideoAnalyseChannel;		// Remote video analysis channel amount
	int					nRemoteTransmitChannel;			// Remote real-time stream transmit max channel amount
	int					nRemoteTransmitFileChannel;		// Remote transmit file channel amount
	int					nStreamTransmitChannel;			// Max network transmit channel amount
	int					nStreamReadChannel;				// Max read file channel amount
	int					nMaxStreamSendBitrate;			// Max bit stream network send capability, kbps
	int					nMaxStreamRecvBitrate;			// Max bit stream network interface capability, kbps
	BOOL				bCompressOldFile;				// Old compression file or not. Delete P frame and save I frame.
	BOOL				bRaid;							// Support RAID or not.
	int					nMaxPreRecordTime;				// Max pre-record time.Unit is second.
	BOOL				bPtzAlarm;						// Support PTZ alarm or not.
	BOOL				bPtz;							// Support PTZ or not.
	BOOL				bATM;							// Support corresponding function of the ATM or not.
	BOOL				b3G;							// Support 3G module or not.
	BOOL				bNumericKey;					// With number button or not.
	BOOL				bShiftKey;						// With Shift button or not.
	BOOL				bCorrectKeyMap;					// Number character map sheet is right or not.
	BOOL				bNewATM;						// The new 2nd ATM front panel.
	BOOL				bDecoder;						// Decoder or not
	DEV_DECODER_INFO	stuDecoderInfo;					// Decoder info. Valid when bDecoder=true.bDecoder=true
	int					nVideoOutputCompositeChannels;	// integration ceiling screen output channel
	BOOL                bSupportedWPS;                  // support WPS or not
	int					nVGAVideoOutputChannels;		// VGA video output channel number
	int					nTVVideoOutputChannels;			// TV video output channel number
	int					nMaxRemoteInputChannels;			// max number of remote channels
	int					nMaxMatrixInputChannels;			// max number of matrix channels
	int                 nMaxRoadWays;                   // max counts of road ways 1~6
	int                 nMaxParkingSpaceScreen;         // max counts of screen when docking with the camera 0~20

	int					nPtzHorizontalAngleMin;			// PTZ'horizontal minimum Angle, [0-360]
	int					nPtzHorizontalAngleMax;			// PTZ'horizontal maximum Angle, [0-360]
	int					nPtzVerticalAngleMin;			// PTZ'vertical  minimum Angle, [-90,90]
	int					nPtzVerticalAngleMax;			// PTZ'vertical  maximum Angle, [-90,90]
	BOOL				bPtzFunctionMenu;				// Whether to support PTZ's function menu 
	BOOL				bLightingControl;				// Whether to support lighting control 
	DWORD				dwLightingControlMode;			// Manual lighting control mode,bitwise,see NET_LIGHTING_CTRL_ON_OFF
	int					nNearLightNumber;				// dipped headlight group number, 0 means no support 
	int					nFarLightNumber;				// High beam group number, 0 means no support
	BOOL				bFocus;							// Whether to support control focus 
	BOOL				bIris;							// Whether to support control aperture 
	char				szPtzProtocolList[DH_COMMON_STRING_1024];	// PTZ support agreement list, can be more, each with '; 'delimited 
	BOOL				bRainBrushControl;				// Whether to support wiper control 
	int					nBrushNumber;					// Number of wiper, 0 means no support
	int					nLowerMatrixInputChannels[DH_MAX_LOWER_MITRIX_NUM];	// inferior video matrix input channel, the subscript corresponding matrix number 
	int					nLowerMatrixOutputChannels[DH_MAX_LOWER_MITRIX_NUM];	// inferior video matrix output channel, the subscript corresponding matrix number 
    BOOL                bSupportVideoAnalyse;           // support intelligent analuysis or not
    BOOL                bSupportIntelliTracker;         // support intelligen tracking or not
    DWORD               nSupportBreaking;               //device supported violation type mask(by bit Get )
                                                        //0-run the red light 1-cross line  2-retrogradation  3-under speed 4-over speed 5-car in lane 6-yellow plate in lane 7-violation driving¡ê¡§left, right, u-turn¡ê?
                                                        //8-violation enter waiting zone 9-illegal parking 10-Traffic jam 11-driving not by lane 12-illegal lane change 13-cross yellow line 14-should driving
                                                        //15-manual snapshot 16-illegal retention 17-crosswalk pedestration first 18-over flow 19-under flow 20-illegal in lane 21-illegal back car
                                                        //22-cross stop line 23-run yellow light 24-yellow grid line parking 25-car in parking 26-car not in parking 27-car in parking cross line  28-limited plate
                                                        //29-no pass 30-unfasten seat belt 31-drvier smoking
    DWORD               nSupportBreaking1;              //0-driver call 1-trafic-pedestrian redlight running 2-Traffic Jam Forbid Into 3-Pass Not In Order
    NET_PD_VIDEOANALYSE stuVideoAnalyse;                //IVS
} DH_PRODUCTION_DEFNITION;

// Manual lighting control mode 
#define NET_LIGHTING_CTRL_ON_OFF				0x01	// Direct switch mode 
#define NET_LIGHTING_CTRL_ADJUST_BRIGHTNESS		0x02	// Manually adjust brightness mode 
#define NET_LIGHTING_CTRL_ZOOM_PRIO				0x04	// Ratio prefer 


// Matrix sub card type. Various setups.
#define DH_MATRIX_CARD_MAIN				0x10000000		// main card
#define DH_MATRIX_CARD_INPUT			0x00000001		// input card 
#define DH_MATRIX_CARD_OUTPUT			0x00000002		// output card
#define DH_MATRIX_CARD_ENCODE			0x00000004		// encode card
#define DH_MATRIX_CARD_DECODE			0x00000008		// decode card
#define DH_MATRIX_CARD_CASCADE			0x00000010		// cascade card
#define DH_MATRIX_CARD_INTELLIGENT		0x00000020		// intelligent card
#define DH_MATRIX_CARD_ALARM            0x00000040      // alarm card 
#define DH_MATRIX_CARD_RAID             0x00000080      // Hdd Raid Card
#define DH_MATRIX_CARD_NET_DECODE       0x00000100      // net decode card

// Matrix sub card info
typedef struct tagDH_MATRIX_CARD
{
	DWORD				dwSize;
	BOOL				bEnable;					// Valid or not
	DWORD				dwCardType;					// Sub card type
	char		    	szInterface[DH_MATRIX_INTERFACE_LEN];	// Signal interface type, "CVBS", "VGA", "DVI"...
	char		    	szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];	// Device IP or domain name. The sub card that has no network conneciton can be null.
	int			    	nPort;						// Port No. The sub card that has no network conneciton can be 0.
	int					nDefinition;				// Definition. 0=standard definition. 1=High definition
	int					nVideoInChn;				// Video input channel amount
	int					nAudioInChn;				// Audio input channel amount
	int					nVideoOutChn;				// Video output channel amount
	int				    nAudioOutChn;				// Audio output channel amount
	int			    	nVideoEncChn;				// Video encode channel amount
	int				    nAudioEncChn;				// Audio encode channel amount
	int			    	nVideoDecChn;				// Video decode channel amount
	int			    	nAudioDecChn;				// Audio decode channel amount
	int					nStauts;					// Status: 0-OK, 1-no respond, 2-network disconnection, 3-conflict, 4-upgrading now
	int					nCommPorts;					// COM amount
	int					nVideoInChnMin;				// Video input channel min value
	int					nVideoInChnMax;				// Video input channel max value
	int					nAudioInChnMin;				// Audio input channel min value
	int					nAudioInChnMax;				// Audio input channel max value
	int					nVideoOutChnMin;			// Video output channel min value
	int					nVideoOutChnMax;			// Video output channel max value
	int					nAudioOutChnMin;			// Audio output channel min value
	int					nAudioOutChnMax;			// Audio output channel max value	
	int					nVideoEncChnMin;			// Video encode channel min value
	int					nVideoEncChnMax;			// Video encode channel max value
	int					nAudioEncChnMin;			// Audio encode channel min value
	int					nAudioEncChnMax;			// Audio encode channel max value
	int					nVideoDecChnMin;			// Video decode channel min value
	int					nVideoDecChnMax;			// Video decode channel max value
	int					nAudioDecChnMin;			// Audio decode channel min value
	int					nAudioDecChnMax;			// Audio decode channel max value
	int					nCascadeChannels;			// number of cascade channel
	int					nCascadeChannelBitrate;		// cascade channel bitrate (Mbps)
	int					nAlarmInChnCount;			// Alarm input channel number 
	int					nAlarmInChnMin;				// Alarm input channel number minimum value 
	int					nAlarmInChnMax;				// Alarm input channel number maximum value 
	int					nAlarmOutChnCount;			// Alarm output channel number 
	int					nAlarmOutChnMin;			// Alarm output channel number minimum value
	int					nAlarmOutChnMax;			// Alarm output channel number maximum value
	int					nVideoAnalyseChnCount;		// Intelligent analysis of channel number 
	int					nVideoAnalyseChnMin;		// Intelligent analysis of channel number minimum value 
	int					nVideoAnalyseChnMax;		// Intelligent analysis of channel number maximum value
	int					nCommPortMin;				// minimum value of serial port number  
	int					nCommPortMax;				// maximum value of serial port number
    char                szVersion[DH_COMMON_STRING_32];         // Version info
    NET_TIME            stuBuildTime;                           // compile time
} DH_MATRIX_CARD;

// Matrix sub card list
typedef struct tagDH_MATRIX_CARD_LIST 
{
	DWORD				dwSize;
	int					nCount;							// sub card  amount
	DH_MATRIX_CARD		stuCards[DH_MATRIX_MAX_CARDS];	// Sub card list 
} DH_MATRIX_CARD_LIST;

// Video output window
typedef struct tagDH_VIDEO_OUT_WINDOW
{
	DWORD				dwSize;
	int					nBackboardID;				// Backboard ID
	int					nScreenID;					// Screen ID
	int					nWindowID;					// Window ID
} DH_VIDEO_OUT_WINDOW;

// CLIENT_GetISCSITargets
typedef struct tagDH_IN_ISCSI_TARGETS 
{
	DWORD				dwSize;
	const char*			pszAddress;					// Server address
	int					nPort;						// port
	const char*			pszUser;					// Username
	const char*			pszPwd;						// Password
} DH_IN_ISCSI_TARGETS;

// ISCSI Target Info
typedef struct tagDH_ISCSI_TARGET 
{
	DWORD				dwSize;
	char				szName[DH_MAX_ISCSI_NAME_LEN];	// Name
	char				szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];	// service address
	char				szUser[DH_NEW_USER_NAME_LENGTH];// user name
	int					nPort;							// port
	UINT				nStatus;						// status, 0- unknow, 1-connected, 2-un connected, 3-connect failed, 4-authentication failed, 5-connect time out	
} DH_ISCSI_TARGET;

// CLIENT_GetISCSITargets Interface output parameter
typedef struct tagDH_OUT_ISCSI_TARGETS
{
	DWORD				dwSize;
	DH_ISCSI_TARGET*	pstuTargets;				// iscsi array
	int					nMaxCount;					// iscsi group size
	int					nRetCount;					// Received iscSi amount
} DH_OUT_ISCSI_TARGETS;

typedef enum tagDH_BITMAP_ACCURACY
{
    BA_DAY ,            //day 
    BA_HOUR ,           //day
    BA_5MIN ,           //5 miuntes
}DH_BITMAP_ACCURACY;

#define DH_MAX_BITMAPS        256                        // Bitmap bytes¡ê?DH_MAX_BITMAPS*8-bit
#define DH_MAX_CHN_NUM        256                        // The maximum channel number 
//CLIENT_GetBitmap Interface input parameters 
typedef struct tagDH_IN_BITMAP
{
    DWORD               dwSize;
    NET_TIME            stuStartTime;                   // start time, accurate to seconds 
    NET_TIME            stuEndTime;                     // Over time, accurate to seconds 
    int                 nChnList[DH_MAX_CHN_NUM];       // [1, ?-, 10]	Channel number list ,-1 means all channels ,0 means channels end
    DH_BITMAP_ACCURACY  emAccuracy;                     // Precision of the bitmap     
}DH_IN_BITMAP;

typedef struct tagDH_BITMAP_INFO
{
    DWORD               dwSize;
    int                 nChnID;                         //Channel number¡ê?Channel number is 0¡ê?means the end of the list 
    BYTE                bBitmap[DH_MAX_BITMAPS];        //Bitmap (each bit means a query scale, from low to high filling) 
                                                        //support DH_MAX_BITMAPS * 8 scale
    int                 nBitNum;                        //the digits of bitmap 
}DH_BITMAP_INFO;

//CLIENT_GetBitmap  Interface output parameters 
typedef struct tagDH_OUT_BITMAP
{
    DWORD               dwSize;
    DH_BITMAP_INFO      *pstBitmapInfos;
    int                 nGetBitmapInfo;
    int                 nMaxBitmapInfo;    
}DH_OUT_BITMAP;

// Storage device name
typedef struct tagDH_STORAGE_DEVICE_NAME 
{
	DWORD				dwSize;
	char				szName[DH_STORAGE_NAME_LEN];
} DH_STORAGE_DEVICE_NAME;

// RAID state
#define DH_RAID_STATE_ACTIVE		0x00000001
#define DH_RAID_STATE_INACTIVE		0x00000002
#define DH_RAID_STATE_CLEAN			0x00000004
#define DH_RAID_STATE_FAILED		0x00000008
#define DH_RAID_STATE_DEGRADED		0x00000010
#define DH_RAID_STATE_RECOVERING	0x00000020
#define DH_RAID_STATE_RESYNCING		0x00000040
#define DH_RAID_STATE_RESHAPING		0x00000080
#define DH_RAID_STATE_CHECKING		0x00000100
#define DH_RAID_STATE_NOTSTARTED	0x00000200

// RAID member info
typedef struct tagNET_RAID_MEMBER_INFO 
{
    DWORD               dwSize;
    DWORD               dwID;                                       // disk no., may use to describe disk cabinet slot
    BOOL                bSpare;                                     // partial hot device, true-partial hot device, false-RAID sub disk
} NET_RAID_MEMBER_INFO;

// RAID Info
typedef struct tagDH_STORAGE_RAID
{
	DWORD				dwSize;
	int					nLevel;										// level
	int					nState;										// RAID state combinationDH_RAID_STATE_ACTIVE | DH_RAID_STATE_DEGRADED
	int					nMemberNum;									// member amount
	char				szMembers[DH_MAX_MEMBER_PER_RAID][DH_STORAGE_NAME_LEN];	// RAID member
    float               fRecoverPercent;                            // Sync percentage, 0~100, RAID status has"Recovering" or "Resyncing" valid
    float               fRecoverMBps;                               // Sync speed, unit MBps, RAID status has"Recovering" or "Resyncing" valid
    float               fRecoverTimeRemain;                         // Sync remaining time, unit minute, RAID status has "Recovering" or "Resyncing" valid
    NET_RAID_MEMBER_INFO stuMemberInfos[DH_MAX_MEMBER_PER_RAID];    // RAID member info
} DH_STORAGE_RAID;

// Storage partition info
typedef struct tagDH_STORAGE_PARTITION
{
	DWORD				dwSize;
	char				szName[DH_STORAGE_NAME_LEN];				// Name
	INT64				nTotalSpace;   							    //Total space(MB) 
	INT64				nFreeSpace;								    // free space(MB)
	char				szMountOn[DH_STORAGE_MOUNT_LEN];			// Mount point
	char				szFileSystem[DH_STORAGE_FILE_SYSTEM_LEN];	//File system
	int					nStatus;									// partition state, 0-LV not available, 1-LV available
} DH_STORAGE_PARTITION;

// storage tank info
typedef struct tagDH_STORAGE_TANK 
{
	DWORD				dwSize;
	int					nLevel;										// level, the host is 0 level
	int					nTankNo;									// extend port number from 0
    int                 nSlot;                                      // Corresponding cabinet board card no., start from 0
} DH_STORAGE_TANK;

// storage device status
#define NET_STORAGE_DEV_OFFLINE                 0                   // physical disk offline status
#define NET_STORAGE_DEV_RUNNING                 1                   // physicali disk running ststus
#define NET_STORAGE_DEV_ACTIVE                  2                   // RAID activity
#define NET_STORAGE_DEV_SYNC                    3                   // RAID sync
#define NET_STORAGE_DEV_SPARE                   4                   // RAID hotdevice(partial)
#define NET_STORAGE_DEV_FAULTY                  5                   // RAID invalid
#define NET_STORAGE_DEV_REBUILDING              6                   // RAID re-build
#define NET_STORAGE_DEV_REMOVED                 7                   // RAID remove
#define NET_STORAGE_DEV_WRITE_ERROR             8                   // RAID error
#define NET_STORAGE_DEV_WANT_REPLACEMENT        9                   // RAID need to be replaced
#define NET_STORAGE_DEV_REPLACEMENT             10                  // RAID is replacement
#define NET_STORAGE_DEV_GLOBAL_SPARE            11                  // Global hotdevice
#define NET_STORAGE_DEV_ERROR                   12                  // Error, partial available
#define NET_STORAGE_DEV_RAIDSUB                 13                  // The disk is single, originally is Raid sub disk, may auto add Raid after reboot

// Storage device info
typedef struct tagDH_STORAGE_DEVICE 
{
	DWORD				dwSize;
	char				szName[DH_STORAGE_NAME_LEN];				// name
	INT64				nTotalSpace;								// Total space (MB) 
	INT64				nFreeSpace;									// free space (MB) 
	BYTE				byMedia;									// Media, 0-DISK, 1-CDROM, 2-FLASH medium,  
	BYTE				byBUS;										// BUS, 0-ATA, 1-SATA, 2-USB, 3-SDIO, 4-SCSI main line 0-ATA, 1-SATA, 2-USB, 3-SDIO, 4-SCSI
	BYTE				byVolume;									// volume type, 0-physics, 1-Raid, 2- VG virtual 
	BYTE				byState;									// Physics disk state, 0-physics disk offline state 1-physics disk  2- RAID activity 3- RAID sync 4-RAID hotspare 5-RAID invalidation 6- RAID re-creation  7- RAID delete
	int					nPhysicNo;									// storage interface of devices of same type logic number
	int					nLogicNo;									// storage interface of devices of same type physics number
	char				szParent[DH_STORAGE_NAME_LEN];				// superior storage group name
	char				szModule[DH_STORAGE_NAME_LEN];				// device module
	char				szSerial[DH_SERIALNO_LEN];					// device serial number
	char				szFirmware[DH_VERSION_LEN];					// Firmware version
	int					nPartitionNum;								//partition number
	DH_STORAGE_PARTITION stuPartitions[DH_MAX_STORAGE_PARTITION_NUM];// partition info
	DH_STORAGE_RAID		stuRaid;									// Raid info, for RAID use only(byVolume == 1) 
	DH_ISCSI_TARGET		stuISCSI;									// Iscsi info, for iscsi use only (byVolume == 2)
	BOOL				abTank;										// tank enable
	DH_STORAGE_TANK		stuTank;									// tank info, effectice when abTank = TRUE
} DH_STORAGE_DEVICE; 

// OSD channel info
typedef struct tagNET_SPLIT_OSD 
{
    DWORD               dwSize;
    BOOL                bEnable;                    // enable
    DH_COLOR_RGBA       stuFrontColor;              // The foreground color 
    DH_COLOR_RGBA       stuBackColor;               // The background color 
    DH_RECT             stuFrontRect;               // Foreground area 
    DH_RECT             stuBackRect;                // Background region 
    BOOL                bRoll;                      // Whether the scroll display, applies to the text only 
    BYTE                byRollMode;                 // Scroll mode, applies only to text, 0 -from left to right,1-from right to left 
    BYTE                byRoolSpeed;                // Rolling speed, applies to text  only , 0 ~ 4, the greater the value the faster the scrolling 
    BYTE                byFontSize;                 // The font size, applies to the text only  
    BYTE                byTextAlign;                // Alignment, 0 - left, 1 - centered, 2 - right 
    BYTE                byType;                     // OSD type, 0 - text, 1 - icon 
    BYTE                Reserved[3];                // retain byte
    char                szContent[MAX_PATH];        // OSD content, if the type is icon, the content is the name of the icon 
    float               fPitch;                     // field interval, 0.0 ~ 5.0
    char                szFontType[DH_COMMON_STRING_64]; // font type 
} NET_SPLIT_OSD;

// CLIENT_GetSplitOSD's interface input param(get split window input OSD info)
typedef struct tagDH_IN_SPLIT_GET_OSD
{
	DWORD					dwSize;
	int						nChannel;				// channel no.
	int						nWindow;				// window no.
} DH_IN_SPLIT_GET_OSD;

// CLIENT_GetSplitOSD's interface input param(get split window output OSD info)
typedef struct tagDH_OUT_SPLIT_GET_OSD
{
	DWORD					dwSize;
    int                 nOSDNum;                            // OSD number
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD information
} DH_OUT_SPLIT_GET_OSD;

// CLIENT_SetSplitOSD's interface input param(setting split window input OSD info)
typedef struct tagDH_IN_SPLIT_SET_OSD
{
	DWORD					dwSize;
	int						nChannel;				// channel no.
	int						nWindow;				// window no.
    int                 nOSDNum;                            // OSD number
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD information
} DH_IN_SPLIT_SET_OSD;

// CLIENT_SetSplitOSD's interface input param(setting split window output OSD info)
typedef struct tagDH_OUT_SPLIT_SET_OSD
{
	DWORD					dwSize;
} DH_OUT_SPLIT_SET_OSD;

// Video output control method 
typedef enum
{
    EM_VIDEO_OUT_CTRL_CHANNEL,              // Logical channel number control mode,effective for physical screen and splicing screen 
    EM_VIDEO_OUT_CTRL_COMPOSITE_ID,         // Splice screen ID control mode, applies to splice screen only  
} EM_VIDEO_OUT_CTRL_TYPE;

// CLIENT_SetSplitSourceEx  The input parameters of the interface 
typedef struct tagNET_IN_SET_SPLIT_SOURCE 
{
    DWORD                   dwSize;
    EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // Video output control method 
    int                     nChannel;           // Video output logical channel number,when the emCtrlType is EM_VIDEO_OUT_CTRL_CHANNEL effective
    const char*             pszCompositeID;     // Splicing screen ID, when the emCtrlType is EM_VIDEO_OUT_CTRL_CHANNEL effective
    int                     nWindow;            // winder number, -1 means all windows of the current segmentation mode 
    DH_SPLIT_SOURCE*        pstuSources;        // Video source information, when nWindow=-1, Video source is an array, and the number and the window number
    int                     nSourceCount;       // Video source number 
} NET_IN_SET_SPLIT_SOURCE;

// Set the return result of video source  
typedef struct tagNET_SET_SPLIT_SOURCE_RESULT 
{
    DWORD                   dwSize;
    int                     nPushPort;          // Monitor Port Number of Push Flow Pattern Equipment 
} NET_SET_SPLIT_SOURCE_RESULT;

// CLIENT_SetSplitSourceEx output parameters of the interface 
typedef struct tagNET_OUT_SET_SPLIT_SOURCE
{
    DWORD                   dwSize;
    NET_SET_SPLIT_SOURCE_RESULT* pstuResults;   // returned value after successful setting , corresponding the window array in NET_IN_SET_SPLIT_SOURCE, user allocates memory , If don't need can be NULL 
    int                     nMaxResultCount;    // The size of the pstuResults array
    int                     nRetCount;          // The Number Of Return
} NET_OUT_SET_SPLIT_SOURCE;

//volume type enumeration
typedef enum tagNET_VOLUME_TYPE
{
    VOLUME_TYPE_ALL = 0      ,      //all volume
    VOLUME_TYPE_PHYSICAL     ,      //physical volume
    VOLUME_TYPE_RAID         ,      //Raid volume
    VOLUME_TYPE_VOLUME_GROUP ,      //VG virtual volume
    VOLUME_TYPE_ISCSI        ,      //iSCSI volume
    VOLUME_TYPE_INVIDUAL_PHY ,      //independent physical volume¡ê¡§this physical volume¡ê?is not added into¡ê? RAID¡ê?virtual volume group¡ê?
    VOLUME_TYPE_GLOBAL_SPARE ,      //global hot spare volume
    VOLUME_TYPE_MAX          ,
}NET_VOLUME_TYPE;


#define    MAX_DEVICE_VOLUME_NUMS        128                //volume type upper limit

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES type port input parameter
typedef struct tagNET_IN_STORAGE_DEV_NAMES
{
    DWORD               dwSize;
    NET_VOLUME_TYPE     emVolumeType;       //volume type to get
} NET_IN_STORAGE_DEV_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES type volume output parameter
typedef struct tagNET_OUT_STORAGE_DEV_NAMES
{
    DWORD               dwSize;
    int                 nDevNamesNum;                       //got device storage module name quantity
    char                szStoregeDevNames[MAX_DEVICE_VOLUME_NUMS][DH_STORAGE_NAME_LEN]; //device name list
}NET_OUT_STORAGE_DEV_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS port input parameter
typedef struct tagNET_IN_STORAGE_DEV_INFOS
{
    DWORD               dwSize;
    NET_VOLUME_TYPE     emVolumeType;       //volume type to get
} NET_IN_STORAGE_DEV_INFOS;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS port output parameter
typedef struct tagNET_OUT_STORAGE_DEV_INFOS
{
    DWORD               dwSize;
    int                 nDevInfosNum;                      //device storage moduleinfo list to get
    DH_STORAGE_DEVICE   stuStoregeDevInfos[MAX_DEVICE_VOLUME_NUMS]; //device info list,DH_STORAGE_DEVICE¦Ì?dwsize need to assign value
} NET_OUT_STORAGE_DEV_INFOS;

typedef enum tagNET_RECENCY_CAR_INFO
{
    RECENCY_CAR_INFO_UNKNOW = 0 ,
    RECENCY_CAR_INFOO_NEWEST    ,      //newest
    RECENCY_CAR_INFO_ODLEST     ,      //oldest
    RECENCY_CAR_INFO_MAX        ,
}NET_RECENCY_CAR_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO port input parameter
typedef struct tagNET_IN_GET_RECENCY_JUNCTION_CAR_INFO
{
    DWORD                   dwSize;
    int                     nChannel;       //snapshot channel no.
    NET_RECENCY_CAR_INFO    emRecencyType;  //get vehicle info type¡ê?newest or latest
    DWORD                   nIndex;         //no. vehicle info, from 1¡ê?if it is 0, it alsomeans no. 1
}NET_IN_GET_RECENCY_JUNCTION_CAR_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO port output parameter
typedef struct tagNET_OUT_GET_RECENCY_JUNCTION_CAR_INFO
{
    DWORD           dwSize;
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;        // traffic vehicle info
}NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO;

// 
#define NET_MAX_FISHEYE_WINDOW_NUM        8     // Max fish eye window number

// window position info 
typedef struct tagNET_FISHEYE_WINDOW_INFO
{
  DWORD       dwSize;
  DWORD       dwWindowID;            // window ID
  int        nFocusX;              // EPtz¡ê¡§E-PTZ ¡ê?focus horizontal coordinate
  int        nFocusY;              // EPtz (E-PTZ ¡ê?focus vertical coordinate  
  int        nHorizontalAngle;         // EPtz horizontal degree
  int        nVerticalAngle;          // EPtz vertical degree
}NET_FISHEYE_WINDOW_INFO;

// corresponding to CLIENT_QueryDevInfo port¡ê?NET_QUERY_DEV_FISHEYE_WININFO search Fish eye window info input parameter
typedef struct tagNET_IN_FISHEYE_WININFO
{
  DWORD        dwSize;
  int         nChannelId;           // channel no.
  int         nWindowNum;           // search window number
  int         nWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // window id¡ê?cannot repeat
}NET_IN_FISHEYE_WININFO;

// corresponding to CLIENT_QueryDevInfo port¡ê?NET_QUERY_DEV_FISHEYE_WININFO search Fish eye window info output parameter
typedef struct tagNET_OUT_FISHEYE_WININFO
{
  DWORD        dwSize;
  int         nWindowNum;           //window number
  NET_FISHEYE_WINDOW_INFO stuWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // windowdetail info 
}NET_OUT_FISHEYE_WININFO;

//CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE port input parameter
typedef struct tagNET_IN_GET_LANES_STATE
{
  DWORD          dwSize;
  int           nLaneNumber; //-1 represents search all lane,>=0 means search specify lane
}NET_IN_GET_LANES_STATE;

//signal light indicator status 
typedef enum tagNET_TRAFFIC_LIGHT_STATUS
{
  LIGHT_STATUS_UNKNOWN = 0  ,  // unknown 
  LIGHT_STATUS_RED      ,  //red
  LIGHT_STATUS_GREEN     ,  //green
  LIGHT_STATUS_YELLOW     ,  //yellow
}NET_TRAFFIC_LIGHT_STATUS;

//signal light indicator info 
typedef struct tatNET_TRAFFIC_LIGHT_INFO
{
  DWORD            dwSize;
  NET_TRAFFIC_LIGHT_STATUS  emStraightLightInfo;  //straight light status 
  NET_TRAFFIC_LIGHT_STATUS  emLeftLightInfo;    //left light status 
  NET_TRAFFIC_LIGHT_STATUS  emRightLightInfo;    //right light status 
  NET_TRAFFIC_LIGHT_STATUS  emUTurnLightInfo;    //u-turn light status 
}NET_TRAFFIC_LIGHT_INFO;

//lane direction
typedef enum tagNET_TRAFFIC_DIRECTION
{
  DIRECTION_UNKNOW  = 0 ,  // unknown 
  DIRECTION_STRAIGHT   ,  //straight
  DIRECTION_LEFT     ,  //left
  DIRECTION_RIGHT     ,  //right
  DIRECTION_UTURN     ,  //u-turn
}NET_TRAFFIC_DIRECTION;

//lane info 
typedef struct tagNET_TRAFFIC_LANE_INFO
{
  DWORD          dwSize;
  UINT          nLaneNumber;                  //lane no.,0 start 
  UINT          nSupportDirectionNum;              //lane can drive direction number
  NET_TRAFFIC_DIRECTION  emTrafficDirections[MAX_LANE_DIRECTION_NUM];  //lane direction, means this lane can drive in all directions
  NET_TRAFFIC_JAM_STATUS emJamState;                   //road jam status
  //flow info 
  UINT          nLargeVehicleNum;                //large car quantity
  UINT          nMediumVehicleNum;               //medium car quantity
  UINT          nSmallVehicleNum;                //small car quantity
  UINT          nMotoNum;                    //motor quantity
}NET_TRAFFIC_LANE_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE port output parameter
typedef struct tagNET_OUT_GET_LANES_STATE
{
  DWORD          dwSize;
  int           nGetLaneInfoNum;          // Get lane info quantity
  NET_TRAFFIC_LANE_INFO  stLaneInfos[MAX_LANE_INFO_NUM];   // Get lane info 
  NET_TRAFFIC_LIGHT_INFO stLightInfo;            //signal light indicator status 
}NET_OUT_GET_LANES_STATE;

//CLIENT_QueryDevInfo , input param
typedef struct tagNET_IN_SYSTEM_INFO
{
    DWORD               dwSize;
} NET_IN_SYSTEM_INFO;

//CLIENT_QueryDevInfo , output param
typedef struct tagNET_OUT_SYSTEM_INFO
{
    DWORD               dwSize;
    BOOL                bHasRTC;                       // whether system has RTC(for recording system time),TRUE:Yes,FALSE:No
}NET_OUT_SYSTEM_INFO;


// port  CLIENT_AttachLanesState input parameter
typedef struct tagNET_IN_REGDEV_NET_INFO
{
    DWORD               dwSize;
    char                szDevSerial[DH_DEV_SERIALNO_LEN];   // Device SN by auto register 
}NET_IN_REGDEV_NET_INFO;

// celluar net type
typedef enum tagNET_CELLUAR_NET_TYPE 
{
    EM_CELLUAR_NET_UNKNOW           =   -1  ,    //Unknown 
    EM_CELLUAR_NET_PRIVATE_3G_4G    =   0   ,    //Special 3G/4G network (such as the internal network of the public security authority)
    EM_CELLUAR_NET_COMMERCIAL_3G_4G =   1   ,    //Business 3G/4G network (Such as internet service provider)
    EM_CELLUAR_NET_MAX , 
}NET_CELLUAR_NET_TYPE;

//output param of CLIENT_QueryDevInfo according to NET_QUERY_REG_DEVICE_NET_INFO 
typedef struct tagNET_OUT_REGDEV_NET_INFO
{
    DWORD                   dwSize;
    NET_CELLUAR_NET_TYPE    emCelluarNetType;           //Network type when auto register 
}NET_OUT_REGDEV_NET_INFO;

// video channel type when query video channel info
typedef enum tagNET_VIDEO_CHANNEL_TYPE
{
    NET_VIDEO_CHANNEL_TYPE_ALL,                         // all types
    NET_VIDEO_CHANNEL_TYPE_INPUT,                       // input
    NET_VIDEO_CHANNEL_TYPE_OUTPUT,                      // output
} NET_VIDEO_CHANNEL_TYPE;

//input param of CLIENT_QueryDevInfo according to NET_QUERY_VIDEOCHANNELSINFO 
typedef struct tagNET_IN_GET_VIDEOCHANNELSINFO
{
    DWORD                               dwSize;
    NET_VIDEO_CHANNEL_TYPE              emType;         // video channel type to query                     
} NET_IN_GET_VIDEOCHANNELSINFO;

typedef struct tagNET_VIDEOCHANNELS_INPUT 
{
    int                     nThermographyCount;         // thermo channel count in nThermography
    int                     nThermography[64];          // thermo channel numbers
    int                     nMultiPreviewCount;         // multi preview channel count in nMultiPreview
    int                     nMultiPreview[4];	        // multi preview channel numbers
    int                     nPIPCount;                  // PIP channel count in nPIP
    int                     nPIP[4];    	            // PIP channel numbers
    int                     nCompressPlayCount;         // compress play channel count in nCompressPlay
    int                     nCompressPlay[4];	        // compress play channel numbers
    char                    reserved[512];
} NET_VIDEOCHANNELS_INPUT;

typedef struct tagNET_VIDEOCHANNELS_OUTPUT 
{
    int                     nVGACount;                  // VGA output count in nVGA
    int                     nVGA[128];                  // VGA output channel numbers
    int                     nTVCount;                   // TV output count in nTV
    int                     nTV[128];                   // TV output channel numbers
    char                    reserved[512];
} NET_VIDEOCHANNELS_OUTPUT;

//output param of CLIENT_QueryDevInfo according to NET_QUERY_VIDEOCHANNELSINFO
typedef struct tagNET_OUT_GET_VIDEOCHANNELSINFO
{
    DWORD                       dwSize;
    NET_VIDEOCHANNELS_INPUT     stInputChannels;        // input channel info        
    NET_VIDEOCHANNELS_OUTPUT    stOutputChannels;       // output channel info
} NET_OUT_GET_VIDEOCHANNELSINFO;

// CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_NAMES input
typedef struct tagNET_IN_WORKGROUP_NAMES
{
    DWORD                       dwSize;
} NET_IN_WORKGROUP_NAMES;

// max length for workgroup name
#define WORKGROUP_NAME_LEN      32

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_NAMES output
typedef struct tagNET_OUT_WORKGROUP_NAMES
{
    DWORD                       dwSize;
    int                         nCount;                         // workgroup count
    char                        szName[64][WORKGROUP_NAME_LEN]; // name of each workgroup
} NET_OUT_WORKGROUP_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_INFO input
typedef struct tagNET_IN_WORKGROUP_INFO
{
    DWORD                       dwSize;
    char                        szName[WORKGROUP_NAME_LEN];     // workgroup whose info you want to query                    
} NET_IN_WORKGROUP_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_INFO input
typedef struct tagNET_OUT_WORKGROUP_INFO
{
    DWORD                       dwSize;
    int                         nState;                         // state£º0 nonsense, 1 normal, 2 damaged, 3 error
    int                         nTotalSpace;                    // Total Space Unit£ºMB, -1 for error
    int                         nFreeSpace;                     // Free Space Unit£ºMB -1 for error
} NET_OUT_WORKGROUP_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WLAN_ACCESSPOINT input
typedef struct tagNET_IN_WLAN_ACCESSPOINT
{
    DWORD                       dwSize;
    char                        szSSID[DH_MAX_SSID_LEN];        // SSID of wireless network whose info you want to query. if null, query all wireless network                    
} NET_IN_WLAN_ACCESSPOINT;

typedef struct tagNET_WLAN_ACCESSPOINT_INFO
{
    char                        szSSID[DH_MAX_SSID_LEN];        // SSID (name of wireless network)
    int                         nStrength;                      // signal strength, range: 0-100
    char                        reserved[1024];
} NET_WLAN_ACCESSPOINT_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WLAN_ACCESSPOINT output
typedef struct tagNET_OUT_WLAN_ACCESSPOINT
{
    DWORD                       dwSize;
    int                         nCount;                         // wireless network count
    NET_WLAN_ACCESSPOINT_INFO   stuInfo[64];                    // info for each network                       
} NET_OUT_WLAN_ACCESSPOINT;

// input for CLIENT_QueryDevInfo, NET_QUERY_TRAFFICRADAR_VERSION 
typedef struct tagNET_IN_TRAFFICRADAR_VERSION
{
    DWORD                   dwSize;
    int                     nChannel;                   // serial port number
} NET_IN_TRAFFICRADAR_VERSION;
// output of CLIENT_QueryDevInfo , NET_QUERY_TRAFFICRADAR_VERSION
typedef struct tagNET_OUT_TRAFFICRADAR_VERSION
{
    DWORD                   dwSize;
    char                    szVersion[DH_MAX_VERSION_LEN];  // version
} NET_OUT_TRAFFICRADAR_VERSION;

// input for CLIENT_AttachLanesState 
typedef NET_OUT_GET_LANES_STATE NET_CB_LANES_STATE;

// callback for CLIENT_AttachLanesState 
typedef void (CALLBACK *fNotifyLanesState)(LLONG lLanesStateHandle, NET_CB_LANES_STATE* pLanesStateInfo, LDWORD dwUser, void *reserved);

// port  CLIENT_AttachLanesState input parameter
typedef struct tagNET_IN_ATTACH_LANES_STATE
{
  DWORD        dwSize;             // this structure size
  int         nChannelID;           // channel no.
  int         nLaneNumber;          // -1order all lanes¡ê?>=0 means order specific lane
  
  fNotifyLanesState  cbNotifyLanesState;       // call function
  LDWORD        dwUser;             // user custom parameter
} NET_IN_ATTACH_LANES_STATE;

// port  CLIENT_AttachLanesState output parameter
typedef struct tagNET_OUT_ATTACH_LANES_STATE
{
  DWORD        dwSize;             // this structure size
} NET_OUT_ATTACH_LANES_STATE;


// CLIENT_MatrixSwitch The input parameters 
typedef struct tagNET_IN_MATRIX_SWITCH
{
    DWORD           dwSize;
    DH_SPLIT_MODE   emSplitMode;                // Segmentation Model 
    int*            pnOutputChannels;           // Output channel, can specify multiple output channel switch together at the same time, the content is consistent 
    int             nOutputChannelCount;        // Output channel number 
    int*            pnInputChannels;            // Input channel, each split window corresponding to one input channel 
    int             nInputChannelCount;         // Input channel number
} NET_IN_MATRIX_SWITCH;

// CLIENT_MatrixSwitch Output Parameters 

typedef struct tagNET_OUT_MATRIX_SWITCH 
{
    DWORD            dwSize;
} NET_OUT_MATRIX_SWITCH;

// CLIENT_SplitSetMultiSource The Input Parameters of the Interface 
typedef struct tagNET_IN_SPLIT_SET_MULTI_SOURCE 
{
    DWORD                   dwSize;
    EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // Video output control method 
    int                     nChannel;           // Video output logical channel number,Effective When emCtrlType is EM_VIDEO_OUT_CTRL_CHANNEL
    const char*             pszCompositeID;     // Splicing screen ID,When emCtrlType is EM_VIDEO_OUT_CTRL_COMPOSITE_ID
    BOOL                    bSplitModeEnable;   // Whether to change segmentation model 
    DH_SPLIT_MODE           emSplitMode;        // Segmentation model,Enable when bSplitModeEnable=TRUE
    int                     nGroupID;           // Segmentation group number,Effective when bSplitModeEnable=TRUE
    int*                    pnWindows;          // Window Number Array 
    int                     nWindowCount;       // Window Number
    DH_SPLIT_SOURCE*        pstuSources;        // Video source information, corresponding to each window, the number with the number of window 
} NET_IN_SPLIT_SET_MULTI_SOURCE;

// CLIENT_SplitSetMultiSource The output parameters of the interface
typedef struct tagNET_OUT_SPLIT_SET_MULTI_SOURCE 
{
    DWORD                   dwSize;
} NET_OUT_SPLIT_SET_MULTI_SOURCE;

// Video split operation type
typedef enum tagNET_SPLIT_OPERATE_TYPE
{
    NET_SPLIT_OPERATE_SET_BACKGROUND,            // Set background, corresponding NET_IN_SPLIT_SET_BACKGROUND  and NET_OUT_SPLIT_SET_BACKBROUND
    NET_SPLIT_OPERATE_GET_BACKGROUND,            // get background, corresponding NET_IN_SPLIT_GET_BACKGROUND  and NET_OUT_SPLIT_GET_BACKGROUND
    NET_SPLIT_OPERATE_SET_PREPULLSRC,            // set pre stream srouce, corresponding to NET_IN_SPLIT_SET_PREPULLSRC and NET_OUT_SPLIT_SET_PREPULLSRC
    NET_SPLIT_OPERATE_SET_HIGHLIGHT,             // set source frame brightness switch, corresponding to NET_IN_SPLIT_SET_HIGHLIGHT and NET_OUT_SPLIT_SET_HIGHLIGHT
    NET_SPLIT_OPERATE_SET_ZORDER,                // adjust window Z order, corresponding to NET_IN_SPLIT_SET_ZORDER  and  NET_OUT_SPLIT_SET_ZORDER
    NET_SPLIT_OPERATE_SET_TOUR,                  // window tour control, corresponding to NET_IN_SPLIT_SET_TOUR  and  NET_OUT_SPLIT_SET_TOUR
    NET_SPLIT_OPERATE_GET_TOUR_STATUS,           // Get window tour status , corresponding to NET_IN_SPLIT_GET_TOUR_STATUS  and  NET_OUT_SPLIT_GET_TOUR_STATUS
    NET_SPLIT_OPERATE_GET_SCENE,                 // Get screen window info , corresponding to NET_IN_SPLIT_GET_SCENE  and  NET_OUT_SPLIT_GET_SCENE
    NET_SPLIT_OPERATE_OPEN_WINDOWS,              // batch window, corresponding to NET_IN_SPLIT_OPEN_WINDOWS  and  NET_OUT_SPLIT_OPEN_WINDOWS
    NET_SPLIT_OPERATE_SET_WORK_MODE,             // set work mode , corresponding to NET_IN_SPLIT_SET_WORK_MODE  and  NET_OUT_SPLIT_SET_WORK_MODE
    NET_SPLIT_OPERATE_GET_PLAYER,                // Get player example, corresponding to NET_IN_SPLIT_GET_PLAYER  and  NET_OUT_SPLIT_GET_PLAYER
    NET_WM_OPERATE_SET_WORK_MODE,                // Set window working mode, corresponding  NET_IN_WM_SET_WORK_MODE and NET_OUT_WM_SET_WORK_MODE
    NET_WM_OPERATE_GET_WORK_MODE,                // Get window working mode, corresponding  NET_IN_WM_GET_WORK_MODE and NET_OUT_WM_GET_WORK_MODE
    NET_SPLIT_OPERATE_CLOSE_WINDOWS,             // close batch windows NET_IN_SPLIT_CLOSE_WINDOWS o¨ª NET_OUT_SPLIT_CLOSE_WINDOWS
    NET_WM_OPERATE_SET_FISH_EYE_PARAM,           // set the output rules of the fish eyes, corresponding NET_IN_WM_SET_FISH_EYE_PARAM and NET_OUT_WM_SET_FISH_EYE_PARAM
	NET_WM_OPERATE_SET_CORRIDOR_MODE,			 // set the corridor mode of the window, corresponding NET_IN_WM_SET_CORRIDOR_MODE and NET_OUT_WM_SET_CORRIDOR_MODE
	NET_WM_OPERATE_GET_CORRIDOR_MODE,			 // get the corridor mode of the window, corresponding NET_IN_WM_GET_CORRIDOR_MODE and NET_OUT_WM_GET_CORRIDOR_MODE
} NET_SPLIT_OPERATE_TYPE;

// Set source frame brightness switch input parameter
typedef struct tagNET_IN_SPLIT_SET_HIGHLIGHT
{
    DWORD           dwSize; 
    int             nChannel;                   // video output channel
    int             nWindow;                    // window no.
    BOOL            bHighLightEn;               // frame brightness,TRUE-high brightness
    DH_COLOR_RGBA   stuColor;                   // frame color 
}NET_IN_SPLIT_SET_HIGHLIGHT;

// set frame brightness enable switch output parameter
typedef struct tagNET_OUT_SPLIT_SET_HIGHLIGHT
{
    DWORD           dwSize;
}NET_OUT_SPLIT_SET_HIGHLIGHT;

// Set pre stream input parameter
typedef struct tagNET_IN_SPLIT_SET_PREPULLSRC 
{
    DWORD           dwSize;
    int             nChannel;                   // video output channel
    int             nWindow;                    // window no.
    int             nSrcCount;                  // pre stream source quantity
    DH_SPLIT_SOURCE* pSources;                  // re stream source info
} NET_IN_SPLIT_SET_PREPULLSRC;

// Set pre stream source return result
typedef struct tagNET_SPLIT_SET_PREPULLSRC_RESULT 
{
    DWORD           dwSize;
    BOOL            bResult;                    // set result, TRUE-successful, FALSE-failed
    DWORD           dwErrorCode;                // Error code
} NET_SPLIT_SET_PREPULLSRC_RESULT;

// Set pre source output parameter
typedef struct tagNET_OUT_SPLIT_SET_PREPULLSRC 
{
    DWORD           dwSize;
    int             nResultCount;               // result quantity, same with pre source    NET_SPLIT_SET_PREPULLSRC_RESULT* pResults;  // result
    NET_SPLIT_SET_PREPULLSRC_RESULT* pResults;  // result
} NET_OUT_SPLIT_SET_PREPULLSRC;

// Set video output background input parameter
typedef struct tagNET_IN_SPLIT_SET_BACKGROUND
{
    DWORD            dwSize;
    int              nChannel;                   // Video output channel no.
    BOOL             bEnable;                    // enable
    const char*      pszFileName;                // background name
} NET_IN_SPLIT_SET_BACKGROUND;

// Set video output background parameter
typedef struct tagNET_OUT_SPLIT_SET_BACKGROUND 
{
    DWORD            dwSize;
} NET_OUT_SPLIT_SET_BACKGROUND;

// get video output background input parameter
typedef struct tagNET_IN_SPLIT_GET_BACKGROUND 
{
    DWORD            dwSize;
    int              nChannel;                   // video output channel o.
} NET_IN_SPLIT_GET_BACKGROUND;

// get video output background output parameter
typedef struct tagNET_OUT_SPLIT_GET_BACKGROUND 
{
    DWORD            dwSize;
    BOOL            bEnable;                            // enable
    char            szFileName[DH_COMMON_STRING_256];   // background name
} NET_OUT_SPLIT_GET_BACKGROUND;

// window Z sequence
typedef enum tagNET_WINDOW_ZORDER
{
  NET_WINDOW_ZORDER_TOP,               // top
  NET_WINDOW_ZORDER_BOTTOM,              // bottom
  NET_WINDOW_ZORDER_UP,                // up
  NET_WINDOW_ZORDER_DOWN,               // down
} NET_WINDOW_ZORDER;

// window layer order
typedef struct tagDH_WND_ZORDER
{
  DWORD        dwSize;
  unsigned int    nWindowID;           // window no.
  unsigned int    nZOrder;            // Z order
} DH_WND_ZORDER;

// set window Z order input parameter
typedef struct tagNET_IN_SPLIT_SET_ZORDER 
{
  DWORD        dwSize;
  int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char*     pszCompositeID;         // cubeless video wall ID
  int         nWindow;            // window no.
  NET_WINDOW_ZORDER  emZOrder;            // adjust Z order
} NET_IN_SPLIT_SET_ZORDER;

// set window Z order output parameter, adjust one window Z order will affect all windows,  return adjusted all windows?¡¥ Z order
typedef struct tagNET_OUT_SPLIT_SET_ZORDER
{
  DWORD        dwSize;
  DH_WND_ZORDER*   pZOders;            // window order group, user allocate memory
  int         nMaxWndCount;          // window order group size
  int         nWndCount;           // return window quantity
} NET_OUT_SPLIT_SET_ZORDER;

// window tour motion 
typedef enum tagEM_NET_WINDOW_TOUR_ACTION 
{
  EM_NET_WND_TOUR_ACTION_START,            //  start 
  EM_NET_WND_TOUR_ACTION_STOP,            // stop
} EM_NET_WINDOW_TOUR_ACTION;

// window tour control input parameter, corresponding to NET_SPLIT_OPERATE_SET_TOUR
typedef struct tagNET_IN_SPLIT_SET_TOUR 
{
  DWORD        dwSize;
  int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char*     pszCompositeID;         // cubeless video wall ID
  int         nWindow;            // window no.
  EM_NET_WINDOW_TOUR_ACTION emAction;         // tour motion 
} NET_IN_SPLIT_SET_TOUR;

// window tour control output parameter, corresponding to NET_SPLIT_OPERATE_SET_TOUR
typedef struct tagNET_OUT_SPLIT_SET_TOUR 
{
  DWORD        dwSize;
} NET_OUT_SPLIT_SET_TOUR;

// Get window tour status input parameter, corresponding to NET_SPLIT_OPERATE_GET_TOUR_STATUS
typedef struct tagNET_IN_SPLIT_GET_TOUR_STATUS
{
  DWORD        dwSize;
  int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char*     pszCompositeID;         //  cubeless video wall ID
  int         nWindow;            // window no., -1 means all window
} NET_IN_SPLIT_GET_TOUR_STATUS;

// tour status 
typedef enum tagNET_TOUR_STATUS
{
  NET_TOUR_UNKNOWN,                // unknown 
  NET_TOUR_START,                 // touring
  NET_TOUR_STOP,                 // tour stop
}NET_TOUR_STATUS;

// window tour status info 
typedef struct tagNET_WINDOW_TOUR_STATUS_INFO 
{
  DWORD        dwSize;
  int         nWindow;            // window no.
  NET_TOUR_STATUS   emStatus;            // status 
} NET_WINDOW_TOUR_STATUS_INFO;

// Get window tour status output parameter, corresponding to NET_SPLIT_OPERATE_GET_TOUR_STATUS
typedef struct tagNET_OUT_SPLIT_GET_TOUR_STATUS
{
  DWORD        dwSize;
  NET_WINDOW_TOUR_STATUS_INFO* pstuStatus;      // status info indicator, user allocation memory. search window no. is -1 means multi-window info group.
  int         nMaxStatusCount;        // status info max quantity, user input
  int         nRetStatusCount;        // status info actual quantity, search to get
} NET_OUT_SPLIT_GET_TOUR_STATUS;

// batch window input parameter, corresponding to NET_SPLIT_OPERATE_OPEN_WINDOWS
typedef struct tagNET_IN_SPLIT_OPEN_WINDOWS 
{
  DWORD        dwSize;
  int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char*     pszCompositeID;         //  cubeless video wall id
  int         nWindowNum;           // window quantity
  NET_RECT*      pstuWindowRects;        // window zone group
  BOOL        bDirectable;          // meet direct criteria 
} NET_IN_SPLIT_OPEN_WINDOWS;

// window info 
typedef struct tagNET_SPLIT_WINDOW_INFO
{
  DWORD        dwSize;
  int         nWindowID;           // window no.
  int         nZOrder;            // Z order
  char        szControlID[DH_DEV_ID_LEN];   // control no.
} NET_SPLIT_WINDOW_INFO;

// batch window output parameter, corresponding to NET_SPLIT_OPERATE_OPEN_WINDOWS
typedef struct tagNET_OUT_SPLIT_OPEN_WINDOWS 
{
  DWORD        dwSize;
  NET_SPLIT_WINDOW_INFO* pstuWindows;        // window info , user allocation memory
  int         nMaxWindowCount;        // window info max quantity, user input
  int         nRetWindowCount;        // window quantity
} NET_OUT_SPLIT_OPEN_WINDOWS;

// video split work mode 
typedef enum tagNET_SPLIT_WORK_MODE
{
  NET_SPLIT_WORK_MODE_UNKNOWN,            // unknown 
  NET_SPLIT_WORK_MODE_LOCAL,             // local normal mode 
  NET_SPLIT_WORK_MODE_REPLAY,             // playback mode 
}NET_SPLIT_WORK_MODE;

// setup work mode input parameter, corresponding to NET_SPLIT_OPERATE_SET_WORK_MODE
typedef struct tagNET_IN_SPLIT_SET_WORK_MODE 
{
  DWORD        dwSize;
  int         nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char*     pszCompositeID;         //  cubeless video wall ID
  NET_SPLIT_WORK_MODE emMode;             // work mode 
}NET_IN_SPLIT_SET_WORK_MODE;

// setup work mode output parameter, corresponding to NET_SPLIT_OPERATE_SET_WORK_MODE
typedef struct tagNET_OUT_SPLIT_SET_WORK_MODE 
{
  DWORD        dwSize;
}NET_OUT_SPLIT_SET_WORK_MODE;

// player type 
typedef enum tagNET_SPLIT_PLAYER_TYPE
{
  NET_SPLIT_PLAYER_TYPE_UNKNOWN,            // unknown 
  NET_SPLIT_PLAYER_TYPE_FILE_LIST,           // file list player
  NET_SPLIT_PLAYER_TYPE_FILE,             // file player
}NET_SPLIT_PLAYER_TYPE;

// Get player actual input parameter, corresponding to NET_SPLIT_OPERATE_GET_PLAYER
typedef struct tagNET_IN_SPLIT_GET_PLAYER
{
  DWORD         dwSize;
  int          nChannel;            // output channel no. or cubeless video wall virtual channel no., pszCompositeID is NULL is valid 
  const char*      pszCompositeID;         //  cubeless video wall ID
  NET_SPLIT_PLAYER_TYPE emType;             // player type 
  int          nWindow;            // player window no.
}NET_IN_SPLIT_GET_PLAYER;

// Get player actual output parameter, corresponding to NET_SPLIT_OPERATE_GET_PLAYER
typedef struct tagNET_OUT_SPLIT_GET_PLAYER
{
  DWORD         dwSize;
  LLONG         lPlayerID;           // player actual ID
}NET_OUT_SPLIT_GET_PLAYER;

// Window Working Mode
typedef enum tagNET_WM_WORK_MODE
{
    NET_WM_WORK_MODE_UNKNOWN,                             // Unknown
    NET_WM_WORK_MODE_DISPLAY,                             // Preview mode
    NET_WM_WORK_MODE_REPLAY,                              // Playback mode  
}NET_WM_WORK_MODE;

// Set window working mode input parameter, corresponding  NET_WM_OPERATE_SET_WORK_MODE
typedef struct tagNET_IN_WM_SET_WORK_MODE
{
    DWORD                 dwSize;
    int                   nChannel;                       // Output channel no. or cubeless video wall virtual channel no., when pszCompositeID is NULL. valid
    const char*           pszCompositeID;                 // Cubeless video wall ID
    int                   nWindow;                        // Window no.
    NET_WM_WORK_MODE      emMode;                         // Window working mode
}NET_IN_WM_SET_WORK_MODE;

//Set window working mode output parameter, corresponding  NET_WM_OPERATE_SET_WORK_MODE
typedef struct tagNET_OUT_WM_SET_WORK_MODE
{
    DWORD                 dwSize;
}NET_OUT_WM_SET_WORK_MODE;

// Get window woking mode input parameter, corresponding  NET_WM_OPERATE_GET_WORK_MODE
typedef struct tagNET_IN_WM_GET_WORK_MODE
{
    DWORD                 dwSize;
    int                   nChannel;                       // Output channel no. or cubeless virtual channel no., when pszCompositeID is NULL, valid
    const char*           pszCompositeID;                 // Cubeless video wall ID
    int                   nWindow;                        // Window no.
}NET_IN_WM_GET_WORK_MODE;

//Get window working mode output parameter, corresponding  NET_WM_OPERATE_GET_WORK_MODE
typedef struct tagNET_OUT_WM_GET_WORK_MODE
{
    DWORD                 dwSize;
    NET_WM_WORK_MODE      emMode;                         // Window working mode
}NET_OUT_WM_GET_WORK_MODE;

// Set window corridor mode input parameter, corresponding  NET_WM_OPERATE_SET_CORRIDOR_MODE
typedef struct tagNET_IN_WM_SET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// the value is the size of this struct
	int 				  nChannel;			// Output channel index or the virtual channel index of multi-screen display, it is valid when pszCompositeID =NULL
	const char* 		  pszCompositeID;	// Multi-screen display ID
	int 				  nWindow;			// window ID
	BOOL	  			  bIsCorridor;		// the corridor mode of the window(TRUE:open FALSE:close)
} NET_IN_WM_SET_CORRIDOR_MODE;

// Set window corridor mode output parameter, corresponding  NET_WM_OPERATE_SET_CORRIDOR_MODE
typedef struct tagNET_OUT_WM_SET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// the value is the size of this struct
} NET_OUT_WM_SET_CORRIDOR_MODE;


// Get window corridor mode input parameter, corresponding  NET_WM_OPERATE_GET_CORRIDOR_MODE
typedef struct tagNET_IN_WM_GET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// the value is the size of this struct
	int 				  nChannel;			// Output channel index or the virtual channel index of multi-screen display, it is valid when pszCompositeID =NULL
	const char* 		  pszCompositeID;	// Multi-screen display ID
	int 				  nWindow;			// window ID
} NET_IN_WM_GET_CORRIDOR_MODE;

// Get window corridor mode output parameter, corresponding  NET_WM_OPERATE_GET_CORRIDOR_MODE
typedef struct tagNET_OUT_WM_GET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// the value is the size of this struct
	BOOL	  			  bIsCorridor;		// the corridor mode of window(TRUE:open FALSE:close)
} NET_OUT_WM_GET_CORRIDOR_MODE;

// The input for close batch windows,  corresponding to NET_SPLIT_OPERATE_CLOSE_WINDOWS
typedef struct tagNET_IN_SPLIT_CLOSE_WINDOWS
{
    DWORD               dwSize;
    int                 nChannel;                       // Output channel index or the virtual channel index of multi-screen display, it is valid when pszCompositeID =NULL
    const char*         pszCompositeID;                 // Multi-screen display ID
    int*                pnWindows;                      // The pointer of windows index array 
    int                 nWindowCount;                   // The number of windows
} NET_IN_SPLIT_CLOSE_WINDOWS;

// Close windows operation result
typedef struct tagNET_SPLIT_CLOSE_WINDOW_RESULT 
{
    BOOL                bResult;                        // Result
    char                reserved[256];                  // Reserved bytes
} NET_SPLIT_CLOSE_WINDOW_RESULT ;

// The output parameters of Close batch windows, corresponding to NET_SPLIT_OPERATE_CLOSE_WINDOWS
typedef struct tagNET_OUT_SPLIT_CLOSE_WINDOWS
{
    DWORD               dwSize;
    NET_SPLIT_CLOSE_WINDOW_RESULT* pstuResults;         // Result array, memory assigned by users. Set to Null if no need the return
    int                 nMaxResultCount;                // The maximum of result array, filled in by user.
int                 nRetResultCount;                // The number of return result

} NET_OUT_SPLIT_CLOSE_WINDOWS;

//Êä³öÆÁÓãÑÛ½ÃÕýÄ£Ê½
typedef enum tagNET_WM_FISHEYE_CALIBRATE_MODE
{
    NET_WM_FISHEYE_CALIBRATE_MODE_UNKOWN ,            // Î´ÖªÄ£Ê½
    NET_WM_FISHEYE_CALIBRATE_MODE_CLOSE ,             // ¹Ø±ÕÓãÑÛËã·¨
    NET_WM_FISHEYE_CALIBRATE_MODE_ORIGINAL,           // Ô­Ê¼Ä£Ê½(Õý·½ÐÎ) ´øËõ·Å±ÈÀý
    NET_WM_FISHEYE_CALIBRATE_MODE_PANORAMA,           // 1P
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_ONE,       // 1P+1
    NET_WM_FISHEYE_CALIBRATE_MODE_DOUBLE_PANORAMA,    // 2P        
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_DOUBLE_PAN,     // 1+2p
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_THREEE,    // 1+3
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_THREEE,    // 1p+3
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_TWO,       // 1+2
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_FOUR,      // 1+4
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_FOUR,      // 1p+4
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_SIX,       // 1p+6
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_EIGHT,     // 1+8
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_EIGHT,     // 1P+8
}NET_WM_FISHEYE_CALIBRATE_MODE;

//ÓãÑÛ½ÃÕý´°¿ÚÇøÓò²ÎÊý
typedef struct tagNET_WM_FISH_EYE_REGION_PARAM
{
    int     nCoordinateX;         // ´°¿ÚÖÐÐÄ¶ÔÓ¦µ½Ô­Ê¼Ô²µÄºá×ø±ê
    int     nCoordinateY;         // ´°¿ÚÖÐÐÄ¶ÔÓ¦µ½Ô­Ê¼Ô²µÄºá×ø±ê×Ý×ø±ê
    int     nAngleH;              // ÒÔX¡¢YÎªÖÐÐÄ£¬Ð£ÕýÇøÓò·¶Î§µÄË®Æ½½Ç¶È
    int     nAngleV;              // ÒÔX¡¢YÎªÖÐÐÄ£¬Ð£ÕýÇøÓò·¶Î§µÄ´¹Ö±½Ç¶È
    int 	nAvailable;			  // ±íÊ¾ÊÇ·ñ¿ÉÓÃ
    BYTE    Reserved[124];        // ±£Áô×Ö½Ú
}NET_WM_FISH_EYE_REGION_PARAM;

#define MAX_FISH_EYE_REGION_NUM     9
//Ä£Ê½³õÊ¼»¯¸÷»­ÃæÐÅÏ¢,ÊÊÓÃÓÚÄ£Ê½ÇÐ»»»Ö¸´µ½ÉÏÒ»´ÎµÄ×´Ì¬
typedef struct tagNET_WM_SET_FISHEYE_INIT_PARAM
{
    BOOL                            bUseRegion;         // ÎªTRUEÊ±,Ê¹ÓÃÒÔÏÂ³ÉÔ±½øÐÐ³õÊ¼»¯£¬ÎªFALSEÊ±ÒÔÏÂ³ÉÔ±ÎÞÐ§
    int                             nCircular;          // »·ÐÎÆ«ÒÆ(ÓãÑÛÏÔÊ¾Ä£Ê½ÖÐ´øÔ­Ê¼Í¼Ê±ÓÐÒâÒå¡£Èç1+3¡¢1+8µÈÄ£Ê½µÄ1»­Ãæ)
    int                             nPanorama;          // È«¾°Æ«ÒÆ(ÓãÑÛÏÔÊ¾Ä£Ê½´øÈ«¾°Ê±ÓÐÒâÒå,Èç1P¡¢2PµÈÄ£Ê½)
	int                             nFishEyeRegionNum;  // ÓãÑÛ½ÃÕý´°¿ÚÇøÓò²ÎÊý¸öÊý(Êý×é¸öÊýµÈÓÚÊµ¼ÊµÄ½ÃÕýÄ£Ê½.Èç1+3£¬ÔòÓÐ4¸öÔªËØ)
    NET_WM_FISH_EYE_REGION_PARAM    stFishEyeRegions[MAX_FISH_EYE_REGION_NUM];    // ÓãÑÛ½ÃÕý´°¿ÚÇøÓò²ÎÊýÐÅÏ¢
    BYTE                            Reserved[1024];                       // ±£Áô×Ö½Ú
}NET_WM_SET_FISHEYE_INIT_PARAM;

//µç×ÓÔÆÌ¨Ëõ·ÅÒÆ¶¯²ÎÊý
typedef struct tagNET_WM_SET_FISHEYE_EPTZ_PARAM
{
	int 							nOptWayType;		// ²Ù×÷ÀàÐÍ(±íÊ¾ÓãÑÛÔÆÌ¨¿ØÖÆÊ±µÄarg1£¬±íÊ¾ÊÇÒÆ¶¯»¹ÊÇ·Å´ó)
	int 							nOptWinNum; 		// Ð¡´°¿ÚºÅ(µ±Ç°ÕýÔÚ²Ù×÷µÄÐ¡´°¿ÚºÅ)
	int 							nOptWayData;		// ²Ù×÷Êý¾Ý(±íÊ¾ÓãÑÛÔÆÌ¨¿ØÖÆÊ±µÄÊý¾Ý´óÐ¡¡£ºÍOptWayTypeÅäºÏÊ¹ÓÃ)
	BYTE                            Reserved[512];      // ±£Áô×Ö½Ú
}NET_WM_SET_FISHEYE_EPTZ_PARAM;


//ÉèÖÃÊä³öÆÁµÄÓãÑÛ½ÃÕý¹æÔòÊäÈë²ÎÊý, ¶ÔÓ¦NET_IN_WM_SET_FISH_EYE_PARAM
typedef struct tagNET_IN_WM_SET_FISH_EYE_PARAM
{
    DWORD                           dwSize;
    int                             nChannel;            // Êä³öÍ¨µÀºÅ»òÈÚºÏÆÁÐéÄâÍ¨µÀºÅ, pszCompositeIDÎªNULLÊ±ÓÐÐ§
    const char*                     pszCompositeID;      // ÈÚºÏÆÁID
    int                             nWindowID;           // ¶ÔÓ¦Êä³öÆÁµÄ´°¿ÚºÅ

    NET_FISHEYE_MOUNT_MODE          emMount;            // ÓãÑÛ°²×°Ä£Ê½
    NET_WM_FISHEYE_CALIBRATE_MODE   emCalibrate;        // ÓãÑÛ½ÃÕýÄ£Ê½
    NET_WM_SET_FISHEYE_INIT_PARAM   stInitParam;        // Ä£Ê½³õÊ¼»¯¸÷»­ÃæÐÅÏ¢   
    NET_WM_SET_FISHEYE_EPTZ_PARAM	stEPtzParam;		// µç×ÓÔÆÌ¨Ëõ·ÅÒÆ¶¯²ÎÊý
}NET_IN_WM_SET_FISH_EYE_PARAM;

//ÉèÖÃÊä³öÆÁµÄÓãÑÛ½ÃÕý¹æÔòÊä³ö²ÎÊý, ¶ÔÓ¦NET_OUT_WM_SET_FISH_EYE_PARAM
typedef struct tagNET_OUT_WM_SET_FISH_EYE_PARAM
{
    DWORD dwSize;
}NET_OUT_WM_SET_FISH_EYE_PARAM;


////////////////////////////////// System status////////////////////////////////////////

// CPU info
typedef struct tagDH_CPU_INFO
{
	DWORD				dwSize;
	int					nUsage;						// CPU usage
} DH_CPU_INFO;

// CPU status
typedef struct tagDH_CPU_STATUS
{
	DWORD				dwSize;
	BOOL				bEnable;					// Search succeeded or not
	int					nCount;						// CPU amount
	DH_CPU_INFO			stuCPUs[DH_MAX_CPU_NUM];	// CPU info
} DH_CPU_STATUS;

// Memory info
typedef struct tagDH_MEMORY_INFO
{
	DWORD				dwSize;
	DWORD				dwTotal;					// Total memory, M
	DWORD				dwFree;						// Free memory, M
} DH_MEMORY_INFO;

// Memory status
typedef struct tagDH_MEMORY_STATUS 
{
	DWORD				dwSize;
	BOOL				bEnable;					// Search succeeded or not
	DH_MEMORY_INFO		stuMemory;					// Memory info
} DH_MEMORY_STATUS;

// Fan info
typedef struct tagDH_FAN_INFO
{
	DWORD				dwSize;
	char				szName[DH_DEVICE_NAME_LEN];	// Name
	DWORD				nSpeed;						// Speed
} DH_FAN_INFO;

// Fan status
typedef struct tagDH_FAN_STATUS
{
	DWORD				dwSize;
	BOOL				bEnable;					// Search succeeded or not
	int					nCount;						// Fan amount
	DH_FAN_INFO			stuFans[DH_MAX_FAN_NUM];	// Fan status
} DH_FAN_STATUS;

// power current status type
typedef enum __EM_CURRENT_STATE_TYPE
{
    EM_CURRENT_STATE_UNKNOWN = 0,
    EM_CURRENT_STATE_OVER_CURRENT,                      // current too high
    EM_CURRENT_STATE_NORMAL,                            // current normal
    EM_CURRENT_STATE_UNDER_CURRENT,                     // current too low
}EM_CURRENT_STATE_TYPE;

// Power info
typedef struct tagDH_POWER_INFO
{
    DWORD               dwSize;
    BOOL                bPowerOn;                       // Power is on or not
    EM_CURRENT_STATE_TYPE emCurrentState;               // power current status
} DH_POWER_INFO;


// battery in-place status
typedef enum __EM_BATTERY_EXIST_STATE
{
    EM_BATTERY_EXIST_STATE_UNKNOWN = 0,
    EM_BATTERY_EXIST_STATE_EXIST,                       // battery in-place
    EM_BATTERY_EXIST_STATE_MISSING,                     // battery lost
}EM_BATTERY_EXIST_STATE;

// battery status
typedef enum __EM_BATTERY_STATE
{
	EM_BATTERY_STATE_UNKNOWN = 0,
	EM_BATTERY_STATE_NORMAL,							// normal power
	EM_BATTERY_STATE_LOW,								// low power
}EM_BATTERY_STATE;

// Battery Information 
typedef struct tagDH_BATTERY_INFO
{
    DWORD               dwSize;
    int                 nPercent;                       // Battery Capacity Percentage
    BOOL                bCharging;                      // Whether real charging 
    EM_BATTERY_EXIST_STATE emExistState;                // battery in-place status
	EM_BATTERY_STATE	emState;						// battery power status
} DH_BATTERY_INFO;

// Power status
typedef struct tagDH_POWER_STATUS
{
	DWORD				dwSize;
	BOOL				bEnable;					//Search succeeded or not
	int					nCount;						// Power amount
	DH_POWER_INFO		stuPowers[DH_MAX_POWER_NUM];// Power status
    int                 nBatteryNum;                        // Battery Number
    DH_BATTERY_INFO     stuBatteries[DH_MAX_BATTERY_NUM];   // Battery Status 
} DH_POWER_STATUS;

// Temperature info
typedef struct tagDH_TEMPERATURE_INFO
{
	DWORD				dwSize;
	char				szName[DH_DEVICE_NAME_LEN];	// Sensor name
	float				fTemperature;				// Temperature
} DH_TEMPERATURE_INFO;

//Temperature status
typedef struct tagDH_TEMPERATURE_STATUS
{
	DWORD				dwSize;
	BOOL				bEnable;							// Search succeeded or not
	int					nCount;								// Temperature  amount
	DH_TEMPERATURE_INFO	stuTemps[DH_MAX_TEMPERATURE_NUM];	// Temperature  info
} DH_TEMPERATURE_STATUS;

// System status
typedef struct tagDH_SYSTEM_STATUS
{
	DWORD				dwSize;
	DH_CPU_STATUS*		pstuCPU;					// CPU status
	DH_MEMORY_STATUS*	pstuMemory;					// Memory status
	DH_FAN_STATUS*		pstuFan;					// Fan status
	DH_POWER_STATUS*	pstuPower;					// Power status
	DH_TEMPERATURE_STATUS*	pstuTemp;				// Temperature  status
} DH_SYSTEM_STATUS;

// Corresponding CLIENT_QueryDevState() Interface's DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE Command Parameter 
// For Alarm Channel Status 
typedef enum tagNET_ALARM_CHANNEL_TYPE
{
    NET_ALARM_CHANNEL_TYPE_ALL,                             // All channels (including all of the following)
    NET_ALARM_CHANNEL_TYPE_ALARMIN,                         // Alarm input channel 
    NET_ALARM_CHANNEL_TYPE_ALARMOUT,                        // Alarm output channel 
    NET_ALARM_CHANNEL_TYPE_ALARMBELL,                       // Signal channel 
    NET_ALARM_CHANNEL_TYPE_EXALARMIN,                       // Extension module alarm input channel 
    NET_ALARM_CHANNEL_TYPE_EXALARMOUT,                      // Extension module and alarm output channel
}NET_ALARM_CHANNEL_TYPE;

typedef struct tagNET_CLIENT_ALARM_CHANNELS_STATE
{
    DWORD                       dwSize;
    NET_ALARM_CHANNEL_TYPE      emType;                     // The type of query alarm channel 	                                                                                                                                
    int                         nAlarmInCount;              // Alarm input number, specified by the user 
    int                         nAlarmInRetCount;           // The number of returned alarm input 
    BOOL*                       pbAlarmInState;             // Alarm state of input arrays, memory allocated by the user, each element represents a channel status, TRUE for input, FALSE for no input 
    int                         nAlarmOutCount;             // The number of alarm output,specified by the user 
    int                         nAlarmOutRetCount;          // The number of alarm output 
    BOOL*                       pbAlarmOutState;            // Alarm state of output arrays, memory allocated by the user, each element represents a channel status, TRUE for output, FALSE for no output 
    int                         nAlarmBellCount;            // Alarm Number,specified by the user 
    int                         nAlarmBellRetCount;         // Returned Alarm Number 
    BOOL*                       pbAlarmBellState;           // Alarm state array, allocate memory by the user, each element represents a channel status, TRUE for output, FALSE for no output
    int                         nExAlarmInCount;            // Extension module alarm input number, specified by the user 
    int                         nExAlarmInRetCount;         // The number of returned extension module alarm input 
    BOOL*                       pbExAlarmInState;           // Extension module alarm input state array¡ê?Memory allocated by the user, each element represents a channel status, TRUE for output, FALSE for no output 
    int*                        pnExAlarmInDestionation;    // The location of the extension module alarm input effective channels 
    int                         nExAlarmOutCount;           // Extension module alarm output number, specified by the user
    int                         nExAlarmOutRetCount;        // Extension module alarm output number 
    BOOL*                       pbExAlarmOutState;          // Extension module alarm output state array¡ê?Memory allocated by the user, each element represents a channel status, TRUE for output, FALSE for no output 
    int*                        pnExAlarmOutDestionation;   // The location of the extension module alarm output effective channels
}NET_CLIENT_ALARM_CHANNELS_STATE;


// the number of alarm keyboard connecting on a serial port
typedef struct tagNET_ALARMKEYBOARD_COUNT
{
    DWORD               dwSize;
    int                 nAlarmKeyboardCount;        // The number of alarm keyboard connected 
}NET_ALARMKEYBOARD_COUNT;

////////////////////////////////// screen control////////////////////////////////////////
// CLIENT_OpenSplitWindow's interface input param(open window)
typedef struct tagDH_IN_SPLIT_OPEN_WINDOW
{
	DWORD				dwSize;
	int					nChannel;					// channel no.
	DH_RECT				stuRect;					// windon position, 0~8192
	BOOL				bDirectable;				// coordinate whether meet the confitions
} DH_IN_SPLIT_OPEN_WINDOW;

// CLIENT_OpenSplitWindow's interface output param(open window)
typedef struct tagDH_OUT_SPLIT_OPEN_WINDOW
{
	DWORD				dwSize;
	unsigned int		nWindowID;					// window ID
	unsigned int		nZOrder;					// window order	
} DH_OUT_SPLIT_OPEN_WINDOW;

// CLIENT_CloseSplitWindow's interface input param(close window)
typedef struct tagDH_IN_SPLIT_CLOSE_WINDOW
{
	DWORD				dwSize;
	int					nChannel;					// channel ID
	UINT				nWindowID;					// window order
    const char*         pszCompositeID;             // multi-screen display ID
} DH_IN_SPLIT_CLOSE_WINDOW;

// CLIENT_CloseSplitWindow's interface output param(close window)
typedef struct tagDH_OUT_SPLIT_CLOSE_WINDOW
{
	DWORD				dwSize;
} DH_OUT_SPLIT_CLOSE_WINDOW;

// CLIENT_SetSplitWindowRect's interface input param(setting the window position)
typedef struct tagDH_IN_SPLIT_SET_RECT
{
	DWORD				dwSize;
	int					nChannel;					// channel ID
	UINT				nWindowID;					// window order
	DH_RECT				stuRect;					// window position, 0~8192
	BOOL				bDirectable;				//  coordinate whether meet the confitions
} DH_IN_SPLIT_SET_RECT;

// CLIENT_SetSplitWindowRect's interface output param(setting the window position)
typedef struct tagDH_OUT_SPLIT_SET_RECT
{
	DWORD				dwSize;
} DH_OUT_SPLIT_SET_RECT;

// CLIENT_GetSplitWindowRect's interface input param(get window position)
typedef struct tagDH_IN_SPLIT_GET_RECT
{
	DWORD				dwSize;
	int					nChannel;					// channel ID
	UINT				nWindowID;					// window ID
} DH_IN_SPLIT_GET_RECT;

// CLIENT_GetSplitWindowRect's interface output param(get window position)
typedef struct tagDH_OUT_SPLIT_GET_RECT
{
	DWORD				dwSize;	
	DH_RECT				stuRect;					// window position, 0~8192
} DH_OUT_SPLIT_GET_RECT;

// CLIENT_SetSplitWindowLevels's interface input param(setting window order)
typedef struct tagDH_IN_SPLIT_SET_TOP_WINDOW
{
	DWORD				dwSize;
	int					nChannel;					// channel ID
	int					nWindowID;					// windown ID
} DH_IN_SPLIT_SET_TOP_WINDOW;

// CLIENT_SetSplitWindowLevels's interface output param(setting window order)
typedef struct tagDH_OUT_SPLIT_SET_TOP_WINDOW
{
	DWORD				dwSize;
	DH_WND_ZORDER*		pZOders;					// window order array
	int					nMaxWndCount;				// window order array size
	int					nWndCount;					// count of returned window
} DH_OUT_SPLIT_SET_TOP_WINDOW;

// CLIENT_SetDisplayMode's interface input param(monitor wall display mode settings)
typedef struct tagDH_IN_WM_SET_DISPLAY_MODE 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszBlockID;					// block ID, NULL/""-all region
	int					nTVID;						// display unit ID, -1 means all unit
	UINT				nDisplayMode;				// display mode, 0-standard, 1-highlighting, 2-energy saving
} DH_IN_WM_SET_DISPLAY_MODE;

// CLIENT_SetDisplayMode's interface output param(monitor wall display mode settings)
typedef struct tagDH_OUT_WM_SET_DISPLAY_MODE
{
	DWORD				dwSize;
} DH_OUT_WM_SET_DISPLAY_MODE;

// all display unit in the area of the display mode
typedef struct tagDH_BLOCK_DISPLAY_MODE
{
	DWORD				dwSize;
	int*				pTVModes;					// TV display mode
	int					nMaxTVCount;				// max count of tV
	int					nRetTVCount;				// count of retTV
} DH_BLOCK_DISPLAY_MODE;

// CLIENT_GetDisplayMode's interface input param(get monitor wall display mode)
typedef struct tagDH_IN_WM_GET_DISPLAY_MODE 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszBlockID;					// block ID, NULL/""-means all
	int					nTVID;						// TV ID, -1 means all
} DH_IN_WM_GET_DISPLAY_MODE;

// CLIENT_GetDisplayMode's interface output param(get monitor wall display mode)
typedef struct tagDH_OUT_WM_GET_DISPLAY_MODE
{
	DWORD				dwSize;
	DH_BLOCK_DISPLAY_MODE* pBlockModes;				// display mode
	int					nMaxBlockCount;				// count of array
	int					nRetBlockCount;				// count of ret 
} DH_OUT_WM_GET_DISPLAY_MODE;

// CLIENT_PowerControl's interface input param(monitor wall power control)
typedef struct tagDH_IN_WM_POWER_CTRL 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszBlockID;					// block ID, NULL/""- means all
	int					nTVID;						// TV ID, -1 means all
	BOOL				bPowerOn;					// power on or not
} DH_IN_WM_POWER_CTRL;

// CLIENT_PowerControl's interface input param(monitor wall power control)
typedef struct tagDH_OUT_WM_POWER_CTRL
{
	DWORD				dwSize;
} DH_OUT_WM_POWER_CTRL;

// CLIENT_LoadMonitorWallCollection's interface input param(load monitor wall plans)
typedef struct tagDH_IN_WM_LOAD_COLLECTION 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszName;					// name of plan
} DH_IN_WM_LOAD_COLLECTION;

// CLIENT_LoadMonitorWallCollection's interface output param(load monitor wall plans)
typedef struct tagDH_OUT_WM_LOAD_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_WM_LOAD_COLLECTION;

// CLIENT_SaveMonitorWallCollection's interface input param(save monitor wall plans)
typedef struct tagDH_IN_WM_SAVE_COLLECTION 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszName;					// name pf plan
    const char*         pszControlID;               // control id
} DH_IN_WM_SAVE_COLLECTION;

// CLIENT_SaveMonitorWallCollection's interface output param(load monitor wall plans)
typedef struct tagDH_OUT_WM_SAVE_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_WM_SAVE_COLLECTION;

// CLIENT_RenameMonitorWallCollection's interface input param(plan rename)
typedef struct tagDH_IN_WM_RENAME_COLLECTION 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
	const char*			pszOldName;					// old name
	const char*			pszNewName;					// new name
} DH_IN_WM_RENAME_COLLECTION;

// CLIENT_RenameMonitorWallCollection's interface input param(plan rename)
typedef struct tagDH_OUT_WM_RENAME_COLLECTION
{
	DWORD				dwSize;
} DH_OUT_WM_RENAME_COLLECTION;

// infomation window areas
typedef struct tagDH_WINDOW_COLLECTION
{
	DWORD				dwSize;
	int					nWindowID;					// window ID
	BOOL				bWndEnable;					// enable
	DH_RECT				stuRect;					// rect, effect when free split mode
	BOOL				bDirectable;				// coordinate whether meet the conditions
	int					nZOrder;					// z order
	BOOL				bSrcEnable;					// source enable
	char				szDeviceID[DH_DEV_ID_LEN_EX]; // device ID
	int					nVideoChannel;				// video channel
	int					nVideoStream;				// video stream type
	int					nAudioChannel;				// audio channel
	int					nAudioStream;				// audio stream type
	int					nUniqueChannel;				// unique channel
} DH_WINDOW_COLLECTION;

// areas collection
typedef struct tagDH_BLOCK_COLLECTION 
{
	DWORD				dwSize;
	DH_SPLIT_MODE		emSplitMode;				// split mode
	DH_WINDOW_COLLECTION stuWnds[DH_MAX_SPLIT_WINDOW];// window info array
	int					nWndsCount;					// count of window
	char				szName[DH_DEVICE_NAME_LEN];	// favorites name
    int                  nScreen;                       // The output channel number, including the splicing screen 
    char                szCompositeID[DH_DEV_ID_LEN_EX]; //  splicing video wall ID
    DH_WINDOW_COLLECTION* pstuWndsEx;                   // Windows information array pointer, the memory assigned by user. Use when the size of stuWnds array is not enough.  
    int                  nMaxWndsCountEx;               // The maximum number of windows, filled by user. pstuWndsEx the muber of the array element.
    int                  nRetWndsCountEx;               // The number of return windows.
} DH_BLOCK_COLLECTION;

// TV wall display unit
typedef struct tagDH_MONITORWALL_OUTPUT 
{
    DWORD       dwSize;
    char        szDeviceID[DH_DEV_ID_LEN];     // device ID, local time is""
    int         nChannel;              // channel no.
    char        szName[DH_DEV_NAME_LEN];      // screen name 
} DH_MONITORWALL_OUTPUT;

// TV wall display block
typedef struct tagDH_MONITORWALL_BLOCK
{
  DWORD          dwSize;
  char          szName[DH_DEV_NAME_LEN];    // block name 
  char          szCompositeID[DH_DEV_ID_LEN];  //  splicing video wall ID
  char          szControlID[DH_DEV_ID_LEN];   // control ID
  int           nSingleOutputWidth;       // single display unit occupied grid column number
  int           nSingleOutputHeight;      // single display unit occupied grid row number
  DH_RECT         stuRect;            // zone coordinate
  DH_TSECT        stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // switch on time chart, first-dimension each element means sunday~saturday and holiday
  DH_MONITORWALL_OUTPUT* pstuOutputs;          // display unit data,  user allocation memory
  int           nMaxOutputCount;        // display unit group size,user fill in
  int           nRetOutputCount;        // return display unit quantity
} DH_MONITORWALL_BLOCK;

// tv wall config 
typedef struct tagDH_MONITORWALL 
{
  DWORD          dwSize;
  char          szName[DH_DEV_NAME_LEN];    // name 
  int           nGridLine;           // grid row
  int           nGridColume;          // grid column
  DH_MONITORWALL_BLOCK*  pstuBlocks;           // display block group, user allocation nmemory
  int           nMaxBlockCount;         // display zone group size, user fill in
  int           nRetBlockCount;         // return display block quantity
  BOOL          bDisable;            // disable or not, 0-tv wall is valid , 1-tv wall is invalid
  char          szDesc[DH_COMMON_STRING_256];  // tv wall description info 
} DH_MONITORWALL;


// plan of monitor wall
typedef struct tagDH_MONITORWALL_COLLECTION 
{
	DWORD				dwSize;
	char				szName[DH_DEVICE_NAME_LEN];	// name
	DH_BLOCK_COLLECTION	stuBlocks[DH_MAX_BLOCK_NUM];// area array
	int					nBlocksCount;				// area count
	char				szControlID[DH_DEV_ID_LEN_EX];	// control ID
    DH_MONITORWALL      stuMonitorWall;             // tv wall config 
} DH_MONITORWALL_COLLECTION;

// CLIENT_GetMonitorWallCollections's interface input param(get plan infomation of monitor wall)
typedef struct tagDH_IN_WM_GET_COLLECTIONS 
{
	DWORD				dwSize;
	int					nMonitorWallID;				// monitor wall ID
} DH_IN_WM_GET_COLLECTIONS;

// CLIENT_GetMonitorWallCollections's interface output param(get plan infomation of monitor wall)
typedef struct tagDH_OUT_WM_GET_COLLECTIONS 
{
	DWORD				dwSize;	
	DH_MONITORWALL_COLLECTION* pCollections;		// plan of monitor wall array
	int					nMaxCollectionsCount;		// array size
	int					nCollectionsCount;			// max count of plan
} DH_OUT_WM_GET_COLLECTIONS;

// CLIENT_GetSplitWindowsInfo's interface input param
typedef struct tagDH_IN_SPLIT_GET_WINDOWS 
{
	DWORD				dwSize;
	int					nChannel;					// channel
} DH_IN_SPLIT_GET_WINDOWS;

// CLIENT_GetSplitWindowsInfo's interface output param
typedef struct tagDH_OUT_SPLIT_GET_WINDOWS 
{
	DWORD				dwSize;
	DH_BLOCK_COLLECTION	stuWindows;					// channel
} DH_OUT_SPLIT_GET_WINDOWS;

// CLIENT_LoadSplitCollection's interface input param(load collection)
typedef struct tagDH_IN_SPLIT_LOAD_COLLECTION 
{
	DWORD				dwSize;
	int					nChannel;					// channel
	const char*			pszName;					// name
} DH_IN_SPLIT_LOAD_COLLECTION;

// CLIENT_LoadSplitCollection's interface output param(load collection)
typedef struct tagDH_OUT_SPLIT_LOAD_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_SPLIT_LOAD_COLLECTION;

// CLIENT_SaveSplitCollection's interface input param(save collection)
typedef struct tagDH_IN_SPLIT_SAVE_COLLECTION 
{
	DWORD				dwSize;
	int					nChannel;					// channle
	const char*			pszName;					// name
} DH_IN_SPLIT_SAVE_COLLECTION;

// CLIENT_SaveSplitCollection's interface input param(save collection)
typedef struct tagDH_OUT_SPLIT_SAVE_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_SPLIT_SAVE_COLLECTION;

// CLIENT_RenameSplitCollection's interface input param(collection rename)
typedef struct tagDH_IN_SPLIT_RENAME_COLLECTION 
{
	DWORD				dwSize;
	int					nChannel;					// channel
	const char*			pszOldName;					// old name
	const char*			pszNewName;					// new name
} DH_IN_SPLIT_RENAME_COLLECTION;

// CLIENT_RenameSplitCollection's interface output param(collection rename)
typedef struct tagDH_OUT_SPLIT_RENAME_COLLECTION
{
	DWORD				dwSize;
} DH_OUT_SPLIT_RENAME_COLLECTION;

// CLIENT_GetSplitCollections's interface input param(get infomation of favorites)
typedef struct tagDH_IN_SPLIT_GET_COLLECTIONS 
{
	DWORD				dwSize;
	int					nChannel;					// channel
} DH_IN_SPLIT_GET_COLLECTIONS;

// CLIENT_GetSplitCollections's interface output param(get infomation of favorites)
typedef struct tagDH_OUT_SPLIT_GET_COLLECTIONS 
{
	DWORD				dwSize;	
	DH_BLOCK_COLLECTION* pCollections;				// array
	int					nMaxCollectionsCount;		// size
	int					nCollectionsCount;			// count
} DH_OUT_SPLIT_GET_COLLECTIONS;

// CLIENT_DeleteSplitCollection's interface input param(delete favorites)
typedef struct tagDH_IN_SPLIT_DELETE_COLLECTION 
{
	DWORD				dwSize;
	int					nChannel;					// channel
	const char**		ppszNames;					// array of favorites name
	int					nNameCount;					// size of array
} DH_IN_SPLIT_DELETE_COLLECTION;

// CLIENT_DeleteSplitCollection's interface input param(delete favorites)
typedef struct tagDH_OUT_SPLIT_DELETE_COLLECTION 
{
	DWORD				dwSize;
} DH_OUT_SPLIT_DELETE_COLLECTION;

// composite screen channel information
typedef struct tagDH_COMPOSITE_CHANNEL
{
	DWORD				dwSize;
	char				szMonitorWallName[DH_DEVICE_NAME_LEN];	// monitor wall name
	char				szCompositeID[DH_DEV_ID_LEN_EX];		// composite ID
	int					nVirtualChannel;						// virtual channel
} DH_COMPOSITE_CHANNEL;

// tour enable configuration
typedef struct tagDHDEV_TOUR_ENABLE
{
	DWORD				dwSize;
	BOOL				bEnable;					// enable
	BOOL				bStart;						// is touring or not(read only). bStart=FALSE when tour is able but doesn't set
} DHDEV_TOUR_ENABLE_CFG;

// CLIENT_SetDecodePolicy's interface input param(set the decoding policy)
typedef struct tagDH_IN_SET_DEC_POLICY 
{
	DWORD				dwSize;
	int					nChannel;			// channel
	int					nWindow;			// window no., -1 means all
	int					nPolicyLevel;		// policy level, a total of 5 file(-2, -1, 0, 1, 2), the greater the vale ,the bigger the fluid but delay
											// -2 real-time good, 2 fluency good, 0 default
} DH_IN_SET_DEC_POLICY;

// CLIENT_SetDecodePolicy's interface output param(set the decoding policy)
typedef struct tagDH_OUT_SET_DEC_POLICY 
{
	DWORD				dwSize;
} DH_OUT_SET_DEC_POLICY;

// CLIENT_GetDecodePolicy's interface input param(get the decoding policy)
typedef struct tagDH_IN_GET_DEC_POLICY 
{
	DWORD				dwSize;
	int					nChannel;			// channel
	int					nWindow;			// window ID, -1 means all
} DH_IN_GET_DEC_POLICY;

// CLIENT_GetDecodePolicy's interface output param(get the decoding policy)
typedef struct tagDH_OUT_GET_DEC_POLICY 
{
	DWORD				dwSize;
	int					nPolicyLevel;		// policy level, a total of 5 file(-2, -1, 0, 1, 2), the greater the vale ,the bigger the fluid but delay
											// -2 real-time good, 2 fluency good, 0 default
} DH_OUT_GET_DEC_POLICY;

// audio output mode
typedef enum
{
	DH_AUDIO_AUTO,							// automatic switch
	DH_AUDIO_DISABLE,						// all output disable 
	DH_AUDIO_FORCE,							// mandatory audio output to the user to specify a window
    DH_AUDIO_ENABLE_ONE,                        // Open the audio of target window, multi-channel of audio output is available    
    DH_AUDIO_DISABLE_ONE,                       //Close the audio of target window, multi-channel of audio output is available    
    DH_AUDIO_MULTI,                             // Multi-channel of audio output, be used when inquire not setting
} DH_AUDIO_OUTPUT_MODE;

// CLIENT_SetSplitAudioOuput's interface input param(set mode of audio output)
typedef struct tagDH_IN_SET_AUDIO_OUTPUT 
{
	DWORD				dwSize;
	int					nChannel;			// channel ID
	DH_AUDIO_OUTPUT_MODE emMode;			// mode
	int					nWindow;			// window no. , effect when emMode = DH_AUDIO_FORCE
} DH_IN_SET_AUDIO_OUTPUT;

// CLIENT_SetSplitAudioOuput's interface output param(set mode of audio output)
typedef struct tagDH_OUT_SET_AUDIO_OUTPUT
{
	DWORD				dwSize;
} DH_OUT_SET_AUDIO_OUTPUT;

// CLIENT_GetSplitAudioOuput's interface input param(get mode of audio output)
typedef struct tagDH_IN_GET_AUDIO_OUTPUT
{
	DWORD				dwSize;
	int					nChannel;			// channel ID
} DH_IN_GET_AUDIO_OUTPUT;

// CLIENT_GetSplitAudioOuput's interface output param(get mode of audio output)
typedef struct tagDH_OUT_GET_AUDIO_OUTPUT
{
	DWORD				dwSize;
	DH_AUDIO_OUTPUT_MODE emMode;			// mode of audio output
	int					nWindow;			// window no., effect when emMode = DH_AUDIO_FORCE
    int*                 pMultiWindows;         // The list of output windows number, valid when emMode = DH_AUDIO_MULTI, user assign the memory
    int                  nMaxMultiWindowCount;  // ouput the maximum number of window list, filled by user
    int                  nRetMultiWindowCount;  // Output the number of windows, effect  when  emMode=DH_AUDIO_MULTI
} DH_OUT_GET_AUDIO_OUTPUT;

// CLIENT_GetEncodePlan's interface output param(access to burn a CD to yer coding parameters)
typedef struct tagDH_IN_GET_ENCODE_PLAN
{
	DWORD				dwSize;
	unsigned int        nChannel;          // channel
	unsigned int        nExpectTime;       // expect time,int(min)
	unsigned int        nCapacity;         // capacity,int(M)
}DH_IN_GET_ENCODE_PLAN;
// CLIENT_GetEncodePlan's interface output param(access to burn a CD to yer coding parameters)
typedef struct tagDH_OUT_GET_ENCODE_PLAN
{
	DWORD				dwSize;
	int                 nResolutionType;    // emResolutionTypes counts
	CAPTURE_SIZE        emResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// the scope of video resolution
	CAPTURE_SIZE        emResolution;       // the recommended video resolution
	unsigned int        nBitRate;           // bit rate
}DH_OUT_GET_ENCODE_PLAN;

// organization directory logical objects
typedef struct tagDH_ORGANIZATION_NODE_LOGIC_OBJECT 
{
	DWORD				dwSize;
	char				szName[DH_NODE_NAME_LEN];	// name
	char				szType[DH_DEV_TYPE_LEN];	// type
	char				szDevID[DH_DEV_ID_LEN_EX];	// deviceID
	char				szControlID[DH_DEV_ID_LEN_EX]; // control ID, read only
	int					nChannel;					// channel
} DH_ORGANIZATION_NODE_LOGIC_OBJECT;

// organization directory
typedef struct tagDH_ORGANIZATION_NODE_DIRECTORY
{
	DWORD				dwSize;
	char				szName[DH_NODE_NAME_LEN];		// name
	char				szControlID[DH_DEV_ID_LEN_EX];	// control ID
} DH_ORGANIZATION_NODE_DIRECTORY;

// info of organization directory node
typedef struct tagDH_ORGANIZATION_NODE 
{
	DWORD				dwSize;
	int					nNodeType;						// node type, 0-logical objects, 1-list
	DH_ORGANIZATION_NODE_LOGIC_OBJECT	stuLogicObject;	// logical object, effective when nNodeType==0
	DH_ORGANIZATION_NODE_DIRECTORY		stuDirectory;	// list,effective when nNodeType==1		
} DH_ORGANIZATION_NODE;

// add node param
typedef struct tagDH_ORGANIZATION_ADD_NODE_PARAM
{
	DWORD				dwSize;
	int					nPosition;					// position, -1-start, -2-end, 0~n
	DH_ORGANIZATION_NODE stuNode;					// info of node
} DH_ORGANIZATION_ADD_NODE_PARAM;

// CLIENT_OrganizationAddNodes's interface input param(add node)
typedef struct tagDH_IN_ORGANIZATION_ADD_NODES
{
	DWORD				dwSize;
	char*				pszPath;					// path
	DH_ORGANIZATION_ADD_NODE_PARAM* pstuNodes;		// node pointer
	int					nNodeCount;					// count of node
} DH_IN_ORGANIZATION_ADD_NODES;

// result of added node
typedef struct tagDH_ORGANIZATION_ADD_NODE_RESULT
{
	DWORD				dwSize;
	BOOL				bResult;					// result
	char				szPath[MAX_PATH];			// path, return node path when succeed,return add node path when failed
} DH_ORGANIZATION_ADD_NODE_RESULT;

// CLIENT_OrganizationAddNodess interface output param(add node)
typedef struct tagDH_OUT_ORGANIZATION_ADD_NODES
{
	DWORD				dwSize;
	DH_ORGANIZATION_ADD_NODE_RESULT* pstuResults;	// result pointer
	int					nMaxResultCount;			// size of result
	int					nRetResultCount;			// count of result
} DH_OUT_ORGANIZATION_ADD_NODES;

// node path
typedef struct tagDH_ORGANIZATION_NODE_PATH 
{
	DWORD				dwSize;
	char				szPath[MAX_PATH];			// path
} DH_ORGANIZATION_NODE_PATH;

// CLIENT_OrganizationDeleteNodes's interface input param(delete node)
typedef struct tagDH_IN_ORGANIZATION_DELETE_NODES
{
	DWORD				dwSize;
	DH_ORGANIZATION_NODE_PATH*	pstuPath;			// path array
	int					nPathCount;					// count
} DH_IN_ORGANIZATION_DELETE_NODES;

// CLIENT_OrganizationDeleteNodes's interface output param(delete node)
typedef struct tagDH_OUT_ORGANIZATION_DELETE_NODES 
{
	DWORD				dwSize;
} DH_OUT_ORGANIZATION_DELETE_NODES;

// CLIENT_OrganizationGetNodes's interface input param(get node info)
typedef struct tagDH_IN_ORGANIZATION_GET_NODES 
{
	DWORD				dwSize;
	char*				pszPath;					// path
	int					nLevel;						// level, 0-the level, 1-next level
} DH_IN_ORGANIZATION_GET_NODES;

// CLIENT_OrganizationGetNodes's interface output param(get node info)
typedef struct tagDH_OUT_ORGANIZATION_GET_NODES 
{
	DWORD				dwSize;
	DH_ORGANIZATION_NODE*	pstuNodes;				// node array
	int					nMaxNodeCount;				// size of array
	int					nRetNodeCount;				// count of node count
} DH_OUT_ORGANIZATION_GET_NODES;

// CLIENT_OrganizationSetNode's interface input param(get node info)
typedef struct tagDH_IN_ORGANIZATION_SET_NODE 
{
	DWORD				dwSize;
	char*				pszPath;					// path
	DH_ORGANIZATION_NODE stuNode;					// node info
} DH_IN_ORGANIZATION_SET_NODE;

// CLIENT_OrganizationSetNode's interface output param(set node)
typedef struct tagDH_OUT_ORGANIZATION_SET_NODE 
{
	DWORD				dwSize;
} DH_OUT_ORGANIZATION_SET_NODE;

// channel info of video input
typedef struct tagDH_VIDEO_INPUTS
{
	DWORD				dwSize;
	char				szChnName[DH_DEVICE_NAME_LEN];		// channel name
	BOOL				bEnable;							// enable
	char				szControlID[DH_DEV_ID_LEN_EX];		// control ID
	char				szMainStreamUrl[MAX_PATH];			// main stream url 
	char				szExtraStreamUrl[MAX_PATH];			// extra stream url
    int                 nOptionalMainUrlCount;              // spare main stream address quantity
    char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // spare main stream address list
    int                 nOptionalExtraUrlCount;             // spare sub stream address quantity
    char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // spare substream address list
} DH_VIDEO_INPUTS;

typedef struct tagDH_REMOTE_DEVICE 
{
	DWORD				dwSize;
	BOOL				bEnable;							// enable
	char			    szIp[DH_MAX_IPADDR_LEN];		    // IP
	char			    szUser[DH_USER_NAME_LENGTH];	    // username
	char			    szPwd[DH_USER_PSW_LENGTH];	    	// password
	int			    	nPort;							    // port
	int				    nDefinition;					    // definition. 0-standard definition, 1-high definition
	DH_DEVICE_PROTOCOL  emProtocol;							// protocol type
	char			    szDevName[DH_DEVICE_NAME_LEN];		// device name
	int					nVideoInputChannels;				// count channel of video input
	int					nAudioInputChannels;				// count channel of audio input
	char				szDevClass[DH_DEV_TYPE_LEN];		// device type, such as IPC, DVR, NVR
	char				szDevType[DH_DEV_TYPE_LEN];			// device type, such as IPC-HF3300
	int					nHttpPort;							// Http port
	int					nMaxVideoInputCount;				// max count of video input
	int					nRetVideoInputCount;				// return count
	DH_VIDEO_INPUTS*	pstuVideoInputs;					// max count of audion input
	char				szMachineAddress[DH_MAX_CARD_INFO_LEN];	// machine address
	char				szSerialNo[DH_SERIALNO_LEN];		// serial no.
    int                 nRtspPort;                          // Rtsp Port

	/*use to new plaform for extension*/
	char                szUserEx[DH_USER_NAME_LEN_EX];       // username
    char                szPwdEx[DH_USER_PSW_LEN_EX];         // password
} DH_REMOTE_DEVICE;

typedef enum tagNET_LOGIC_CHANNEL_TYPE
{
    LOGIC_CHN_UNKNOWN,              // Unknow
    LOGIC_CHN_LOCAL,                // Local channel 
    LOGIC_CHN_REMOTE,               // Remote access channel 
    LOGIC_CHN_COMPOSE,              // Synthesis of channel, for the judicial equipment contains picture in picture channel and mixing channel
    LOGIC_CHN_MATRIX,               // matrix channel¡ê?including analog matrix and digital matrix
    LOGIC_CHN_CASCADE,              // cascading channel
} NET_LOGIC_CHN_TYPE;

// available according to the source of information
typedef struct tagDH_MATRIX_CAMERA_INFO
{
	DWORD				dwSize;
	char				szName[DH_DEV_ID_LEN_EX];		// name
	char				szDevID[DH_DEV_ID_LEN_EX];		// device ID
	char				szControlID[DH_DEV_ID_LEN_EX];	// control ID
	int					nChannelID;						// channel ID, DeviceID is unique
	int					nUniqueChannel;					// unique channel
	BOOL				bRemoteDevice;					// support remote device or not
	DH_REMOTE_DEVICE	stuRemoteDevice;				// info of remote device
	NET_STREAM_TYPE     emStreamType;                   // stream type
    NET_LOGIC_CHN_TYPE  emChannelType;                      // Channel Types 
} DH_MATRIX_CAMERA_INFO;

// CLIENT_MatrixGetCameras's interface input param
typedef struct tagDH_IN_MATRIX_GET_CAMERAS 
{
	DWORD				dwSize;
} DH_IN_MATRIX_GET_CAMERAS;

// CLIENT_MatrixGetCameras's interface output param
typedef struct tagDH_OUT_MATRIX_GET_CAMERAS 
{
	DWORD				dwSize;
	DH_MATRIX_CAMERA_INFO* pstuCameras;					// array
	int					nMaxCameraCount;				// size of source array
	int					nRetCameraCount;				// return count
} DH_OUT_MATRIX_GET_CAMERAS;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO inquire  the input parameters of remote device information 
typedef struct tagNET_IN_GET_DEVICE_INFO
{
    DWORD                       dwSize;                                         // when this structure be used¡ê?dwSize assigned to sizeof(NET_IN_GET_DEVICE_INFO)
    char                        szDevice[DH_DEV_ID_LEN_EX];                 // Device ID
    // Device attribute¡ê?when szDevice is null¡ê?the following do effect
    char                        szAttributeIP[DH_COMMON_STRING_32];             // device address
    int                         nAttributePort;                                 // device port
    char                        szAttributeUsername[DH_COMMON_STRING_128];      // user name
    char                        szAttributePassword[DH_COMMON_STRING_128];      // password
    char                        szAttributeManufacturer[DH_COMMON_STRING_128];  // manufacturer protocl
}NET_IN_GET_DEVICE_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO inquire the output parameter of remote device information 
typedef struct tagNET_OUT_GET_DEVICE_INFO
{
    DWORD                       dwSize;         // When this structure is used, dwSize should be assigned to sizeof(NET_OUT_GET_DEVICE_INFO)
DH_REMOTE_DEVICE            stuInfo;        // Device information, the member of this structur,  dwSize, should be assigned by user
}NET_OUT_GET_DEVICE_INFO;

// CLIENT_MatrixSetCameras's interface input param
typedef struct tagDH_IN_MATRIX_SET_CAMERAS 
{
	DWORD				dwSize;
	DH_MATRIX_CAMERA_INFO* pstuCameras;					// array
	int					nCameraCount;				    // size of source array
} DH_IN_MATRIX_SET_CAMERAS;

// CLIENT_MatrixSetCameras's interface output param
typedef struct tagDH_OUT_MATRIX_SET_CAMERAS 
{
	DWORD				dwSize;
} DH_OUT_MATRIX_SET_CAMERAS;

// source of window display info 
typedef struct tagDH_SPLIT_WND_SOURCE 
{
	DWORD				dwSize;
	BOOL				bEnable;						// enable
	char				szDeviceID[DH_DEV_ID_LEN];		// device ID
	char				szControlID[DH_DEV_ID_LEN];		// control ID
	int					nVideoChannel;					// video channel ID
	int					nVideoStream;					// video stream type
	int					nAudioChannel;					// audio channel ID
	int					nAudioStream;					// audio stream type
	int					nUniqueChannel;					// unique channel,read only
	BOOL				bRemoteDevice;					// support remote device
	DH_REMOTE_DEVICE	stuRemoteDevice;				// info of remote device
} DH_SPLIT_WND_SOURCE;

// info of split window
typedef struct tagDH_SPLIT_WINDOW 
{
	DWORD				dwSize;
	BOOL				bEnable;						// enable
	int					nWindowID;						// window ID
	char				szControlID[DH_DEV_ID_LEN];		// control ID
	DH_RECT				stuRect;						// rect of window, effective when free split
	BOOL				bDirectable;					// coordinate whether meet the conditions
	int					nZOrder;						// Z order
	DH_SPLIT_WND_SOURCE stuSource;						// source info
} DH_SPLIT_WINDOW;

// split scene
typedef struct tagDH_SPLIT_SCENE 
{
	DWORD				dwSize;
	char				szCompositeID[DH_DEV_ID_LEN];	// composite ID
	char				szControlID[DH_DEV_ID_LEN];		// control ID
	DH_SPLIT_MODE		emSplitMode;					// split mode
	DH_SPLIT_WINDOW*	pstuWnds;						// info of array
	int					nMaxWndCount;					// size of array
	int					nRetWndCount;					// return count
} DH_SPLIT_SCENE;

// monitor wall scene
typedef struct tagDH_MONITORWALL_SCENE
{
	DWORD				dwSize;
	char				szName[DH_DEV_NAME_LEN];		// name of plan
	char				szControlID[DH_DEV_ID_LEN];		// control ID
	DH_MONITORWALL		stuMonitorWall;					// monitor wall configuration	
	DH_SPLIT_SCENE*		pstuSplitScene;					// array of split scene
	int					nMaxSplitSceneCount;			// size of array
	int					nRetSplitSceneCount;			// return count
} DH_MONITORWALL_SCENE;

// CLIENT_MonitorWallGetScene's interface input param(get monitor wall scene)
typedef struct tagDH_IN_MONITORWALL_GET_SCENE 
{
	DWORD				dwSize;
	int					nMonitorWallID;					// monitor wall ID
} DH_IN_MONITORWALL_GET_SCENE;

// CLIENT_MonitorWallGetScene's interface output param(get monitor wall scene)
typedef struct tagDH_OUT_MONITORWALL_GET_SCENE 
{
	DWORD				dwSize;
	char				szName[DH_DEV_NAME_LEN];		// name of plan, can be null
	DH_MONITORWALL_SCENE stuScene;						// minotor wall scene
} DH_OUT_MONITORWALL_GET_SCENE;

// CLIENT_MonitorWallSetScene's interface input param(set monitor wall scene)
typedef struct tagDH_IN_MONITORWALL_SET_SCENE 
{
	DWORD				dwSize;
	int					nMonitorWallID;					// TV Wall No. 
	DH_MONITORWALL_SCENE stuScene;						// TV Wall Scene
} DH_IN_MONITORWALL_SET_SCENE;

// CLIENT_MonitorWallSetScene's interface output param(set monitor wall scene)
typedef struct tagDH_OUT_MONITORWALL_SET_SCENE 
{
	DWORD				dwSize;
} DH_OUT_MONITORWALL_SET_SCENE;

//CLIENT_QueryNetStat Port, input parameter when the Types of queries is NET_APP_DATA_STAT (statistics for protocol stack) 
typedef struct tagNET_IN_NETAPP_NET_DATA_STAT
{
    DWORD       dwSize;    
    char        szEthName[DH_MAX_ETH_NAME];                // The network card name
}NET_IN_NETAPP_NET_DATA_STAT;

//Receive relevant statistics, same meaning with the ifconfig 
typedef struct tagNET_NETAPP_RECEIVE_STAT
{
    DWORD        dwSize;
    DWORD        dwPackets;
    DWORD        dwBytes;
    DWORD        dwErrors;
    DWORD        dwDroped;
    DWORD        dwOverruns;
    DWORD        dwFrame;
}NET_NETAPP_RECEIVE_STAT;

//Transport statistics,same meaning with the ifconfig 
typedef struct tagNET_NETAPP_TRANSMIT_STAT
{
    DWORD        dwSize;
    DWORD        dwPackets;
    DWORD        dwBytes;
    DWORD        dwErrors;
    DWORD        dwDroped;
    DWORD        dwOverruns;
    DWORD        dwCarrier;
    DWORD        dwCollisions;
    DWORD        dwTxQueue;
}NET_NETAPP_TRANSMIT_STAT;

//CLIENT_QueryNetStat Port, output parameter when the Types of queries is NET_APP_DATA_STAT (statistics for protocol stack) 
typedef struct tagNET_OUT_NETAPP_NET_DATA_STAT
{                    
    DWORD                        dwSize;
    NET_NETAPP_RECEIVE_STAT      stuReceiveStat;        // Receive relevant statistics,same meaning with the ifconfig 
    NET_NETAPP_TRANSMIT_STAT     stuTransmitStat;       // Transport statistics,same meaning with the ifconfig 
    int                          nSpeed;                // Network speed¡ê?unit is Mbps
}NET_OUT_NETAPP_NET_DATA_STAT;

//CLIENT_QueryNetStatPort, input parameter when the Types of queries is NET_APP_DATA_STAT(access to physical link state)
typedef struct tagNET_IN_NETAPP_LINK_STATUS
{
    DWORD       dwSize;
    char        szEthName[DH_MAX_ETH_NAME];             // Network Card Name 
}NET_IN_NETAPP_LINK_STATUS;

//CLIENT_QueryNetStatPort, output parameter when the Types of queries is NET_APP_DATA_STAT(access to physical link state)
typedef struct tagNET_OUT_NETAPP_LINK_STATUS
{
    DWORD       dwSize;
    BOOL        bWorking;               // Whether working  
    BOOL        bIPConflict;            // Whether IP conflict 
}NET_OUT_NETAPP_LINK_STATUS;

// type of input signal
#define DH_VIDEO_SIGNAL_CVBS	0x0001
#define DH_VIDEO_SIGNAL_SDI		0x0002
#define DH_VIDEO_SIGNAL_VGA		0x0004 
#define DH_VIDEO_SIGNAL_DVI		0x0008
#define DH_VIDEO_SIGNAL_HDMI	0x0010 
#define DH_VIDEO_SIGNAL_YPBPR	0x0020 
#define DH_VIDEO_SIGNAL_SFP		0x0040 
#define DH_VIDEO_SIGNAL_HDCVI       0x0080 
#define DH_VIDEO_SIGNAL_DUAL_LINK   0x0100 

// caps of video inpt
typedef struct tagDH_VIDEO_IN_CAPS 
{
	DWORD					dwSize;
	DWORD					dwSignalType;				// type of signal in
	BOOL					bAutoFocusPeak;				// support auto focus peak or not
	BOOL					bElectricFocus;				// support electric focus or not
	BOOL					bSyncFocus;					// support sync focus
    BOOL                    bSetColor;                  // if support video color setup
    BOOL                    bGain;                      // support gain control or not
    BOOL                    bPhase;                     // support phase control or not
} DH_VIDEO_IN_CAPS;

// CLIENT_GetVideoInCaps's interface input param
typedef struct tagDH_IN_GET_VIDEO_IN_CAPS 
{
	DWORD			dwSize;
	int				nChannel;							// channel ID of video in
} DH_IN_GET_VIDEO_IN_CAPS;

// CLIENT_GetVideoInCaps's interface output param
typedef struct tagDH_OUT_GET_VIDEO_IN_CAPS 
{
	DWORD			dwSize;
	DH_VIDEO_IN_CAPS stuCaps;							// ability
} DH_OUT_GET_VIDEO_IN_CAPS;

// mode of video out
typedef struct tagDH_VIDEO_OUT_MODE 
{
	DWORD			dwSize;
	int				nWidth;								// horizontal resolution
	int				nHeight;							// vertical resolution
	int				nBPP;								// color depth
	int				nFormat;							// format of signel out, 0-Auto, 1-TV, 2-VGA, 3-DVI
	int				nRefreshRate;						// refersh rate
	int				nPhysicalPort;						// physical port, VGA, TV, DVI independent number
    int              nScanFormat;                       // Scanning mode, 0 - line by line, 1 - interlaced 
} DH_VIDEO_OUT_MODE;

// CLIENT_EnumVideoOutModes's interface input param
typedef struct tagDH_IN_ENUM_VIDEO_OUT_MODES 
{
	DWORD			dwSize;
	int				nChannel;
} DH_IN_ENUM_VIDEO_OUT_MODES;

// CLIENT_EnumVideoOutModes's interface output param
typedef struct tagDH_OUT_ENUM_VIDEO_OUT_MODES 
{
	DWORD			dwSize;
	DH_VIDEO_OUT_MODE* pstuModes;						// mode array
	int				nMaxModeCount;						// count of mode
	int				nRetModeCount;						// return count
} DH_OUT_ENUM_VIDEO_OUT_MODES;

// minotor wall attribute type
typedef enum tagDH_OUTPUT_ATTRIBUTE_TYPE
{
	DH_OUTPUT_ATTRIBUTE_VIDEO, 
	DH_OUTPUT_ATTRIBUTE_YPBPR, 
	DH_OUTPUT_ATTRIBUTE_VGA, 
	DH_OUTPUT_ATTRIBUTE_DVI, 
	DH_OUTPUT_ATTRIBUTE_MENU, 
} DH_OUTPUT_ATTRIBUTE_TYPE;

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) Video ability
#define	DH_ATTR_VIDEO_BRIGHTNESS	0X00000001
#define	DH_ATTR_VIDEO_CONTRAST		0X00000002
#define	DH_ATTR_VIDEO_SATURATION	0X00000004
#define	DH_ATTR_VIDEO_SHAPENESS		0X00000008
#define	DH_ATTR_VIDEO_DENOISE		0X00000010

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) YPbPr ability
#define	DH_ATTR_YPBPR_BRIGHTNESS	0X00000001
#define	DH_ATTR_YPBPR_CONTRAST		0X00000002
#define	DH_ATTR_YPBPR_SATURATION	0X00000004
#define	DH_ATTR_YPBPR_SHAPENESS		0X00000008
#define	DH_ATTR_YPBPR_DENOISE		0X00000010

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) VGA ability
#define	DH_ATTR_VGA_BRIGHTNESS		0X00000001
#define	DH_ATTR_VGA_CONTRAST		0X00000002
#define	DH_ATTR_VGA_HORPOSITION		0X00000004
#define	DH_ATTR_VGA_VERPOSITION		0X00000008
#define	DH_ATTR_VGA_CLOCK			0X00000010

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) DVI ability
#define	DH_ATTR_DVI_BRIGHTNESS		0X00000001
#define	DH_ATTR_DVI_CONTRAST		0X00000002
#define	DH_ATTR_DVI_HORPOSITION		0X00000004
#define	DH_ATTR_DVI_VERPOSITION		0X00000008
#define	DH_ATTR_DVI_CLOCK			0X00000010

// caps of monitor wall adjust (DH_OUTPUT_ATTRIBUTE_CAPS) Menu ability
#define	DH_ATTR_MENU_MENU			0X00000001
#define	DH_ATTR_MENU_UP				0X00000002
#define	DH_ATTR_MENU_DOWN			0X00000004
#define	DH_ATTR_MENU_LEFT			0X00000008
#define	DH_ATTR_MENU_RIGHT			0X00000010
#define	DH_ATTR_MENU_FACTORYMENU	0X00000020

// caps of monitor wall adjust 
typedef struct tagDH_OUTPUT_ATTRIBUTE_CAPS
{
	DWORD			dwSize;
	BOOL			abVideo;			// Video enable
	DWORD			dwVideo;			// Video ability, by bite, specific to see DH_ATTR_VIDEO_BRIGHTNESS
	BOOL			abYPbPr;			// YPbPr enable
	DWORD			dwYPbPr;			// YPbPr ability, by bite, specific to see DH_ATTR_VGA_BRIGHTNESS
	BOOL			abVGA;				// VGA enable
	DWORD			dwVGA;				// VGA ability, by bite, specific to see DH_ATTR_VGA_BRIGHTNESS
	BOOL			abDVI;				// DVI enable
	DWORD			dwDVI;				// DVI ability, by bite, specific to see DH_ATTR_DVI_BRIGHTNESS
	BOOL			abMenu;				// Menu enable
	DWORD			dwMemu;				// Menu ability, by bite, specific to see DH_ATTR_MENU_MENU
} DH_OUTPUT_ATTRIBUTE_CAPS;

// CLIENT_MonitorWallGetAttributeCaps's interface input param
typedef struct tagDH_IN_MONITORWALL_GET_ARRT_CAPS
{
	DWORD			dwSize;
	int				nMonitorWallID;			// monitor wall ID
	const char*		pszCompositeID;			// composite ID
	int				nOutputID;				// output ID
} DH_IN_MONITORWALL_GET_ARRT_CAPS;

// CLIENT_MonitorWallGetAttributeCaps's interface output param
typedef struct tagDH_OUT_MONITORWALL_GET_ARRT_CAPS
{
	DWORD			dwSize;
	DH_OUTPUT_ATTRIBUTE_CAPS stuCaps;		// caps of attribute
} DH_OUT_MONITORWALL_GET_ARRT_CAPS;


// CLIENT_MonitorWallAutoAdjust's interface input param
typedef struct tagDH_IN_MONITORWALL_AUTO_ADJUST
{
	DWORD			dwSize;
	int				nMonitorWallID;			// monitor wall ID
	const char*		pszCompositeID;			// composite ID
	int*			pOutputs;				// array pointer
	int				nOutputCount;			// count of pOutputs
} DH_IN_MONITORWALL_AUTO_ADJUST;

// CLIENT_MonitorWallAutoAdjust's interface output param
typedef struct tagDH_OUT_MONITORWALL_AUTO_ADJUST
{
	DWORD			dwSize;
} DH_OUT_MONITORWALL_AUTO_ADJUST;

// display unit attribute key/value
typedef struct tagDH_ATTR_PAIR
{
	DWORD	dwKey;					// attribute key
									// dwKey = DH_OUTPUT_ATTRIBUTE_VIDEO , uses DH_ATTR_VIDEO_BRIGHTNESS
									// dwKey = DH_OUTPUT_ATTRIBUTE_YPBPR, usesDH_ATTR_YPBPR_BRIGHTNESS
									// so on
	int		nValue;					// value of attribute, 0-reduce 1-increase, 2-no change
} DH_ATTR_PAIR;

// CLIENT_MonitorWallSetAttribute's interface input param
typedef struct tagDH_IN_MONITORWALL_SET_ATTR
{
	DWORD					dwSize;
	int						nMonitorWallID;					// monitor wall ID
	const char*				pszCompositeID;					// composite ID
	int						nOutputID;						// output ID
	DH_OUTPUT_ATTRIBUTE_TYPE emAttrType;					// attribute, the differ type, the stuAttrs differ also
	DH_ATTR_PAIR			stuAttrs[DH_MAX_ATTR_NUM];		// value of attribute
} DH_IN_MONITORWALL_SET_ATTR;

// CLIENT_MonitorWallSetAttribute's interface output param
typedef struct tagDH_OUT_MONITORWALL_SET_ATTR
{
	DWORD			dwSize;
} DH_OUT_MONITORWALL_SET_ATTR;

// CLIENT_MonitorWallSetBackLight's interface input param
typedef struct tagDH_IN_MONITORWALL_SET_BACK_LIGHT
{
	DWORD					dwSize;
	int						nMonitorWallID;					// monitor wall ID
	const char*				pszCompositeID;					// omposite ID
	int						nOutputID;						// output ID
	int						nMode;							// backlight model, 0-circulation patterns,1-not circulation
} DH_IN_MONITORWALL_SET_BACK_LIGHT;

// CLIENT_MonitorWallSetBackLight's interface output param
typedef struct tagDH_OUT_MONITORWALL_SET_BACK_LIGHT
{
	DWORD			dwSize;
} DH_OUT_MONITORWALL_SET_BACK_LIGHT;

// CLIENT_MonitorWallGetPowerSchedule Interface Input Parameters 
typedef struct tagNET_IN_WM_GET_POWER_SCHEDULE
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // TV Wall Serial Number 
    const char*         pszCompositeID;                     // Splicing Screen ID 
} NET_IN_MW_GET_POWER_SCHEDULE;

// CLIENT_MonitorWallGetPowerSchedule Interface Output Parameters 
typedef struct tagNET_OUT_MW_GET_POWER_SCHEDULE
{
    DWORD               dwSize;
    DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // starting up schedule, the first dimension means Saturday and Sunday and other holidays 
} NET_OUT_MW_GET_POWER_SCHEDULE;

// CLIENT_MonitorWallSetPowerSchedule Interface Input Parameters
typedef struct tagNET_IN_MW_SET_POWER_SCHEDULE
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // TV wall serial number 
    const char*         pszCompositeID;                     // Splicing Screen ID, NULL means all the screen 
    DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // starting up schedule, the first dimension means Saturday and Sunday and other holidays
} NET_IN_MW_SET_POWER_SCHEDULE;

// CLIENT_MonitorWallSetPowerSchedule Interface Output Parameters 
typedef struct tagNET_OUT_MW_SET_POWER_SCHEDULE
{
    DWORD               dwSize;
} NET_OUT_MW_SET_POWER_SCHEDULE;

// CLIENT_MonitorWallGetScrnCtrlParam Interface Intput Parameters 
typedef struct tagNET_IN_MW_GET_SCRN_CTRL_PARAM
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // TV wall Serial Number
    const char*         pszCompositeID;                     // Splicing Screen ID 
} NET_IN_MW_GET_SCRN_CTRL_PARAM;

#define DH_MAX_SCREEN_PORT_NUM        16                    // The biggest screen input port number 
#define DH_MAX_COMPSITE_SCREEN_NUM    256                   // The biggest splicing screen number 

// Screen Input Port Information
typedef struct tagNET_SCREEN_PORT_INFO
{
    DWORD               dwSize;
    char                szType[DH_COMMON_STRING_16];        // Port type, "DVI", "VGA", "HDMI"Etc., Allow the same type of multiple ports 
    char                szAddress[DH_COMMON_STRING_16];     // Port address 
    char                szDeviceID[DH_DEV_ID_LEN_EX];       // The video output device of a binding 
    int                 nOutputChannel;                     // Video output channel number 
} NET_SCREEN_PORT_INFO;


typedef struct tagNET_SCREEN_PORT_GROUP 
{
    DWORD                dwSize;
    int                  nPortNum;                          // Port Number
    NET_SCREEN_PORT_INFO stuPorts[DH_MAX_SCREEN_PORT_NUM];  // Port Information
} NET_SCREEN_PORT_GROUP;

// TV wall screen control parameters 
typedef struct tagNET_WM_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    int                     nCommPort;                                  // Serial Number
    DH_COMM_PROP            stuCommProp;                                // Port Attributes
    char                    szProtocol[DH_COMMON_STRING_32];            // Port Protocol 
    int                     nResolutionNum;                             // Resolution Number
    CAPTURE_SIZE            emResolutions[DH_MAX_CAPTURE_SIZE_NUM];     // Video Resolution List 
    int                     nScreenCodeNum;                             // Screen Code Number 
    char                    szScreenCode[DH_MAX_COMPSITE_SCREEN_NUM][DH_COMMON_STRING_16];    // Screen code, using for serial command addressing,this encoding configuration by the user, can be the same 
    int                     nScreenPortsNum;                            // Number of screen input port information
    NET_SCREEN_PORT_GROUP   stuScreenPorts[DH_MAX_COMPSITE_SCREEN_NUM]; // Screen input port information     
} NET_WM_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallGetScrnCtrlParam Interface Input Parameters 
typedef struct tagNET_OUT_MW_GET_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // Screen Control Parameters
} NET_OUT_MW_GET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallSetScrnCtrlParam Interface Input Parameters
typedef struct tagNET_IN_MW_SET_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    int                     nMonitorWallID;             // TV Wall Serial Number 
    const char*             pszCompositeID;             // Splicing Screen ID 
    NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // Screen Control Parameters
} NET_IN_MW_SET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallSetScrnCtrlParam    Interface Output Parameters 
typedef struct tagNET_OUT_MW_SET_SCRN_CTRL_PARAM
{
    DWORD           dwSize;
} NET_OUT_MW_SET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallGetBackgroudColor Interface Input Parameters 
typedef struct tagNET_IN_MW_GET_BACKGROUDND_COLOR
{
    DWORD           dwSize;
    int             nMonitorWallID;             // TV Wall Serial Number
} NET_IN_MW_GET_BACKGROUDND_COLOR;

// CLIENT_MonitorWallGetBackgroudColor    Interface Output Parameters 
typedef struct tagNET_OUT_MW_GET_BACKGROUDND_COLOR
{
    DWORD           dwSize;
    DH_COLOR_RGBA   stuScreenColor;             // Screen Background Color 
    DH_COLOR_RGBA   stuWindowColor;             // Window Background Color 
} NET_OUT_MW_GET_BACKGROUDND_COLOR;

// CLIENT_MonitorWallSetBackgroudColor Interface Input Parameters 
typedef struct tagNET_IN_MW_SET_BACKGROUD_COLOR 
{
    DWORD           dwSize;
    int             nMonitorWallID;             // TV Wall Serial Number
    DH_COLOR_RGBA   stuScreenColor;             // Screen Background Color 
    DH_COLOR_RGBA   stuWindowColor;             // Window Background Color 
} NET_IN_MW_SET_BACKGROUD_COLOR;

// CLIENT_MonitorWallSetBackgroudColor Interface Output Parameters
typedef struct tagNET_OUT_MW_SET_BACKGROUD_COLOR 
{
    DWORD           dwSize;
} NET_OUT_MW_SET_BACKGROUD_COLOR;


// signal type
typedef enum tagEM_SIGNAL_TYPE
{
	EM_SIGNAL_TYPE_UNKNOWN,				// unknown
	EM_SIGNAL_TYPE_VIDEO,				// "Video"
	EM_SIGNAL_TYPE_VGA,				    // "VGA"
	EM_SIGNAL_TYPE_YPBPR,				// "YPbPr"
	EM_SIGNAL_TYPE_HDMI,				// "HDMI"
	EM_SIGNAL_TYPE_DVI,					// "DVI"
	EM_SIGNAL_TYPE_SDI,					// "SDI"
	EM_SIGNAL_TYPE_CVBS,				// "CVBS"
}EM_SIGNAL_TYPE;
// CLIENT_MonitorWallSwitchDisplaySignal interface input param
typedef struct tagNET_IN_MW_SWITCH_DISPLAY_SIGNAL
{	
	DWORD				dwSize;							// When this structure is used, dwSize should be assigned to sizeof(NET_IN_MW_SWITCH_DISPLAY_SIGNAL)
    int                 nMonitorWallID;                 // TV wall ID
	char*				pszCompositeID;					// Splicing ID
	int					nOutputID;						// Splicing Block Index ID, -1 means wall
	EM_SIGNAL_TYPE		emSignalType;					// signal type
	int					nIndex;							// index of signal interface
}NET_IN_MW_SWITCH_DISPLAY_SIGNAL;
// CLIENT_MonitorWallSwitchDisplaySignal interface output param
typedef struct tagNET_OUT_MW_SWITCH_DISPLAY_SIGNAL			
{
	DWORD				dwSize;							//When this structure is used, dwSize should be assigned to sizeof(NET_OUT_MW_SWITCH_DISPLAY_SIGNAL)
}NET_OUT_MW_SWITCH_DISPLAY_SIGNAL;
// tv wall operation type
// monitorwall operate type
typedef enum tagNET_MONITORWALL_OPERATE_TYPE
{
    NET_MONITORWALL_OPERATE_ADD,            // add tv wall, corresponding to  NET_IN_MONITORWALL_ADD and NET_OUT_MONITORWALL_ADD
    NET_MONITORWALL_OPERATE_CTRL_TOUR,      // scheme tour control, corresponding to  NET_IN_CTRL_COLLECTIONTOUR and NET_OUT_CTRL_COLLECTIONTOUR
    NET_MONITORWALL_OPERATE_GET_STATUS,     // get matrix current status, corresponding to  NET_IN_MONITORWALL_GET_STATUS NET_OUT_MONITORWALL_GET_STATUS
    NET_MONITORWALL_OPERATE_SET_COLL_SCHD,  // set scheme time schedule, corresponding to  NET_IN_MONITORWALL_SET_COLL_SCHD NET_OUT_MONITORWALL_SET_COLL_SCHD
    NET_MONITORWALL_OPERATE_GET_COLL_SCHD,  // get scheme schedule, corresponding to  NET_IN_MONITORWALL_GET_COLL_SCHD and NET_OUT_MONITORWALL_GET_COLL_SCHD
    NET_MONITORWALL_OPERATE_REMOVE,         // delete tv wall, corresponding to NET_IN_MONITORWALL_REMOVE  and  NET_OUT_MONITORWALL_REMOVE
    NET_MONITORWALL_OPERATE_SET_ENABLE,     // setup enable, corresponding to NET_IN_MONITORWALL_SET_ENABLE  and  NET_OUT_MONITORWALL_SET_ENABLE
    NET_MONITORWALL_OPERATE_GET_ENABLE,     // Get  enable, corresponding to NET_IN_MONITORWALL_GET_ENABLE  and  NET_OUT_MONITORWALL_GET_ENABLE
    NET_MONITORWALL_OPERATE_NAME_EXIST,     // tv wall exists or not, corresponding to NET_IN_MONITORWALL_NAME_EXIST  and  NET_OUT_MONITORWALL_NAME_EXIST
} NET_MONITORWALL_OPERATE_TYPE;

// add tv wall input parameter
typedef struct tagNET_IN_MONITORWALL_ADD
{
    DWORD dwSize;
    DH_MONITORWALL stuMonitorWall; // tv wall info
} NET_IN_MONITORWALL_ADD;

// add tv wall output parameter
typedef struct tagNET_OUT_MONITORWALL_ADD
{
    DWORD dwSize;
    unsigned int nMonitorWallID; // tv wall ID
} NET_OUT_MONITORWALL_ADD;

// CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_CTRL_TOUR
typedef struct tagNET_IN_CTRL_COLLECTIONTOUR 
{
    DWORD              dwSize;
    int                nChannel;                       // channel no.
    int                nAction;                        // tour action, 0:ebd, 1:start
} NET_IN_CTRL_COLLECTIONTOUR;

// CLIENT_OperateMonitorWallport output parameter=>NET_MONITORWALL_OPERATE_CTRL_TOUR
typedef struct tagNET_OUT_CTRL_COLLECTIONTOUR 
{
    DWORD                   dwSize;
} NET_OUT_CTRL_COLLECTIONTOUR;

// matrix operation status
typedef enum tagNET_MATRIX_STATUS
{
    MATRIX_STATUS_UNKNOWN,              // unknown 
    MATRIX_STATUS_TOUR,                 // scheme tour
    MATRIX_STATUS_NORMAL,               // normal tour
} NET_MATRIX_STATUS;

#define DH_MAX_COLLECTION_NUM   64      // max scheme
// matrix status info
typedef struct tagNET_MONITORWALL_STATUS_INFO
{
    DWORD       dwSize;
    int         nInterval;                      // tour interval
    int         nCollectionNum;                 // scheme tour
    char        szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];         // scheme tour content
    char        szName[DH_DEVICE_NAME_LEN];     // current display scheme name
} NET_MONITORWALL_STATUS_INFO;

// // CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_GET_STATUS
typedef struct tagNET_IN_MONITORWALL_GET_STATUS 
{
    DWORD              dwSize;
    int                nChannel;                        //channel no.
} NET_IN_MONITORWALL_GET_STATUS;

// CLIENT_OperateMonitorWallport output parameter=>NET_MONITORWALL_OPERATE_GET_STATUS
typedef struct tagNET_OUT_MONITORWALL_GET_STATUS
{
    DWORD                           dwSize;
    NET_MATRIX_STATUS               emMatrixStatus;     // operation status
    NET_MONITORWALL_STATUS_INFO     stuStatusInfo;      // status info
} NET_OUT_MONITORWALL_GET_STATUS;

// tv wall scheme schedule
typedef struct tagMONITORWALL_COLLECTION_SCHEDULE
{
    DWORD               dwSize;
    char                szName[DH_DEVICE_NAME_LEN];     // schedule name
    DH_TSECT            stuSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];   // schedule, first each element means sunday~Saturday and holiday
} MONITORWALL_COLLECTION_SCHEDULE;

// CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
typedef struct tagNET_IN_MONITORWALL_SET_COLL_SCHD 
{
    DWORD               dwSize;
    int                 nCollectionNum;                 // scheme number
    MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // scheme schedule
    int                 nMonitorWallID;                 // tv wall ID
} NET_IN_MONITORWALL_SET_COLL_SCHD;

// CLIENT_OperateMonitorWallport output parameter=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
typedef struct tagNET_OUT_MONITORWALL_SET_COLL_SCHD 
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_SET_COLL_SCHD;

// CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
typedef struct tagNET_IN_MONITORWALL_GET_COLL_SCHD 
{
    DWORD               dwSize;
    BOOL                bAllCollections;                // TRUE-search all scheme, no need to appoint scheme name. FALSE-search name corresponding scheme
    int                 nCollectionNum;                 // scheme, bAllCollections is FALSE valid
    char                szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];   // scheme name
    int                 nMonitorWallID;                 // tv wall ID
} NET_IN_MONITORWALL_GET_COLL_SCHD;

// CLIENT_OperateMonitorWallport input parameter=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
typedef struct tagNET_OUT_MONITORWALL_GET_COLL_SCHD 
{
    DWORD               dwSize;
    int                 nCollectionNum;                 // scheme number
    MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // scheme schedule
} NET_OUT_MONITORWALL_GET_COLL_SCHD;

// CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_REMOVE
typedef struct tagNET_IN_MONITORWALL_REMOVE 
{
    DWORD       dwSize;
    int         nMonitorWallNum;        // tv wall quantity to delete
    char        szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128]; // tv wall  name 
} NET_IN_MONITORWALL_REMOVE;

// CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_REMOVE
typedef struct tagNET_OUT_MONITORWALL_REMOVE 
{
    DWORD       dwSize;
} NET_OUT_MONITORWALL_REMOVE;

// tv wall enable info 
typedef struct tagNET_MONITORWALL_ENABLE_INFO
{
    DWORD       dwSize;
    BOOL        bEanble;            // enable 
    char        szName[DH_COMMON_STRING_128];  // tv wall  name 
} NET_MONITORWALL_ENABLE_INFO;

// CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_IN_MONITORWALL_SET_ENABLE
{
    DWORD       dwSize;
    int         nMonitorWallNum;        // tv wall quantity to set
    NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM]; // tv wall enable 
} NET_IN_MONITORWALL_SET_ENABLE;

// CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_OUT_MONITORWALL_SET_ENABLE
{
    DWORD        dwSize;
} NET_OUT_MONITORWALL_SET_ENABLE;

// CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_GET_ENABLE
typedef struct tagNET_IN_MONITORWALL_GET_ENABLE
{
    DWORD       dwSize;
    int         nMonitorWallNum;        //tv wall quantity to search, -1 means search alltv wall 
    char        szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128]; // tv wall  name , nMonitorWallNum>0 is valid 
} NET_IN_MONITORWALL_GET_ENABLE;

// CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_OUT_MONITORWALL_GET_ENABLE
{
    DWORD       dwSize;
    int         nMonitorWallNum;        // tv wall quantity
    NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM]; // tv wall enable 
} NET_OUT_MONITORWALL_GET_ENABLE;

// CLIENT_OperateMonitorWallport input parameter =>NET_MONITORWALL_OPERATE_NAME_EXIST
typedef struct tagNET_IN_MONITORWALL_NAME_EXIST 
{
    DWORD           dwSize;
    const char*     pszName;            // tv wall  name 
} NET_IN_MONITORWALL_NAME_EXIST;

// CLIENT_OperateMonitorWallport  output parameter =>NET_MONITORWALL_OPERATE_NAME_EXIST
typedef struct tagNET_OUT_MONITORWALL_NAME_EXIST 
{
    DWORD       dwSize;
    BOOL        bExist;            // tv wall exists or not
} NET_OUT_MONITORWALL_NAME_EXIST;






/************************************************************************/
/*  U disk caught
/************************************************************************/

// CLIENT_StartSniffer's interface input param
typedef struct tagDH_IN_START_SNIFFER 
{
	DWORD		dwSize;
	const char*	pszNetInterface;				// name of network card
	const char*	pszPath;						// path of caught file, it is means the default path when pszPath = NULL
	int			nSaveType;						// type of file, 0-Wireshark/Tcpdump
    const char*     pszFilter;                  // Filter Conditions ,Such as "host 172.9.88.200 and port 8080 and tcp"
} DH_IN_START_SNIFFER;

// CLIENT_StartSniffer's interface output param
typedef struct tagDH_OUT_START_SNIFFER 
{
	DWORD		dwSize;
} DH_OUT_START_SNIFFER;

// grasp the package information
typedef struct tagDH_SNIFFER_INFO
{
	DWORD		dwSize;
	DWORD		nSnifferID;					// Sniffer ID
} DH_SNIFFER_INFO;

// CLIENT_GetSnifferInfo's interface input param
typedef struct tagDH_IN_GET_SNIFFER_INFO
{
	DWORD		dwSize;
	const char*	pszNetInterface;
} DH_IN_GET_SNIFFER_INFO;

// CLIENT_GetSnifferInfo's interface output param
typedef struct tagDH_OUT_GET_SNIFFER_INFO
{
	DWORD		dwSize;
	DH_SNIFFER_INFO	* pstuSniffers;			// array of Sniffer
	int			nMaxSnifferCount;			// size of array
	int			nRetSnifferCount;			// return count
} DH_OUT_GET_SNIFFER_INFO;

/************************************************************************/
/*  manage file
/************************************************************************/

// format the partition information 
typedef struct tagDH_FORMAT_PATITION 
{
	DWORD			dwSize;
	const char*		pszStorageName;							// storage name
	const char*		pszPatitionName;						// partition name
} DH_FORMAT_PATITION;

// CLIENT_CreateRemoteFile's interface input param
typedef struct tagDH_IN_CREATE_REMOTE_FILE
{
	DWORD			dwSize;
	const char*		pszPath;								// path of file
	BOOL			bDirectory;								// is directory or not
} DH_IN_CREATE_REMOTE_FILE;

// CLIENT_CreateRemoteFile's interface output param
typedef struct tagDH_OUT_CREATE_REMOTE_FILE 
{
	DWORD			dwSize;
} DH_OUT_CREATE_REMOTE_FILE;

// CLIENT_RemoveRemoteFiles's interface input param
typedef struct tagDH_IN_REMOVE_REMOTE_FILES
{
	DWORD			dwSize;
	const char**	pszPath;								// pointer of file path
	int				nFileCount;								// count of file
} DH_IN_REMOVE_REMOTE_FILES;

// CLIENT_RemoveRemoteFiles's interface output param
typedef struct tagDH_OUT_REMOVE_REMOTE_FILES 
{
	DWORD		dwSize;
} DH_OUT_REMOVE_REMOTE_FILES;

// CLIENT_RenameRemoteFile's interface input param
typedef struct tagDH_IN_RENAME_REMOTE_FILE
{
	DWORD			dwSize;
	const char*		pszOldPath;								// old path
	const char*		pszNewPath;								// new path
} DH_IN_RENAME_REMOTE_FILE;

// CLIENT_RenameRemoteFile's interface output param
typedef struct tagDH_OUT_RENAME_REMOTE_FILE 
{
	DWORD			dwSize;
} DH_OUT_RENAME_REMOTE_FILE;

// file/catalog info
typedef struct tagDH_REMOTE_FILE_INFO 
{
	DWORD			dwSize;
	BOOL			bDirectory;								// is directory or not
	char			szPath[MAX_PATH];						// path
	NET_TIME		stuCreateTime;							// create time
	NET_TIME		stuModifyTime;							// modify time
	INT64			nFileSize;								// size of file
	char			szFileType[DH_FILE_TYPE_LEN];			// type of file
} DH_REMOTE_FILE_INFO;

// remote file query condition
typedef enum tagDH_REMOTE_FILE_COND
{
    DH_REMOTE_FILE_COND_NONE,                           // no condition
    DH_REMOTE_FILE_COND_VOICE,                          // voice file, CANNOT specify search path£¬ONLY file name obtained
} DH_REMOTE_FILE_COND;

// CLIENT_ListRemoteFile's interface input param
typedef struct tagDH_IN_LIST_REMOTE_FILE
{
	DWORD			dwSize;
	const char*		pszPath;								// path
	BOOL			bFileNameOnly;							// only for file name
    DH_REMOTE_FILE_COND emCondition;                        // query condition
} DH_IN_LIST_REMOTE_FILE;

// CLIENT_ListRemoteFile's interface output param
typedef struct tagDH_OUT_LIST_REMOTE_FILE 
{
	DWORD			dwSize;
	DH_REMOTE_FILE_INFO*	pstuFiles;						// array of file 
	int						nMaxFileCount;					// size of array
	int						nRetFileCount;					// return count
} DH_OUT_LIST_REMOTE_FILE;

// set file property?aproperty name
typedef enum tagNET_SET_FILEATTR_ACTION
{
    EM_SET_FILEATTR_ACTION_UNKNOWN = 0,                 // unknown
    EM_SET_FILEATTR_ACTION_MARK,                        // file lock
} NET_SET_FILEATTR_ACTION;

// CLIENT_SetFileAttribute port input paramete
typedef struct tagDH_IN_SET_FILEATTRIBUTE
{
    DWORD                   dwSize;
    unsigned int            nDriveNo;                       // disk no.
    unsigned int            nPartition;                     // partition no.
    unsigned int            nCluster;                       // cluster no.
    NET_SET_FILEATTR_ACTION emAction;                       // each property corresponding to one key, set value depends on value
                                                            // set key:Mark file lock ,corresponding to value, delay lock time(unit:day)
    char                    szValue[DH_COMMON_STRING_64];   // property valu
} DH_IN_SET_FILEATTRIBUTE;

// CLIENT_SetFileAttribute port output parameter
typedef struct tagDH_OUT_SET_FILEATTRIBUTE
{
    DWORD                   dwSize;
} DH_OUT_SET_FILEATTRIBUTE;

// manual pop-up storage device
typedef struct tagDH_EJECT_STORAGE_DEVICE
{
	DWORD				dwSize;	
	const char*			pszStorageName;						// storage name
} DH_EJECT_STORAGE_DEVICE;

//  manual load storage device
typedef struct tagDH_LOAD_STORAGE_DEVICE 
{
	DWORD				dwSize;
	const char*			pszStorageName;						// storage name
} DH_LOAD_STORAGE_DEVICE;

// CLIENT_UploadRemoteFile's interface input param(upload file to the device)
typedef struct tagDH_IN_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszFileSrc;			// path of source file
    const char*         pszFileDst;			// path of goal file
    const char*         pszFolderDst;       // target file path¡êomay be NULL, NULL device use default path
    unsigned int        nPacketLen;         // file pack size(byte): 0 means not pack
} DH_IN_UPLOAD_REMOTE_FILE;

// CLIENT_UploadRemoteFile's interface output param(upload file to the device)
typedef struct tagDH_OUT_UPLOAD_REMOTE_FILE
{
	DWORD					dwSize;
} DH_OUT_UPLOAD_REMOTE_FILE;

// CLIENT_DownloadRemoteFile    Interface Input Parameters (the file download)
typedef struct tagDH_IN_DOWNLOAD_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszFileName;                    // File Name Needs to Download 
    const char*         pszFileDst;                     // File Path 
} DH_IN_DOWNLOAD_REMOTE_FILE;

// CLIENT_DownloadRemoteFile Interface Output Parameters (the file download) 
typedef struct tagDH_OUT_DOWNLOAD_REMOTE_FILE
{
    DWORD               dwSize;
} DH_OUT_DOWNLOAD_REMOTE_FILE;

/************************************************************************/
/* cascade device
/************************************************************************/
// conditon of cascade device search
typedef struct tagDH_IN_SEARCH_CONDITON
{
	DWORD					dwSize;
	const char*				pMachineName;					// device name or no.
	const char*				pMachineAddr;					// machine address (XX.XX.XX)
	const char*				pSerialNo;						// serial no.
	const char*				pChannelName;					// channel name of video in
} DH_MATRIX_SEARCH_CONDITON;

// CLIENT_MatrixSearch's interface input param(search cascade device)
typedef struct tagDH_IN_MATIRX_SEARCH
{
	DWORD					dwSize;
	const char*				pSerialNo;						// servial no.,"Local""Root",other devices with a serial number
	DH_MATRIX_SEARCH_CONDITON stuCondition;					// condition of search, can be for a single or combination
} DH_IN_MATRIX_SEARCH;

// CLIENT_MatrixSearch's interface output param(search cascade device)
typedef struct tagDH_OUT_MATRIX_SEARCH
{
	DWORD					dwSize;
	DH_REMOTE_DEVICE*		pstuRemoteDevices;				// devices list
	int						nMaxDeviceCount;				// max count of device
	int						nRetDeviceCount;				// return count
} DH_OUT_MATRIX_SEARCH;

// CLIENT_GetMatrixTree's interface input param
typedef struct tagDH_IN_GET_MATRIX_TREE
{
	DWORD					dwSize;
	const char*				pSerialNo;						// servial no.,"Local""Root",other devices with a serial number
	int						nLevel;							// get device information,0-all, 1-Local, 2-Local+device under
															// 3-Local+device under+ the next next devuce
} DH_IN_GET_MATRIX_TREE;

// cascade device info
typedef struct tagDH_CASCADE_DEVICE_INFO
{
	DWORD					dwSize;
	int						nLevel;							// level
	char					szPath[MAX_PATH];				// set path,format:name1.name2.name3...
	DH_REMOTE_DEVICE		stuDeviceInfo;					// device info
} DH_CASCADE_DEVICE_INFO;

// CLIENT_GetMatrixTree's interface output param
typedef struct tagDH_OUT_GET_MATRIX_TREE
{
	DWORD					dwSize;
	DH_CASCADE_DEVICE_INFO*	pstuRemoteDevices;				// info of cascade device
	int						nMaxDeviceCount;				// max number of cascade device
	int						nRetDeviceCount;				// return count
} DH_OUT_GET_MATRIX_TREE;

// CLIENT_GetSuperiorMatrixList's interface input param
typedef struct tagDH_IN_GET_SUPERIOR_MATRIX_LIST
{
	DWORD					dwSize;
} DH_IN_GET_SUPERIOR_MATRIX_LIST;

// CLIENT_GetSuperiorMatrixList's interface output param
typedef struct tagDH_OUT_GET_SUPERIOR_MATRIX_LIST
{
	DWORD					dwSize;
	DH_REMOTE_DEVICE*		pstuRemoteDevices;				// device list
	int						nMaxDeviceCount;				// max count of device
	int						nRetDeviceCount;				// return count
} DH_OUT_GET_SUPERIOR_MATRIX_LIST;

////////////////////////////////////record backup to restore//////////////////////////////////////

// task of record backup to restore
typedef struct tagDH_RECORD_BACKUP_RESTORE_TASK
{
    DWORD				dwSize;
    unsigned int		nTaskID;                        // task ID
    char				szDeviceID[DH_DEV_ID_LEN_EX];   // device ID
    int			        nChannelID;                     // channek ID
    NET_TIME			stuStartTime;                   // start time
    NET_TIME			stuEndTime;                     // end time
    int			        nState;                         // state of backup, 0-wait, 1-working, 2-finish, 3-failed
} DH_REC_BAK_RST_TASK;

// CLIENT_AddRecordBackupRestoreTask's interface input param
typedef struct tagDH_IN_ADD_RECORD_BACKUP_RESTORE_TASK
{
    DWORD				dwSize;
    const char*			pszDeviceID;					// device ID
    int*		        pnChannels;						// array of channel
	int					nChannelCount;					// size of array
    NET_TIME			stuStartTime;					// start time
    NET_TIME			stuEndTime;						// end time
} DH_IN_ADD_REC_BAK_RST_TASK;

// CLIENT_RemoveRecordBackupRestoreTask's interface input param
typedef struct tagDH_IN_REMOVE_RECORD_BACKUP_RESTORE_TASK
{
    DWORD				dwSize;
    unsigned int*		pnTaskIDs;						// array of task ID
	int					nTaskCount;						// count of task
} DH_IN_REMOVE_REC_BAK_RST_TASK;

// CLIENT_QueryRecordBackupRestoreTask's interface input param
typedef struct tagDH_IN_QUERY_RECORD_BACKUP_RESTORE_TASK
{
    DWORD		        dwSize;
} DH_IN_QUERY_REC_BAK_RST_TASK;

// CLIENT_QueryRecordBackupRestoreTask's interface output param
typedef struct tagDH_OUT_QUERY_RECORD_BACKUP_RESTORE_TASK
{
    DWORD				 dwSize;
    DH_REC_BAK_RST_TASK* pTasks;						// array of task
    int					 nMaxCount;						// size of array
    int					 nReturnCount;					// return count
} DH_OUT_QUERY_REC_BAK_RST_TASK;

typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_PARAM
{
	DWORD			dwSize;
	const char*		pszDeviceID;			// device ID
	int				nChannel;				// channel
} DH_LOGIC_DEVICE_ADD_CAMERA_PARAM;

typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_RESULT
{
	DWORD			dwSize;
	char			szDeviceID[DH_DEV_ID_LEN];	// device ID
	int				nChannel;					// channel ID
	int				nUniqueChannel;				// uniform number
	int				nFailedCode;				// failure code, 0-succeed 1-Unique 2-have added
} DH_LOGIC_DEVICE_ADD_CAMERA_RESULT;

// CLIENT_AddLogicDeviceCamera's interface input param
typedef struct tagDH_IN_ADD_LOGIC_DEVICE_CAMERA
{
	DWORD			dwSize;
	DH_LOGIC_DEVICE_ADD_CAMERA_PARAM*	pCameras;	// array of source video 
	int				nCameraCount;					// count of sourcevideo
} DH_IN_ADD_LOGIC_DEVICE_CAMERA;

// CLIENT_AddLogicDeviceCamera's interface output param
typedef struct tagDH_OUT_ADD_LOGIC_DEVICE_CAMERA 
{
	DWORD			dwSize;
	DH_LOGIC_DEVICE_ADD_CAMERA_RESULT* pResults;	// result
	int				nMaxResultCount;				// size of array
	int				nRetResultCount;				// return count
} DH_OUT_ADD_LOGIC_DEVICE_CAMERA;

//array info
typedef struct tagDH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM
{
    DWORD                   dwSize;
    int                     nUniqueChannel;             // UniqueChannel
    int                     nChannel;                   // channel         
} DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM;

//result info
typedef struct tagDH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT
{
    DWORD                   dwSize;
    int                     nUniqueChannel;             // UniqueChannel
    int                     nFailedCode;                // FaileCode, 0-Success,1-unsupport           
} DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT;

// CLIENT_MatrixAddCamerasByDevice's interface input param
typedef struct tagDH_IN_ADD_LOGIC_BYDEVICE_CAMERA
{
    DWORD                   dwSize;
    char                    pszDeviceID[DH_DEV_ID_LEN]; // DeviceID
    DH_REMOTE_DEVICE        stuRemoteDevice;            // RemoteDevice Info
    int                     nCameraCount;               // source video number
    DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM* pCameras;       // array of source video 
}DH_IN_ADD_LOGIC_BYDEVICE_CAMERA;

// CLIENT_MatrixAddCamerasByDevice's interface output param
typedef struct tagDH_OUT_ADD_LOGIC_BYDEVICE_CAMERA
{
    DWORD                   dwSize;                         
    char                    szDeviceID[DH_DEV_ID_LEN];    // DeviceID
    int                     nMaxResultCount;              // ResultCount
    int                     nRetResultCount;              // return count
    DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT* pResults;        // result
}DH_OUT_ADD_LOGIC_BYDEVICE_CAMERA;
/************************************************************************/
/*                         Database Records                               */
/************************************************************************/
typedef struct tagNET_AUTHORITY_TYPE
{
  DWORD                       dwSize; 
  EM_NET_AUTHORITY_TYPE       emAuthorityType;                          //Permission Types 
  BOOL                        bAuthorityEnable;                         //Permission Enabled
}NET_AUTHORITY_TYPE;

// Information of recorded in transportation black and white list 
typedef struct tagNET_TRAFFIC_LIST_RECORD
{
  DWORD                      dwSize; 
  int                        nRecordNo;                                 // Queried Record Number 
  char                       szMasterOfCar[DH_MAX_NAME_LEN];            // Car Owner's Name
  char                       szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];    // License Plate Number 
  EM_NET_PLATE_TYPE          emPlateType;                               // License Plate Type 
  EM_NET_PLATE_COLOR_TYPE    emPlateColor;                              // License Plate Color   
  EM_NET_VEHICLE_TYPE        emVehicleType;                             // Vehicle Type  
  EM_NET_VEHICLE_COLOR_TYPE  emVehicleColor;                            // Car Body Color
  NET_TIME                   stBeginTime;                               // Start Time 
  NET_TIME                   stCancelTime;                              // Undo Time
  int                        nAuthrityNum;                              // Permission Number
  NET_AUTHORITY_TYPE         stAuthrityTypes[DH_MAX_AUTHORITY_LIST_NUM];// Permissions List, White List Only 
  EM_NET_TRAFFIC_CAR_CONTROL_TYPE emControlType;                        // Monitor Type, Black List Only 
}NET_TRAFFIC_LIST_RECORD;

// Query Conditions Of Traffic Black And White List Account Records 
typedef struct
{
    DWORD                    dwSize;
    char                     szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];      // License Plate Number
    char                     szPlateNumberVague[DH_MAX_PLATE_NUMBER_LEN]; // License Plate Number Fuzzy Query 
    int                      nQueryResultBegin;                           // Offset in the query results of first results returned   
    BOOL                     bRapidQuery;                                 // Whether support the quick query, TRUE: for quick, quick query time don't wait for all add, delete, change operation is completed. The default is non-quick query 
}FIND_RECORD_TRAFFICREDLIST_CONDITION;

// ?¨®¨°¨¦3¦Ì¨¢?¨¦?¡À¡§¨º??t, ??¨®|¨º??t¨¤¨¤D¨ª DH_ALARM_TRAFFIC_SUSPICIOUSCAR
typedef struct tagALARM_TRAFFIC_SUSPICIOUSCAR_INFO
{
    DWORD                   dwSize;
    int                     nAction;                        // ¨º??t?¡¥¡Á¡Â, -1:?¡ä?a,0:Start, 1:Stop, 2:Pulse
    DH_MSG_OBJECT           stuVehicle;                     // 3¦Ì¨¦¨ªD??¡é
    NET_TRAFFIC_LIST_RECORD stuCarInfo;                     // 3¦Ì¨¢?¦Ì?o¨²??¦Ì£¤D??¡é
    EVENT_COMM_INFO         stCommInfo;                     // 1?12D??¡é
}ALARM_TRAFFIC_SUSPICIOUSCAR_INFO;

//Record Case Record Query Conditions 
typedef struct
{
    DWORD                    dwSize;
    NET_TIME                 stuStartTime;                      // Start Time 
    NET_TIME                 stuEndTime;                        // End Time
}FIND_RECORD_BURN_CASE_CONDITION;


// Entrance Card Record Query Conditions 
typedef struct tagFIND_RECORD_ACCESSCTLCARD_CONDITION
{
    DWORD                    dwSize;
    char                     szCardNo[DH_MAX_CARDNO_LEN];      // Card Number 
    char                     szUserID[DH_MAX_USERID_LEN];      // User ID 
    BOOL                     bIsValid;                         // Whether effective, TRUE: effective, FALSE: invalid 
    BOOL                     abCardNo;                         // Card inquire condition effects or not, for member szCardNo
    BOOL                     abUserID;                         // User ID inquire condition effects or not, for member  szUserID
    BOOL                     abIsValid;                        // IsValid inquire condition effects or not¡ê?for member  bIsValid
}FIND_RECORD_ACCESSCTLCARD_CONDITION;

// Access password record query conditions 
typedef struct tagFIND_RECORD_ACCESSCTLPWD_CONDITION
{
    DWORD                     dwSize;
    char                      szUserID[DH_MAX_USERID_LEN];      // User ID
}FIND_RECORD_ACCESSCTLPWD_CONDITION;

// Entrance guard access records query conditions 
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_CONDITION
{
    DWORD                     dwSize;
    char                      szCardNo[DH_MAX_CARDNO_LEN];      // User ID
    NET_TIME                  stStartTime;                      // Start Time 
    NET_TIME                  stEndTime;                        // End Time
}FIND_RECORD_ACCESSCTLCARDREC_CONDITION;

// A&C extry/exit search criteria
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX
{
    DWORD                     dwSize;
    BOOL                      bCardNoEnable;                    // Enable card search
    char                      szCardNo[DH_MAX_CARDNO_LEN];      // Card No.
    BOOL                      bTimeEnable;                      // Enable search by period
    NET_TIME                  stStartTime;                      // Start time 
    NET_TIME                  stEndTime;                        // End time 
}FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX;


// Holiday Recordset Query Conditions 
typedef struct tagFIND_RECORD_ACCESSCTLHOLIDAY_CONDITION
{
    DWORD                     dwSize;
}FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION;

// traffic flow record search filter
typedef struct tagFIND_RECORD_TRAFFICFLOW_CONDITION
{
    DWORD                     dwSize;
    BOOL                      abChannelId;                      // channel no. search filter is valid or not     
    int                       nChannelId;                       // channel no.
    BOOL                      abLane;                           // lane no. searchfilter is valid or not
    int                       nLane;                            // lane no.
    BOOL                      bStartTime;						// The start time search critiera is valid or not    
    NET_TIME                  stStartTime;                      // start time
    BOOL					  bEndTime;							// The end time search criteria is valid or not. 
    NET_TIME                  stEndTime;                        // end time 
}FIND_RECORD_TRAFFICFLOW_CONDITION;

#define DH_MAX_CALLTYPE_LIST_NUM        16              // call  type search criteria listmax number 
#define DH_MAX_ENDSTATE_LIST_NUM        16              // final status  search criteria listmax number 

// call record search criteria 
typedef struct tagFIND_RECORD_VIDEO_TALK_LOG_CONDITION
{
    DWORD               dwSize;
    BOOL                bCallTypeEnable;                // call  type search criteria valid or not
    int                 nCallTypeListNum;               // corresponding to emCallTypeList valid enumeration number 
    EM_VIDEO_TALK_LOG_CALLTYPE   emCallTypeList[DH_MAX_CALLTYPE_LIST_NUM];  // call  type enable list
    BOOL                bEndStateEnable;                // final status  search criteria isvalid or not
    int                 nEndStateListNum;               // corresponding to emEndStateList valid enumeration number 
    EM_VIDEO_TALK_LOG_ENDSTATE   emEndStateList[DH_MAX_ENDSTATE_LIST_NUM];  // final status enable list
    BOOL                            bTimeEnable;                                // ÆôÓÃÊ±¼ä¶Î²éÑ¯
    NET_TIME                        stStartTime;                                // ÆðÊ¼Ê±¼ä
    NET_TIME                        stEndTime;                                  // ½áÊøÊ±¼ä
}FIND_RECORD_VIDEO_TALK_LOG_CONDITION;

// status  record search criteria 
typedef struct tagFIND_RECORD_REGISTER_USER_STATE_CONDITION
{
    DWORD               dwSize;
    BOOL                bUserIDEnable;                  // userID search criteria is valid or not
    char                szUserID[DH_MAX_USERID_LEN];    // user ID
    BOOL                bOnlineEnable;                  // online search criteria is valid or not
    int								nOnline;                                        // ÊÇ·ñÔÚÏß
    BOOL                bVideoTalkingEnable;            // audio talk status  search criteria  is valid or not 
    EM_REGISTER_USER_STATE     emVideoTalking;          // audio talk status 
}FIND_RECORD_REGISTER_USER_STATE_CONDITION;

// contact record search criteria 
typedef struct tagFIND_RECORD_VIDEO_TALK_CONTACT_CONDITION
{
    DWORD               dwSize;
    BOOL                bVTShortNumberEnable;                   // visual talk short no. search criteria  is valid or not 
    char                szVTShortNumber[DH_COMMON_STRING_32];   // visual talk short no.
}FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION;

// Delivered commodies search criteria 
typedef struct tagFIND_RECORD_COMMODITY_NOTICE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bIDEnable;                                   // IDºÅ²éÑ¯Ìõ¼þÊÇ·ñÓÐÐ§
    char                            szID[DH_COMMON_STRING_64];                   // IDºÅ
}FIND_RECORD_COMMODITY_NOTICE_CONDITION;

// Medical check info search criteria 
typedef struct tagFIND_RECORD_HEALTH_CARE_NOTICE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bIDEnable;                                   // IDºÅ²éÑ¯Ìõ¼þÊÇ·ñÓÐÐ§
    char                            szID[DH_COMMON_STRING_64];                   // IDºÅ
}FIND_RECORD_HEALTH_CARE_NOTICE_CONDITION;


// traffic flow record
typedef struct tagNET_RECORD_TRAFFIC_FLOW_STATE 
{
    DWORD                           dwSize;
    int                             nRecordNum;                 // record no.
    int                             nChannel;                   // channel no.   
    int                             nLane;                      // lane no.
    int                             nVehicles;                  // pass vehicle total
    float                           fAverageSpeed;              // average speed¡ê?unit km/h
    float                           fTimeOccupyRatio;           // time occupancy rate¡ê?as within unit time passed vehicle used time total and unit occupied scale
    float                           fSpaceOccupyRatio;          // space occupancy¡ê?as percentage of total vehicle length to time interval average vehicle driving distance
    float                           fSpaceHeadway;              // head distance, with adjacent vehicle, unit meter/vehicle
    float                           fTimeHeadway;               // head distance¡ê?unit meter/vehicle
    int                             nLargeVehicles;             // truck flow(9m<vehicle length<12m)¡ê?vehicle/unit time
    int                             nMediumVehicles;            // Midsize vehicle flow(6m<vehicle length<9m)¡ê?vehicle/unit time
    int                             nSmallVehicles;             // car flow(4m<vehicle legnth<6m)¡ê?vehicle/unit¡ê?
    float                           fBackOfQueue;               // line length¡ê?unit¡êometer, from signal cross to front line end
}NET_RECORD_TRAFFIC_FLOW_STATE;

// CLIENT_FindRecord    Interface Input Parameters 
typedef struct _NET_IN_FIND_RECORD_PARAM
{
    DWORD                     dwSize;          // The Structure Size 
    EM_NET_RECORD_TYPE        emType;          // The record type to query
    void*                     pQueryCondition; // Query types corresponding to the query conditions 
}NET_IN_FIND_RECORD_PARAM;

// CLIENT_FindRecord  Interface Output Parameters 
typedef struct _NET_OUT_FIND_RECORD_PARAM
{
    DWORD                     dwSize;          // Structure Size
    LLONG                     lFindeHandle;    // Query Log Handle,Uniquely identifies a certain query
}NET_OUT_FIND_RECORD_PARAM;

// CLIENT_FindNextRecord  Interface Input Parameters 
typedef struct _NET_IN_FIND_NEXT_RECORD_PARAM
{
    DWORD                     dwSize;          // Structure Size 
    LLONG                     lFindeHandle;    // Query Log Handle
    int                       nFileCount;      // The current number of records  need query 
}NET_IN_FIND_NEXT_RECORD_PARAM;

// CLIENT_FindNextRecord  Interface Output Parameters 
typedef struct _NET_OUT_FIND_NEXT_RECORD_PARAM
{
    DWORD                     dwSize;          // Structure Size 
    void*                     pRecordList;     // Record List, the user allocates memory 
    int                       nMaxRecordNum;   // List Record Number 
    int                       nRetRecordNum;   // Query to the number of records, when the query to the article number less than want to query the number, end 
}NET_OUT_FIND_NEXT_RECORD_PARAM;

typedef struct tagNET_INSERT_RECORD_INFO
{
    DWORD                     dwSize;
    NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // Record the content information                 
}NET_INSERT_RECORD_INFO;

typedef struct tagNET_UPDATE_RECORD_INFO
{
    DWORD                     dwSize;
    NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // Record the content information                 
}NET_UPDATE_RECORD_INFO;

typedef struct tagNET_REMOVE_RECORD_INFO
{
    DWORD                     dwSize;
    int                       nRecordNo;       // Queried Record Number    
}NET_REMOVE_RECORD_INFO;

typedef struct tagNET_IN_OPERATE_TRAFFIC_LIST_RECORD
{
    DWORD                     dwSize;
    
    EM_RECORD_OPERATE_TYPE    emOperateType;
    EM_NET_RECORD_TYPE        emRecordType;    // record type to operate 
    void                      *pstOpreateInfo;
    
}NET_IN_OPERATE_TRAFFIC_LIST_RECORD;

//In current implementation of operation interface, only return nRecordNo operation, stRetRecord is temporarily unavailable 
typedef struct tagNET_OUT_OPERATE_TRAFFIC_LIST_RECORD
{
    DWORD                     dwSize;
    int                       nRecordNo;        //Record Number     
}NET_OUT_OPERATE_TRAFFIC_LIST_RECORD;

//PTZ control coordinate unit 
typedef struct tagPTZ_SPEED_UNIT
{
    float                  fPositionX;           //PTZ horizontal speed, normalized to -1~1 
    float                  fPositionY;           //PTZ vertical speed, normalized to -1~1 
    float                  fZoom;                //PTZ aperture magnification, normalized to 0~1 
    char                   szReserve[32];        //Reserved
}PTZ_SPEED_UNIT;

//PTZ control coordinate unit 
typedef struct tagPTZ_SPACE_UNIT
{
    int                    nPositionX;           //PTZ horizontal motion position, effective range¡êo[0,3600]
    int                    nPositionY;           //PTZ vertical motion position, effective range¡êo[-1800,1800]
    int                    nZoom;                //PTZ aperture change position, the effective range¡êo[0,128]
    char                   szReserve[32];        //Reserved
}PTZ_SPACE_UNIT;

//Continuous control PTZ corresponding structure 
typedef struct tagPTZ_Control_Continuously
{
    PTZ_SPEED_UNIT         stuSpeed;              //PTZ speed 
    int                    nTimeOut;              //Continuous motion timeout, the unit is in seconds 
    char                   szReserve[64];         //Reserved
}PTZ_CONTROL_CONTINUOUSLY;

//Absolute control PTZ corresponding structure 
typedef struct tagPTZ_Control_Absolutely
{
    PTZ_SPACE_UNIT         stuPosition;           //PTZ Absolute Speed 
    PTZ_SPEED_UNIT         stuSpeed;              //PTZ Operation Speed
    char                   szReserve[64];         //Reserved
}PTZ_CONTROL_ABSOLUTELY;

// Alarm input channel information 
typedef struct tagNET_ALARM_IN_CHANNEL
{
    DWORD                   dwSize;
    BOOL                    bValid;                             // whether effective,FALSE show the alarm channel is not used
    int                     nChannel;                           // Alarm channel number 
    char                    szDeviceID[DH_DEV_ID_LEN];          // Device ID, Local alarm channel: "Local",remote device : use uuid express
    char                    szName[DH_DEV_NAME_LEN];            // Alarm  Channel Names 
}NET_ALARM_IN_CHANNEL;

// Alarm Channel Number 
typedef struct tagNET_ALARM_CHANNEL_COUNT 
{
    DWORD                   dwSize;
    int                     nLocalAlarmIn;                      // Local Alarm Input Channel Number
    int                     nLocalAlarmOut;                     // Local Alarm Output Channel Number 
    int                     nRemoteAlarmIn;                     // Remote Alarm Input Channel Number 
    int                     nRemoteAlarmOut;                    // Remote Alarm Output Channel Number 
}NET_ALARM_CHANNEL_COUNT;

//With speed rotation site PTZ control corresponding to the preset structure 
typedef struct tagPTZ_Control_GotoPreset
{
    int                     nPresetIndex;           //Preset BIT Index 
    PTZ_SPEED_UNIT          stuSpeed;               //PTZ Operation Speed
    char                    szReserve[64];          //Reserved
}PTZ_CONTROL_GOTOPRESET;

//remove preset PTZ control corresponding to the preset structure
typedef struct tagPTZ_Control_RemovePreset
{
    int                     nPresetIndex;           //Preset BIT Index
    char                    szReserve[64];          //Reserved
}PTZ_CONTROL_REMOVEPRESET;

// CLIENT_SetTourSource   Interface input parameters (Settings window round tour shows source) 
typedef struct tagNET_IN_SET_TOUR_SOURCE 
{
    DWORD                   dwSize;
    int                     nChannel;               // Output Channel Number 
    int                     nWindow;                // Window Number
    DH_SPLIT_SOURCE*        pstuSrcs;               // Display Origin Array,can be round tour in the window  
    int                     nSrcCount;              // Display Origin Number
} NET_IN_SET_TOUR_SOURCE;

// CLIENT_SetTourSource    Interface output parameters (Settings window round tour shows source) 
typedef struct tagNET_OUT_SET_TOUR_SOURCE
{
    DWORD                   dwSize;
} NET_OUT_SET_TOUR_SOURCE;

// CLIENT_GetTourSource port input parameter 
typedef struct tagNET_IN_GET_TOUR_SOURCE 
{
    DWORD           dwSize;
    int             nChannel;           // output channel no., pszCompsiteIDis NULL, it is valid 
    const char*     pszCompositeID;     //  splicing video wall ID
    int             nWindow;            // window no., -1 means all window
} NET_IN_GET_TOUR_SOURCE;

// window tour display source info 
typedef struct tagNET_SPLIT_TOUR_SOURCE 
{
    DWORD           dwSize;
    DH_SPLIT_SOURCE*    pstuSrcs;       // display source group, user allocation memory
    int             nMaxSrcCount;       // display source max quantity
    int             nRetSrcCount;       // return display source quantity
} NET_SPLIT_TOUR_SOURCE;

// CLIENT_GetTourSource port  output parameter 
typedef struct tagNET_OUT_GET_TOUR_SOURCE
{
    DWORD          dwSize;  
    NET_SPLIT_TOUR_SOURCE* pstuWndSrcs; // window tour info group, user allocation memory
    int            nMaxWndCount;        // window max group, user fill in
    int            nRetWndCount;        // return window  quantity
} NET_OUT_GET_TOUR_SOURCE;

// split tour status info 
typedef struct tagNET_SPLIT_TOUR_STATUS_INFO
{
    DWORD          dwSize;
    int            nWindow;             // window no.
    NET_TOUR_STATUS   emStatus;         // status 
    DH_SPLIT_WND_SOURCE stuSource;      //  current display source info 
}NET_SPLIT_TOUR_STATUS_INFO;

// tour status call function origin, lAttachHandle is CLIENT_AttachSplitTour return value 
typedef void (CALLBACK *fTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SPLIT_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);

// CLIENT_AttachSplitTourport input parameter 
typedef struct tagNET_IN_ATTACH_SPLIT_TOUR
{
    DWORD           dwSize;
    int             nChannel;           // output channel no., pszCompsiteIDis NULL, it is valid 
    const char*     pszCompositeID;     //  splicing video wall ID
    fTourStatusCallBack cbStatus;       // tour status call function
    LDWORD          dwUser;             // tour status call function
}NET_IN_ATTACH_SPLIT_TOUR;

// CLIENT_AttachSplitTourport  output parameter 
typedef struct tagNET_OUT_ATTACH_SPLIT_TOUR 
{
    DWORD           dwSize;
}NET_OUT_ATTACH_SPLIT_TOUR;

// fAttachRecordInfoCB parameter, information of reported video file 
typedef struct tagNET_CB_RECORD_INFO
{
    DWORD                   dwSize;
    int                     nChannel;               // Channel number 
    char                    szFileName[MAX_PATH];   // The name of the video 
    DWORD                   dwType;                 // Video type,defined by bit as follows¡êo
                                                    // Bit0-Timing video 
                                                    // Bit1-Dynamic test video 
                                                    // Bit2-Alarm video
                                                    // Bit3-Video card number
    DWORD                   dwState;                // Video status, 0 - packaging, 1 - to delete 
} NET_CB_RECORD_INFO;



// Video update callback function prototype¡ê?lAttachHandle is return value of CLIENT_AttachRecordInfo, n strip per time¡ê?pBuf->dwSize * n == nBufLen
typedef void (CALLBACK *fAttachRecordInfoCB)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_RECORD_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachRecordInfo  Input Parameters
typedef struct tagNET_IN_ATTACH_RECORD_INFO
{
    DWORD                   dwSize;
    int                     nInterval;              // Time Interval, Every Interval second, equipment send video information 
    int                     nDelay;                 // Report Delay, after equipment choice a random number between 1 and nDelay value, delay report video state, nDelayMust be smaller than nInterval
    fAttachRecordInfoCB     cbAttachRecordInfo;     // Video update callback function 
    LDWORD                  dwUser;                 // User data 
} NET_IN_ATTACH_RECORD_INFO;

typedef struct tagNET_OUT_ATTACH_RECORD_INFO
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_RECORD_INFO;


//Subscribe to PTZ metadata interface and callback function prototypes 
//Pbufs at this stage mainly DH_PTZ_LOCATION_INFO type 
typedef void (CALLBACK *fPTZStatusProcCallBack)(LLONG lLoginID, LLONG lAttachHandle, void* pBuf, int nBufLen, LDWORD dwUser);

// Subscribe to PTZ metadata interface input parameters 
typedef struct tagNET_IN_PTZ_STATUS_PROC
{
    DWORD                   dwSize;
    int                     nChannel;              // PTZ Channel 
    fPTZStatusProcCallBack  cbPTZStatusProc;       // Callback function 
    LDWORD                  dwUser;                // User data
}NET_IN_PTZ_STATUS_PROC;

// Subscribe to PTZ metadata interface output parameters 
typedef struct tagNET_OUT_PTZ_STATUS_PROC
{
    DWORD                   dwSize;
}NET_OUT_PTZ_STATUS_PROC;

//PTZ conditions for visual structure
typedef struct tagDH_OUT_PTZ_VIEW_RANGE_STATUS
{
    DWORD      dwSize;
    double     dbDistance;                         // Visual range, the unit: m 
    int        nAngelH;                            // Horizontal viewing angles, 0~1800, unit: degrees 
    int        nAzimuthH;                          // Horizontal azimuth Angle, 0 ~ 3600, unit: degrees 
    int        nInclinationH;                      // Horizontal inclination angle, -900~900, unit: degree
}DH_OUT_PTZ_VIEW_RANGE_STATUS;

//Subscribe to yuntai horizon callback function prototype 
typedef void (CALLBACK *fViewRangeStateCallBack)(LLONG lLoginID, LLONG lAttachHandle, DH_OUT_PTZ_VIEW_RANGE_STATUS* pBuf, int nBufLen, LDWORD dwUser);

// Subscribe to the visible range input parameters 
typedef struct tagNET_IN_VIEW_RANGE_STATE
{
    DWORD                   dwSize;
    int                     nChannel;              // PTZ channel
    fViewRangeStateCallBack cbViewRange;           // State Callback Function 
    LDWORD                  dwUser;                // User Data
}NET_IN_VIEW_RANGE_STATE;

// Subscribe to the visible range output parameters 
typedef struct tagNET_OUT_VIEW_RANGE_STATE
{
    DWORD                   dwSize;
}NET_OUT_VIEW_RANGE_STATE;

//Set the PTZ vision information 
typedef struct tagPTZ_VIEW_RANGE_INFO
{
    int                     nStructSize;
    int                     nAzimuthH;              // Horizontal azimuth Angle, 0~3600, unit: degrees 
}PTZ_VIEW_RANGE_INFO;

// Channel number information 
typedef struct tagNET_CHN_COUNT_INFO
{
    DWORD                   dwSize;
    int                     nMaxTotal;              // Equipment to the total number of channels (the sum of all valid channel number
    int                     nCurTotal;              // the number of configured on channels 
    int                     nMaxLocal;              // Maximum number of local channels, including motherboard and pluggable cartoon 
    int                     nCurLocal;              // configured local channel number 
    int                     nMaxRemote;             // Maximum number of remote channel 
    int                     nCurRemote;             // Configured remote channel number
} NET_CHN_COUNT_INFO;

// Equipment channel number information  
typedef struct tagNET_DEV_CHN_COUNT_INFO
{
    DWORD                   dwSize;
    NET_CHN_COUNT_INFO      stuVideoIn;             // Video Input Channel 
    NET_CHN_COUNT_INFO      stuVideoOut;            // Video Output Channel 
} NET_DEV_CHN_COUNT_INFO;

//  detailed information of video state
typedef struct tagNET_RECORD_STATE_DETAIL 
{
    DWORD                   dwSize;
    BOOL                    bMainStream;            // The main stream, TRUE - are video, FALSE - not in the video 
    BOOL                    bExtraStream1;          // Auxiliary stream 1, TRUE - are video, FALSE - not in the video 
    BOOL                    bExtraStream2;          // Auxiliary stream 2, TRUE - are video, FALSE - not in the video 
    BOOL                    bExtraStream3;          // Auxiliary stream 3, TRUE - are video, FALSE - not in the video 
} NET_RECORD_STATE_DETAIL;


//PTZ Absolute Focus Corresponding Structure 
typedef struct tagPTZ_Focus_Absolutely
{
    DWORD                    dwValue;               // PTZ Focused On Location, range (0~8191) 
    DWORD                    dwSpeed;               // PTZ Focused On Speed, the scope (0~7) 
    char                     szReserve[64];         // reserved 64 bytes 
}PTZ_FOCUS_ABSOLUTELY;

// CLIENT_PlayAudioFile   Interface Input Parameters 
typedef struct tagNET_IN_PLAY_AUDIO_FILE
{
    DWORD                   dwSize;
    const char*             pszFilePath;            // File Path
    DWORD                   dwOutput;               // Output Path, can be a variety of output, according to the bit, bit0-mic, bit1-speaker
} NET_IN_PLAY_AUDIO_FILE;

// CLIENT_PlayAudioFile   Interface Output Parameters 
typedef struct tagNET_OUT_PLAY_FILE_STREAM
{
    DWORD                   dwSize;
} NET_OUT_PLAY_AUDIO_FILE;

// RTSP URLInformation list structure 
typedef struct tagNET_DEV_RTSPURL_LIST
{
    DWORD                   dwSize;
    int                     nChannelID;                                 // Channel number (user input parameters) 
    int                     nUrlNum;                                    // Url Address Number 
    char                    szURLList[DH_MAX_URL_NUM][DH_MAX_URL_LEN];  // UrlAddress List 
}NET_DEV_RTSPURL_LIST;

// PTZ control - fan and corresponding structure 
typedef struct tagPTZ_Control_SectorScan
{
    int             nBeginAngle;                    // Staring Angle,Range:[-180,180]
    int             nEndAngle;                      // Ending Angle,Range:[-180,180]
    int             nSpeed;                         // Speed,Range:[0,255]
    char            szReserve[64];                  // Reserved 64 bytes 
}PTZ_CONTROL_SECTORSCAN;

// control Fish eye E-PTZ info 
typedef struct tagPTZ_CONTROL_SET_FISHEYE_EPTZ
{
    DWORD       dwSize;	                // structure size
    DWORD       dwWindowID;             // EPtz control window no.
    DWORD       dwCommand;              // E-PTZ command 
    DWORD       dwParam1;               // command corresponding to parameter 1
    DWORD       dwParam2;               // command corresponding to  parameter 2
    DWORD       dwParam3;               // command corresponding to  parameter 3
    DWORD       dwParam4;               // command corresponding to  parameter 4
}PTZ_CONTROL_SET_FISHEYE_EPTZ;

// Track Control Information
typedef struct tagPTZ_CONTROL_SET_TRACK_CONTROL
{
        DWORD           dwSize;                         // dwSize need to be assigned sizeof(PTZ_CONTROL_SET_TRACK_CONTROL)
        DWORD           dwChannelID;                    // channel number
        DWORD           dwCommand;                      // Control command£¬orresponding to enum NET_TRACK_CONTROL_CMD
        DWORD           dwParam1;                       // command corresponding to parameter 1
        DWORD           dwParam2;                       // command corresponding to parameter 2
        DWORD           dwParam3;                       // command corresponding to parameter 3
} PTZ_CONTROL_SET_TRACK_CONTROL;

// CLIENT_TransmitInfoForWeb   Interface Extension Parameters 
typedef struct tagNET_TRANSMIT_EXT_INFO
{
    DWORD           dwSize;
    unsigned char*  pInBinBuf;                      // Binary Input Data Buffer 
    DWORD           dwInBinBufSize;                 // Binary Input Data Length 
    int             nJsonDataLen;                   // Json Output Data Length
    int             nBinDataLen;                    // Binary Output Data Length
} NET_TRANSMIT_EXT_INFO;

// Monitor CAN Bus Data 
// fAttachProxyCB Parameter 
typedef struct tagNET_CB_CANDATA
{
    DWORD           dwSize;
    int             nDataLength;                    // Common Data Length
    unsigned char*  pDataContent;                   // Common Data Content
}NET_CB_CANDATA;

// Monitor CAN bus data callback function prototype ¡ê?lAttachHandle is return value of CLIENT_AttachCAN
typedef void (CALLBACK *fAttachCANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_CANDATA* pBuf, LDWORD dwUser);

// CLIENT_AttachCAN() Input Parameters 
typedef struct tagNET_IN_ATTACH_CAN
{
    DWORD          dwSize;
    int            nChannel;                        // Monitor CAN channel number 
    fAttachCANCB   cbAttachCAN;                     // Callback Registered Video Phone State Changes 
    LDWORD         dwUser;                          // User Data 
}NET_IN_ATTACH_CAN;

// CLIENT_AttachCAN() Output Parameters 
typedef struct tagNET_OUT_ATTACH_CAN
{
    DWORD          dwSize;
}NET_OUT_ATTACH_CAN;

// CLIENT_SendCAN() input parameter
typedef struct tagNET_IN_SEND_CAN
{
    DWORD          dwSize;
    int            nChannel;                       // CAN channel no.
	int            nSendDataLength;                // Send data length
    unsigned char* pSendData;                      // Send data content
}NET_IN_SEND_CAN;

// CLIENT_SendCAN() output parameter
typedef struct tagNET_OUT_SEND_CAN
{
    DWORD          dwSize;
}NET_OUT_SEND_CAN;

// parameter of fAttachDevCommCB
typedef struct tagNET_CB_DEVCOMMDATA
{
    DWORD           dwSize;
    int             nDataLength;                    // data length
    unsigned char*  pDataContent;                   // data content
}NET_CB_DEVCOMMDATA;

// callback prototype of listening to data from trans comm, lAttachHandle is return value of CLIENT_AttachDevComm
typedef void (CALLBACK *fAttachDevCommCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_DEVCOMMDATA* pBuf, LDWORD dwUser);

// CLIENT_AttachDevComm() input parameter
typedef struct tagNET_IN_ATTACH_DEVCOMM
{
    DWORD               dwSize;
    int                 nChannel;                        // channel
    fAttachDevCommCB    cbAttachDevComm;                 // callback function
    LDWORD              dwUser;                          // user param
}NET_IN_ATTACH_DEVCOMM;

// CLIENT_AttachDevComm() output parameter
typedef struct tagNET_OUT_ATTACH_DEVCOMM
{
    DWORD          dwSize;
}NET_OUT_ATTACH_DEVCOMM;

// Gets the current equipment serial number¡ê?corresponding CLIENT_QueryDevState() Interface's DH_DEVSTATE_GET_COMM_COUNT command parameter 
typedef struct tagNET_GET_COMM_COUNT
{
    DWORD          dwSize;
    int            nChannelCout;                    // Number Of Accessed serial port
}NET_GET_COMM_COUNT;

// CLIENT_ExChangeData  port input  structure 
typedef struct tagNET_IN_EXCHANGEDATA
{
    DWORD           dwSize;
    int             nChannel;                       // serial port no
    BOOL            bFlag;                          // TRUE is to send data and wait for response¡ê?FALSE is to collect data
    int             nCollectTime;                   // Serial collection time length(unit¡êoms)
    int             nSendDataLength;                // send data length¡ê?bFlag = TRUE valid
    unsigned char*  pSendData;                      // send data content¡ê?bFlag = TRUE valid
}NET_IN_EXCHANGEDATA;

// CLIENT_ExChangeData port output  structure 
typedef struct tagNET_OUT_EXCHANGEDATA
{
    DWORD           dwSize;
}NET_OUT_EXCHANGEDATA;

// PTZ preset
typedef struct tagNET_PTZ_PRESET 
{
    int                     nIndex;                         // no.
    char                    szName[PTZ_PRESET_NAME_LEN];    // name
    char                    szReserve[64];                  // reserve 64 bytes
} NET_PTZ_PRESET;

// PTZ preset list
typedef struct tagNET_PTZ_PRESET_LIST 
{
    DWORD                   dwSize;
    DWORD                   dwMaxPresetNum;                 // preset max
    DWORD                   dwRetPresetNum;                 // return preset quantity
    NET_PTZ_PRESET          *pstuPtzPorsetList;             // preset list(apply according to max quantity)
} NET_PTZ_PRESET_LIST;

// event type EVENT_IVS_TRAFFIC_RESTRICTED_PLATE (limited plate event)corresponding data module description info
typedef struct tagDEV_EVENT_TRAFFIC_RESTRICTED_PLATE
{
    int                     nChannelID;                     // channel no.
    char                    szName[DH_EVENT_NAME_LEN];      // event name
    int                     nTriggerType;                   // TriggerType:¡ê?0 vehicle detector¡ê?1 radar¡ê?2 video
    DWORD                   PTS;                            // time stamp(unit is ms)
    NET_TIME_EX             UTC;                            // event time
    int                     nEventID;                       // event ID
    int                     nSequence;                      // snapshot no.¡ê?as 3,2,1,1 means snapshot end,0 means abnormal end
    BYTE                    byEventAction;                  // event action¡ê?0 means impulse event,1 means continuous event start,2 means continuous event end;
    BYTE                    byImageIndex;                   // picture no., same time(to second)may have many pictures, from 0
    BYTE                    byReserved1[2];
    int                     nLane;                          // corresponding lane no.
    DH_MSG_OBJECT           stuObject;                      // detect object
    DH_MSG_OBJECT           stuVehicle;                     // vehicle info
    DH_EVENT_FILE_INFO      stuFileInfo;                    // event corresponding file info
    int                     nMark;                          // basic level generated trigger snapshot frame mark
    int                     nFrameSequence;                 // video analysis frame no.
    int                     nSource;                        // video analysis data surce address
    DWORD                   dwSnapFlagMask;                 // snapshot mark (by bit)¡ê?see NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // corresponding picture resolution
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // traffic vehicle info
    BYTE                    byReserved[1024];               // reserve text
    EVENT_COMM_INFO         stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_RESTRICTED_PLATE;

// event type EVENT_IVS_TRAFFIC_OVERSTOPLINE (cross line event)corresponding to data module info
typedef struct tagDEV_EVENT_TRAFFIC_OVERSTOPLINE
{
    int                     nChannelID;                     // channel no.
    char                    szName[DH_EVENT_NAME_LEN];      // event name
    int                     nTriggerType;                   // TriggerType: trigger type¡ê?0 detect¡ê?1 radar¡ê?2 video
    DWORD                   PTS;                            // time stamp( unit is ms)
    NET_TIME_EX             UTC;                            // event time
    int                     nEventID;                       // event ID
    int                     nSequence;                      // snapshot no.
    BYTE                    byEventAction;                  // event action¡ê?
    BYTE                    byImageIndex;                   //picture no., within same time, may have more than one picture, start ftom 0
    BYTE                    byReserved1[2];
    int                     nLane;                          // corresponding to lane no.
    DH_MSG_OBJECT           stuObject;                      // detected object
    DH_MSG_OBJECT           stuVehicle;                     // vehicle body info
    DH_EVENT_FILE_INFO      stuFileInfo;                    // event corresponding to text
    int                     nMark;                          // bottom trigger snapshot frame mark
    int                     nFrameSequence;                 // video analysis no.
    int                     nSource;                        // video analysis data source address
    DWORD                   dwSnapFlagMask;                 // snapshot maek¡ê?see NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // corresponding to picture resolution
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // traffic vehicle info
    int                     nSpeed;                         // vehicle speed,Km/h
    BYTE                    byReserved[1024];               // reserved text
    EVENT_COMM_INFO         stCommInfo;                     // public info 
}DEV_EVENT_TRAFFIC_OVERSTOPLINE;



// event type EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT(Traffic unfasten seat belt event event )corresponding to data block description info 
typedef struct tagDEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT
{
    int           nChannelID;					// channel no.
    char          szName[DH_EVENT_NAME_LEN];    // event name 
    int           nTriggerType;                 // TriggerType:trigger type ¡ê?0 vehicle detector¡ê?1 radar¡ê?2 video
    DWORD         PTS;                          // time stamp(unit is ms)
    NET_TIME_EX   UTC;                          // event occurred time
    int           nEventID;                     // event ID
    int           nSequence;                    // means snaoshot no.¡ê?as 3,2,1,1 means snapshotend ,0 means abnormal end
    BYTE          byEventAction;                // event  motion ¡ê?0 means pulse event ,1 means  continuity  event  start ,2 means  continuity  event end;  BYTE          byReserved1[2];
    BYTE          byImageIndex;                 // picture no., same time(accurate to second)may have multiple pictures , start from 0 
    BYTE          byReserved1[2];
    DH_EVENT_FILE_INFO   stuFileInfo;           // event corresponding to file info 
    int           nLane;                        // corresponding to lane no.
    int           nMark;                        // bottom generated trigger snapshot frame mark
    int           nFrameSequence;               // video analysis frame no.
    int           nSource;                      // video analysis data source address
    DH_MSG_OBJECT      stuObject;               // detection object 
    DH_MSG_OBJECT      stuVehicle;              // body info 
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // Traffic vehicle info 
    int           nSpeed;                       // vehicle actual speed,Km/h
    NET_SAFEBELT_STATE   emMainSeat;            // main driver seat belt status 
    NET_SAFEBELT_STATE   emSlaveSeat;           // co-drvier seat belt status 
    DWORD         dwSnapFlagMask;               // snapshot mark(by bit)¡ê?see NET_RESERVED_COMMON  
    DH_RESOLUTION_INFO   stuResolution;         // corresponding to picture resolution
    BYTE          byReserved[1024];             // reserved text
    EVENT_COMM_INFO     stCommInfo;             // public info 
}DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT;

// event type EVENT_IVS_TRAFFIC_DRIVER_SMOKING (driver smoke event )corresponding to data block description info 
typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_SMOKING
{
    int           nChannelID;                   // channel no.
    char          szName[DH_EVENT_NAME_LEN];    // event name 
    int           nTriggerType;                 // TriggerType: trigger type ¡ê?0 vehicle detector¡ê?1 radar¡ê?2 video
    DWORD         PTS;                          // time stamp(unit is ms)
    NET_TIME_EX   UTC;                          // event occurred time
    int           nEventID;                     // event ID
    int           nSequence;                    // means snapshot no.¡ê? as 3,2,1,1 means snapshot end,0 means abnormal end
    BYTE          byEventAction;                // event  motion ¡ê?0 means pulse  event ,1 means  continuity  event  start ,2 means  continuity  event end;  BYTE          byReserved1[2];
    BYTE          byImageIndex;                 // picture no., same time(accurate to second) may be multiple pictures , start from 0  
    BYTE          byReserved1[2];
    DH_EVENT_FILE_INFO   stuFileInfo;           // event corresponding to file info 
    int           nLane;                        // corresponding to lane no.
    int           nMark;                        // bottom occurred trigger snapshot mark
    int           nFrameSequence;               // video analysis frame no.
    int           nSource;                      // video analysis data source address
    DH_MSG_OBJECT      stuObject;               // detection received object 
    DH_MSG_OBJECT      stuVehicle;              // body info 
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // Traffic vehicle info 
    int           nSpeed;                       // car actual speed,Km/h
    DWORD         dwSnapFlagMask;               // snapshot mark(by bit)¡ê?see NET_RESERVED_COMMON  
    DH_RESOLUTION_INFO   stuResolution;         // corresponding to picture resolution
    EVENT_COMM_INFO     stCommInfo;             // public info 
    BYTE          byReserved[1024];             // reserve text
}DEV_EVENT_TRAFFIC_DRIVER_SMOKING;

// event type EVENT_IVS_TRAFFIC_DRIVER_CALLING(driver call event )corresponding to data block description info 
typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_CALLING
{
    int           nChannelID;                   // channel no.
    char          szName[DH_EVENT_NAME_LEN];    // event name 
    int           nTriggerType;                 // TriggerType: trigger type ¡ê?0 vehicle detector¡ê?1 radar¡ê?2 video
    DWORD         PTS;                          // time stamp(unit is ms)
    NET_TIME_EX   UTC;                          // event occurred time
    int           nEventID;                     // event ID
    int           nSequence;                    // means snapshot no.¡ê?as 3,2,1,1 means snapshot end,0 means abnormal end
    BYTE          byEventAction;                // event  motion ¡ê?0 means pulse  event ,1 means  continuity  event  start ,2 means  continuity  event end;  BYTE          byReserved1[2];
    BYTE          byImageIndex;                 // picture no., same time (accurate to second) maybe multiple picture , start from 0  
    BYTE          byReserved1[2];
    DH_EVENT_FILE_INFO   stuFileInfo;           // event corresponding to file info 
    int           nLane;                        // corresponding to lane no.
    int           nMark;                        // bottom trigger snapshot frame mark
    int           nFrameSequence;               // video analysis frame no.
    int           nSource;                      // video analysis data source address
    DH_MSG_OBJECT      stuObject;               // detection received object 
    DH_MSG_OBJECT      stuVehicle;              // body info 
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;    // Traffic vehicle info 
    int           nSpeed;                       // vehicle actual speed,Km/h
    DWORD         dwSnapFlagMask;               // snapshot mark(by bit)¡ê?see NET_RESERVED_COMMON  
    DH_RESOLUTION_INFO   stuResolution;         // corresponding to picture resolution
    EVENT_COMM_INFO     stCommInfo;             // public info 
    BYTE          byReserved[1024];             // reserve text
}DEV_EVENT_TRAFFIC_DRIVER_CALLING;

// event type EVENT_IVS_OBJECT_DETECTION(object feature detection event )corresponding to data description info 
typedef struct tagDEV_EVENT_TRAFFIC_OBJECT_DETECTION
{
    int	        nChannelID;                     // channel no.
    char        szName[128];                    // event name 
    char        bReserved1[4];                  // field align
    double      PTS;                            // time stamp(unit is ms)
    NET_TIME_EX     UTC;                        // event occurred time
    int         nEventID;                       // event ID
    DH_EVENT_FILE_INFO stuFileInfo;             // event corresponding to file info 
    BYTE        bEventAction;                   // event  motion ¡ê?0 means pulse event ,1 means  continuity  event  start ,2 means  continuity  event end;
    BYTE        byReserved[2];                  // reserved text
    BYTE        byImageIndex;                   // picture no., same time(accurate to second)may be multiple picture , start from 0 
    DWORD       dwSnapFlagMask;                 // snapshot mark(by bit)¡ê?see NET_RESERVED_COMMON  
    int         nSourceIndex;                   // event source device index,-1 means data invalid
    char        szSourceDevice[MAX_PATH];       // event source device SN, field does not exist or null means local device 
    unsigned int    nOccurrenceCount;           // event trigger accumilated times 
    int         nObjectNum;                     //object info number
    DH_MSG_OBJECT_EX  *pstObjectInfo;           //object info data 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;     // public info 
    BYTE        byReserved2[1020];              //reserved text
}DEV_EVENT_TRAFFIC_OBJECT_DETECTION;

// redundant power abnormal alarm
typedef struct tagALARM_POWER_ABNORMAL_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                     // channel no.
    NET_TIME                stuTime;                        // time
    DWORD                   dwAction;                       // event ation, 0:Start, 1:Stop
}ALARM_POWER_ABNORMAL_INFO;

// Tri-status enable
typedef enum tagNET_THREE_STATE_ENABLE
{
    EM_STATE_ENABLE_INVALID = 0,            // invalid
    EM_STATE_ENABLE_OFF,                    // off
    EM_STATE_ENABLE_ON,                     // on
} NET_THREE_STATE_ENABLE;

// config enable change reported event
typedef struct tagCONFIG_ENABLE_CHANGE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                     // chanle no., start from 0
    NET_THREE_STATE_ENABLE  emMotionDetect;                 // motion detect,     0: invalid , 1: off, 2: on
	NET_THREE_STATE_ENABLE  emLossDetect;                   // video loss enable, 0: invalid , 1: off, 2: on	NET_THREE_STATE_ENABLE  emBlindDetect;                  // video tempering enable, 0: invalid , 1: off, 2: on	NET_THREE_STATE_ENABLE  emAlarmLocal;                   // external alarm enable, 0: invalid , 1: off, 2: on
	NET_THREE_STATE_ENABLE  emBlindDetect;                  // blind detect enable, 0: invalid , 1: off, 2: on
	NET_THREE_STATE_ENABLE  emAlarmLocal;                   // alarm local enable, 0: invalid , 1: off, 2: on
}ALARM_CONFIG_ENABLE_CHANGE_INFO;

#define UPDATE_VERSION_LEN        64

// get device upgrade status corresponding structure 
typedef struct tagDHDEV_UPGRADE_STATE_INFO
{
    int                  nState;                            // 0:None- no update found, default status; 1:Regular-general upgrade; 
                                                            // 2:Emergency-forced; 3:Upgrading-upgrading
    
    char                szOldVersion[UPDATE_VERSION_LEN];   // old version
    char                szNewVersion[UPDATE_VERSION_LEN];   // new version
    DWORD               dwProgress;                         // upgrading progress
    int                 reserved[256];                      // reserve text
}DHDEV_UPGRADE_STATE_INFO;

// Warning line intrusion direction 
typedef enum tagNET_CROSSLINE_DIRECTION_INFO
{
    EM_CROSSLINE_DIRECTION_UNKNOW = 0 , 
    EM_CROSSLINE_DIRECTION_LEFT2RIGHT ,   //From left to right
    EM_CROSSLINE_DIRECTION_RIGHT2LEFT ,   //From right to left
    EM_CROSSLINE_DIRECTION_ANY        ,   
}NET_CROSSLINE_DIRECTION_INFO;

// Warning line event (Corresponding to event  DH_EVENT_CROSSLINE_DETECTION)
typedef struct tagALARM_EVENT_CROSSLINE_INFO
{
    DWORD                           dwSize;                         
    int					            nChannelID;						// Channel No.
    double				            PTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            UTC;							// Event occurrence time 
    int					            nEventID;						// Event ID
    int                             nEventAction;                   // Event operation. 0=pulse event.1=continious event begin. 2=continuous event stop

    NET_CROSSLINE_DIRECTION_INFO    emCrossDirection;               // Intrusion direction 
    int                             nOccurrenceCount;               // Triggered amount 
    int                             nLevel;                         // Event type
}ALARM_EVENT_CROSSLINE_INFO;


// Waring zone intrusion direction 
typedef enum tagNET_CROSSREGION_DIRECTION_INFO
{
    EM_CROSSREGION_DIRECTION_UNKNOW = 0 , 
    EM_CROSSREGION_DIRECTION_ENTER      ,   //Entry
    EM_CROSSREGION_DIRECTION_LEAVE      ,   //Exit
    EM_CROSSREGION_DIRECTION_APPEAR     ,   //Appear
    EM_CROSSREGION_DIRECTION_DISAPPEAR  ,   //Disappear
}NET_CROSSREGION_DIRECTION_INFO;

//Warning zone detected operation type 
typedef enum tagNET_CROSSREGION_ACTION_INFO
{
    EM_CROSSREGION_ACTION_UNKNOW = 0    , 
    EM_CROSSREGION_ACTION_INSIDE        ,   //In the area
    EM_CROSSREGION_ACTION_CROSS         ,   //Cross area
    EM_CROSSREGION_ACTION_APPEAR        ,   //Appear
    EM_CROSSREGION_ACTION_DISAPPEAR     ,   //Disappear 
}NET_CROSSREGION_ACTION_INFO;

//Warning zone event( Corresponding to event DH_EVENT_CROSSREGION_DETECTION)
typedef struct tagALARM_EVENT_CROSSREGION_INFO
{
    DWORD                           dwSize;    
    int					            nChannelID;						// Channel No. 
    double				            PTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			            UTC;							// Event occurrence time
	int					            nEventID;						// Event ID
    int                             nEventAction;                   // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop

    NET_CROSSREGION_DIRECTION_INFO  emDirection;                    // Warning zone intrusion direction
    NET_CROSSREGION_ACTION_INFO     emActionType;                   // Detected types in the warning zone 
    int                             nOccurrenceCount;               // Rule triggered amount
    int                             nLevel;                         // Event type
}ALARM_EVENT_CROSSREGION_INFO;


//Abandoned object event (Corresponding to event DH_EVENT_LEFT_DETECTION)
typedef struct tagALARM_EVENT_LEFT_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// Channel No.
    double				PTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			UTC;							// Event occurrence time 
    int					nEventID;						// Event ID
    int                 nEventAction;                   // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
    
    int                 nOccurrenceCount;               // Rule triggered amount
    int                 nLevel;                         // Event type 
}ALARM_EVENT_LEFT_INFO;

//Human face detect event( corresponding to event DH_EVENT_FACE_DETECTION)
typedef struct tagALARM_EVENT_FACE_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// Channel No.
    double				PTS;							// Time stamp (Unit is ms)
    NET_TIME_EX			UTC;							// Event occurrence time 
    int					nEventID;						// Event ID
    int                 nEventAction;                   // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
}ALARM_EVENT_FACE_INFO;

   
//IPC alarm,local alarm IPC send out by DVR or NVR(Corresponding to event  DH_ALARM_IPC)
typedef struct tagALARM_IPC_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// Channel No. 
    int                 nEventAction;                   // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
}ALARM_IPC_INFO;
/////////////////////////////////Burning Session /////////////////////////////////////////

// CLIENT_StartBurnSession port input parameter
typedef struct tagNET_IN_START_BURN_SESSION 
{
    DWORD               dwSize;
    unsigned int        nSessionID;                         // session ID
} NET_IN_START_BURN_SESSION;

typedef struct tagNET_OUT_START_BURN_SESSION 
{
    DWORD               dwSize;
} NET_OUT_START_BURN_SESSION;

// Burning session
typedef enum tagNET_BURN_MODE
{
    BURN_MODE_SYNC,                     // sync
    BURN_MODE_TURN,                     // turn
    BURN_MODE_CYCLE,                    // cycle
} NET_BURN_MODE;

// Extension Burning mode
typedef enum tagNET_BURN_EXTMODE
{
    BURN_EXTMODE_NORMAL = 1,                 // Normal Burning
    BURN_EXTMODE_NODISK,                     // Nodist Burning
} NET_BURN_EXTMODE;

// burning stream format
typedef enum tagNET_BURN_RECORD_PACK
{
    BURN_PACK_DHAV,                     // DHAV
    BURN_PACK_PS,                       // PS
    BURN_PACK_ASF,                      // ASF
    BURN_PACK_MP4,                      // MP4
    BURN_PACK_TS,                       // TS
} NET_BURN_RECORD_PACK;

// CLIENT_StartBurn port input parameter
typedef struct tagNET_IN_START_BURN 
{
    DWORD                dwSize;
    DWORD                dwDevMask;                             // burning device mask, by bit means multiple burning device group
    int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // burning channel group
    int                  nChannelCount;                         // burning channel number
    NET_BURN_MODE        emMode;                                // burning mode
    NET_BURN_RECORD_PACK emPack;                                // burning stream format
    NET_BURN_EXTMODE     emExtMode;                             // Extension Burning mode
} NET_IN_START_BURN;

// CLIENT_StartBurn port output parameter
typedef struct tagNET_OUT_START_BURN 
{
    DWORD               dwSize;
} NET_OUT_START_BURN;

// CLIENT_BurnMarkTag port input parameter
typedef struct tagNET_IN_BURN_MAAK_TAG
{
    DWORD               dwSize;
    const char*         pszDescInfo;                            // mark description info
} NET_IN_BURN_MARK_TAG;

// CLIENT_BurnMarkTag port output parameter
typedef struct tagNET_OUT_BURN_MAAK_TAG
{
    DWORD               dwSize;
} NET_OUT_BURN_MARK_TAG;

// CLIENT_BurnChangeDisk port input parameter
typedef struct tagNET_IN_BURN_CHANGE_DISK
{
    DWORD               dwSize;
    BOOL                nAction;                                // switch action, 0-start, 1-end
} NET_IN_BURN_CHANGE_DISK;

// CLIENT_BurnChangeDisk port output parameter
typedef struct tagNET_OUT_BURN_CHANGE_DISK
{
    DWORD               dwSize;
} NET_OUT_BURN_CHANGE_DISK;

// burning status
typedef enum tagNET_BURN_STATE
{
    BURN_STATE_STOP,                    // stop
    BURN_STATE_STOPING,                 // stoping
    BURN_STATE_INIT,                    // initialize
    BURN_STATE_BURNING,                 // burning
    BURN_STATE_PAUSE,                   // pause
    BURN_STATE_CHANGE_DISK,             // changing
    BURN_STATE_PREPARE_EXTRA_FILE,      // attachment initialize
    BURN_STATE_WAIT_EXTRA_FILE,         // wait for attachment burning
    BURN_STATE_UPLOAD_FILE_START,       // attachment burning
    BURN_STATE_CHECKING_DISK,           // detecting disk
    BURN_STATE_DISK_READY,              // disk is ready
} NET_BURN_STATE;

// burning error code
typedef enum tagNET_BURN_ERROR_CODE
{
    BURN_CODE_NORMAL,                   // normal
    BURN_CODE_UNKNOWN_ERROR,            // unknown error
    BURN_CODE_SPACE_FULL,               // burning full
    BURN_CODE_START_ERROR,              // start burning error
    BURN_CODE_STOP_ERROR,               // stop burning  error
    BURN_CODE_WRITE_ERROR,              // burning error
} NET_BURN_ERROR_CODE;

// CLIENT_BurnGetState port input parameter
typedef struct tagNET_IN_BURN_GET_STATE
{
    DWORD                dwSize;
} NET_IN_BURN_GET_STATE;

// burning device status
typedef struct tagNET_BURN_DEV_STATE 
{
    DWORD                dwSize;
    int                  nDeviceID;                             // ROM device ID
    char                 szDevName[DH_BURNING_DEV_NAMELEN];     // ROM devicename
    DWORD                dwTotalSpace;                          // ROM total capacity, uni KB
    DWORD                dwRemainSpace;                         // ROM remaining capacity, unit KB
} NET_BURN_DEV_STATE;

// CLIENT_BurnGetState port output parameter
typedef struct tagNET_OUT_BURN_GET_STATE
{
    DWORD                dwSize;
    NET_BURN_STATE       emState;                               // burning status
    NET_BURN_ERROR_CODE  emErrorCode;                           // error code
    DWORD                dwDevMask;                             // burning device mask, by bit means multiple device group
    int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // burning channel group
    int                  nChannelCount;                         // burning channel number
    NET_BURN_MODE        emMode;                                // burning mode
    NET_BURN_RECORD_PACK emPack;                                // burning stream format
    int                  nFileIndex;                            // current burning file no.
    NET_TIME             stuStartTime;                          // burning start time
    NET_BURN_DEV_STATE   stuDevState[DH_MAX_BURNING_DEV_NUM];   // burning device status
    int                  nRemainTime;                           // Event operation. 0=pulse event.1=continues event begin. 2=continuous event stop
} NET_OUT_BURN_GET_STATE;

// fAttachBurnStateCB parameter
typedef struct tagNET_CB_BURNSTATE
{
    DWORD               dwSize;
    const char*         szState;                        // info type
                                                        //"UploadFileStart"¡êomay start to upload attachment
                                                        //"InitBurnDevice":initialize burning device
                                                        //"Burning":burning
                                                        //"BurnExtraFileStop"¡êostop burning
                                                        //"BurnFilePause":pause burning
                                                        //"SpaceFull":burning space full
                                                        //"BurnFileError": burning error    
    const char*         szFileName;                     // current burning file name, use to "UploadFileStart" start upload attachment info
    unsigned int        dwTotalSpace;                   // total capacity, unit KB¡ê?use to "Burning" ¡ê?display capacity or calculate progress
    unsigned int        dwRemainSpace;                  // free capacity, unit KB¡ê?useto "Burning"
    const char*         szDeviceName;                   // burning device name, use for different burning devices
    int                 nRemainTime;                    // Burning remaining time. Unit is second. -1=invalid 
}NET_CB_BURNSTATE;

// burning device callback function original¡ê?lAttachHandle is CLIENT_AttachBurnState return value,each 1 item¡ê?pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAttachBurnStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURNSTATE* pBuf, int nBufLen, LDWORD dwUser);

// burning device callback extension function original
typedef void (CALLBACK *fAttachBurnStateCBEx)(LLONG lLoginID, LLONG lAttachHandle, NET_OUT_BURN_GET_STATE* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachBurnState() input parameter
typedef struct tagNET_IN_ATTACH_STATE
{
    DWORD                   dwSize;
    const char*             szDeviceName;                   // disk name¡ê?as "/dev/sda"
    fAttachBurnStateCB      cbAttachState;                  // burning listening callback
    LDWORD                  dwUser;                         // user data
    LLONG                   lBurnSession;                   // burning session handle, CLIENT_StartBurnSession retuen value. This value is 0, szDeviceName is valid, by burning device subscribe burning status
    fAttachBurnStateCBEx    cbAttachStateEx;                // extension burning listening callback
    LDWORD                  dwUserEx;                       // extension burninglistening callback user data
}NET_IN_ATTACH_STATE;

// CLIENT_AttachBurnState output parameter
typedef struct tagNET_OUT_ATTACH_STATE
{
    DWORD                   dwSize;
}NET_OUT_ATTACH_STATE;

// burning device callback function orginal¡ê?lUploadHandle is CLIENT_StartUploadFileBurned return value
typedef void (CALLBACK *fBurnFileCallBack) (LLONG lLoginID, LLONG lUploadHandle, int nTotalSize, int nSendSize, LDWORD dwUser);

// CLIENT_StartUploadFileBurned() input parameter
typedef struct tagNET_IN_FILEBURNED_START
{
    DWORD                   dwSize;
    const char*             szMode;                        // file upload method "append", append mode, now burning file name fixed as" FILE.zip ",filename ignored
    const char*             szDeviceName;                  // disk name¡ê?as ?¡ã/dev/sda?¡À
    const char*             szFilename;                    // local file name
    fBurnFileCallBack       cbBurnPos;                     // burning progress callback
    LDWORD                  dwUser;                        // user data
    LLONG                   lBurnSession;                  // burning handle, CLIENT_StartBurnSession return value This value is , szDeviceName valid, now by burning device subscribe burning status
}NET_IN_FILEBURNED_START;

// CLIENT_StartUploadFileBurned output parameter
typedef struct tagNET_OUT_FILEBURNED_START
{
    DWORD                   dwSize;
    char                    szState[DH_MAX_NAME_LEN];      // "start"¡êosystem is ready,may start to upload; "busy"¡êosystem busy, try later."error"¡êosystem is not burning, return error, request failed
}NET_OUT_FILEBURNED_START;

// burning case info
typedef struct tagNET_BURN_CASE_INFO
{
    DWORD       dwSize;
    int         nChannel;                                   // channel no.
    NET_TIME    stuStartTime;                               // burning start time
    NET_TIME    stuEndTime;                                 // burning end time
    int         nIndex;                                     // sn
    int         nCode;                                      // no.
    int         nDiscNum;                                   // disk no.        
    char        szName[DH_COMMON_STRING_128];               // name
    char        szPlace[DH_COMMON_STRING_128];              // location
    char        szInvestigator[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32]; // handled by
    char        szSuspects[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32];     // invloved
    char        szMemo[DH_COMMON_STRING_256];               // note
    char        szVideoName[DH_COMMON_STRING_128];          // record name
    char        szRecorder[DH_COMMON_STRING_32];            // burned by
} NET_BURN_CASE_INFO;

// burning device callback function original¡ê?lAttachHandle is CLIENT_AttachBurnCase return value
typedef void (CALLBACK *fBurnCaseCallBack) (LLONG lAttachHandle, NET_BURN_CASE_INFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachBurnCase port input parameter
typedef struct tagNET_IN_ATTACH_BURN_CASE
{
    DWORD                dwSize;
    fBurnCaseCallBack    cbBurnCase;                        // case info callback function
    LDWORD               dwUser;                            // user data
} NET_IN_ATTACH_BURN_CASE;

// CLIENT_AttachBurnCase port output parameter
typedef struct tagNET_OUT_ATTACH_BURN_CASE
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BURN_CASE;

// CD driver tray state
typedef enum tagEM_NET_BURN_DEV_TRAY_TYPE
{
    EM_NET_BURN_DEV_TRAY_TYPE_UNKNOWN,    // unknown
    EM_NET_BURN_DEV_TRAY_TYPE_READY,      // ready
    EM_NET_BURN_DEV_TRAY_TYPE_OPEN,       // open
    EM_NET_BURN_DEV_TRAY_TYPE_NODISK,     // no disk
    EM_NET_BURN_DEV_TRAY_TYPE_NOT_READY,  // not ready
}EM_NET_BURN_DEV_TRAY_TYPE;

// CD driver using state
typedef enum tagEM_NET_BURN_DEV_OPERATE_TYPE
{
    EM_NET_BURN_DEV_OPERATE_TYPE_UNKNOWN, // unknown
    EM_NET_BURN_DEV_OPERATE_TYPE_WRITE,   // write
    EM_NET_BURN_DEV_OPERATE_TYPE_READ,    // read
    EM_NET_BURN_DEV_OPERATE_TYPE_IDLE,    // idle
}EM_NET_BURN_DEV_OPERATE_TYPE;

// burning device state info
typedef enum tagEM_NET_BURN_DEV_BUS_TYPE
{
    EM_NET_BURN_DEV_BUS_TYPE_UNKNOWN,   // Unknown
    EM_NET_BURN_DEV_BUS_TYPE_IDE,       // IDE
    EM_NET_BURN_DEV_BUS_TYPE_USB,       // USB
    EM_NET_BURN_DEV_BUS_TYPE_1394,      // 1394
    EM_NET_BURN_DEV_BUS_TYPE_SATA,      // SATA
    EM_NET_BURN_DEV_BUS_TYPE_ESATA,     // ESATA
}EM_NET_BURN_DEV_BUS_TYPE;
// device burn medium type
typedef enum tagEM_NET_BURN_DEV_BK_TYPE
{
    EM_NET_BURN_DEV_BK_TYPE_UNKNOWN,    // Unknown
    EM_NET_BURN_DEV_BK_TYPE_DHFS,       // dahua file system
    EM_NET_BURN_DEV_BK_TYPE_DISK,       // Disk
    EM_NET_BURN_DEV_BK_TYPE_CDRW,       // cdrom
}EM_NET_BURN_DEV_BK_TYPE;
// device burn state information
typedef struct tagNET_BURN_DEV_STATE_INFO
{
    char            szName[DH_COMMON_STRING_256];               // burning device name
    unsigned int    nTotalSpace;                                // CD driver total space, unit KB
    unsigned int    nFreeSpace;                                 // CD driver free space, unit KB
    EM_NET_BURN_DEV_TRAY_TYPE        emTrayType;                // CD driver tray state
    EM_NET_BURN_DEV_OPERATE_TYPE     emOperateType;             // CD driver using state
    EM_NET_BURN_DEV_BUS_TYPE         emBusType;                 // burning device bus type
    EM_NET_BURN_DEV_BK_TYPE          emBkType;                  // burning device bk type
} NET_BURN_DEV_STATE_INFO;



// the info list of burning device's state
typedef struct tagNET_BURN_DEV_STATE_INFO_LIST
{
    unsigned int    nListCount; // list count
	NET_BURN_DEV_STATE_INFO *pstuNetBurnDevStateInfo;   // list info
}NET_BURN_DEV_STATE_INFO_LIST;

// burning device state callback function original,lAttachHandle is CLIENT_AttachBurnDevState return value
typedef void (CALLBACK *fBurnDevStateCallBack) (LLONG lAttachHandle, const NET_BURN_DEV_STATE_INFO_LIST* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachBurnDevState port input parameter
typedef struct tagNET_IN_ATTACH_BURN_DEV_STATE
{
    DWORD                       dwSize;
    fBurnDevStateCallBack       cbBurnDevState;             // burning device state callback function
    LDWORD                      dwUser;                     // user data
} NET_IN_ATTACH_BURN_DEV_STATE;

// CLIENT_AttachBurnDevState port output parameter
typedef struct tagNET_OUT_ATTACH_BURN_DEV_STATE
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BURN_DEV_STATE;

/////////////////////////////////// Storage ///////////////////////////////////////

// remote storage writing-in result
typedef enum tagNET_STORAGE_WRITE_STATE
{
    NS_WRITE_UNKNOWN,                                   // unknown
    NS_WRITE_OK,                                        // successful
    NS_WRITE_DISK_IO_ERROR,                             // disk IO error
    NS_WRITE_DISK_NOT_READY,                            // disk not ready
    NS_WRITE_DISK_FAULT,                                // disk failure
    NS_WRITE_STREAM_NOT_EXIST,                          // data stream ID inexists
    NS_WRITE_MOUNT_DISK_ERROR,                          // disk load error
} NET_STORAGE_WRITE_STATE;

// remote module info
typedef struct tagNET_STORAGE_BLOCK 
{
    DWORD                   dwSize;
    unsigned int            nID;                        // CQFS module ID
    unsigned int            nStreamID;                  // data stream SN
    unsigned int            nRecycleTimestamp;          // CQFS recycle time stamp
    unsigned int            nBeginTimestamp;            // module internal data start time stamp
    unsigned int            nEndTimestamp;              //  module internal data endtime stamp
    unsigned int            nLockCount;                 // lock value, 0 means not locked
    char                    szDiskUUID[DH_COMMON_STRING_64]; // disk UUID
} NET_STORAGE_BLOCK;

// remote storage info status
typedef struct tagNET_STORAGE_WRITE_INFO
{
    DWORD                    dwSize;
    NET_STORAGE_WRITE_STATE  emState;                   // writing in result
    int                      nBlockCount;               //  module quantity
    NET_STORAGE_BLOCK        stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; //  module info
} NET_STORAGE_WRITE_INFO;

//////////////////////////////////////////////////////////////////////////
/// \fn subscribe write-in remote storage info status callback function
/// \brief 
/// \author yang_xiuqing
/// \param  LLONG lAttachHandle [OUT] subscribe handle, CLIENT_NetStorageAttachWriteInfo return value 
/// \param  NET_STORAGE_WRITE_INFO * pBuf [OUT] remote storage info status
/// \param  int nBufLen [OUT] status info length
/// \param  LDWORD dwUser user data
/// \return n/a
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fNetStorageAttachWriteInfoCB)(LLONG lAttachHandle, NET_STORAGE_WRITE_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_NetStorageAttachWriteInfo port input parameter
typedef struct tagNET_IN_STORAGE_ATTACH_WRITE_INFO
{
    DWORD                           dwSize;
    const char*                     pszName;                // remote storage name, value from NAS config
    fNetStorageAttachWriteInfoCB    cbISCSIBlcok;           // callback function
    LDWORD                          dwUser;                 // user data
} NET_IN_STORAGE_ATTACH_WRITE_INFO;

// CLIENT_NetStorageAttachWriteInfo port output parameter
typedef struct tagNET_OUT_STORAGE_ATTACH_WRITE_INFO
{
    DWORD                       dwSize;
} NET_OUT_STORAGE_ATTACH_WRITE_INFO;

// CLIENT_NetStorageGetWriteInfo port input parameter
typedef struct tagNET_IN_STORAGE_GET_WRITE_INFO 
{
    DWORD                       dwSize;
    const char*                 pszName;                    // remote storage name
} NET_IN_STORAGE_GET_WRITE_INFO;

// CLIENT_NetStorageGetWriteInfo port output parameter
typedef struct tagNET_OUT_STORAGE_GET_WRITE_INFO 
{
    DWORD                       dwSize;    
    int                         nBlockCount;                //  module quantity
    NET_STORAGE_BLOCK           stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; //  module info
} NET_OUT_STORAGE_GET_WRITE_INFO;

// RAID operation type
typedef enum tagNET_RAID_OPERATE_TYPE
{
    NET_RAID_OPERATE_ADD,                    // add RAID, corresponding structure  NET_IN_RAID_ADD  and NET_OUT_RAID_ADD
    NET_RAID_OPERATE_REMOVE,                 // delete RAID, corresponding structure  NET_IN_RAID_REMOVE  and NET_OUT_RAID_REMOVE
    NET_RAID_OPERATE_GET_SUBDEVICE,          // get RAID sub device info, corresponding structure  NET_IN_RAID_GET_SUBDEVICE  and NET_OUT_RAID_GET_SUBDEVICE
    NET_RAID_OPERATE_GET_SUBSMART,           // get RAID sub device SMART info, corresponding structure  NET_IN_RAID_GET_SUBSMART  and NET_OUT_RAID_GET_SUBSMART
    NET_RAID_OPERATE_MODIFY,                 // modify RAID, corresponding to  structure  NET_IN_RAID_MODIFY and NET_OUT_RAID_MODIFY
} NET_RAID_OPERATE_TYPE;

// RAID info
typedef struct tagNET_RAID_INFO 
{
    DWORD                dwSize;
    char                 szName[DH_COMMON_STRING_64];     // name, as time name returned by device
    char                 szLevel[DH_COMMON_STRING_16];    // level, such as "RAID0", "RAID5" and etc.
    int                  nMemberNum;                      // member quantity
    char                 szMembers[DH_MAX_MEMBER_PER_RAID][DH_COMMON_STRING_64]; // member info
} NET_RAID_INFO;

// add RAID return result
typedef struct tagNET_RAID_ADD_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                    // failed error code
    char                 szName[DH_COMMON_STRING_64];    // name
} NET_RAID_ADD_RESULT;

// add RAID input parameter
typedef struct tagNET_IN_RAID_ADD 
{
    DWORD                dwSize;
    int                    nRaidNun;                        // RAID quantity
    NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID info
} NET_IN_RAID_ADD;

// add RAID oiutput parameter
typedef struct tagNET_OUT_RAID_ADD 
{
    DWORD                dwSize;
    int                  nResultNum;                        // result
    NET_RAID_ADD_RESULT  stuResults[DH_MAX_RAID_NUM];       // RAID operation result
} NET_OUT_RAID_ADD;

// delete RAID return result
typedef struct tagNET_RAID_REMOVE_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                       // failed error code
} NET_RAID_REMOVE_RESULT;

// delete RAID input parameter
typedef struct tagNET_IN_RAID_REMOVE 
{
    DWORD                dwSize;
    int                  nRaidNum;                         // RAID quantity
    char                 szRaids[DH_MAX_RAID_NUM][DH_COMMON_STRING_64];    // RAID name group
} NET_IN_RAID_REMOVE;

// delete RAID output parameter
typedef struct tagNET_OUT_RAID_REMOVE
{
    DWORD                dwSize;
    int                  nResultNum;                       // result
    NET_RAID_REMOVE_RESULT stuResults[DH_MAX_RAID_NUM];    // RAID operation result
} NET_OUT_RAID_REMOVE;

// get RAID sub device input parameter
typedef struct tagNET_IN_RAID_GET_SUBDEVICE 
{
    DWORD                dwSize;
    const char*          pszRaidName;                    // RAID name
} NET_IN_RAID_GET_SUBDEVICE;

// get RAID sub device output parameter
typedef struct tagNET_OUT_RAID_GET_SUBDEVICE 
{
    DWORD                dwSize;
    int                  nSubDeviceNum;                  // sub device quantity
    DH_STORAGE_DEVICE    stuSubDevices[DH_MAX_MEMBER_PER_RAID]; // sub device quantity
} NET_OUT_RAID_GET_SUBDEVICE;

// RAID sub device SMART info
typedef struct tagNET_RAID_SMART_INFO 
{
    DWORD                dwSize;
    unsigned int         nID;                            // property ID
    char                 szName[DH_COMMON_STRING_64];    // property name
    int                  nCurrent;                       // property value
    int                  nWorst;                         // max error value
    int                  nThreshold;                     // threshold
    int                  nPredict;                       // status
    char                 szRaw[DH_COMMON_STRING_16];     // actual value
} NET_RAID_SMART_INFO;

// get RAID sub device SMART info input parameter
typedef struct tagNET_IN_RAID_GET_SUBSMART
{
    DWORD                dwSize;
    const char*          pszSubDevName;                  // RAID sub device name 
} NET_IN_RAID_GET_SUBSMART;

// get RAID sub device SMART info output parameter
typedef struct tagNET_OUT_RAID_GET_SUBSMART
{
    DWORD                dwSize;
    int                  nSmartNum;                          // SMART info
    NET_RAID_SMART_INFO  stuSmartInfos[MAX_SMART_VALUE_NUM]; // SMART info
} NET_OUT_RAID_GET_SUBSMART;

// modify RAID return result
typedef struct tagNET_RAID_MODIFY_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                       // failed error code
} NET_RAID_MODIFY_RESULT;

// modify RAID input parameter
typedef struct tagNET_IN_RAID_MODIFY
{
    DWORD                dwSize;
    int                  nRaidNun;                          // RAID quantity
    NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID info
} NET_IN_RAID_MODIFY;

// modify RAID output parameter
typedef struct tagNET_OUT_RAID_MODIFY 
{
    DWORD                dwSize;
    int                  nResultNum;                        // result
    NET_RAID_MODIFY_RESULT stuResults[DH_MAX_RAID_NUM];     // RAID operation result
} NET_OUT_RAID_MODIFY;


//////////////////////////////// external device //////////////////////////////////////////

// external device type
typedef enum tagNET_EXT_DEV_TYPE
{
    EXT_DEV_UNKNOWN,                    // unknow
    EXT_DEV_PROJECTOR,                  // projector
    EXT_DEV_SEQUENCE_POWER,            // power sequence
} NET_EXT_DEV_TYPE;

// external device info
typedef struct tagNET_EXTERNAL_DEVICE 
{
    DWORD               dwSize;
    NET_EXT_DEV_TYPE    emType;                             // device type
    char                szDevID[DH_DEV_ID_LEN_EX];          // device ID, SN
    char                szDevName[DH_DEV_ID_LEN_EX];        // device name 
} NET_EXTERNAL_DEVICE;

// power sequence control parameter
typedef struct tagNET_CTRL_SEQPOWER_PARAM
{
    DWORD               dwSize;
    const char*         pszDeviceID;                        // device ID
    int                 nChannel;                           // output or output sequence
} NET_CTRL_SEQPOWER_PARAM;

// projector control parameter
typedef struct tagNET_CTRL_PROJECTOR_PARAM 
{
    DWORD               dwSize;
    const char*         pszDeviceID;                        // device ID
} NET_CTRL_PROJECTOR_PARAM;

// IR button
typedef struct tagNET_CTRL_INFRARED_KEY_PARAM 
{
    DWORD               dwSize;
    int                 nChannel;                           // IR control channel no.
    unsigned int        nKey;                               // IR button ID
} NET_CTRL_INFRARED_KEY_PARAM;

// no HDD alarm
typedef struct tagALARM_NO_DISK_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;                            // time
    DWORD               dwAction;                           // event action, 0:Start, 1:Stop
}ALARM_NO_DISK_INFO;
//protective capsule status enumeration
typedef enum __EM_CAPSULE_STATE
{
    CAPSULE_STATE_UNKNOW ,      //undefine
    CAPSULE_STATE_NORMAL ,      //normal
    CAPSULE_STATE_TIME_OUT ,    //overtime
    CAPSULE_STATE_EMERGENCY_CALL,   //sos call
}EM_CAPSULE_STATE;

//protective capsule event
typedef struct tagALARM_PROTECTIVE_CAPSULE_INFO
{
    DWORD               dwSize;
    EM_CAPSULE_STATE    emCapsuleState; //protective capsule status
    DWORD               nLock;          //0:unlock¡ê?1:lock; only when emCapsuleStateis CAPSULE_STATE_NORMAL valid
    DWORD               nInfrared;      //0:idle (no one),1:trigger(someone); only emCapsuleState is CAPSULE_STATE_NORMAL valid
}ALARM_PROTECTIVE_CAPSULE_INFO;

// Get Fish eye capacity input parameter 
typedef struct tagNET_IN_VIDEOIN_FISHEYE_CAPS
{
    DWORD       dwSize; 
    int         nChannel; //channel no.
}NET_IN_VIDEOIN_FISHEYE_CAPS;

// Get Fish eye capacity  output parameter 
typedef struct tagNET_OUT_VIDEOIN_FISHEYE_CAPS
{
    DWORD                   dwSize; 
    int                     nMountModeNum;              // supported installation mode number     
    NET_FISHEYE_MOUNT_MODE  emMountModes[NET_MAX_FISHEYE_MOUNTMODE_NUM]; // supported installation mode list
    int                     nCalibrateModeNum;          // supported Fish eye correction mode number  
    NET_FISHEYE_CALIBRATE_MODE emCalibrateModes[NET_MAX_FISHEYE_CALIBRATEMODE_NUM]; // supported Fish eye correction mode list
    int                     nEPtzCmdNum;                // supported Fish eye E-PTZ operation number 
    NET_FISHEYE_EPTZ_CMD    emEPtzCmds[NET_MAX_FISHEYE_EPTZCMD_NUM]; // supported Fish eye E-PTZ operationlist
    NET_FISHEYE_TYPE        emType;                     //Fish eye type 
}NET_OUT_VIDEOIN_FISHEYE_CAPS;

// get power sequence input parameter
typedef struct tagNET_IN_CAP_SEQPOWER 
{
    DWORD                dwSize;
    const char*          pszDeviceID;                       // device ID
} NET_IN_CAP_SEQPOWER;

// get power sequence output parameter
typedef struct tagNET_OUT_CAP_SEQPOWER
{
    DWORD                dwSize;
    int                  nChannelNum;                       // channel no.
} NET_OUT_CAP_SEQPOWER;

// get device encode config corresponding capacity input parameter
typedef struct tagNET_IN_ENCODE_CFG_CAPS
{
    DWORD               dwSize;           
    int                 nChannelId;                         // channel no.    
    int                 nStreamType;                        // stream type¡ê?0¡êomain stream¡ê?1¡êosub stream1¡ê?2¡êosub stream2¡ê?3¡êosub stream3¡ê?4¡êosnapshot stream
															// can be left unset, whatever value it is set, you get results of main stream, sub stream1 and snapshot stream
    char*               pchEncodeJson;                      // Encode config¡ê?cia calling dhconfigsdk.dll port CLIENT_PacketData to get
                                                            // correspondingsampling command is CFG_CMD_ENCODE                 
}NET_IN_ENCODE_CFG_CAPS;

// stream config corresponding capacity
typedef struct tagNET_STREAM_CFG_CAPS
{
    DWORD               dwSize;
    int                 nAudioCompressionTypes[DH_MAX_AUDIO_ENCODE_TYPE]; // supported audio encode type¡ê?see DH_TALK_CODING_TYPE
    int                 nAudioCompressionTypeNum;                   // audio compression quantity
    int                 dwEncodeModeMask;                           // video encode mode mask¡ê?see "encode mode"
    DH_RESOLUTION_INFO  stuResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// supportedvideo resolution, discard
    int                 nResolutionFPSMax[DH_MAX_CAPTURE_SIZE_NUM]; // different resolution max frame, subscript nResolutionTypescorresponding 
    int                 nResolutionTypeNum;                         // video resolution quantity
    int                 nMaxBitRateOptions;                         // max video stream(kbps) 
    int                 nMinBitRateOptions;                         // min video stream(kbps)
    BYTE                bH264ProfileRank[DH_PROFILE_HIGH];          // supported¦Ì?H.264 Profile level,refer to enumeration type EM_H264_PROFILE_RANK;  
    int                 nH264ProfileRankNum;                        // supported H.264 Profile level
    int                 nCifPFrameMaxSize;                          // when resolution is  cif, max p frame(Kbps)
    int                 nCifPFrameMinSize;                          // when currentresolution is cif, min p frame(Kbps)
    int                 nFPSMax;                                    // video max frame rate¡ê?as 0 ¡ê?make nResolutionFPSMax as standard
    DH_RESOLUTION_INFO  stuIndivResolutionTypes[DH_MAX_COMPRESSION_TYPES_NUM][DH_MAX_CAPTURE_SIZE_NUM];// supportedvideo resolution
	BOOL				abIndivResolution;							// 0: stuResolutionTypes,nResolutionTypeNum is valid
                                                                    // 1: stuIndivResolutionTypes, nIndivResolutionNums is valid
    int                 nIndivResolutionNums[DH_MAX_COMPRESSION_TYPES_NUM];// 2?¨ª?¡À¨¤???¡ê¨º?¡¤?¡Àe?¡ì3?¦Ì?¨º¨®?¦Ì¡¤?¡À??¨º??¨ºy
}NET_STREAM_CFG_CAPS;

// get device encode config corresponding capacity output parameter
typedef struct tagNET_OUT_ENCODE_CFG_CAPS
{
    DWORD               dwSize;
    NET_STREAM_CFG_CAPS stuMainFormatCaps[DH_REC_TYPE_NUM];         // main stream corresponding capacity
    NET_STREAM_CFG_CAPS stuExtraFormatCaps[DH_N_ENCODE_AUX];        // sub streamconfig corresponding capacity
    NET_STREAM_CFG_CAPS stuSnapFormatCaps[SNAP_TYP_NUM];            // sub stream config corresponding capacity
    int                 nMainFormCaps;                              // ÓÐÐ§µÄÖ÷ÂëÁ÷ÅäÖÃ¶ÔÓ¦µÄÄÜÁ¦¸öÊý
    int                 nExtraFormCaps;                             // ÓÐÐ§µÄ¸¨ÂëÁ÷ÅäÖÃ¶ÔÓ¦µÄÄÜÁ¦¸öÊý
    int                 nSnapFormatCaps;                            // ÓÐÐ§µÄ×¥Í¼ÂëÁ÷ÅäÖÃ¶ÔÓ¦µÄÄÜÁ¦¸öÊý
}NET_OUT_ENCODE_CFG_CAPS;

// Video detect device caps
typedef struct tagNET_IN_VIDEO_DETECT_CAPS
{
    DWORD               dwSize;           
    int                 nChannel;  //channel, start from 0
}NET_IN_VIDEO_DETECT_CAPS;

// media capability type
typedef enum tagNET_MEDIA_CAP_TYPE
{
    NET_MEDIA_CAP_TYPE_SENSORINFO,      // camera sensor info
} NET_MEDIA_CAP_TYPE;

// CLIENT_GetDevCaps NET_MEDIAMANAGER_CAPS input parameter
typedef struct tagNET_IN_MEDIAMANAGER_GETCAPS
{
    DWORD               dwSize;
    NET_MEDIA_CAP_TYPE  emType;         // capability type to query
} NET_IN_MEDIAMANAGER_GETCAPS;

// get snap config capbility input parameter	 
typedef struct tagNET_IN_SNAP_CFG_CAPS	 	 	 
{        	 	 	 
    int                 nChannelId;                     // channel num(start from 0) 	 	 	 
    BYTE                bReserved[1024];                // Reserved	 	 	 
}NET_IN_SNAP_CFG_CAPS;	 	 	 

#define DH_MAX_FPS_NUM                128                // max length of nFramesPerSecList array	 	 	 
#define DH_MAX_QUALITY_NUM            32                 // max length of nQualityList array	 	 	 

// get snap config capbility output parameter	 	 	 
typedef struct tagNET_OUT_SNAP_CFG_CAPS 	 	 	 
{	 	 	 
    int                 nResolutionTypeNum;                // valid length of stuResolutionTypes array	 	 	 
    DH_RESOLUTION_INFO  stuResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];	 	 	 
    DWORD               dwFramesPerSecNum;                 // valid length of nFramesPerSecList array		 	 	 
    int                 nFramesPerSecList[DH_MAX_FPS_NUM]; // -25:1f/25s;-24:1f/24s;-23:1f/23s;-22:1f/23s¡­¡­
                                                           // 0: invalid;1:1f/s;2:2f/s;3:13f/s
                                                           // 4:4f/s;5:5f/s;17:17f/s;18:18f/s
                                                           // 19:19f/s;20:20f/s¡­¡­
												           // 25: 25f/s 	  	 	 
    DWORD               dwQualityMun;                      // valid length of nQualityList array	 	 	 
    DWORD               nQualityList[DH_MAX_QUALITY_NUM];  // Image quality(1-6,6 means the best quality)
                                                           // 6:100%; 5:80%; 4:60% 3:50%; 2:30%; 1:10%	 	 
    DWORD               dwMode;                            // (Bit)0:activate scheduled snapshot,1:Manually activate snapshot	 	 	 
    DWORD               dwFormat;                          // (Bit)0:BMP format,1:JPG format 	 	 
    BYTE                bReserved[2048];                   // Reserved	 	 
} NET_OUT_SNAP_CFG_CAPS;

// camera sensor type
typedef enum tagNET_CAMERA_SENSOR
{
    NET_CAMERA_SENSOR_NORMAL,           // normal (visible light)
    NET_CAMERA_SENSOR_LEPTON,           // Lepton infrared
    NET_CAMERA_SENSOR_TAU,              // Tau infrared
} NET_CAMERA_SENSOR;

// camera sensor info
typedef struct tagNET_CAMERA_SENSORINFO
{
    NET_CAMERA_SENSOR   emSensorType;       // sensor type
    int                 nChannelsCount;     // count of channels of the sensor type
    int                 nChannels[512];     // channels of the sensor type
    char                reserved[512];
} NET_CAMERA_SENSORINFO;

// media info - camera sensor
typedef struct tagNET_MEDIA_SENSORINFO
{
    BOOL                    bSupport;               // whether or not support querying this capability. when TRUE, members below are valid
    int                     nSensorTypeCount;       // count of sensor types of the device
    NET_CAMERA_SENSORINFO   stuDetail[16];          // detailed info for each sensor type, nSensorTypeCount elements are in effect 
    char                    reserved[1024];
} NET_MEDIA_SENSORINFO;

// CLIENT_GetDevCaps NET_MEDIAMANAGER_CAPS output parameter
typedef struct tagNET_OUT_MEDIAMANAGER_GETCAPS
{
    DWORD                   dwSize;
    NET_MEDIA_SENSORINFO    stuSensorInfo;           // camera sensor info
} NET_OUT_MEDIAMANAGER_GETCAPS;

// CLIENT_GetDevCaps  NET_VIDEO_MOSAIC_CAPS input parameter
typedef struct tagNET_IN_MEDIA_VIDEOMOSAIC_GETCAPS
{
	DWORD               dwSize;						// the size of this struct
} NET_IN_MEDIA_VIDEOMOSAIC_GETCAPS;

// CLIENT_GetDevCaps  NET_VIDEO_MOSAIC_CAPS output parameter
typedef struct tagNET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS
{
	DWORD               dwSize;									// the size of this struct
	int					nSupportCount;							// counts of supports channels of the device
	short				snSupport[MAX_MOSAIC_CHANNEL_NUM];		// the channels which supported mosaic, -1 mean all
	int					nMosaicCount;							// the count of mosaic particles
	char				szMosaic[MAX_MOSAIC_NUM];				// the size of mosaic particles
	DH_SIZE				stuRectMax;								// the max size of mosaic block
	DH_SIZE				stuRectMin;								// the min size of mosaic block
} NET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS;


typedef enum tagEM_DETECT_VERSION_TYPE
{
    EM_DETECT_VERSION_UNKNOW = 0 , 
    EM_DETECT_VERSION_V1_0 ,           //Ver1 motion detection
    EM_DETECT_VERSION_V3_0 ,           //Ver3 motion detection
}EM_DETECT_VERSION_TYPE;
#define    MAX_DETECT_VERSION_NUM           64

typedef enum tagEM_BLIND_DETECT_VERSION_TYPE
{
    EM_BLIND_DETECT_VERSION_UNKNOW = 0 ,
    EM_BLIND_DETECT_VERSION_FULL_SCREEN ,   //Full screen detection
    EM_BLIND_DETECT_VERSION_MULTI_WINDOW ,  //Multi window detection
}EM_BLIND_DETECT_VERSION_TYPE;
#define    MAX_BLIND_DETECT_VERSION_NUM     64

typedef struct tagNET_OUT_VIDEO_DETECT_CAPS
{
        DWORD                       dwSize;         
        BOOL                        bSupportBlind;          //Is support BlindScreen detect, TRUE:yes, FALSE:no
        BOOL                        bSupportLoss;           //Is support VideoLoss detect, TRUE:yes, FALSE:no
        BOOL                        bSupportMotion;         //Is support VideoMotion detect, TRUE:yes, FALSE:no
        BOOL                        bMotionResult;          //Is support to get motion detect result in every region
        DWORD                       nMotionColumns;         //Columns of motion detect detect region
        DWORD                       nMotionRows;            //Rows of motion detect detect region
        DWORD                       nMotionDetectWindow;    //Video windows of motion detect
        DWORD                       nBlindColumns;          //Columns of video blind detect region
        DWORD                       nBlindRows;             //Rows of video blind detect region
        DWORD                       nBlindDetectWindow;     //Video windows of video blind detect
        BOOL                        bPositionDetect;        //Is support motion position detect
        DWORD                       nDetectVersionNum;      //Number of supported motion detect versions
        EM_DETECT_VERSION_TYPE      emDetectVersions[MAX_DETECT_VERSION_NUM];               //Supported motion detect versions info
        DWORD                       nBlindDetectVersionNum; //Number of supported video blind detect versions
        EM_BLIND_DETECT_VERSION_TYPE emBlindDetectVersions[MAX_BLIND_DETECT_VERSION_NUM];   //Supported video blind detect versions info
        BOOL                        bMotionLinkPtzPreset;   //Is support motion detect linked ptz preset, TRUE:yes, FALSE:no
        BOOL                        bMotionLinkPtzTour;     //Is support motion detect linked ptz tour, TRUE:yes, FALSE:no
        BOOL                        bMotionLinkPtzPattern;  //Is support motion detect linked ptz pattern, TRUE:yes, FALSE:no
        BOOL                        bUnFocusDetect;         //Is support unfocus detect, TRUE:yes, FALSE:no
        BOOL                        bAlarmDetect;           //Is support detect and trigger alarm when motion detect is working, TRUE:yes, FALSE:no
		BOOL						bSupportMoveDetect;		//Is support Moved detect, TRUE:yes, FALSE:no
}NET_OUT_VIDEO_DETECT_CAPS;

// fall event type
typedef struct tagALARM_FALLING_INFO
{
    DWORD               dwStructSize;                               //  structure size
    BYTE                bEventAction;                               // event action¡ê?0 means impulse event,1 means continuous event start,2 means continuous event end;
    BYTE                byRserved[3];                               // align                                                                                                                                                                                                                                                                        
}ALARM_FALLING_INFO;

//order Bus status call function model
typedef void (CALLBACK *fBusStateCallBack)(LLONG lAttachHandle, LONG lCommand, char *pBuf, DWORD dwBufLen, LDWORD dwUser);

// swipe card type
typedef enum tagNET_DRIVER_CHECK_TYPE
{
    NET_DRIVER_CHECK_TYPE_UNKNOWN,                                  // unknow
    NET_DRIVER_CHECK_TYPE_SIGNIN,                                   // sign up
    NET_DRIVER_CHECK_TYPE_SIGNOUT,                                  // sign out
} NET_DRIVER_CHECK_TYPE;

// swipe card
typedef enum tagNET_DRIVER_CHECK_METHOD
{
    NET_DRIVER_CHECK_METHOD_UNKNOWN,                                // unknown
    NET_DRIVER_CHECK_METHOD_POS,                                    // POS device
    NET_DRIVER_CHECK_METHOD_HAND,                                   // manually input
} NET_DRIVER_CHECK_METHOD;

// alarm event type DH_ALARM_BUS_DRIVER_CHECK( driver recognition card detection event)corresponding to data description info
typedef struct tagALARM_BUS_DRIVER_CHECK_INFO
{
    DWORD                   dwSize;
    char                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];       // plate
    char                    szDriverName[DH_COMMON_STRING_16];      // driver name
    char                    szDriverID[DH_MAX_PERSON_ID_LEN];       // ID
    char                    szOrganize[DH_COMMON_STRING_128];       // licence issuing organization name
    NET_TIME_EX             stUsefulLife;                           // licence validity
    NET_GPS_STATUS_INFO     stGPSStatusInfo;                        // GPS info
    NET_TIME_EX             stCheckTime;                            // sign up time
    NET_DRIVER_CHECK_METHOD emCheckMethod;                          // sign up method
    NET_DRIVER_CHECK_TYPE   emCheckType;                            // sign up type
}ALARM_BUS_DRIVER_CHECK_INFO;

// alarm event type DH_ALARM_DEVICE_MSG_NOTIFY(device to platform notice event)corresponding to data description info
typedef struct tagALARM_DEVICE_MSG_NOTIFY_INFO
{
    DWORD                   dwSize;
    char                    szMsg[DH_COMMON_STRING_256];            // message content
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
} ALARM_DEVICE_MSG_NOTIFY_INFO;

// alarm event type DH_ALARM_VEHICLE_STANDING_OVER_TIME(parking timeout alarm)corresponding to  data description info
typedef struct tagALARM_VEHICLE_STANDING_OVER_TIME_INFO
{
    DWORD                   dwSize;
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
    NET_TIME_EX             stuTime;                                // first occurance time
    NET_TIME_EX             stuUtc;                                 // current event occurrence time
    DWORD                   dwUtc;                                  // current event occurrence time
    BOOL                    bEventConfirm;                          // confirm needed or not, invalid in CLIENT_StartListenEx callback
} ALARM_VEHICLE_STANDING_OVER_TIME_INFO;

// direction
typedef enum tagNET_LINE_DIRECTION
{
    NET_LINE_DIRECTION_UNKNOWN,                                     // unknown
    NET_LINE_DIRECTION_POSTIVE,                                     // firward direction
    NET_LINE_DIRECTION_NEGATIVE,                                    // opposite direction
    NET_LINE_DIRECTION_AROUND,                                      // loop
    NET_LINE_DIRECTION_DISPERSE,                                    // disperse
} NET_LINE_DIRECTION;

// in/out station status
typedef enum tagNET_BUS_STATE
{
    NET_BUS_STATE_UNKNOWN,                                         // unknown
    NET_BUS_STATE_ILLEGAL,                                         // illegal
    NET_BUS_STATE_LEGAL,                                           // legal
} NET_BUS_STATE;

// stop announcement method
typedef enum tagNET_PORT_TYPE
{
    NET_PORT_TYPE_UNKOWN,                                           // unknown
    NET_PORT_TYPE_MANUAL,                                           // manual stop announcement
    NET_PORT_TYPE_GPS,                                              // GPS stopannouncement
} NET_PORT_TYPE;

// mobile unlock event data type 
typedef enum tagEM_VEHICLE_DATA_TYPE
{
    EM_VEHICLE_DOOR_OPEN_DATA_UNKNOWN = 0,
    EM_VEHICLE_DOOR_OPEN_DATA_REALTIME,               // real-time data
    EM_VEHICLE_DOOR_OPEN_DATA_HISTORY,                // re-send data
}EM_VEHICLE_DATA_TYPE;

// alarm event type DH_ALARM_BUS_IMPORT_SITE(in station event)corresponding to data description info
typedef struct tagALARM_BUS_IMPORT_SITE_INFO
{
    DWORD                   dwSize;
    char                    szSiteID[DH_COMMON_STRING_64];          // station mark
    DWORD                   dwSiteNum;                              // stop order
    NET_LINE_DIRECTION      emDirection;                            // direction
    char                    szLineID[DH_COMMON_STRING_64];          // maek
    NET_TIME_EX             stuTime;                                // in/out station time
    int                     nTime;                                  // used to confirm event time, UTC, unit is second
    NET_BUS_STATE           emState;                                // if in/out station on time
    NET_PORT_TYPE           emType;                                 // stop announcement method
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
    DWORD                   dwSiteCount;                            // total stop point
    char                    szSiteName[DH_COMMON_STRING_64];        // stop name 
    char                    szDesignation[DH_COMMON_STRING_64];     // path no.
    EM_VEHICLE_DATA_TYPE    emDataType;                             // event data type 
    BOOL                    bNeedConfirm;                           // confirm or not, via callCLIENT_BusConfirmEventport to confirm
} ALARM_BUS_IMPORT_SITE_INFO;

//alarm event type DH_ALARM_BUS_EXPORT_SITE(out station event)corresponding to data description info
typedef struct tagALARM_BUS_EXPORT_SITE_INFO
{
    DWORD                   dwSize;
    char                    szSiteID[DH_COMMON_STRING_64];          // stop mark
    DWORD                   dwSiteNum;                              // order
    NET_LINE_DIRECTION      emDirection;                            // direction
    char                    szLineID[DH_COMMON_STRING_64];          // mark
    NET_TIME_EX             stuTime;                                // in/out station time
    int                     nTime;                                  // used to confirm  event time, UTC, unit is second
    NET_BUS_STATE           emState;                                // if out station on time
    NET_PORT_TYPE           emType;                                 // stop announcement method
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
    DWORD                   dwSiteCount;                            // total stop point
    char                    szSiteName[DH_COMMON_STRING_64];        // stop name 
    char                    szDesignation[DH_COMMON_STRING_64];     // path no.
    EM_VEHICLE_DATA_TYPE    emDataType;                             // event data type 
    BOOL                    bNeedConfirm;                           // confirm or not, via call CLIENT_BusConfirmEventport to confirm
} ALARM_BUS_EXPORT_SITE_INFO;

// abnormal event type 
typedef enum tagEM_ALARM_BUS_ABNORMAL_EVENT_TYPE
{
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_UNKNOWN,      // unknown 
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RUNNING,      // recover operation¡ê?"Running"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MEAL,         // eat¡ê?"Meal"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BLOCK,        // jam¡ê?"Block"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CALL,         // call¡ê?"Call"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BREAKDOWN,    // breakdown¡ê?"Breakdown"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISCONTINUED, // stop operation¡ê?"Discontinued"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ROBING,       // robing¡ê?"Robing"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERLOAD,     // overload¡ê?"Overload"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISPUTE,      // dispute¡ê?"Dispute"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ACCIDENT,     // event¡ê?"Accident"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERSPEED,    // over speed¡ê?"OverSpeed"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RENTAL,       // rental¡ê?"Rental"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MAINTENANCE,  // maintenance¡ê?"Maintenance"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CLOSURE,      // closure¡ê?"Closure"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_PUBSECURITY,       // "PubSecurity"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ENTER_PARK,        // "EnterPark"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_LEAVE_PARK,        // "LeavePark"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_REFUEL,            // "Refuel"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_FIRE,              // "Fire"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_HELP,              // "Help"
}EM_ALARM_BUS_ABNORMAL_EVENT_TYPE;

// alarm event type DH_ALARM_BUS_ABNORMAL(vehicle abnormal event )corresponding to data description info 
typedef struct tagALARM_BUS_ABNORMAL_INFO
{
    DWORD                   dwSize;
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE    emEventType;            // abnormal event type 
    char                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];   // plate
    char                    szLineID[DH_COMMON_STRING_64];      // path mark
    NET_LINE_DIRECTION      emLineDirection;                    // path direction
    NET_TIME_EX             stuTime;                            // occur time
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                   // GPSinfo 
} ALARM_BUS_ABNORMAL_INFO;

// alarm event type DH_ALARM_ENCLOSURE_ALARM(e-fence event)corresponding to data description info
typedef struct tagALARM_ENCLOSURE_ALARM_INFO
{
    DWORD                   dwSize;
    DWORD                   dwAlarmType;                            // alarm type, by bit means¡ê?
                                                                    // 0:LimitSpeed, 1:DriveAllow, 2:ForbidDrive, 3:LoadGoods, 4:UploadGoods
    DWORD                   dwAlarmDetail;                          // alarm description, by bit means,
                                                                    // 0:DriveIn, 1:DriveOut, 2:Overspeed, 3:SpeedClear
    NET_BUS_STATE           emState;                                // if trigger event by schedules time
    DWORD                   dwDriverNo;                             // driver no.
    DWORD                   dwEnclosureID;                          // fence ID
    DWORD                   dwLimitSpeed;                           // speed limit
    DWORD                   dwCurrentSpeed;                         // current speed
    NET_TIME_EX             stuTime;                                // current time
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS info
} ALARM_ENCLOSURE_ALARM_INFO;

// mobile door status 
typedef NET_ACCESS_CTL_STATUS_TYPE NET_VEHICLE_DOOR_STATUS;

// mobile unlock event , corresponding to event type DH_VEHICLE_DOOR_OPEN
typedef struct tagALARM_VEHICLE_DOOR_OPEN_INFO 
{
    DWORD                   dwSize;
    NET_VEHICLE_DOOR_STATUS emStatus;           // door status 
    int                     nDoor;              // door no., 1:front door,2:middle door,3:rear door
    NET_TIME                stuTime;            // event time, UTC
    int                     nTime;              // used to confirm  event used time, UTC, unit is second
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;   // GPSinfo 
    EM_VEHICLE_DATA_TYPE    emDataType;         // event  data  type 
    BOOL                    bNeedConfirm;       // confirm or not, via call CLIENT_BusConfirm Eventport to confirm
}ALARM_VEHICLE_DOOR_OPEN_INFO;

//The current event, the corresponding event type  DH_ALARM_BUS_CUR_MILEAGE
typedef struct tagALARM_BUS_CUR_MILEAGE_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
    int                         nTime;                  //Time for confirming the event, UTC, The unit is in seconds
    EM_VEHICLE_DATA_TYPE        emDataType;             // The type of event data
    NET_TIME                    stuTime;                // Event time, UTC
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
    NET_TIME                    stuStartTime;           // The beginning of the current period of time, UTC
    NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // The informations of the GPS on the beginning of the current period of time
    unsigned int                nMileage;               // Number of miles the current period, unit:0.1km
}ALARM_BUS_CUR_MILEAGE_INFO;

// The current consumption situation, A corresponding event type DH_ALARM_BUS_CUR_OIL
typedef struct tagALARM_BUS_CUR_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
    int                         nTime;                  // Time for confirmmingevent, UTC, unit:seconds
    EM_VEHICLE_DATA_TYPE        emDataType;             // The type of the event data
    NET_TIME                    stuTime;                // Event time, UTC
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
    NET_TIME                    stuStartTime;           // The begining time of the current, UTC
    NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // The GPS informations at the beginning time of the current, only longitude and latitude /speed and direction angle valid
    unsigned int                nCurOil;                // Current oil, unit: 0.1L
    unsigned int                nOilTankage;            // Tank capacity, unit: 0.1L
    int                         nOilChange;             // The changes oil of current time, unit: 0.1L, Positive means refuel, Negative means oil consumption
}ALARM_BUS_CUR_OIL_INFO;

// Low oil alarm events, Corresponding event type DH_ALARM_BUS_LOW_OIL
typedef struct tagALARM_BUS_LOW_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // Whether need confirm, confirm it by CLIENT_BusConfirmEvent
    int                         nTime;                  // Time for confirming the event, UTC, The unit is in seconds
    EM_VEHICLE_DATA_TYPE        emDataType;             // The type of the event data
    NET_TIME                    stuTime;                // Event time, UTC
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS information, only longitude and latitude /speed and direction angle valid
    unsigned int                nCurOil;                // Current oil, unit: 0.1L
    unsigned int                nOilLine;               // Oil threshold, unit: 0.1L
    unsigned int                nOilTankage;            // Tank capacity, unit: 0.1L
}ALARM_BUS_LOW_OIL_INFO;

// order Bus status input structure
typedef struct tagNET_IN_BUS_ATTACH
{
    DWORD                   dwSize;
    fBusStateCallBack       cbBusState;                             // status call function
    LDWORD                  dwUser;                                 // user data
}NET_IN_BUS_ATTACH;

// order Bus status output structure
typedef struct tagNET_OUT_BUS_ATTACH
{
    DWORD                dwSize;
}NET_OUT_BUS_ATTACH;

// extention module alarm channel info
typedef struct tagNET_EXALARMCHANNELS_INFO
{
    DWORD               dwSize;
    int                 nExAlarmBoxNum;                             // extension alarm box channel no.
    int                 nChannelNum;                                // ths channelno. On alarm box
    char                szChannelName[DH_MAX_EXALARMCHANNEL_NAME_LEN];// alarm channel name 
} NET_EXALARMCHANNELS_INFO;

// CLIENT_QueryDevState port input parameter
typedef struct tagNET_EXALARMCHANNELS
{
    DWORD                       dwSize;
    int                         nExAlarmInCount;                    // extension  module alarm input channel quantity¡ê?need user search
    int                         nRetExAlarmInCount;                 // extension  module alarm input channel return quantity
    NET_EXALARMCHANNELS_INFO*   pstuExAlarmInInfo;                  // extension  module alarm input channel info

    int                         nExAlarmOutCount;                   // extension  module alarm output channel quantity¡ê?need user to search
    int                         nRetExAlarmOutCount;                // extension  module alarm output channel return quantity
    NET_EXALARMCHANNELS_INFO*   pstuExAlarmOutInfo;                 // extension  module alarm output channel info
} NET_EXALARMCHANNELS;

// activate zone info
typedef struct tagNET_ACTIVATEDDEFENCEAREA_INFO
{
    DWORD                       dwSize;
    int                         nChannel;                           // zone channel no.
    NET_TIME                    stuActivationTime;                  // zone activation time 
}NET_ACTIVATEDDEFENCEAREA_INFO;
// CLIENT_QueryDevState port input parameter
typedef struct tagNET_ACTIVATEDEFENCEAREA
{
    DWORD                       dwSize;
    int                         nAlarmInCount;                      // search local alarm input channel quantity,  need use to specify
    int                         nRetAlarmInCount;                   // local alarm input channel actual activation quantity
    NET_ACTIVATEDDEFENCEAREA_INFO* pstuAlarmInDefenceAreaInfo;      // local alarm input channel info

    int                         nExAlarmInCount;                    // search extension module alarm input quantity. Use specify
    int                         nRetExAlarmInCount;                 // extension  module alarm input channel actual activation quantity
    NET_ACTIVATEDDEFENCEAREA_INFO* pstuExAlarmInDefenceAreaInfo;    // extension  module alarm input channel info
}NET_ACTIVATEDDEFENCEAREA;

// access control status type
typedef enum tagEM_NET_DOOR_STATUS_TYPE
{
    EM_NET_DOOR_STATUS_UNKNOWN,
    EM_NET_DOOR_STATUS_OPEN,                            // door unlock
    EM_NET_DOOR_STATUS_CLOSE,                           // door lock
    EM_NET_DOOR_STATUS_BREAK,                           // door abnormal unlock
}EM_NET_DOOR_STATUS_TYPE;

// access control status info(CLIENT_QueryDevState port input parameter)
typedef struct tagNET_DOOR_STATUS_INFO
{
    DWORD                       dwSize;
    int                         nChannel;               // access control channel no.
    EM_NET_DOOR_STATUS_TYPE     emStateType;            // access control status info
}NET_DOOR_STATUS_INFO;

// CLIENT_QueryRecordCount port input parameter
typedef struct _NET_IN_QUEYT_RECORD_COUNT_PARAM
{
    DWORD                       dwSize;                 //  structure size
    LLONG                       lFindeHandle;           // search handle
}NET_IN_QUEYT_RECORD_COUNT_PARAM;

// CLIENT_QueryRecordCount port output parameter
typedef struct _NET_OUT_QUEYT_RECORD_COUNT_PARAM
{
    DWORD                       dwSize;                 //  structure size
    int                         nRecordCount;           // device return record item
}NET_OUT_QUEYT_RECORD_COUNT_PARAM;

// analog alarm input channel info
typedef struct tagNET_ANALOGALARM_CHANNELS_INFO 
{
    DWORD               dwSize;
    int                 nSlot;                          // root address, 0 means local channel, 1 means connection to 1st serial extention channel, 2?¡é3...and so on
    int                 nLevel1;                        // 1st level cascading address, means connection to no.nSlot serial no.nLevel1 detector, from 0
    int                 nLevel2;                        // 2nd level cascading address,means cascading address, means connection to no.nLevel1 node no.nLevel2 detector, from 0, -1 means inexist,
    char                szName[DH_COMMON_STRING_128];   // channel name 
}NET_ANALOGALARM_CHANNELS_INFO;

// analog alarm input channel mapping relation (correspondingDH_DEVSTATE_ANALOGALARM_CHANNELS command)
typedef struct tagNET_ANALOGALARM_CHANNELS 
{
    DWORD                          dwSize;
    int                            nMaxAnalogAlarmChannels; // max channel
    int                            nRetAnalogAlarmChannels; // return channel
    NET_ANALOGALARM_CHANNELS_INFO* pstuChannelInfo;         // channel info¡ê?userallocate memory
}NET_ANALOGALARM_CHANNELS;

// sensor data info
typedef struct tagNET_ANALOGALARM_SENSE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // channel no.(from 0)
    NET_SENSE_METHOD        emSense;                        // sensor type
    float                   fData;                          // sensor value
    NET_TIME                stuTime;                        // collection time
    int                     nStatus;                        // data status, -1:unknown,0:normal,1data invalid(over measure),
                                                            // 2: over threshold1,3: over threshold 2,4: over threshold 3,5: over threshold 4,
                                                            // 6:below threshold1,7: below threshold 2,8: below threshold 3,9: below threshold 4
    NET_GPS_STATUS_INFO     stuGpsSatus;                    // GPS status 
    int                     nUint;                          // Unit of the sensor value£¬it is valid when emSense is the following value £º
                                                            // NET_SENSE_TEMP£¬refer to CFG_TEMPERATURE_UNIT for the value. 
}NET_ANALOGALARM_SENSE_INFO;

//subscribe analog alarm channel data callback function original
typedef void (CALLBACK *fAnalogAlarmDataCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_ANALOGALARM_SENSE_INFO* pInfo, int nBufLen, LDWORD dwUser);
// CLIENT_AttachAnalogAlarmData() port input parameter
typedef struct tagNET_IN_ANALOGALARM_DATA 
{
    DWORD                       dwSize;
    int                         nChannelId;                 // from 0, -1 means all channels
    fAnalogAlarmDataCallBack    cbCallBack;                 // data callback function
    LDWORD                      dwUser;                     // user custom parameter
}NET_IN_ANALOGALARM_DATA;

// CLIENT_AttachAnalogAlarmData()port output parameter
typedef struct tagNET_OUT_ANALOGALARM_DATA 
{
    DWORD    dwSize;
}NET_OUT_ANALOGALARM_DATA;

// order  record change port definition
#define DH_MAX_RECORD_INSERT_NUM              128
#define DH_MAX_RECORD_DELETE_NUM              128
#define DH_MAX_RECORD_UPDATE_NUM              128

typedef struct tagNET_RECORDUPDATER_INFO
{
    DWORD           dwSize;
    int             nInsertNum;                   // record info ¡ê?inserted  record number 
    int             nInsertNumberList[DH_MAX_RECORD_INSERT_NUM];  // means new record  index       
    int             nDeleteNum;                   // record info ¡ê?deleted record number 
    int             nDeleteNumberList[DH_MAX_RECORD_DELETE_NUM];  // means deleted record  index ¡ê?-1 means delete all record     
    int             nUpdateNum;                   // record info ¡ê?updated record number 
    int             nUpdateNumberList[DH_MAX_RECORD_UPDATE_NUM];  // means updated record  index      
}NET_RECORDUPDATER_INFO;

//order record change port 
typedef void (CALLBACK *fRecordUpdaterCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_RECORDUPDATER_INFO* pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_AttachRecordUpdater()port input parameter 
typedef struct tagNET_IN_RECORDUPDATER_DATA
{
    DWORD               dwSize;
    EM_NET_RECORD_TYPE  emType;           // record  set info type 
    fRecordUpdaterCallBack   cbRecordUpdater;         // record update call function
    LDWORD              dwUser;           // user defnition parameter 
}NET_IN_RECORDUPDATER_DATA;

// CLIENT_AttachRecordUpdater()port  output parameter 
typedef struct tagNET_OUT_RECORDUPDATER_DATA
{
    DWORD               dwSize;
}NET_OUT_RECORDUPDATER_DATA;


// search device supported sensor type 
// CLIENT_QueryDevState port DH_DEVSTATE_GET_SENSORLIST  command parameter
#define MAX_SUPPORT_SENSORTYPE_NUM    128                   // max supported sensor device type

typedef struct tagNET_SENSOR_LIST 
{
    DWORD       dwSize;
    int         nSupportSensorNum;                          // return sensor device type
    char        szSensorList[MAX_SUPPORT_SENSORTYPE_NUM][DH_COMMON_STRING_64];
}NET_SENSOR_LIST;

// CLIENT_QueryDevLogCount get log item input parameter
typedef struct tagNET_IN_GETCOUNT_LOG_PARAM
{
    DWORD                       dwSize;
    QUERY_DEVICE_LOG_PARAM      stuQueryCondition;          // search record filter
} NET_IN_GETCOUNT_LOG_PARAM;

// CLIENT_QueryDevLogCount get log item output parameter
typedef struct tagNET_OUT_GETCOUNT_LOG_PARAM
{
    DWORD                       dwSize;
    int                         nLogCount;                  // log quantity(device return)
} NET_OUT_GETCOUNT_LOG_PARAM;


// SDK global log print
typedef struct tagLogSetPrintInfo
{
    DWORD           dwSize;
    BOOL            bSetFilePath;                           //reset log path
    char            szLogFilePath[MAX_LOG_PATH_LEN];        // log path(default"./sdk_log/sdk_log.log")
    BOOL            bSetFileSize;                           // reset log size
    unsigned int    nFileSize;                              // each log file size(default size 10240), unit:bit
    BOOL            bSetFileNum;                            // reset log file number
    unsigned int    nFileNum;                               // log file quantity(default size 10)
    BOOL            bSetPrintStrategy;                      // reset log print strategy
    unsigned int    nPrintStrategy;                         // log out strategy, 0: output to file(defualt); 1:output to window
}LOG_SET_PRINT_INFO;

//////////////////////////////////////////////////////////////////////////
//       Low Rate Wireless Personal Area Network low speed wireless private network begin
//////////////////////////////////////////////////////////////////////////

// Wireless Device Type
typedef enum tagNET_WIRELESS_DEVICE_TYPE
{
	NET_WIRELESS_DEVICE_TYPE_UNKNOWN = 0,				
	NET_WIRELESS_DEVICE_TYPE_KEYBOARD,			// Wireless keyboard
	NET_WIRELESS_DEVICE_TYPE_DEFENCE,			// Wireless zone 
	NET_WIRELESS_DEVICE_TYPE_REMOTECONTROL,		// Wireless remote control 
	NET_WIRELESS_DEVICE_TYPE_MAGNETOMER,		// Wireless door sensor 
} NET_WIRELESS_DEVICE_TYPE;

// Wireless Device Mode
typedef enum tagEM_WIRELESS_DEVICE_MODE
{
    EM_WIRELESS_DEVICE_MODE_UNKNOWN = 0,               
        EM_WIRELESS_DEVICE_MODE_NORMAL,                // Normal  
        EM_WIRELESS_DEVICE_MODE_POLLING,               // Polling    It only to be valid when emType is NET_WIRELESS_DEVICE_TYPE_REMOTECONTROL
} EM_WIRELESS_DEVICE_MODE;

// Code info
typedef struct tagNET_CODEID_INFO
{
	DWORD						dwSize;
	TP_U64	                    nWirelessId;					   // Wireless ID no.
	NET_WIRELESS_DEVICE_TYPE	emType;							   // Wireless device type
	char						szName[DH_USER_NAME_LENGTH];	   // Username
	BOOL						bEnable;						   // Enable this device
    char                        szCustomName[DH_COMMON_STRING_64]; // Custom Name
    int                         nChannel;                          // It only to be valid when emType is NET_WIRELESS_DEVICE_TYPE_DEFENCE
    EM_WIRELESS_DEVICE_MODE     emMode;                            // Wireless Device Mode.
}NET_CODEID_INFO;

// Code error type
typedef enum tagNET_CODEID_ERROR_TYPE
{	
	NET_CODEID_ERROR_TYPE_RIGHT = 0,			// Code correct
	NET_CODEID_ERROR_TYPE_ALREADYEXIST,			// Exists
	NET_CODEID_ERROR_TYPE_OTHER,				// Other error
} NET_CODEID_ERROR_TYPE;

// Order wireless code info call function origin¡ê?lAttachHandle is CLIENT_AttachLowRateWPAN return valud
typedef void (CALLBACK *fAttachLowRateWPANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CODEID_INFO* stuBuf, NET_CODEID_ERROR_TYPE emError, LDWORD dwUser);

// CLIENT_AttachLowRateWPAN() input parameter
typedef struct tagNET_IN_ATTACH_LOWRATEWPAN
{
	DWORD					dwSize;
	fAttachLowRateWPANCB	cbAttachLowRateWPANCB;         // Code data call
	LDWORD					dwUser;                        // User Data
}NET_IN_ATTACH_LOWRATEWPAN;

// CLIENT_AttachLowRateWPAN() output parameter
typedef struct tagNET_OUT_ATTACH_LOWRATEWPAN
{
	DWORD		        dwSize;
}NET_OUT_ATTACH_LOWRATEWPAN;

// Delete specific wireless device
// CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_REMOVE command parameter
typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVE
{
	DWORD					dwSize;
	TP_U64			        nWirelessId;				// Wireless device ID	
}NET_CTRL_LOWRATEWPAN_REMOVE;

// Delete all wireless device
// CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_REMOVEALL command parameter
typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVEALL
{
	DWORD					dwSize;
}NET_CTRL_LOWRATEWPAN_REMOVEALL;

// Modify wireless device info
// CLIENT_ControlDevice port DH_CTRL_LOWRATEWPAN_MODIFY command parameter
typedef struct tagNET_CTRL_LOWRATEWPAN_MODIFY
{
	DWORD					dwSize;
	NET_CODEID_INFO			stuCodeIDInfo;			// According to CodeIDInfo CodeID¡ê?modify its UserandEnable indo¡ê?cannot modify others
}NET_CTRL_LOWRATEWPAN_MODIFY;

// Get code successful total items
typedef struct tagNET_GET_CODEID_COUNT
{
	DWORD				dwSize;
	int					nCodeIDCount;		// Code successful total items
}NET_GET_CODEID_COUNT;

// Get code info
typedef struct tagNET_GET_CODEID_LIST
{
	DWORD				dwSize;
	int					nStartIndex;			// Start index symbol, start first search may set to 0
	int					nQueryNum;				// The gotten code items, this value issmaller than or equal to capacity set nMaxPageSize field valud
	int					nRetCodeIDNum;			// Actual returned code items
	NET_CODEID_INFO*	pstuCodeIDInfo;			// Get code content, memory is allocated by user, cannot be lower than nQueryNum*sizeof(NET_CODEID_INFO)
}NET_GET_CODEID_LIST;

// add code info
typedef struct tagNET_CTRL_LOWRATEWPAN_ADD
{
	DWORD dwSize;
	NET_CODEID_INFO stuCodeIDInfo;             // code info data
}NET_CTRL_LOWRATEWPAN_ADD;

//////////////////////////////////////////////////////////////////////////
//       Low Rate Wireless Personal Area Network end
//////////////////////////////////////////////////////////////////////////

// Analog channel data search(corresponding  DH_DEVSTATE_ANALOGALARM_DATA command)
typedef struct tagNET_GET_ANALOGALARM_DATA 
{
    DWORD                       dwSize;
    int                         nChannelID;     // Analog channel no. to search(start from 0)
    NET_ANALOGALARM_SENSE_INFO  stuInfo;        // Get analog channel data
}NET_GET_ANALOGALARM_DATA;

// Monitor control and data collection device type
typedef enum tagEM_NET_SCADA_DEV_TYPE
{
    EM_NET_SCADA_DEV_TYPE_UNKNOWN = 0,                         // Unknown
    EM_NET_SCADA_DEV_TYPE_ALL,                                 // All-type device
    EM_NET_SCADA_DEV_TYPE_UPS,                                 // UPS
} EM_NET_SCADA_DEV_TYPE;

// Monitor control and data collection device spot path info input parameter, search criteria
typedef struct tagNET_IN_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    char                            szDevType[DH_COMMON_STRING_64]; // Device type
}NET_IN_SCADA_POINT_LIST_INFO;

#define MAX_SCADA_POINT_LIST_INDEX          8               // Max SCADADev config subscript number , as max channel

// Spot chart path info
typedef struct tagNET_SCADA_POINT_LIST
{
    DWORD                           dwSize;
    int               nIndexValidNum;                    // Valid config subscript number 
    int               nIndex[MAX_SCADA_POINT_LIST_INDEX];// SCADADev config config subscript value , start from 0
    char              szPath[DH_COMMON_STRING_256];      // chart complete path
}NET_SCADA_POINT_LIST;

#define MAX_SCADA_POINT_LIST_INFO_NUM       256               // max spot path number 
#define MAX_SCADA_POINT_LIST_ALARM_INFO_NUM 256				  // max spot chart alarm number

// Monitor control and data collection device spot chart path info output parameter, search result
typedef struct tagNET_OUT_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    int                             nList;                  // Valid spot chart path info number 
    NET_SCADA_POINT_LIST            stuList[MAX_SCADA_POINT_LIST_INFO_NUM];// spot chart path info
}NET_OUT_SCADA_POINT_LIST_INFO;

// Monitor control and data collection device spot chart path info, (corresponding to DH_DEVSTATE_SCADA_POINT_LIST command )
typedef struct tagNET_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    NET_IN_SCADA_POINT_LIST_INFO    stuIn;                  // search criteria 
    NET_OUT_SCADA_POINT_LIST_INFO   stuOut;                 // search result 
}NET_SCADA_POINT_LIST_INFO;

// Spot type
typedef enum tagEM_NET_SCADA_POINT_TYPE
{
    EM_NET_SCADA_POINT_TYPE_UNKNOWN = 0,                       // unknown
    EM_NET_SCADA_POINT_TYPE_ALL,                               // all type
    EM_NET_SCADA_POINT_TYPE_YC,                                // analog input
    EM_NET_SCADA_POINT_TYPE_YX,                                // switch input
    EM_NET_SCADA_POINT_TYPE_YT,                                // analog output
    EM_NET_SCADA_POINT_TYPE_YK,                                // switch ouput
} EM_NET_SCADA_POINT_TYPE;

// SCADA monitor spot search criteria 
typedef struct tagNET_IN_SCADA_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emPointType;                    // spot type to search
}NET_IN_SCADA_INFO;

#define MAX_SCADA_YX_NUM                128                 // max yx type spot number
#define MAX_SCADA_YC_NUM                128                 // max yc type spot number
#define MAX_SCADA_POINT_INFO_NUM        8                   // max spot chart number

// Spot chart info 
typedef struct tagNET_SCADA_POINT_INFO 
{
    DWORD                   dwSize;
    char                    szDevName[DH_COMMON_STRING_64]; // device name
    int                     nYX;                            // valid count of YX type spot in anYX
    unsigned int            anYX[MAX_SCADA_YX_NUM];         // value of YX type spots
    int                     nYC;                            // valid count of YC type spot in afYC
    float                   afYC[MAX_SCADA_YC_NUM];         // value of YC type spots
}NET_SCADA_POINT_INFO;

// SCADA monitor spot search result 
typedef struct tagNET_OUT_SCADA_INFO 
{
    DWORD                   dwSize;
    int                     nPointInfoNum;                  // valid spot chart number 
    NET_SCADA_POINT_INFO    stuPointInfo[MAX_SCADA_POINT_INFO_NUM];// spot chart info
}NET_OUT_SCADA_INFO;

// Monitor control and data collection device spot chart path monitor spot info (corresponding to DH_DEVSTATE_SCADA_INFO command )
typedef struct tagNET_SCADA_INFO
{
    DWORD                   dwSize;
    NET_IN_SCADA_INFO       stuIn;                          // search criteria
    NET_OUT_SCADA_INFO      stuOut;                         // search result
}NET_SCADA_INFO;

// SCADA capacity type
typedef enum tagEM_NET_SCADA_CAPS_TYPE
{
    EM_NET_SCADA_CAPS_TYPE_UNKNOWN,
    EM_NET_SCADA_CAPS_TYPE_ALL,                                // all type
    EM_NET_SCADA_CAPS_TYPE_DEV,                                // DevInfo
} EM_NET_SCADA_CAPS_TYPE;

// Monitor control and data collection device spot chart path capacity info search criteria 
typedef struct tagNET_IN_SCADA_CAPS
{
    DWORD                   dwSize;
    EM_NET_SCADA_CAPS_TYPE  emType;                         // search type
} NET_IN_SCADA_CAPS;

#define MAX_NET_SCADA_CAPS_TYPE (16)
#define MAX_NET_SCADA_CAPS_NAME (16)

// Monitor control and data collection device spot chart path type capacity info 
typedef struct tagNET_OUT_SCADA_CAPS_ITEM
{
    DWORD                   dwSize;
    char                    szDevType[DH_COMMON_STRING_32];    // device type
    int                     nValidName;                         // valid device name number
    char                    szDevName[MAX_NET_SCADA_CAPS_NAME][DH_COMMON_STRING_32];// unique device names
} NET_OUT_SCADA_CAPS_ITEM;

// Monitor control and data collection device spot chart path capacity info search result 
typedef struct tagNET_OUT_SCADA_CAPS
{
    DWORD                   dwSize;
    int                     nValidType;                         // valid device type number 
    NET_OUT_SCADA_CAPS_ITEM stuItems[MAX_NET_SCADA_CAPS_TYPE];  // Max 16 types 
} NET_OUT_SCADA_CAPS;

// Monitor control and data collection device spot chart path capacity info (corresponding to DH_DEVSTATE_SCADA_CAPS command )
typedef struct tagNET_SCADA_CAPS
{
    DWORD                   dwSize;
    NET_IN_SCADA_CAPS       stuIn;                          // search criteria 
    NET_OUT_SCADA_CAPS      stuOut;                         // search result 
} NET_SCADA_CAPS;

// spot info(queried by device id, sensor id)
typedef struct tagNET_SCADA_POINT_BY_ID_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emType;                         // spot type
    char                    szID[DH_COMMON_STRING_64];      // id
    int                     nMeasuredVal;                   // measured value, valid if spot type is YX
    float                   fMeasureVal;                    // measured value, valid if spot type is YC
    int                     nSetupVal;                      // setup value, valid if spot type is YK
    float                   fSetupVal;                      // setup value, valid if spot type is YT
    int                     nStatus;                        // data status, -1:unknown, 0:normal, 1:alarm level1, 2:alarm level2, 3:alarm level3, 4:alarm level4, 5:operation event, 6:invalid data
    NET_TIME                stuTime;                        // collect time
}NET_SCADA_POINT_BY_ID_INFO;

#define MAX_SCADA_ID_OF_SENSOR_NUM  128                     // Max count of spot id

// get spot info by sensor id, spot id(corresponding to DH_DEVSTATE_SCADA_INFO_BY_ID)
typedef struct tagNET_SCADA_INFO_BY_ID
{
    DWORD                   dwSize;
    char                    szSensorID[DH_COMMON_STRING_64];// input param, sensor ID
    int                     nIDs;                           // input param, valid count of spot id in szIDs
    char                    szIDs[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_64];// input param, spot IDs
    int                     nMaxCount;                      // input param, count of NET_SCADA_POINT_BY_ID_INFO in pstuInfo
    int                     nRetCount;                      // output param, returned count of NET_SCADA_POINT_BY_ID_INFO from device, may be larger than nMaxCount
    NET_SCADA_POINT_BY_ID_INFO* pstuInfo;                   // input/output param, user allocates the memory
}NET_SCADA_INFO_BY_ID;

// scada device id info
typedef struct tagNET_SCADA_DEVICE_ID_INFO 
{
    char                    szDeviceID[DH_COMMON_STRING_64];// device id
    char                    szDevName[DH_COMMON_STRING_64]; // device name, the same as "szDevName" in CFG_SCADA_DEV_INFO
    BYTE                    reserve[1024];
}NET_SCADA_DEVICE_ID_INFO;

// query scada device IDs(corresponding to DH_DEVSTATE_SCADA_DEVICE_LIST)
typedef struct tagNET_SCADA_DEVICE_LIST
{
    DWORD                       dwSize;
    int                         nMax;                       // count of NET_SCADA_DEVICE_ID_INFO in pstuDeviceIDInfo
    int                         nRet;                       // returned count of NET_SCADA_DEVICE_ID_INFO from device, may be larger than nMax
    NET_SCADA_DEVICE_ID_INFO*   pstuDeviceIDInfo;           // scada device id info¡ê?user allocates the memory
}NET_SCADA_DEVICE_LIST;

// monitor spot info 
typedef struct tagNET_SCADA_NOTIFY_POINT_INFO
{
    DWORD                       dwSize; 
    char                        szDevName[DH_COMMON_STRING_64];     // device name ¡ê?and getInfo Get name identical
    EM_NET_SCADA_POINT_TYPE     emPointType;                        // spot type 
    char                        szPointName[DH_COMMON_STRING_64];   // spot name¡ê?and spot chart take value identical
    float                       fValue;                             // value, valid if spot type is YC
    int                         nValue;                             // value, valid if spot type is YX
    char                        szFSUID[DH_COMMON_STRING_64];       // FSUIID(Field Supervision Unit), device itself
    char                        szID[DH_COMMON_STRING_64];          // spot ID
    char                        szSensorID[DH_COMMON_STRING_64];    // sensor ID
    NET_TIME_EX                 stuCollectTime;                     // collect time
} NET_SCADA_NOTIFY_POINT_INFO;

// monitor spot info list
typedef struct tagNET_SCADA_NOTIFY_POINT_INFO_LIST
{
    DWORD                           dwSize;
    int                             nList;                        // monitor spot info number 
    NET_SCADA_NOTIFY_POINT_INFO     stuList[MAX_SCADA_POINT_LIST_INFO_NUM]; // monitor spot info
} NET_SCADA_NOTIFY_POINT_INFO_LIST;

// order monitor spot info  callback prototype
typedef void (CALLBACK *fSCADAAttachInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_SCADAAttachInfo()'s input param
typedef struct tagNET_IN_SCADA_ATTACH_INFO
{
    DWORD                           dwSize;
    fSCADAAttachInfoCallBack        cbCallBack;                 // callback
    EM_NET_SCADA_POINT_TYPE         emPointType;                // spot type
    LDWORD                          dwUser;                     // user's param
} NET_IN_SCADA_ATTACH_INFO;

// CLIENT_SCADAAttachInfo()'s output param
typedef struct tagNET_OUT_SCADA_ATTACH_INFO
{
    DWORD    dwSize;
} NET_OUT_SCADA_ATTACH_INFO;

//////////////////////////////////////////////////////////////////////////
#define MAX_SCADA_ID_NUM                            1024    // max number of spot id

// spot threshold info
typedef struct tagNET_SCADA_ID_THRESHOLD_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emPointType;                // spot type
    char                    szID[DH_COMMON_STRING_32];  // spot ID
    float                   fThreshold;                 // threshold to trigger alarm
    float                   fAbsoluteValue;             // absolute value of threshold
    float                   fRelativeValue;             // relative value of threshold
    int                     nStatus;                    // data state, -1:unknown, 0:normal, 1:alarm level 1, 2:alarm level 2, 3:alarm level 3, 4:alarm level 4, 5:operation event, 6:invalid data
}NET_SCADA_ID_THRESHOLD_INFO;

// CLIENT_SCADAGetThreshold's input param
typedef struct tagNET_IN_SCADA_GET_THRESHOLD 
{
    DWORD           dwSize;
    char            szDeviceID[DH_COMMON_STRING_64];                // device id
    int             nIDs;                                           // valid spot count
    char            szIDs[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];   // spot IDs to query
}NET_IN_SCADA_GET_THRESHOLD;

// CLIENT_SCADAGetThreshold's output param
typedef struct tagNET_OUT_SCADA_GET_THRESHOLD 
{
    DWORD                           dwSize;
    int                             nMax;               // number user malloced, unit:sizeof(NET_SCADA_ID_THRESHOLD_INFO)
    int                             nRet;               // return number, unit:sizeof(NET_SCADA_ID_THRESHOLD_INFO)
    NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // spot threshold info, user malloc the memory
}NET_OUT_SCADA_GET_THRESHOLD;

//////////////////////////////////////////////////////////////////////////
// CLIENT_SCADASetThreshold's input param
typedef struct tagNET_IN_SCADA_SET_THRESHOLD 
{
    DWORD                           dwSize;
    char                            szDeviceID[DH_COMMON_STRING_64];// device id
    int                             nMax;               // count of user malloced, unit: sizeof(NET_SCADA_ID_THRESHOLD_INFO)
    NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // spots threshold info, user malloc the memory
}NET_IN_SCADA_SET_THRESHOLD;

// CLIENT_SCADASetThreshold's output param
typedef struct tagNET_OUT_SCADA_SET_THRESHOLD 
{
    DWORD           dwSize;
    int             nSuccess;                                           // valid count of successfully set id
    char            szSuccessID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32]; // IDs that set successfully
    int             nFail;                                              // valid count of failed set id
    char            szFailID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];    // IDs that set failed
}NET_OUT_SCADA_SET_THRESHOLD;

//////////////////////////////////////////////////////////////////////////
// CLIENT_StartFindSCADA's input param
typedef struct tagNET_IN_SCADA_START_FIND 
{
    DWORD           dwSize;
    NET_TIME        stuStartTime;                   // start time, must provide
    BOOL            bEndTime;                       // to set the end time, TRUE: must provide stuEndTime, FLASE: do not limit the end time
    NET_TIME        stuEndTime;                     // end time
    char            szDeviceID[DH_COMMON_STRING_64];// DeviceID, must provide
    char            szID[DH_COMMON_STRING_32];      // spot ID, must provide
}NET_IN_SCADA_START_FIND;

// CLIENT_StartFindSCADA's output param
typedef struct tagNET_OUT_SCADA_START_FIND 
{
    DWORD           dwSize;
    DWORD           dwTotalCount;                   // total count matching the finding condition
}NET_OUT_SCADA_START_FIND;

// CLIENT_DoFindSCADA's input param
typedef struct tagNET_IN_SCADA_DO_FIND 
{
    DWORD                       dwSize;
    int                         nStartNo;           // start number
    int                         nCount;             // number to query
}NET_IN_SCADA_DO_FIND;

// CLIENT_DoFindSCADA's output param
typedef struct tagNET_OUT_SCADA_DO_FIND 
{
    DWORD                       dwSize;
    int                         nRetNum;            // return number
    NET_SCADA_POINT_BY_ID_INFO* pstuInfo;           // result, user malloc the memroy
    int	                        nMaxNum;            // number of user malloced, unit: sizeof(NET_SCADA_POINT_BY_ID_INFO)
}NET_OUT_SCADA_DO_FIND;

// spot alarm event info
typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO
{
    DWORD           dwSize;
    char            szDevID[DH_COMMON_STRING_16];               // device ID
    char            szPointID[DH_COMMON_STRING_128];            // spot ID
    BOOL            bAlarmFlag;                                 // alarm flag
    NET_TIME        stuAlarmTime;                               // alarm time
    int	            nAlarmLevel;                                // alarm level¡ê¡§0~6¡ê?
    int             nSerialNo;                                  // alarm number
    char            szAlarmDesc[DH_COMMON_STRING_128];          // alarm descriptioin
} NET_SCADA_NOTIFY_POINT_ALARM_INFO;

// spot alarm event list info
typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST
{
    DWORD                               dwSize;
    int	                                nList;                                          // spot alarm event number
    NET_SCADA_NOTIFY_POINT_ALARM_INFO   stuList[MAX_SCADA_POINT_LIST_ALARM_INFO_NUM];   // spot alarm event info
} NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST;

// spot alarm event info callback prototype
typedef void (CALLBACK *fSCADAAlarmAttachInfoCallBack)(LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_SCADAAlarmAttachInfo()'s input param
typedef struct tagNET_IN_SCADA_ALARM_ATTACH_INFO
{
    DWORD                           dwSize;
    fSCADAAlarmAttachInfoCallBack   cbCallBack;                 // callback
    LDWORD                          dwUser;	                    // user's param
} NET_IN_SCADA_ALARM_ATTACH_INFO;

// CLIENT_SCADAAlarmAttachInfo()'s output param
typedef struct tagNET_OUT_SCADA_ALARM_ATTACH_INFO
{
    DWORD                       dwSize;
} NET_OUT_SCADA_ALARM_ATTACH_INFO;

// spot param and value info to be set
typedef struct tagNET_SCADA_POINT_SET_INFO
{
    DWORD                       dwSize;
    EM_NET_SCADA_POINT_TYPE	    emType;                         // spot type, only support YK?¡éYT
    char                        szPointID[DH_COMMON_STRING_64];	// spot ID
    int	                        nSetupVal;                      // value, if emType is YK
    float                       fSetupVal;                      // value, if emType is YT
} NET_SCADA_POINT_SET_INFO;

// set scada spot param and value,CLIENT_SetSCADAInfo()'s input param
typedef struct tagNET_IN_SCADA_POINT_SET_INFO_LIST
{
    DWORD                       dwSize;
    char                        szDevID[DH_COMMON_STRING_32];           // device ID
    int	                        nPointNum;                              // spot number
    NET_SCADA_POINT_SET_INFO    stuList[MAX_SCADA_ID_OF_SENSOR_NUM];    // spot info to set
} NET_IN_SCADA_POINT_SET_INFO_LIST;

// set scada spot param and value,CLIENT_SetSCADAInfo()'s output param
typedef struct tagNET_OUT_SCADA_POINT_SET_INFO_LIST
{
    DWORD                   dwSize;
    int                     nSuccess;                                                       // valid count of spot that set ok
    char                    szSuccessID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];   // spot list that set ok
    int                     nFail;                                                          // valid count of spot that set failed
    char                    szFailID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];      // spot list that set failed
} NET_OUT_SCADA_POINT_SET_INFO_LIST;


// get current sub system enable status(correspondingDH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS?¨¹¨¢?)
typedef struct tagNET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES
{
	DWORD				dwSize;
	int					nChannelId;			// sub system no.
	BOOL				bActive;			// sub system enable status, , TRUE  means enable,FALSE means disable
}NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES;

// alarm sub system activation setup parameter(correspondingDH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET command)
typedef struct tagNET_CTRL_ALARM_SUBSYSTEM_SETACTIVE 
{
	DWORD				dwSize;
	int					nChannelId;			// sub system no.
	BOOL				bActive;			// sub system enable status ,TRUE means enable, FALSE means disable
}NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE;

// Forbid open strobe param(corresponding to  DH_CTRL_FORBID_OPEN_STROBE)
typedef struct tagNET_CTRL_FORBID_OPEN_STROBE
{
    DWORD               dwSize;             
    int                 nChannelID;        // channel no.    
    int                 nTime;             // forbid open gateway duration¡ê?unit:s¡ê?as after this operation corresponding to time cannot open device gateway 
}NET_CTRL_FORBID_OPEN_STROBE;

#define MAX_PLATENUMBER_LEN    64           // max palte no length
// open gateway parameter(corresponding to DH_CTRL_OPEN_STROBE command)
typedef struct tagNET_CTRL_OPEN_STROBE
{
	DWORD				dwSize;
	int				nChannelId;			                // channel no.
	char				szPlateNumber[MAX_PLATENUMBER_LEN];		// plate no.
}NET_CTRL_OPEN_STROBE;

// close gateway parameter(corresponding to DH_CTRL_CLOSE_STROBE command)
typedef struct tagNET_CTRL_CLOSE_STROBE
{
    DWORD               dwSize;
    int                 nChannelId;                         // channel no.
}NET_CTRL_CLOSE_STROBE;

// playback refuse listening parameter(corresponding to DH_CTRL_TALKING_REFUSE command)
typedef struct tagNET_CTRL_TALKING_REFUSE 
{
    DWORD           dwSize;
    int             nChannelID;                 // talk channel no.
}NET_CTRL_TALKING_REFUSE;

// parking reservation status
typedef enum tagEM_NET_ORDER_STATE
{
    EM_NET_ORDER_STATE_UNKNOWN,
    EM_NET_ORDER_STATE_FREE,                            // Free
    EM_NET_ORDER_STATE_ORDERED,                         // Ordered
}EM_NET_ORDER_STATE;

// parking reservation status info
typedef struct tagNET_ORDER_STATE_INFO
{
    DWORD               dwSize;
    unsigned int        nLane;                          // parking no.
    EM_NET_ORDER_STATE  emOrderState;                   // reservation status
}NET_ORDER_STATE_INFO;

// set parking reservation status parameter(corresponding to DH_CTRL_SET_ORDER_STATE command)
typedef struct tagNET_CTRL_SET_ORDER_STATE
{
    DWORD                   dwSize;
    NET_ORDER_STATE_INFO*   pOrderStateInfo;              // parking reservation infouser allocation space
    unsigned int            nStateCount;                  // valid reservation number
}NET_CTRL_SET_ORDER_STATE;

// Parking lot entrance/exit controller LED roll screen subtitle speed
typedef enum tagNET_ECK_LED_SPEED_TYPE 
{
    NET_ECK_LED_SPEED_UNKNOWN = 0,
    NET_ECK_LED_SPEED_LOW,                              // Slow
    NET_ECK_LED_SPEED_NORMAL,                           // Normal
    NET_ECK_LED_SPEED_HIGH,                             // Fast
}NET_ECK_LED_SPEED_TYPE;

// Parking lot entrance/exit controller LED setup parameter DH_CTRL_ECK_LED_SET
typedef struct tagNET_CTRL_ECK_LED_SET_PARAM 
{
    DWORD                   dwSize;
    NET_ECK_LED_SPEED_TYPE  emLEDSpeed;                 // Subtitle rolling speed
    int                     nCount;                     // Valid display times, range 0-255, 0 means permanent
    char                    szCustomData[DH_COMMON_STRING_512];// LED rolling screen initial characters, 0-256 bytes
}NET_CTRL_ECK_LED_SET_PARAM;


// Intelligent parking system entrance/exit device IC card user type
typedef enum tagNET_ECK_IC_CARD_USER_TYPE
{
    NET_ECK_IC_CARD_USER_UNKNOWN,
    NET_ECK_IC_CARD_USER_ALL,                           // all type
    NET_ECK_IC_CARD_USER_TEMP,                          // Temporary user
    NET_ECK_IC_CARD_USER_LONG,                          // Long-term user
    NET_ECK_IC_CARD_USER_ADMIN,                         // admin
    NET_ECK_IC_CARD_USER_BLACK_LIST,                    // black list
}NET_ECK_IC_CARD_USER_TYPE;

//Intelligent parking lot system entrance/exit device abnormal pass car record type
typedef enum tagNET_ECK_CAR_PASS_FLAG
{
    NET_ECK_CAR_PASS_FLAG_NORMAL = 0,                   // Normal
    NET_ECK_CAR_PASS_FLAG_ABNORMAL = 1,                 // Abnormal
    NET_ECK_CAR_PASS_FLAG_ALL,                          // All
} NET_ECK_CAR_PASS_FLAG;

// Intelligent parking system entrance/exit device IC card info
typedef struct tagNET_ECK_IC_CARD 
{
    DWORD                   dwSize;
    DWORD                   dwCard;                     // card no.
    NET_ECK_IC_CARD_USER_TYPE emUserType;               // User type
}NET_ECK_IC_CARD;

#define NET_MAX_ECK_IC_CARD_IMPORT_NUM      50          // Intelligent parking system entrance/exit device max inport IC card quantity

// Intelligent parking system entrance/exit deviceIC card info import parameter DH_CTRL_ECK_IC_CARD_IMPORT
typedef struct tagNET_CTRL_ECK_IC_CARD_IMPORT_PARAM
{
    DWORD               dwSize;
    int                 nCardNum;                       // IC card quantity
    NET_ECK_IC_CARD     stuCardInfo[NET_MAX_ECK_IC_CARD_IMPORT_NUM];// IC card info
}NET_CTRL_ECK_IC_CARD_IMPORT_PARAM;

// Intelligent parking system entrance/exit deviceIC card info sync info parameter DH_CTRL_ECK_SYNC_IC_CARD
typedef struct tagNET_CTRL_ECK_SYNC_IC_CARD_PARAM
{
    DWORD               dwSize;
    int                 nCount;                         // Client IC card info quantity
}NET_CTRL_ECK_SYNC_IC_CARD_PARAM;

#define ECK_SCREEN_NUM_MAX (8)                         // The largest number of screens entrance and exits intelligent parking system 
// Set parking informations on the entrance and exits on the intelligent parking system DH_CTRL_ECK_SET_PARK_INFO
typedef struct tagNET_CTRL_ECK_SET_PARK_INFO_PARAM
{
    DWORD           dwSize;
    int             nScreenNum;                             // Screen numbers, not exceeding  ECK_SCREEN_NUM_MAX
    int             nScreenIndex[ECK_SCREEN_NUM_MAX];       // Screen series , every element means the screen series
    int             nFreeParkNum[ECK_SCREEN_NUM_MAX];       // Corresponding to the free parking number under the screen adminstration
                                                            // The length and the subscript accordance with nScreenIndex¡ê?every element means the free parking }NET_CTRL_ECK_SET_PARK_INFO_PARAM;
}NET_CTRL_ECK_SET_PARK_INFO_PARAM;

// fingerprint collection (corresponding to DH_CTRL_CAPTURE_FINGER_PRINT command )
typedef struct tagNET_CTRL_CAPTURE_FINGER_PRINT 
{
    DWORD      dwSize;
    int        nChannelID;                      // access control no.(start from 0)
    char       szReaderID[DH_COMMON_STRING_32]; // card reader ID
}NET_CTRL_CAPTURE_FINGER_PRINT;

// Hang up video phone(Corresponding DH_CTRL_VTP_DISCONNECT)
typedef struct tagNET_CTRL_VTP_DISCONNECT 
{
    DWORD                   dwSize;
    const char*             szTargetID;                     // The device ID to be forward , NULL means don?¡¥t forward
    EM_NET_VTP_CALL_TYPE    emCallType;                     // Call type
    char                    szCallID[DH_COMMON_STRING_128]; // Intercom unique identifier}NET_CTRL_VTP_DISCONNECT;
}NET_CTRL_VTP_DISCONNECT;

// client(video talk phone) ack type
typedef enum tagNET_EM_VTP_ACK
{
    NET_EM_VTP_OK,                              // client calls right after get the event
    NET_EM_VTP_BUSY,                            // client busy, do not call
}NET_EM_VTP_ACK;

// client(video talk phone) divert ack
typedef struct tagNET_CTRL_VTP_DIVERTACK
{
    DWORD                   dwSize;
    EM_NET_VTP_CALL_TYPE    emCallType;                     // Calling type to query
    const char*             szCallID;                       // Unique ID for calling
    NET_EM_VTP_ACK          emAck;                          // Client's ack
}NET_CTRL_VTP_DIVERTACK;

// The operation model of remote multimedia files
typedef enum tagNET_EM_SPEAK_FILE_ACTION
{
    NET_EM_SPEAK_FILE_ACTION_UPDATE = 0,                    // Update the original file
    NET_EM_SPEAK_FILE_ACTION_ADD,                           // Added files
    NET_EM_SPEAK_FILE_ACTION_DEL,                           //Delete files
}NET_EM_SPEAK_FILE_ACTION;

// The operation informations of the remote multimedia files 
typedef struct tagNET_SPEAK_FILE_INFO
{
    DWORD                       dwSize;
    char                        szFilePath[MAX_PATH];       // File path, use the address setted up by CFG_CMD_NASEX firstly    NET_EM_SPEAK_FILE_ACTION    emAction;                   // Operation type, operation for the files appointed by szFilePath 
    NET_EM_SPEAK_FILE_ACTION    emAction;                   // 2¨´¡Á¡Â¨¤¨¤D¨ª, ?¡ä??szFilePath???¡§¦Ì????t¦Ì?2¨´¡Á¡Â
    BOOL                        bSave;                      // Whether update or save the files in local device 
}NET_SPEAK_FILE_INFO;

#define MAX_SPEAK_FILE_NUM      32                          // The max number of the files for remote

// Update the files for remote
typedef struct tagNET_CTRL_UPDATE_FILES
{
    DWORD                   dwSize;
    DWORD                   dwFileNum;                      // The valid file number
    NET_SPEAK_FILE_INFO     stuFileInfo[MAX_SPEAK_FILE_NUM];// The multimedia file information
}NET_CTRL_UPDATE_FILES;


// (corresponding to DH_CTRL_RAINBRUSH_MOVEONCE)
typedef struct tagNET_CTRL_RAINBRUSH_MOVEONCE
{
    DWORD           dwSize;
    int             nChannel;       // Rain-brush channel
}NET_CTRL_RAINBRUSH_MOVEONCE;

// (corresponding to DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
typedef struct tagNET_CTRL_RAINBRUSH_MOVECONTINUOUSLY
{
    DWORD           dwSize;
    int             nChannel;       // Rain-brush channel
    unsigned int    nInterval;      // Interval
}NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY;

// (corresponding to DH_CTRL_RAINBRUSH_STOPMOVE)
typedef struct tagNET_CTRL_RAINBRUSH_STOPMOVE
{
    DWORD           dwSize;
    int             nChannel;       // Rain-brush channel
}NET_CTRL_RAINBRUSH_STOPMOVE;

// (corresponding to DH_CTRL_ALARM_ACK)
typedef struct tagNET_CTRL_ALARM_ACK
{
    DWORD                   dwSize;
    int                     nEventID;   // Event ID
}NET_CTRL_ALARM_ACK;
////////////////////////////////system task subscription//////////////////////////////////////////
// zone status
typedef struct __NET_PARTITION_STATE
{
    DWORD             dwSize;
    int               nStatus;                  // zone status¡ê?0-normal¡ê?1-error 
    double            dbTotalSize;              // zone total capacity¡ê?byte is unit
    double            dbRemainSize;             // free capacity¡ê?byte is unit
    
}NET_PARTITION_STATE;

// HDD status
typedef struct __NET_HDD_STATE
{
    DWORD             dwSize; 
    int               nState;                   // HDD status¡ê?0-normal¡ê?1-error   
    double            dbTotalSize;              // HDD total capacity¡ê?byte is unit
    NET_PARTITION_STATE stuPartitions[DH_MAX_STORAGE_PARTITION_NUM]; // zone status
    int               nPartitionNum;              // zone quantity
}NET_HDD_STATE;

// channel status
typedef struct __NET_CHANNLE_STATE
{
    DWORD             dwSize;
    BYTE              byRecState;               // record status¡ê?1-record¡ê?0-close
    BYTE              byVideoInState;           // video input status¡ê?1-video in¡ê?0-no video  
    BYTE              byReserved[2];            // text align
}NET_CHANNLE_STATE;

// PAD/DVR connection state type
typedef enum tagNET_PAD_CONNECT_STATE
{
    NET_PAD_CONNECT_STATE_UNKNOWN,             // unknown
    NET_PAD_CONNECT_STATE_UNCONNECTED,         // unconnected
    NET_PAD_CONNECT_STATE_CONNECTED,           // connected
} NET_PAD_CONNECT_STATE;

// Home key state
typedef enum tagNET_HOME_STATE
{
    NET_HOME_STATE_UNKNOWN,                    // unknown
    NET_HOME_STATE_UNPRESSED,                  // unpressed
    NET_HOME_STATE_PRESSED,                    // pressed
} NET_HOME_STATE;

// device self-check info
typedef struct __NET_SELFCHECK_INFO
{
    DWORD             dwSize;
    int               nAlarmIn;                 // alarm input channel number
    int               nAlarmOut;                // alarm output channel number  
    NET_TIME          stuTime;                  // report time
    char              szPlateNo[DH_MAX_PLATE_NUMBER_LEN]; // plate
    char              szICCID[DH_MAX_SIM_LEN];  // SIM card no.
    BYTE              byOrientation;            // position status¡ê?0-not position¡ê?1-position 
    BYTE              byACCState;               // ACC status¡ê?0-close¡ê?1-open
    BYTE              byConstantElecState;      // power on¡ê?0-normal¡ê?1-disconnect¡ê?2-less pressure, 3-over pressure
    BYTE              byAntennaState;           // channel signal status¡ê?0-normal¡ê?1-unknown failure¡ê?2-disaonnect¡ê?3-short circuit
    
    // external device status
    BYTE              byReportStation;          //station announcer status¡ê?0-disconnect¡ê?1-normal¡ê?2-abnormal
    BYTE              byControlScreen;          // dispatch status¡ê?0-disconnect¡ê?1-normal¡ê?2-abnormal
    BYTE              byPOS;                    // POS status¡ê?0-disconnect¡ê?1-normal¡ê?2-abnormal
    BYTE              byCoinBox;                // box status¡ê?0-disconnect¡ê?1-normal¡ê?2-abnormal
    
    // capacity set
    BOOL              bTimerSnap;               // schedule snapshot¡ê?TRUE-support¡ê?FALSE-not support
    BOOL              bElectronEnclosure;       // e-fence¡ê?TRUE-support¡ê?FALSE-not support
    BOOL              bTeleUpgrade;             // remote upgrade¡ê?TRUE-support¡ê?FALSE-not support   
    
    NET_HDD_STATE     stuHddStates[DH_MAX_DISKNUM]; //HDD status
    int               nHddNum;                  // HDD quantity
    
    NET_CHANNLE_STATE* pChannleState;           // channel status¡ê?is a group¡ê? memoryis applied by sdk internally¡ê?released by sdk intenally
    int               nChannleNum;              // channel quantity
    int               nChannelMax;              // pChannleState max counts mallcoed by caller
    NET_PAD_CONNECT_STATE         emConnState;  // PAD/DVR connection state
    NET_HOME_STATE                emHomeState;  // Home key state
}NET_SELFCHECK_INFO;

typedef void (CALLBACK *fMissionInfoCallBack)(LLONG lAttachHandle, DWORD dwType, void* pMissionInfo, void* pReserved, LDWORD dwUserData);

typedef enum EM_MISSION_TYPE
{
    NET_MISSION_TYPE_UNKOWN,                    // unknown
        NET_MISSION_TYPE_SELFCHECK,                 // device self-check¡ê?corresponding structure  NET_SELFCHECK_INFO
}EM_MISSION_TYPE;

//CLIENT_AttachMissionport input parameter
typedef struct __NET_IN_ATTACH_MISSION_PARAM
{
    DWORD             dwSize;
    EM_MISSION_TYPE   emMissionType;            // task type
    fMissionInfoCallBack cbMissionInfofunc;     // task info callback function
    LDWORD            dwUser;                   // user data 
}NET_IN_ATTACH_MISSION_PARAM;

// CLIENT_DetachMissionport output parameter
typedef struct NET_OUT_ATTACH_MISSION_PARAM
{
    DWORD             dwSize;
    LLONG             lAttachHandle;           // subscribe handle
}NET_OUT_ATTACH_MISSION_PARAM;

#define MAX_EVENT_TO_CONFIRM_NUM    8    // max to confirm event number 

//to confirm event info 
typedef struct tagNET_EVENT_INFO_TO_CONFIRM 
{
    DWORD           dwSize;
    DWORD           dwEventType;        // event type , corresponding to CLIENT_AttachBusStateport event type 
    NET_TIME        stuTime;            // event time, UTC
    LONG            lTime;              // event time, UTC, unit is second
}NET_EVENT_INFO_TO_CONFIRM;

// vehicle emergency alarm confirm input parameter 
typedef struct tagNET_IN_BUS_CONFIRM_EVENT 
{
    DWORD           dwSize;
    int             nEvent;             // to confirm event valid quantity
    NET_EVENT_INFO_TO_CONFIRM  stuEventInfo[MAX_EVENT_TO_CONFIRM_NUM];// to confirm event info 
}NET_IN_BUS_CONFIRM_EVENT;

// vehicle emergency alarm confirm  output parameter 
typedef struct tagNET_OUT_BUS_CONFIRM_EVENT 
{
    DWORD           dwSize;
}NET_OUT_BUS_CONFIRM_EVENT;

// CLIENT_SetDevicePosition interface parameter input 
typedef struct tagNET_IN_SET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // Struture size. Must fill in when initialization 
    char                    szPosition[DH_COMMON_STRING_512];   // Address info 
}NET_IN_SET_DEVICE_POSITION;

// CLIENT_SetDevicePosition interface paramter output
typedef struct tagNET_OUT_SET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // Structure size. Must fill in when initialization
}NET_OUT_SET_DEVICE_POSITION;

// CLIENT_GetDevicePosition interface paramter input
typedef struct tagNET_IN_GET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // Structure size. Must fill in when initialization
}NET_IN_GET_DEVICE_POSITION;

// CLIENT_GetDevicePosition interface paramter output
typedef struct tagNET_OUT_GET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // Structure size. Must fill in when initialization
    char                    szPosition[DH_COMMON_STRING_512];   // Address info 
}NET_OUT_GET_DEVICE_POSITION;

// CLIENT_SnapPictureByEvent interface paramter input
typedef struct tagNET_IN_SNAP_BY_EVENT 
{
    DWORD                   dwSize;                             // Struture size. Must fill in when initialization
    int                     nChannel;                           // Video channel No. Begins with 0. 
    DWORD                   dwEventID;                          // Refer to event type of CLIENT_RealLoadPicEx
}NET_IN_SNAP_BY_EVENT;

// CLIENT_SnapPictureByEvent interface paramter output
typedef struct tagNET_OUT_SNAP_BY_EVENT 
{
    DWORD                   dwSize;                             // Struture size. Must fill in when initialization
}NET_OUT_SNAP_BY_EVENT;
// CLIENT_StartQueryLog input parameter
typedef struct tagNET_IN_START_QUERYLOG
{
    DWORD               dwSize;
} NET_IN_START_QUERYLOG;

// CLIENT_StartQueryLog ouput parameter
typedef struct tagNET_OUT_START_QUERYLOG
{
    DWORD               dwSize;
}NET_OUT_START_QUERYLOG;

// Detail info of log
typedef struct tagNET_LOG_MESSAGE
{
    DWORD               dwSize;
    char				szLogMessage[DH_COMMON_STRING_1024];    // detailed info
} NET_LOG_MESSAGE;

// Info of log
typedef struct tagNET_LOG_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;                        // time 
    char                szUserName[DH_COMMON_STRING_32];// operator
    char                szLogType[DH_COMMON_STRING_128];// type
    NET_LOG_MESSAGE	    stuLogMsg;                      // detailed info
} NET_LOG_INFO;

// CLIENT_QueryNextLog input parameter
typedef struct tagNET_IN_QUERYNEXTLOG
{
    DWORD               dwSize;
    int                 nGetCount;      // count of log item try to query
}NET_IN_QUERYNEXTLOG;

// CLIENT_QueryNextLog ouput parameter
typedef struct tagNET_OUT_QUERYNEXTLOG
{
    DWORD               dwSize;
    int                 nMaxCount;      // count of log item malloced by user¡ê?should be NET_IN_GETNEXTLOG*nGetCount
    NET_LOG_INFO*       pstuLogInfo;    // buffer for log item malloced by user, should be nMaxCount*sizeof(NET_LOG_INFO)
    int                 nRetCount;      // return count of log item
}NET_OUT_QUERYNEXTLOG;

// Asynchronous callback function registered equipment prototype (when nError back to 11, reserved fields reserved for int type parameters and used to invoke the CLIENT_StartLoginEx landed the port)
typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);

// CLIENT_StartLoginEx  input parameter
typedef struct tagNET_IN_STARTLOGINEX 
{
    DWORD               dwSize;
    const char*         szIp;           // device ip
    DWORD               dwPort;         // login port
    const char*         szName;         // username
    const char*         szPwd;          // password
    fHaveLogin          cbLogin;        // login result call
    LDWORD              dwUser;         // call user parameter
}NET_IN_STARTLOGINEX;

// CLIENT_StartLoginEx output parameter
typedef struct tagNET_OUT_STARTLOGINEX 
{
    DWORD       dwSize;
}NET_OUT_STARTLOGINEX;

// video splicing operation type
typedef enum tagNET_VIDEOJOIN_OPERATE_TYPE
{
    NET_VIDEOJOIN_GET_STATUS,               // get splicing status, corresponding to  NET_IN_VIDEOJOIN_GET_STATUS and NET_OUT_VIDEOJOIN_GET_STATUS
    NET_VIDEOJOIN_GET_CALIBRATE_POINTS,     // get calibrate point , corresponding to  tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS and  tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
    NET_VIDEOJOIN_CALIBRATE,                // mark ,  corresponding to  NET_IN_VIDEOJOIN_CALIBRATE and NET_OUT_VIDEOJOIN_CALIBRATE
}NET_VIDEOJOIN_OPERATE_TYPE;

// video splicing status
typedef enum tagNET_VIDEOJOIN_STATUS
{
    NET_VIDEOJOIN_STATUS_UNKNOWN,               // unknow
    NET_VIDEOJOIN_STATUS_NOTSTART,              // not started
    NET_VIDEOJOIN_STATUS_DOING,                 // running
    NET_VIDEOJOIN_STATUS_FINISH,                // complate
}NET_VIDEOJOIN_STATUS;

// video splicing mark mode
typedef enum tagNET_VIDEOJOIN_MODE
{
    NET_VIDEOJOIN_MODE_UNKNOWN,                 // unknow
    NET_VIDEOJOIN_MODE_AUTO,                    // auto
    NET_VIDEOJOIN_MODE_MANUAL,                  // manual
}NET_VIDEOJOIN_MODE;

// CLIENT_OperateVideoJoin input parameter, corresponding to NET_VIDEOJOIN_GET_STATUS
typedef struct tagNET_IN_VIDEOJOIN_GET_STATUS
{
    DWORD           dwSize;
}NET_IN_VIDEOJOIN_GET_STATUS;

// CLIENT_OperateVideoJoin output parameter, corresponding to NET_VIDEOJOIN_GET_STATUS
typedef struct tagNET_OUT_VIDEOJOIN_GET_STATUS
{
    DWORD           dwSize;
    NET_VIDEOJOIN_STATUS emStatus;              // splicing status
}NET_OUT_VIDEOJOIN_GET_STATUS;

// camera mark pair, means one pair of marks
typedef struct tagNET_POINT_PAIR 
{
    DH_POINT        stuPoints[POINT_NUM_IN_PAIR];           // camera mark
}NET_POINT_PAIR;

// video splicing mark group, each group means two channels and multiple mark pairs
typedef struct tagNET_VIDEOJOIN_POINT_GROUP
{
    DWORD           dwSize;
    int             nPointPairNum;                          // mark quantity
    NET_POINT_PAIR  stuPointPairs[MAX_POINT_PAIR_NUM];      // mark
    int             nChannels[CHANNEL_NUM_IN_POINT_GROUP];  // video channel no., via data mark to correspond ¡ê?mark 0 channel corresponding to NET_POINT_PAIR mark 0 point
}NET_VIDEOJOIN_POINT_GROUP;

// CLIENT_OperateVideoJoin input parameter, corresponding to NET_VIDEOJOIN_GET_CALIBRATE_POINTS
typedef struct tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS
{
    DWORD           dwSize;
}NET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS;

// CLIENT_OperateVideoJoin output parameter, corresponding to NET_VIDEOJOIN_GET_CALIBRATE_POINTS
typedef struct tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
{
    DWORD               dwSize;
    NET_VIDEOJOIN_MODE  emMode;                                 // mark mode
    int                 nPointGroupNum;                         // mark point quantity
    NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // mark pointgroup, under manual mode is valid
}NET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS;

// CLIENT_OperateVideoJoin input parameter, corresponding to NET_VIDEOJOIN_CALIBRATE
typedef struct tagNET_IN_VIDEOJOIN_CALIBRATE
{
    DWORD               dwSize;
    NET_VIDEOJOIN_MODE  emMode;                                 // mark mode
    int                 nPointGroupNum;                         // mark point group quantity
    NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // mark pointgroup, manual mode valid
}NET_IN_VIDEOJOIN_CALIBRATE;

// CLIENT_OperateVideoJoin output mode, corresponding to NET_VIDEOJOIN_CALIBRATE
typedef struct tagNET_OUT_VIDEOJOIN_CALIBRATE
{
    DWORD           dwSize;
}NET_OUT_VIDEOJOIN_CALIBRATE;

// Get screen window info input parameter , corresponding to NET_SPLIT_OPERATE_GET_SCENE
typedef struct tagNET_IN_SPLIT_GET_SCENE 
{
    DWORD           dwSize;
    int             nChannel;               // output channel no. or cubeless video wall virtual channel no., pszCompositeIDis NULL, it is valid 
    const char*     pszCompositeID;         //  cubeless video wall ID
}NET_IN_SPLIT_GET_SCENE;

// Get  screen window info  output parameter , corresponding to NET_SPLIT_OPERATE_GET_SCENE
typedef struct tagNET_OUT_SPLIT_GET_SCENE 
{
    DWORD           dwSize;
    DH_SPLIT_SCENE  stuScene;               // window info 
}NET_OUT_SPLIT_GET_SCENE;

// tv wall tour status 
typedef enum tagEM_NET_WM_TOUR_STATUS
{
    EM_NET_WM_TOUR_STATUS_UNKNOWN,          // unknown 
    EM_NET_WM_TOUR_STATUS_START,            // touring
    EM_NET_WM_TOUR_STATUS_STOP,             // tour stop
} EM_NET_WM_TOUR_STATUS;

// tv wall scheme tour status info 
typedef struct tagNET_WM_TOUR_STATUS_INFO 
{
    DWORD          dwSize;
    EM_NET_WM_TOUR_STATUS  emStatus;        // tour status 
    DH_MONITORWALL_SCENE  stuScene;         // scheme info 
} NET_WM_TOUR_STATUS_INFO;

// tv wall scheme tour status call function origin, lAttachHandle is CLIENT_MonitorWallAttachTour return value 
typedef void (CALLBACK *fMonitorWallTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WM_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);

// CLIENT_MonitorWallAttachTour port input parameter 
typedef struct tagNET_IN_WM_ATTACH_TOUR 
{
    DWORD       dwSize;
    int       	nMonitorWallID;             // tv wall ID
    fMonitorWallTourStatusCallBack cbStatus;// tour status  call function 
    LDWORD     	dwUser;                     // tour status call parameter 
} NET_IN_WM_ATTACH_TOUR;

// CLIENT_MonitorWallAttachTour port  output parameter 
typedef struct tagNET_OUT_WM_ATTACH_TOUR 
{
    DWORD      dwSize;
} NET_OUT_WM_ATTACH_TOUR;

// CLIENT_SnapManagerConfirmUpload port input parameter
typedef struct tagNET_IN_SNAP_MANAGER_CONFIRM_UPLOAD
{
    DWORD           dwSize;
    char            szFilePath[DH_COMMON_STRING_256];       // File path¡ê?used for SN of picture
    BOOL            bResult;                                // If picture upload is complete
}NET_IN_SNAP_MANAGER_CONFIRM_UPLOAD;

// CLIENT_SnapManagerConfirmUpload port output parameter
typedef struct tagNET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD
{
    DWORD           dwSize;
}NET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD;

// Video phone status informations
typedef struct tagNET_VTP_CALL_STATE_INFO 
{
    DWORD                       dwSize;
    char                        szNumber[DH_COMMON_STRING_128]; // Call number
    char                        szCallID[DH_COMMON_STRING_128]; // Intercom unique identifier
    EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // Call status
}NET_VTP_CALL_STATE_INFO;

// The callback function prototypes of subscribe to video phone
typedef void (CALLBACK *fVTPCallStateCallBack)(LLONG lAttachHandle, NET_VTP_CALL_STATE_INFO *pInfo, int nBufLen, LDWORD dwUser);

// Input parameter about the status informations of subscribe to video phone
typedef struct tagNET_IN_VTP_CALL_STATE_ATTACH 
{
    DWORD                       dwSize;
    EM_NET_VTP_CALL_TYPE        emCallType;                     // The call type for checking
    fVTPCallStateCallBack       cbCallState;                    // The callback function    LDWORD                      dwUser;                         // User parameter
    LDWORD                      dwUser;                         // user's param
    const char*                 szTargetID;                     // The device ID for forward, NULL means not formard
}NET_IN_VTP_CALL_STATE_ATTACH;

// The output parameter of the status information of subscribes to video phone
typedef struct tagNET_OUT_VTP_CALL_STATE_ATTACH 
{
    DWORD                       dwSize;
}NET_OUT_VTP_CALL_STATE_ATTACH;


//////////////////////////////////////////////////////////////////////////
// ABILITY INFO
//////////////////////////////////////////////////////////////////////////

// Check the buses?¡¥ routeCLIENT_CheckBusLine()input parameter
typedef struct tagNET_IN_CHECK_BUS_LINE 
{
    DWORD           dwSize;
    char            szLineID[DH_COMMON_STRING_32];          // Line marking
    char            szDesignation[DH_COMMON_STRING_32];     // Line serial number
    NET_LINE_DIRECTION  emDirection;                        // Line direction
    int             nSiteCount;                             // The total stations number on the route
    char            szDirectionName[DH_COMMON_STRING_32];   // Name of the line firection
    char            szVersion[DH_COMMON_STRING_32];         // Line version number
}NET_IN_CHECK_BUS_LINE;


// The status type of the bus line whether to update
typedef enum tagNET_BUS_LINE_UPDATE_TYPE
{
    NET_BUS_LINE_UPDATE_UNKNOWN = 0,
    NET_BUS_LINE_UPDATE_UPDATED,                            // Need update
    NET_BUS_LINE_UPDATE_NOT_UPDATED,                        // Not update
}NET_BUS_LINE_UPDATE_TYPE;

// Check the bus routeCLIENT_CheckBusLine()output parameter
typedef struct tagNET_OUT_CHECK_BUS_LINE
{
    DWORD           dwSize;
    char            szDeviceID[DH_COMMON_STRING_32];        // device ID
    char            szLineID[DH_COMMON_STRING_32];          // Line marking
    NET_BUS_LINE_UPDATE_TYPE emUpdate;                      // Indicator for whether need to update the status
}NET_OUT_CHECK_BUS_LINE;
#define MAX_SITE_GPS_POINT_NUM                      64      // Describe the bus stops the largest GPS point

// The shape type of the bus station
typedef enum tagNET_SITE_AREA_TYPE
{
    NET_SITE_AREA_ENCLOSURE = 0,                            // Type of the fence
    NET_SITE_AREA_CIRCLE,                                   // Circular
}NET_SITE_AREA_TYPE;

// Bus station information
typedef struct tagNET_BUS_SITE_INFO
{
    DWORD           dwSize;
    char            szLineID[DH_COMMON_STRING_32];          //Line marking
    int             nSiteCount;                             // Total number of the stations
    NET_LINE_DIRECTION  emDirection;                        // Line direction
    int             nStopSequence;                          // Station serial number
    char            szSiteID[DH_COMMON_STRING_32];          // Station ID
    char            szSiteName[DH_COMMON_STRING_32];        // Station name, you can use szSiteNameEx to input a longer name
    NET_SITE_AREA_TYPE emAreaType;                          // Station type
    int             nGPSPointNum;                           // valid GPS points number
    GPS_POINT       stuPoint[MAX_SITE_GPS_POINT_NUM];       // Station GPS information
    int             nRadius;                                // Radius of the station, unit: meter, valid only for the circulai
    int             nSpeedLimit;                            //Station speed limit, unit: km/H
    int             nDriveTime;                             // Time for the last station to current, unit:minute
    int             nTicketPrice;                           // Filp fares
    DH_TSECT        stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // Time table, The first dimension of each element means ~ on Saturday and Sunday ,holidays
    char            szDesignation[DH_COMMON_STRING_64];     // Line serial number
    char            szDirectionName[DH_COMMON_STRING_64];   // Line direction name
    char            szVersion[DH_COMMON_STRING_32];
    BOOL            bUseExName;                             // Use new site name flag
    char            szSiteNameEx[DH_COMMON_STRING_128];     // site name with 128 bytes
}NET_BUS_SITE_INFO;

#define MAX_BUS_STOP_NUM                            32      // The max number of  the stations in a bus line

// Issue bus line CLIENT_DispatchBusLineInfo()Interface input parameters
typedef struct tagNET_IN_DISPATCH_BUS_LINE_INFO 
{
    DWORD           dwSize;
    int             nBusStopNum;                            // The number of bus line stations
    NET_BUS_SITE_INFO   stuStopInfo[MAX_BUS_STOP_NUM];      // The information of the bus line
}NET_IN_DISPATCH_BUS_LINE_INFO;

// Issue bus line  CLIENT_DispatchBusLineInfo()Interface output parameters
typedef struct tagNET_OUT_DISPATCH_BUS_LINE_INFO 
{
    DWORD           dwSize;
}NET_OUT_DISPATCH_BUS_LINE_INFO;

// Vehicle operation dispatching CLIENT_BusSchedule()Interface input parameters
typedef struct tagNET_IN_BUS_SCHEDULE_INFO 
{
    DWORD               dwSize;
    char                szLineID[DH_COMMON_STRING_64];      // Operating line identification
    NET_LINE_DIRECTION  emDirection;                        // Operating line direction
    NET_TIME_EX         stuStartTime;                       // Departure time 

}NET_IN_BUS_SCHEDULE_INFO;

// Vehicle operation dispatching CLIENT_BusSchedule()Interface output parameters
typedef struct tagNET_OUT_BUS_SCHEDULE_INFO 
{
    DWORD           dwSize;
}NET_OUT_BUS_SCHEDULE_INFO;

// Vehicle scheduling plan information
typedef struct tagNET_BUS_WORK_PLAN 
{
    DWORD               dwSize;
    char                szID[DH_COMMON_STRING_32];          // Scheduling record only, Up to 16 characters
    NET_TIME_EX         stuTime;                            // Departure time 
    char                szDriverName[DH_COMMON_STRING_64];  // The driver name
    char                szStartSite[DH_COMMON_STRING_64];   // Starting station name
    char                szEndSite[DH_COMMON_STRING_64];     // The terminal point name
    BOOL                bRunning;                           // Operation state, TRUE: run, FALSE:stop
}NET_BUS_WORK_PLAN;

// Issued by the vehicle scheduling plan CLIENT_DispatchWorkPlan Interface input parameters
typedef struct tagNET_IN_BUS_DISPATCH_WORK_PLAN 
{
    DWORD               dwSize;
    NET_BUS_WORK_PLAN   stuWorkPlan;                        // Vehicle scheduling plan information }NET_IN_BUS_DISPATCH_WORK_PLAN;
}NET_IN_BUS_DISPATCH_WORK_PLAN;

// Issued by the vehicle scheduling plan CLIENT_DispatchWorkPlan Interface output parameters
typedef struct tagNET_OUT_BUS_DISPATCH_WORK_PLAN 
{
    DWORD               dwSize;
}NET_OUT_BUS_DISPATCH_WORK_PLAN;

// Thermal image color 
typedef enum tagNET_THERMO_COLORIZATION 
{
    NET_THERMO_COLORIZATION_UNKNOWN,                        // Unknown 
    NET_THERMO_COLORIZATION_WHITE_HOT,                      // White 
    NET_THERMO_COLORIZATION_BLACK_HOT,                      // Black
    NET_THERMO_COLORIZATION_IRONBOW2,                       // Iron 
    NET_THERMO_COLORIZATION_ICEFIRE,                        // Icefire
} NET_THERMO_COLORIZATION;

// Thermal ROI mode 
typedef enum tagNET_THERMO_ROI 
{
    NET_THERMO_ROI_UNKNOWN,                                 // Unknown 
    NET_THERMO_ROI_FULL_SCREEN,                             // Full-screen 
    NET_THERMO_ROI_SKY,                                     // Top
    NET_THERMO_ROI_GROUND,                                  // Middle
    NET_THERMO_ROI_HORIZONTAL,                              // Bottom
    NET_THERMO_ROI_CENTER_75,                               // Center point 75%
    NET_THERMO_ROI_CENTER_50,                               // Center point  50%
    NET_THERMO_ROI_CENTER_25,                               // Center point  25%
    NET_THERMO_ROI_CUSTOM,                                  // Customized 
} NET_THERMO_ROI;

// Thermal mode 
typedef enum tagNET_THERMO_MODE 
{
    NET_THERMO_MODE_UNKNOWN,                                // Unknown
    NET_THERMO_MODE_DEFAULT,                                // Default
    NET_THERMO_MODE_INDOOR,                                 // Indoor 
    NET_THERMO_MODE_OUTDOOR,                                // Outdoor 
} NET_THERMO_MODE;

// Thermal optimized region 
typedef struct tagNET_THERMO_GRAPHY_OPT_REGION 
{
    BOOL                bOptimizedRegion;                   // Enable optimized region or not 
    int                 nOptimizedROIType;                  // Optimized region type. Please refer to NET_THERMO_ROI
    int                 nCustomRegion;                      // Customized region amount 
    NET_RECT            stCustomRegions[64];                // Customized region. Valid only when nOptimizedROIType is NET_THERMO_ROI_CUSTOM 
    char                Reserved[256];
} NET_THERMO_GRAPHY_OPTREGION;

// Thermal info 
typedef struct tagNET_THERMO_GRAPHY_INFO 
{
    int                         nBrightness;                // brightness
    int                         nSharpness;                 // Sharpness
    int                         nEZoom;                     // Zoom 
    int                         nThermographyGamma;         // Gamma value 
    int                         nColorization;              // Color. Refer to NET_THERMO_COLORIZATION
    int                         nSmartOptimizer;            // Optimized indicator 
    NET_THERMO_GRAPHY_OPTREGION stOptRegion;                // Optimized region 
    int                         nAgc;                       // Auto gain control 
    int                         nAgcMaxGain;                // Max auto gain
    int                         nAgcPlateau;                // Gain balance 
    char reserved[244];
} NET_THERMO_GRAPHY_INFO;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_PRESET command to input parameter  
typedef struct tagNET_IN_THERMO_GET_PRESETINFO 
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
    NET_THERMO_MODE     emMode;                             // mode
} NET_IN_THERMO_GET_PRESETINFO;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_PRESET command to output parameter
typedef struct tagNET_OUT_THERMO_GET_PRESETINFO 
{
    DWORD                       dwSize;
    NET_THERMO_GRAPHY_INFO      stInfo;                     // thermal info
} NET_OUT_THERMO_GET_PRESETINFO;

// CLIENT_QueryDevInfo port_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO command to input parameter
typedef struct tagNET_IN_THERMO_GET_EXTSYSINFO
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
} NET_IN_THERMO_GET_EXTSYSINFO;

// CLIENT_QueryDevInfo port  NET_QUERY_GET_LINKCHANNELS command to input parameter
typedef struct tagNET_IN_GET_LINKCHANNELS
{	
    DWORD               dwSize;
    int                 nChannel;	                        // channel number, check if there is related video channel in this video channel number
} NET_IN_GET_LINKCHANNELS;

#define NET_LINKCHANNEL_MAX     512                         // max linked video channel count
#define NET_LINKGROUP_MAX       64                          // max linked video channel group count

// CLIENT_QueryDevInfo port NET_QUERY_GET_LINKCHANNELS command to output parameter
typedef struct tagNET_OUT_GET_LINKCHANNELS
{	
    DWORD               dwSize;
    int                 nLinkedCnt;                         // related  number of video channel number
    int                 nLinked[NET_LINKCHANNEL_MAX];	    // related video channel number, including request channel number
} NET_OUT_GET_LINKCHANNELS;

// input param of CLIENT_QueryDevInfo according to NET_QUERY_GET_ALLLINKCHANNELS
typedef struct tagNET_IN_GET_ALLLINKCHANNELS
{	
    DWORD               dwSize;
} NET_IN_GET_ALLLINKCHANNELS;

// output param of CLIENT_QueryDevInfo according to NET_QUERY_GET_ALLLINKCHANNELS
typedef struct tagNET_OUT_GET_ALLLINKCHANNELS
{	
    DWORD               dwSize;
    int                 nGroupCnt;                                              // linked video channel group count in
    int                 nLinkedCnt[NET_LINKGROUP_MAX];                          // linked video channel counts in a group
    int                 nLinked[NET_LINKGROUP_MAX][NET_LINKCHANNEL_MAX];	    // linked video channel group info
                                                                                // first dimension: channel group, second dimension: video channel number
} NET_OUT_GET_ALLLINKCHANNELS;

// CLIENT_QueryDevInfo port NET_QUERY_GET_CAMERA_STATE command to input parameter
typedef struct tagNET_IN_GET_CAMERA_STATEINFO
{
    DWORD               dwSize;
    BOOL                bGetAllFlag;                                // if it is to check all the cameras status, if the member is TRUE, then nChannels member is unnecessary to set.
    int                 nValidNum;                                  // the member is valid when bGetAllFlag is FALSE, which means valid number of nChannels member
    int                 nChannels[DH_MAX_CAMERA_CHANNEL_NUM];       // The member is valid when bGetAllFlag is FALSE, it is to fill in the channel numbers in turn which needs inquiry. 
} NET_IN_GET_CAMERA_STATEINFO;

typedef enum tagEM_CAMERA_STATE_TYPE
{
    EM_CAMERA_STATE_TYPE_UNKNOWN,       // unknown 
    EM_CAMERA_STATE_TYPE_CONNECTING,    // connecting
    EM_CAMERA_STATE_TYPE_CONNECTED,     // connected
    EM_CAMERA_STATE_TYPE_UNCONNECT,     // unconnected
    EM_CAMERA_STATE_TYPE_EMPTY,         // channel is not configured, no info
    EM_CAMERA_STATE_TYPE_DISABLE,       // channel is configured, but it is forbidden. 
}EM_CAMERA_STATE_TYPE;

typedef struct tagNET_CAMERA_STATE_INFO
{
    int                     nChannel;           // camera channel number, -1 means invalid channel number
    EM_CAMERA_STATE_TYPE    emConnectionState;  // connection state
    char                    szReserved[1024];   // byte reserved
}NET_CAMERA_STATE_INFO;

// CLIENT_QueryDevInfo port NET_QUERY_GET_CAMERA_STATE command to output parameter
typedef struct tagNET_OUT_GET_CAMERA_STATEINFO 
{
    DWORD                       dwSize;
    int                         nValidNum;              // valid number of camera channel state, returned by sdk
    int                         nMaxNum;                // max number of array, filled in by user
    NET_CAMERA_STATE_INFO*      pCameraStateInfo;       // camera channel info array, distributed by user
} NET_OUT_GET_CAMERA_STATEINFO;

// CLIENT_QueryDevInfo port NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE command to input parameter
typedef struct tagNET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO
{
    DWORD               dwSize;
    int                 nChannel;                                   // channel number
    int                 nStreamType;                                // stream type, 0: main stream; 1: sub stream 1; 2: sub stream 2; 3: sub stream 3; 4: talk stream
} NET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO;

// CLIENT_QueryDevInfo port NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE command to output parameter
typedef struct tagNET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO
{
    DWORD                       dwSize;
    int                         nValidNum;                                  // valid number of audio coding
    DHDEV_TALKDECODE_INFO       stuListAudioEncode[MAX_AUDIO_ENCODE_NUM];   // audio coding list
} NET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO;

// API CLIENT_QueryDevInfo  NET_QUERY_GET_COMM_PORT_INFO in param
typedef struct tagNET_IN_GET_COMM_PORT_INFO
{
    DWORD               dwSize;
} NET_IN_GET_COMM_PORT_INFO;

// API CLIENT_QueryDevInfo NET_QUERY_GET_COMM_PORT_INFO out param
//port type
typedef enum tagEM_COMM_PORT_TYPE_INFO
{
    EM_COMM_PORT_TYPE_UNKNOW = 0    ,
        EM_COMM_PORT_TYPE_RS232         ,
        EM_COMM_PORT_TYPE_RS485         ,
        EM_COMM_PORT_TYPE_RS422         ,
        EM_COMM_PORT_TYPE_RS485_422     ,
}EM_COMM_PORT_TYPE_INFO;

//port info
typedef struct  tagNET_COMM_PORT_INFO
{
    EM_COMM_PORT_TYPE_INFO  emCommPortType;     //Port Type
    int                     nCommPortNum;       //Port Number
    BYTE                    bReserved[1024];    //reserved bytes
}NET_COMM_PORT_INFO;

#define MAX_COMM_PORT_NUM       8
typedef struct tagNET_OUT_GET_COMM_PORT_INFO
{
    DWORD                       dwSize;
    int                         nPortInfosNum;                          //Port Infos Number
    NET_COMM_PORT_INFO          stCommPortInfos[MAX_COMM_PORT_NUM];     //Port Info
} NET_OUT_GET_COMM_PORT_INFO;

// external system info
typedef struct tagNET_THERMO_SYSINFO 
{
    char                szSerialNumber[64];                 // serial number
    char                szSoftwareVersion[64];              // software version
    char                szFirmwareVersion[64];              // firmware version
    char                szLibVersion[64];                   // library version
    char                reserved[256];
} NET_THERMO_SYSINFO;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO command to output parameter
typedef struct tagNET_OUT_THERMO_GET_EXTSYSINFO
{
    DWORD                       dwSize;
    NET_THERMO_SYSINFO          stInfo;                     // external system info
} NET_OUT_THERMO_GET_EXTSYSINFO;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION command to input parameter
typedef struct tagNET_IN_THERMO_GET_OPTREGION
{
    DWORD               dwSize;
    int                 nChannel;                           // channel nunmber
} NET_IN_THERMO_GET_OPTREGION;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION command to output parameter
typedef struct tagNET_OUT_THERMO_GET_OPTREGION
{
    DWORD                       dwSize;
    NET_THERMO_GRAPHY_OPTREGION stInfo;                     // optimize area info
} NET_OUT_THERMO_GET_OPTREGION;


// CLIENT_QueryDevInfo ½Ó¿Ú NET_QUERY_GET_VIDEOOUTPUTCHANNELS ÃüÁîÈë²Î
typedef struct tagNET_IN_GET_VIDEOOUTPUTCHANNELS
{
    DWORD               dwSize;             // ÓÃ»§Ê¹ÓÃ¸Ã½á¹¹ÌåÊ±£¬dwSize Ðè¸³ÖµÎª sizeof(NET_IN_GET_VIDEOOUTPUTCHANNELS)
} NET_IN_GET_VIDEOOUTPUTCHANNELS;

// CLIENT_QueryDevInfo ½Ó¿Ú NET_QUERY_GET_VIDEOOUTPUTCHANNELS ÃüÁî³ö²Î
typedef struct tagNET_OUT_GET_VIDEOOUTPUTCHANNELS
{
    DWORD               dwSize;             // ÓÃ»§Ê¹ÓÃ¸Ã½á¹¹ÌåÊ±£¬dwSize Ðè¸³ÖµÎª sizeof(NET_OUT_GET_VIDEOOUTPUTCHANNELS)
    int                 nMaxLocal;          // ×î´ó±¾µØÊä³öÍ¨µÀ×ÜÊý£¬º¬Ö÷°åºÍ¿É²å°Î×Ó¿¨Í¨µÀ
} NET_OUT_GET_VIDEOOUTPUTCHANNELS;


// CLIENT_QueryDevInfo ½Ó¿Ú NET_QUERY_GET_VIDEOINFO ÃüÁîÈë²Î
typedef struct tagNET_IN_GET_VIDEOINFO
{
    DWORD               dwSize;             // ÓÃ»§Ê¹ÓÃ¸Ã½á¹¹ÌåÊ±£¬dwSize Ðè¸³ÖµÎª sizeof(NET_IN_GET_VIDEOINFO)
} NET_IN_GET_VIDEOINFO;

// ½âÂëÍ¨µÀ×´Ì¬
typedef enum  tagNET_VIDEOCHANNEL_STATE
{
    NET_VIDEOCHANNEL_STATE_UNKNOWN,        // Î´Öª×´Ì¬
    NET_VIDEOCHANNEL_STATE_IDLE,           // ¿ÕÏÐ
    NET_VIDEOCHANNEL_STATE_PLAY,           // ²¥·Å
    NET_VIDEOCHANNEL_STATE_MONITOR,        // ¼àÊÓ
    NET_VIDEOCHANNEL_STATE_TOUR,           // ÂÖÑ¯
} NET_VIDEOCHANNEL_STATE;

// ½âÂëÍ¨µÀÐÅÏ¢
typedef struct tagNET_VIDEOCHANNELINFO
{
    BOOL                         bEnable;                // Í¨µÀÊ¹ÄÜ×´Ì¬, ×´Ì¬ÎªtrueÊ±£¬GB28181Ð­Òé»á½«Õâ¸öÍ¨µÀÉÏ±¨·þÎñÆ÷
    NET_VIDEOCHANNEL_STATE       emVideoChannelState;    // ½âÂëÍ¨µÀ×´Ì¬
    int                          nNetflow;               // ÍøÂçÁ÷Á¿(µ¥Î»£ºkbps)
    int                          nBitrate;               // ÂëÂÊ(µ¥Î»£ºkbps)
    int                          nFrame;                 // Ö¡ÂÊ
    CAPTURE_SIZE                 emResolution;           // ·Ö±æÂÊ
    BYTE                         byReserved[512];        // Ô¤Áô×Ö½Ú 
} NET_VIDEOCHANNELINFO;


// CLIENT_QueryDevInfo ½Ó¿Ú NET_QUERY_GET_VIDEOINFO ÃüÁî³ö²Î
typedef struct tagNET_OUT_GET_VIDEOINFO
{
    DWORD                    dwSize;                // ÓÃ»§Ê¹ÓÃ¸Ã½á¹¹ÌåÊ±£¬dwSize Ðè¸³ÖµÎª sizeof(NET_OUT_GET_VIDEOINFO)
    int                      nVideoInfoNum;         // ÓÃ»§ÐèÒª»ñÈ¡µÄ½âÂëÍ¨µÀÐÅÏ¢¸öÊý£¬´Ó0¿ªÊ¼»ñÈ¡£¬ÓÃ»§Ö¸¶¨
    NET_VIDEOCHANNELINFO*    pNetVideoChannelInfo;  // ½âÂëÍ¨µÀÐÅÏ¢ÁÐ±í£¬ÓÃ»§ÉêÇë¿Õ¼ä£¬ÓÃ»§ÉêÇëÁÐ±í¸öÊýºÍnVideoInfoNumÒ»ÖÂ
    int                      nRetVideoInfoNum;      // ·µ»ØÊµ¼Ê»ñÈ¡µ½µÄ½âÂëÍ¨µÀÐÅÏ¢¸öÊý£¬SDK·µ»Ø
} NET_OUT_GET_VIDEOINFO;



// CLIENT_ControlDeviceEx port NET_CTRL_DEV_THERMO_GRAPHY_ENSHUTTER command to input parameter
typedef struct tagNET_IN_THERMO_EN_SHUTTER
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
    BOOL                bEnable;                            // switch shutter, TRUE on, FALSE off
} NET_IN_THERMO_EN_SHUTTER;

// CLIENT_ControlDeviceEx port NET_CTRL_DEV_THERMO_GRAPHY_ENSHUTTER command to output parameter
typedef struct tagNET_OUT_THERMO_EN_SHUTTER
{
    DWORD               dwSize;
} NET_OUT_THERMO_EN_SHUTTER;

// CLIENT_GetDevCaps port NET_THERMO_GRAPHY_CAPS command to input parameter
typedef struct tagNET_IN_THERMO_GETCAPS
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
} NET_IN_THERMO_GETCAPS;

// CLIENT_GetDevCaps port NET_THERMO_GRAPHY_CAPS command to output parameter
typedef struct tagNET_OUT_THERMO_GETCAPS
{
    DWORD               dwSize;
    DWORD               dwModes;                            // supported preset mode mask
    DWORD               dwColorization;                     // preset colorization mode mask
    DWORD               dwROIModes;                         // preset ROI mode mask
    RANGE               stBrightness;                       // brightness ability
    RANGE               stSharpness;                        // sharpness ability
    RANGE               stEZoom;                            // zoom ability
    RANGE               stThermographyGamma;                // Gamma ability
    RANGE               stSmartOptimizer;                   // optimize parameter ability
} NET_OUT_THERMO_GETCAPS;

// CLIENT_GetDevCaps port NET_RADIOMETRY_CAPS command to input parameter
typedef struct tagNET_IN_RADIOMETRY_GETCAPS
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
} NET_IN_RADIOMETRY_GETCAPS;

// temperature measurement mode type
typedef enum tagNET_RADIOMETRY_METERTYPE 
{
    NET_RADIOMETRY_METERTYPE_UNKNOWN,
    NET_RADIOMETRY_METERTYPE_SPOT,                          // spot
    NET_RADIOMETRY_METERTYPE_LINE,                          // line
    NET_RADIOMETRY_METERTYPE_AREA,                          // area
} NET_RADIOMETRY_METERTYPE;

// total number ability of spot, line and area
typedef struct tagNET_RADIOMETRY_TOTALNUM 
{
    DWORD               dwMaxNum;                           // max support number
    DWORD               dwMaxSpots;                         // max number of spot
    DWORD               dwMaxLines;                         // max number of line
    DWORD               dwMaxAreas;                         // max number of area
    char reserved[32]; 
} NET_RADIOMETRY_TOTALNUM;

// CLIENT_GetDevCaps port NET_RADIOMETRY_CAPS command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_GETCAPS
{
    DWORD                       dwSize;
    NET_RADIOMETRY_TOTALNUM     stTotalNum;                 // total number abllity of spot, line and area
    DWORD                       dwMaxPresets;               // max number of temperature measurement preset
    DWORD                       dwMeterType;                // type mask of temperature measurement mode, refer to NET_RADIOMETRY_METERTYPE 
    RANGE                       stObjectEmissivity;         // emissivity related ability
    RANGE                       stObjectDistance;           // distance related ability
    RANGE                       stReflectedTemperature;     // reflected temperature related ability
    RANGE                       stRelativeHumidity;         // relative humidity related ability
    RANGE                       stAtmosphericTemperature;   // atmospheric temperature related ability
    int                         nStatisticsMinPeriod;       // min storage data interval of temperature measuring point statistics function, unit is second.
    float                       fIsothermMaxTemp;           // color code bar max temperature value
    float                       fIsothermMinTemp;           // color code bar min temperature value
} NET_OUT_RADIOMETRY_GETCAPS;

// temperature measurement info
typedef struct tagNET_RADIOMETRYINFO
{
    int                 nMeterType;                         // return to temperature measurement type, refer to NET_RADIOMETRY_METERTYPE 
    int                 nTemperUnit;                        // temperature unit (currently configured temperature unit), refer to CFG_TEMPERATURE_UNIT 
    float               fTemperAver;                        // only return to this field when it is spot temperature or average temperature
    float               fTemperMax;                         // max temperature 
    float               fTemperMin;                         // min temperature 
    float               fTemperMid;                         // middle temperature value        
    float               fTemperStd;                         // standard deviation value
    char                reserved[64];
} NET_RADIOMETRYINFO;

// acquire thermal condition of temperature measurement   
typedef struct tagNET_RADIOMETRY_CONDITION
{
    int                 nPresetId;                          // preset number        
    int                 nRuleId;                            // rule number  
    int                 nMeterType;                         // temperature measurement type, refer to NET_RADIOMETRY_METERTYPE 
    char                szName[64];                         // name of temperature measurement, select from the name of temperature measurement configured rule
    int                 nChannel;                           // channel number
    char                reserved[256];
} NET_RADIOMETRY_CONDITION;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER command to input parameter
typedef struct tagNET_IN_RADIOMETRY_GETPOINTTEMPER
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number
    DH_POINT            stCoordinate;                       // temperature measurement spot coordinate, coordinate value 0~8192 
} NET_IN_RADIOMETRY_GETPOINTTEMPER;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_GETPOINTTEMPER
{
    DWORD               dwSize;
    NET_RADIOMETRYINFO  stPointTempInfo;                    // acquire the parameter value of temperature measurement spot
} NET_OUT_RADIOMETRY_GETPOINTTEMPER;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_RADIOMETRY_TEMPER command to input parameter
typedef struct tagNET_IN_RADIOMETRY_GETTEMPER
{
    DWORD                       dwSize;
    NET_RADIOMETRY_CONDITION    stCondition;                // acquire the temperature condition of temperature measurement 
} NET_IN_RADIOMETRY_GETTEMPER;

// CLIENT_QueryDevInfo port NET_QUERY_DEV_RADIOMETRY_TEMPER command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_GETTEMPER
{
    DWORD               dwSize;
    NET_RADIOMETRYINFO  stTempInfo;                         // acquire parameter value of temperature measurement
} NET_OUT_RADIOMETRY_GETTEMPER;

// CLIENT_ControlDeviceEx port NET_CTRL_DEV_RADIOMETRY_SETOSDMARK command to input parameter
typedef struct tagNET_IN_RADIOMETRY_SETOSDMARK
{
    DWORD                       dwSize;
    NET_RADIOMETRY_CONDITION    stCondition;                // it needs to set the matching condition of osd temperature measurement 
} NET_IN_RADIOMETRY_SETOSDMARK;

// CLIENT_ControlDeviceEx port NET_CTRL_DEV_RADIOMETRY_SETOSDMARK command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_SETOSDMARK
{
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_SETOSDMARK;

// CLIENT_StartFind port NET_FIND_RADIOMETRY command to input parameter
typedef struct tagNET_IN_RADIOMETRY_STARTFIND
{   
    DWORD               dwSize;
    NET_TIME            stStartTime;                       // query start time
    NET_TIME            stEndTime;                         // query end time
    int                 nMeterType;                        // query type
    int                 nChannel;                          // channel number
} NET_IN_RADIOMETRY_STARTFIND;

// CLIENT_StartFind port NET_FIND_RADIOMETRY command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_STARTFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                      // acquired query handle
    int                 nTotalCount;                       // total number of result which conforms to the query condition
} NET_OUT_RADIOMETRY_STARTFIND;

#define NET_RADIOMETRY_DOFIND_MAX 32

// CLIENT_DoFind port NET_FIND_RADIOMETRY command to input parameter
typedef struct tagNET_IN_RADIOMETRY_DOFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                      // query handle
    int                 nBeginNumber;                      // index number of query begin
    int                 nCount;                            // the number of query, max is NET_IN_RADIOMETRY_DOFIND_MAX 
} NET_IN_RADIOMETRY_DOFIND;

// return to query result
typedef struct tagNET_RADIOMETRY_QUERY
{
    NET_TIME            stTime;                            // record time
    int                 nPresetId;                         // preset number
    int                 nRuleId;                           // rule number
    char                szName[64];                        // query name
    DH_POINT            stCoordinate;                      // query temperature measurement coordinate
    int                 nChannel;                          // channel number
    NET_RADIOMETRYINFO  stTemperInfo;                      // temperature measurement info, currently nTemperMid, nTemperStd member invalid
    char                reserved[256];
} NET_RADIOMETRY_QUERY;

// CLIENT_DoFind port_FIND_RADIOMETRY command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_DOFIND
{   
    DWORD                       dwSize;
    int                         nFound;                             // actual query spot number
    NET_RADIOMETRY_QUERY        stInfo[NET_RADIOMETRY_DOFIND_MAX];  // temperature statistics info 
} NET_OUT_RADIOMETRY_DOFIND;

// CLIENT_StopFind port_FIND_RADIOMETRY command to input parameter
typedef struct tagNET_IN_RADIOMETRY_STOPFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                       // query handle 
} NET_IN_RADIOMETRY_STOPFIND;

// CLIENT_StopFind port_FIND_RADIOMETRY command to output parameter
typedef struct tagNET_OUT_RADIOMETRY_STOPFIND
{   
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_STOPFIND;

// thermal temperature measurement spot alarm result value type 
typedef enum tagNET_RADIOMETRY_RESULT 
{
    NET_RADIOMETRY_RESULT_UNKNOWN,
    NET_RADIOMETRY_RESULT_VAL,                  // concrete value 
    NET_RADIOMETRY_RESULT_MAX,                  // max
    NET_RADIOMETRY_RESULT_MIN,                  // min
    NET_RADIOMETRY_RESULT_AVR,                  // average
    NET_RADIOMETRY_RESULT_STD,                  // standard
    NET_RADIOMETRY_RESULT_MID,                  // middle
    NET_RADIOMETRY_RESULT_ISO,                  // ISO
    NET_RADIOMETRY_RESULT_DIFF,                 // difference
    NET_RADIOMETRY_RESULT_SLOPE,                // slope
} NET_RADIOMETRY_RESULT;

// thermal temperature measurement spot alarm condition 
typedef enum tagNET_RADIOMETRY_ALARMCONTION 
{
    NET_RADIOMETRY_ALARMCONTION_UNKNOWN,
    NET_RADIOMETRY_ALARMCONTION_BELOW,          // below
    NET_RADIOMETRY_ALARMCONTION_MATCH,          // equal 
    NET_RADIOMETRY_ALARMCONTION_ABOVE,          // above
} NET_RADIOMETRY_ALARMCONTION;

// thermal temperature measurement spot temperature abnormity alarm 
typedef struct tagALARM_HEATIMG_TEMPER_INFO
{
    char                szName[64];                         // temperature abnormal spot name, select from the temperature measurement rule config
    int                 nAlarmId;                           // alarm number    
    int                 nResult;                            // alarm result value nValue type, refer to enumeration NET_RADIOMETRY_RESULT 
    int                 nAlarmContion;                      // alarm condition, refer to enumeration NET_RADIOMETRY_ALARMCONTION 
    float               fTemperatureValue;                  // alarm temperature value 
    int                 nTemperatureUnit;                   // temperature unit (currently configured temperature unit), refer to CFG_TEMPERATURE_UNIT 
    DH_POINT            stCoordinate;                       // alarm spot coordinate, relative coordinate system, value is 0~8191 
    int                 nPresetID;                          // preset
    int                 nChannel;                           // channel number
    int                 nAction;                            // 0:start 1: stop
    char                reserved[240];
} ALARM_HEATIMG_TEMPER_INFO;

// thermal kindling point alarm 
typedef struct tagALARM_FIREWARNING_INFO
{
    int                 nPresetId;                          // preset number is selected from the temperature measurement rule config
    int                 nState;                             // 0-start, 1-finish 
    DH_RECT             stBoundingBox;                      // kindling point rectangular box 	
    int                 nTemperatureUnit;                   // temperature unit (currently configured temperature unit), refer to CFG_TEMPERATURE_UNIT 
    float               fTemperature;                       // max spot temperature value provided by same frame detection and differential detection 
    unsigned            nDistance;                          // kindling point distance, unit is meter, 0 means invalid
	GPS_POINT           stGpsPoint;                         // kindling point longitude and latitude
    int                 nChannel;                           // ¶ÔÓ¦ÊÓÆµÍ¨µÀºÅ
    char                reserved[252];
} ALARM_FIREWARNING_INFO;

// heat map metadata info 
typedef struct tagNET_RADIOMETRY_METADATA
{
    int                 nHeight;                            // height 
    int                 nWidth;                             // width 
    int                 nChannel;                           // channel 
    NET_TIME            stTime;                             // acquire data time
    int                 nLength;                            // data size
    char                szSensorType[64];                   // module type
    int                 nUnzipParamR;                       // uncompressing parameter R 
    int                 nUnzipParamB;                       // uncompressing parameter B
    int                 nUnzipParamF;                       // uncompressing parameter F
    int                 nUnzipParamO;                       // uncompressing parameter O
    char                Reserved[256];
} NET_RADIOMETRY_METADATA;

// heat map data 
typedef struct tagNET_RADIOMETRY_DATA
{
    NET_RADIOMETRY_METADATA     stMetaData;                 // metadata
    BYTE*                       pbDataBuf;                  // heat map data buffer (for compressed data, it is temperature data of each pixel inside, it can use metadata info to compress)
    DWORD                       dwBufSize;                  // heat map data buffer size
    char                        reserved[512];
} NET_RADIOMETRY_DATA;

//////////////////////////////////////////////////////////////////////////
/// \fn temperature distribution data state callback function 
/// \brief 
/// \param  LLONG lAttachHandle [OUT] subscription handle, CLIENT_RadiometryAttach returned value
/// \param  NET_RADIOMETRY_DATA* pBuf [OUT] heat map data info
/// \param  int nBufLen [OUT] state info length
/// \param  param  LDWORD dwUser user data
/// \return none
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fRadiometryAttachCB)(LLONG lAttachHandle, NET_RADIOMETRY_DATA* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_RadiometryAttach input parameter
typedef struct tagNET_IN_RADIOMETRY_ATTACH
{
    DWORD               dwSize;
    int                 nChannel;                           // video channel number -1, it means all
    fRadiometryAttachCB cbNotify;                           // state callback function pointer
    LDWORD              dwUser;                             // user data 
} NET_IN_RADIOMETRY_ATTACH;

// CLIENT_RadiometryAttach output parameter
typedef struct tagNET_OUT_RADIOMETRY_ATTACH
{
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_ATTACH;

// subscribe temperature distribution data (heat map)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RadiometryAttach(LLONG lLoginID, const NET_IN_RADIOMETRY_ATTACH* pInParam, NET_OUT_RADIOMETRY_ATTACH* pOutParam, int nWaitTime);

// cancel subscribing temperature distribution data£¬lAttachHandle is the returned value of CLIENT_RadiometryAttach
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDetach(LLONG lAttachHandle);

// CLIENT_RadiometryFetch input parameter
typedef struct tagNET_IN_RADIOMETRY_FETCH
{
    DWORD               dwSize;
    int                 nChannel;                           // channel number, channel number needs to be in accordance with subscription, -1 excluded
} NET_IN_RADIOMETRY_FETCH;

// CLIENT_RadiometryFetch output parameter
typedef struct tagNET_OUT_RADIOMETRY_FETCH 
{
    DWORD               dwSize;
    int                 nStatus;                            // 0: unknown, 1: free, 2: acquiring heat map
} NET_OUT_RADIOMETRY_FETCH;

// inform to start acquiring heat map data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryFetch(LLONG lLoginID, const NET_IN_RADIOMETRY_FETCH* pInParam, NET_OUT_RADIOMETRY_FETCH* pOutParam, int nWaitTime);

// radiometry data unachieving and conversion
/// \brief 
/// \param  pRadiometryData [IN] radiometry data, obtained from fRadiometryAttachCB 
/// \param  pGrayImg [IN, OUT] unachieved data, which is a grayscale image
///			you can pass NULL if this is not needed
///         you must ensure that the buffer is enough (no less than 'pixel number'*sizeof(unsigned short))
///         for each pixel, there is an unsigned short value representing the grayscale value (range: 0 ~ 16383)
///         and the ordering is top-left pixels in low memory address and lower-right pixels in high memory address 
/// \param  pTempForPixels [IN, OUT] temperature for each pixel
///			you can pass NULL if this is not needed
///         you must ensure that the buffer is enough (no less than 'pixel number'*sizeof(float))
///         for each pixel, there is a float value representing temperature at pixel position, in centigrade
///         and the ordering is top-left pixels in low memory address and lower-right pixels in high memory address 
/// \return TRUE for success, FALSE for failure
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDataParse(const NET_RADIOMETRY_DATA* pRadiometryData, unsigned short* pGrayImg, float* pTempForPixels);

//////////////////////////////////////////////////////////////////////////
// query the infomation of flux
//////////////////////////////////////////////////////////////////////////

// input parameter for flux infomation
typedef struct tagNET_IN_SIM_CARD_FLUX_INFO
{	
	DWORD dwSize;                 // size of this struct
	int nCardIndex;               // sim number£¬start from zero
}NET_IN_SIM_CARD_FLUX_INFO;

#define NET_FLUX_RECORD_MAX_NUM 7      // the max count for infomation of flux

// infomation of flux structure
typedef struct tagNET_SIM_CARD_FLUX_RECORD
{	
	NET_TIME stuDate;            // date
	UINT nDaySendFlux;           // the up flux on that day£¬unit:0.1kb
	UINT nDayRecvFlux;           // the down flux on that day£¬unit:0.1kb
	BYTE byReserved[512];        // reserved bytes

}NET_SIM_CARD_FLUX_RECORD;

// output parameter for flux infomation
typedef struct tagNET_OUT_SIM_CARD_FLUX_INFO
{
	DWORD dwSize;                                        // size of this struct        
	UINT nTotalFlux;                                     // the total flux£¬unit£º0.1kb  
	UINT nSendFlux;                                      // the up flux£¬unit£º0.1kb 
	UINT nRecvFlux;                                      // the down flux£¬unit£º0.1kb
	NET_TIME stuTime;                                    // the date of writing in the total flux
	int nRecordNum;                                      // the number of records£¬this value must LE NET_RECORD_MAX_NUM
	NET_SIM_CARD_FLUX_RECORD stuRecord[NET_FLUX_RECORD_MAX_NUM];  // the records of the last seven days

}NET_OUT_SIM_CARD_FLUX_INFO;

// get the flux infomattion of the sim card
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSimCardFlux(LLONG lLoginID,const NET_IN_SIM_CARD_FLUX_INFO* pNetDataIn,NET_OUT_SIM_CARD_FLUX_INFO* pNetDataOut,int nWaitTime = 1000);

// set the work mode of door
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDoorWorkMode(LLONG lLoginID,const NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE* pNetDataIn,NET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE* pNetDataOut,int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// control the cabin's led
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlCabinLED(LLONG lLoginID, EM_CABIN_LED_CONTROL_TYPE emType,const void *pInParam, void* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);


#define NET_SELECT_UPDATE_LOCK_MAX_NUM 32               // the max selection count when updating lock

// intput param for smart lock's channel info
typedef struct tagNET_IN_SELECT_UPDATE_LOCK_INFO
{
    DWORD dwSize;
    int nChannelNum;                                    // count of selected smart locks
    int nChannel[NET_SELECT_UPDATE_LOCK_MAX_NUM];       // array of selected smart lock channels
}NET_IN_SELECT_UPDATE_LOCK_INFO;

// output param for smart lock's channel info
typedef struct tagNET_OUT_SELECT_UPDATE_LOCK_INFO
{
    DWORD dwSize;   
}NET_OUT_SELECT_UPDATE_LOCK_INFO;

// select the smart lock(s) by channel(s)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SelectLockToUpdate(LLONG lLoginID,const NET_IN_SELECT_UPDATE_LOCK_INFO* pNetDataIn,NET_OUT_SELECT_UPDATE_LOCK_INFO* pNetDataOut,int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);


//////////////////////////////////////////////////////////////////////////
// ÄÜÁ¦ÐÅÏ¢
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//	Search Type
typedef enum
{
	ABILITY_DYNAMIC_CONNECT = 1,        // dynamic connect capacity
	ABILITY_WATERMARK_CFG = 17,			// Watermark configuration capacity
	ABILITY_WIRELESS_CFG = 18,			// wireless  configuration capacity
	ABILITY_DEVALL_INFO = 26,			// Device capacity list 
	ABILITY_CARD_QUERY = 0x0100,		// Card number search capacity 
	ABILITY_MULTIPLAY = 0x0101,			// Multiple-window preview capacity 
	ABILITY_QUICK_QUERY_CFG = 0x0102,	// Fast query configuration Capabilities
	ABILITY_INFRARED = 0x0121,			// Wireless alarm capacity 
	ABILITY_TRIGGER_MODE = 0x0131,		// Alarm activation mode function 
	ABILITY_DISK_SUBAREA = 0x0141,		// Network hard disk partition
	ABILITY_DSP_CFG = 0x0151,			// Query DSP Capabilities
	ABILITY_STREAM_MEDIA = 0x0161,		// Query SIP,RTSP Capabilities
	ABILITY_INTELLI_TRACKER = 0x0171,   // Search intelligent track capability.
} DH_SYS_ABILITY;

//////////////////////////////////////////////////////////////////////////
//	The function list device supported 
enum 
{
	EN_FTP = 0,						// FTP bitwise, 1: send out record file;  2: Send out snapshot file
	EN_SMTP,						// SMTP bitwise,1: alarm send out text mail 2: Alarm send out image3:support HealthMail
	EN_NTP,							// NTP	 Bitwise:1:Adjust system time 
	EN_AUTO_MAINTAIN,				// Auto maintenance  Bitwise:1:reboot 2:close  3:delete file
	EN_VIDEO_COVER,					// Privacy mask Bitwise  :1:multiple-window privacy mask 
	EN_AUTO_REGISTER,				// Auto registration	Bitwise:1:SDK auto log in after registration 
	EN_DHCP,						// DHCP	Bitwise 1:DHCP
	EN_UPNP,						// UPNP	Bitwise 1:UPNP
	EN_COMM_SNIFFER,				// COM sniffer  Bitwise :1:CommATM
	EN_NET_SNIFFER,					// Network sniffer Bitwise : 1:NetSniffer
	EN_BURN,						// Burn function Bitwise 1:Search burn status 
	EN_VIDEO_MATRIX,				// Video matrix Bitwise  1:Support video matrix or not 2:Support SPOT video matrix or not
	EN_AUDIO_DETECT,				// Video detection Bitwise :1:Support video detection or not 
	EN_STORAGE_STATION,				// Storage position Bitwise:1:Ftp server (Ips) 2:SBM 3:NFS 16:DISK 17:Flash disk 
	EN_IPSSEARCH,					// IPS storage search  Bitwise  1:IPS storage search 	
	EN_SNAP,						// Snapshot Bitwise  1:Resoluiton 2:Frame rate 3:Snapshoot  4:Snapshoot file image; 5:Image quality 
	EN_DEFAULTNIC,					// Search default network card search  Bitwise  1:Support
	EN_SHOWQUALITY,					// Image quality configuration time in CBR mode 1:support 
	EN_CONFIG_IMEXPORT,				// Configuration import& emport function capacity.  Bitwise   1:support 
	EN_LOG,							// Support search log page by page or not. Bitwise 1:support 
	EN_SCHEDULE,					// Record setup capacity. Bitwise  1:Redandunce  2:Pre-record 3:Record period
	EN_NETWORK_TYPE,				// Network type. Bitwise 1:Wire Network 2:Wireless Network 3:CDMA/GPRS,4:CDMA/GPRS multi network card
	EN_MARK_IMPORTANTRECORD,		// Important record. Bitwise 1:Important record mark
	EN_ACFCONTROL,					// Frame rate control activities. Bitwise 1:support frame rate control activities;2:support timing alarm type activate frame rate control(it does not support dynamic detection), this ability mutually exclusive with ACF ability.
	EN_MULTIASSIOPTION,				// Multiple-channel extra stream. Bitwise:1:support three channel extra stream
	EN_DAVINCIMODULE,				// Component modules bitwise: 1.Separate processing the schedule 2.Standard I franme Interval setting
	EN_GPS,                         // GPS function bitwise:1:Gps locate function	
	EN_MULTIETHERNET,				// Support multi net card query   bitwise: 1: support
	EN_LOGIN_ATTRIBUTE,             // Login properties   bitwise: 1: support query login properties  
	EN_RECORD_GENERAL,				// Recording associated  bitwise: 1:Normal recording; 2:Alarm recording; 
									// 3:Motion detection recording;  4:Local storage; 5: Network storage ;  
									// 6:Redundancy storage;  7:Local emergency storage
	EN_JSON_CONFIG,					// Whether support Json configuration, bitwise: 1: support Json
	EN_HIDE_FUNCTION,				// Hide function:bitwise::1,hide PTZ function
	EN_DISK_DAMAGE,                 // Harddisk damage information support ability: bitwise:1,harddisk damage information
	EN_PLAYBACK_SPEED_CTRL,			// Support playback network transmission speed control, bitwise::1 support playback acceleration 
	EN_HOLIDAYSCHEDULE,				// Support holiday period setup : bitwise:1,Support holiday period setup 
	EN_FETCH_MONEY_TIMEOUT,			// ATM fetch money overtime
	EN_BACKUP_VIDEO_FORMAT,			// Device backup support format. DAV, ASF
	EN_QUERY_DISK_TYPE,             // backup disk type query
	EN_CONFIG_DISPLAY_OUTPUT,       // backup device output of display (such as VGA) configuration, by bit: 1: configuration on tour of frame segmentation 
	EN_SUBBITRATE_RECORD_CTRL,      // backup extra stream control configuration, by bit: 1-extra stream control configuration
	EN_IPV6,                        // backup IPV6 configuration, by bit:1-IPV6 configuration
   	EN_SNMP,                        // SNMP
	EN_QUERY_URL,                   // back up query device's URL info, by bit: 1-query device's config URL info
	EN_ISCSI,						// ISCSI
	EN_RAID,						// Raid
	EN_HARDDISK_INFO,				// Support disk info query
	EN_PICINPIC,                    // support picture in pictu,by bit:1,set; 2,preview , record , query record , download record
	EN_PLAYBACK_SPEED_CTRL_SUPPORT, // same to EN_PLAYBACK_SPEED_CTRL
	EN_LF_XDEV,						// support LF-X series of 24, 32, 64 channels, label their encode ability with sepcial calculation, by bit 1: able;
	EN_DSP_ENCODE_CAP,				// support F5 DSP encode
	EN_MULTICAST,                   // support different multicast config for different channel
	EM_NET_LIMIT,   				// query the limit ability of net, bitwise,1-limit size of net send code stream  
	EM_COM422, 						// serial port 422
	EM_PROTOCAL_FRAMEWORK,			// support three generations of framework agrement or not(need actualize listMethod(),listService()),by F6 to visit
	EM_WRITE_DISK_OSD,				// write disk OSD overlying ,bitwise, 1-write disk OSD overlying configuration
	EM_DYNAMIC_MULTI_CONNECT,		// dynamic multi-connect,bitise,1-request reply video data
	EM_CLOUDSERVICE,  				// cloud service,bitwise,1- support private cloud service
	EM_RECORD_INFO,					// Video Information Report, by bit. 1-Active video information report, 2-Frame numbers inquiry support
	EN_DYNAMIC_REG,                 // Active Register Support, by bit. 1- Dynamic active register support.
	EM_MULTI_PLAYBACK,              // Multi-channel Preview and Playback, by bit. 1-Multi-channel preview and playback support.
	EN_ENCODE_CHN,					// Encoding Channel, by bit. 1- Audio-only channel support
    EN_SEARCH_RECORD,               // Record search, by bit, 1-support sync search record, 2-support 3rd generation protocol search record
    EN_UPDATE_MD5,                  // Support MD5 check after update file send finish£¬1- support MD5
};

typedef struct 
{
	DWORD IsFucEnable[512];			// Function list capacity set. Corresponding to the above mentioned enumeration. Use bit to represent sub-function.
} DH_DEV_ENABLE_INFO;

//////////////////////////////////////////////////////////////////////////
//Card number search function structure 
typedef struct 
{
	char		IsCardQueryEnable;
	char		iRev[3];
} DH_CARD_QUERY_EN;

//////////////////////////////////////////////////////////////////////////
//	Wireless capacity structure 
typedef struct 
{
	char		IsWirelessEnable;
	char		iRev[3];
} DH_WIRELESS_EN;

//////////////////////////////////////////////////////////////////////////
//	Image watermark capacity structure 
typedef struct 
{
	char		isSupportWM;		// 1:Support; 0 Do not support
	char		supportWhat;		// 0:Characrer watermark; 1:Image watermark; 2:Support character watermark and image watermark at the same time.
	char		reserved[2];
} DH_WATERMAKE_EN;

//////////////////////////////////////////////////////////////////////////
//	Multiple-window preview capacity structure 
typedef struct  
{
	int			nEnable;				// 1:Support;  0 :Do not support 
	DWORD		dwMultiPlayMask;		// Multiple-window preview mask 
	char		reserved[4];			// Reserved 
} DH_MULTIPLAY_EN;

//////////////////////////////////////////////////////////////////////////
//	Wireless alarm capacity structure 
typedef struct  
{
	BOOL		bSupport;				// Support or not 
	int			nAlarmInCount;			// Input amount
	int			nAlarmOutCount;			// Output amount 
	int			nRemoteAddrCount;		// Remote control amount 
	BYTE		reserved[32];
}DH_WIRELESS_ALARM_INFO;

//////////////////////////////////////////////////////////////////////////
// Network hard disk partition capacity structure
typedef struct 
{
	BOOL		bSupported;				// Support or not
	int			nSupportNum;			// Support the number of disk partition
	BYTE		bReserved[32];
} DH_DISK_SUBAREA_EN;

// DSP capabilities query ,use when DSP capabilities algorithm with ID 2.
typedef struct  
{
	BYTE bMainFrame[32];				//Use the resolution enumeration value (CAPTURE_SIZE) as index, the main code stream corresponds to the max resolution it support, if do not support, the value should be 0.
	BYTE bExtraFrame_1[32];				//Extra code stream1,use the same method as: bMainFrame
	BYTE bReserved[128];				//obligate for extra code stream 2 and 3.		
}DH_DSP_CFG_ITEM;

typedef struct  
{
	int nItemNum;						//Valid number of DH_DSP_CFG_ITEM, equals to channel number
	DH_DSP_CFG_ITEM	stuDspCfgItem[32];	//Main code stream Information
	BYTE bReserved[128];				//Retain
}DH_DSP_CFG; 

//////////////////////////////////////////////////////////////////////////
//	Fast query configuration capabilities struct 
typedef struct 
{
	char		IsQuickQueryEnable;    //1 is device support configuration command go back easily,please set enough configuration time to ensure reading the configuration in narrowband. Recommended for 60S
	char		iRev[3];
} DH_QUICK_QUERY_CFG_EN;

typedef struct  
{
	int			nStreamType;			// 0,null 1,SIP 2,RTSP
	BYTE		bReserved[16];			// Reserved
} DH_STREAM_MEDIA_EN;

//Search intelligent speed dome track capability 
typedef struct
{
	char		IsIntelliTrackerEnable;	// Has intelligent speed dome track capability if it is more than 0
	BYTE		bReserved[3];
}DH_INTELLI_TRACKER_EN;

#define NET_MAX_COMPOSITE_CHANNEL       256                 // ¡Á¨¦o?¨¨¨²o??¨¢¦Ì?¨ª¡§¦Ì¨¤¡Á?¡ä¨®¨ºy¨¢?

// ??¨¨?¨¨¨²o??¨¹¨¢|?¡¥¦Ì?¨º?¨¨?2?¨ºy, ??¨®|NET_COMPOSITE_CAPS
typedef struct tagNET_IN_COMPOSITE_CAPS 
{
    DWORD           dwSize;
    int             nChannelCount;                          // D¨¨¨°a¨¨¨²o?¦Ì?¡ä¡ã?¨²¨ºy¨¢?
    int             nChannels[NET_MAX_COMPOSITE_CHANNEL];   // D¨¨¨°a¨¨¨²o?¦Ì?¡ä¡ã?¨²o?¨¢D¡À¨ª
    int             nLayoutX;                               // ????¡¤??¨°¡ä¡ã?¨²¨ºy¨¢?
    int             nLayoutY;                               // ¡ä1?¡À¡¤??¨°¡ä¡ã?¨²¨ºy¨¢?
} NET_IN_COMPOSITE_CAPS;

// ??¨¨?¨¨¨²o??¨¹¨¢|?¡¥¦Ì?¨º?3?2?¨ºy, ??¨®|NET_COMPOSITE_CAPS
typedef struct tagNET_OUT_COMPOSITE_CAPS 
{
    DWORD           dwSize;
    int             nSplitModeCount;                        // ?¡ì3?¦Ì?¡¤????¡ê¨º?¨ºy¨¢?
    DH_SPLIT_MODE   emSplitModes[DH_MAX_SPLIT_MODE_NUM];    // ?¡ì3?¦Ì?¡¤????¡ê¨º?¨¢D¡À¨ª
    int             nMaxFreeWindow;                         // ¡Á?¡ä¨®?a¡ä¡ã¨ºy
} NET_OUT_COMPOSITE_CAPS;

#define MAX_REGISTER_ID_LEN       (256)
#define MAX_APP_ID_LEN            (256)
#define MAX_URL_LEN               (1024)
#define MAX_IOS_CERTIFICATE_LEN   (1024 * 14)
#define MAX_IOS_SECRET_KEY_LEN    (512)
#define MAX_MOBILE_CHANNEL_NUM    (256)

// Mobile server type
typedef enum tagEM_MOBILE_SERVER_TYPE
{
    EM_MOBILE_SERVER_TYPE_UNKNOWN,             // Unknown
    EM_MOBILE_SERVER_TYPE_APPLE,               // Apple
    EM_MOBILE_SERVER_TYPE_ANDROID,             // Android
    EM_MOBILE_SERVER_TYPE_SDKCLOUD,            // Private_CLOUD
} EM_MOBILE_SERVER_TYPE;

// Push server config info
typedef struct tagNET_PUSH_SERVER_INFO
{
    char                            szAddress[MAX_URL_LEN];                    // ip address
    int                             nPort;                                     // port
} NET_PUSH_SERVER_INFO;

// Event sub code type
typedef enum tagEM_EVENT_SUB_CODE
{
    EM_EVENT_SUB_CODE_UNKNOWN = -1,            // Unknown
    EM_EVENT_SUB_CODE_LOSS,                    // Loss
    EM_EVENT_SUB_CODE_COVER,                   // Cover
    EM_EVENT_SUB_CODE_FROZEN,                  // Frozen
    EM_EVENT_SUB_CODE_LIGHT,                   // Light
    EM_EVENT_SUB_CODE_DARK,                    // Dark
    EM_EVENT_SUB_CODE_SCENECHANGE,             // SceneChange
} EM_EVENT_SUB_CODE;

// Subscrbie info
typedef struct tagNET_SUBSCRIBE_INFO
{
    int                             nCode;                                     // Event code
    EM_EVENT_SUB_CODE               emSubCode;                                 // ¨º??t¡Á¨®¨¤¨¤D¨ª, EM_EVENT_SUB_CODE_UNKNOWN?a?TD¡ì
                                                                               // ????VideoAbnormalDetection,AlarmLocal¦Ì¨¨¡ã¨¹o??¨¤??¨¤¨¤D¨ª¦Ì?¡À¡§?¡¥¨º??t¨®DD¡ì
    int                             nChnNum;                                   // ????¦Ì?¨ª¡§¦Ì¨¤¨ºy¨¢?, ¨¨??T¨ª¡§¦Ì¨¤?????¨°?a0
    int                             nIndexs[MAX_MOBILE_CHANNEL_NUM];           // ¨ª¡§¦Ì¨¤o??¡¥o?
    char                            szNumber[DH_COMMON_STRING_16];             // ????"CallNoAnswered "¨º??t¨º¡À¨®DD¡ì
                                                                               // ?T¨®|¡äeo???¡ê¡§¨¦¨¨¡À?o??D?aD?o???¡ê??T¨®|¡äe¨º¡À¡ê????¨°¨º??¨²¨ª??¨ª???¡é¡ê?
                                                                               // CFG_CMD_MOBILE_PUSH_NOFITY_CFG¨º¡À¨®DD¡ì
    char                            szSound[DH_COMMON_STRING_64];              // ¨º??¨²??¨º?¦Ì?¡ä?¨º??t¨º¡À2£¤¡¤?D¨¨2£¤¡¤?¦Ì?¨¦¨´¨°????t
} NET_SUBSCRIBE_INFO;

// Push gateway type
typedef enum tagEM_PUSH_GATEWAY_TYPE
{
    EM_PUSH_GATEWAY_TYPE_UNKNOWN,              // Unknown
    EM_PUSH_GATEWAY_TYPE_APPLE_PUSH,           // ApplePush
    EM_PUSH_GATEWAY_TYPE_ANDROID_SDKPUSH,      // AndroidPrivatePush
    EM_PUSH_GATEWAY_TYPE_ANDROID_JPUSH,        // AndroidJPush
    EM_PUSH_GATEWAY_TYPE_ANDROID_GCM,          // AndroidGCM
} EM_PUSH_GATEWAY_TYPE;

// Mobile push notification, use RegisterID to subscribe
typedef struct tagNET_MOBILE_PUSH_NOTIFY
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // ¨º??¨²?¨°Appple/ Android¡¤t???¡Â¡Á¡é2¨¢¡¤¦Ì??¦Ì?¡ê???¡ä?2?¨ª?
    EM_MOBILE_SERVER_TYPE           emServerType;                              // ??¨¬¡§¨¤¨¤D¨ª
    int                             nPeriodOfValidity;                         // ¨®DD¡ì¨º¡À??¡ê?¦Ì£¤???a??
    char                            szAuthServerAddr[MAX_URL_LEN];             // Android?¨¦?¡è¡¤t???¡Â¦Ì??¡¤
    int                             nAuthServerPort;                           // Android?¨¦?¡è¡¤t???¡Â???¨²
    char                            szPushServerAddr[MAX_URL_LEN];             // ¨ª??¨ª¡¤t???¡Â¦Ì??¡¤(¡ä¨®?a¡ä¨²¨¤¨ª¡ê?????¡¤t???¡Â¡ê?1???¨¨Y)
                                                                               // ¨®¨¦¡ä¨®?a¡¤t???¡Â¡ã¡ä1¨´¡¤?¡¤t???¡Â¨°a?¨®¡ê???¨®?¡Á?D?¦Ì??¨®?¨¹??¡¤¡§?¨´¡Áa¡¤¡é??1¨´¡¤?¡¤t???¡Â
    int                             nPushServerPort;                           // ¨ª??¨ª¡¤t???¡Â???¨²(¡ä¨®?a¡ä¨²¨¤¨ª)
    NET_PUSH_SERVER_INFO            stuPushServerMain;                         // ¨ª??¨ª¡¤t???¡Â????, 1¨´¡¤??¡ê¨º¡Á??¡¤t???¡Â¡ê?¨¨?1?¨ª??¨ª¨º¡ì¡ã¨¹¡ê??¨´3¡é¨º????¡§?¨°?¨°¡ä¨²¨¤¨ª¡¤t???¡Â
    NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // ¨ª??¨ª¡¤t???¡Â????(¡ä¨®?a???¡§?¨°¡ê?¡ä???¡¤t???¡Â)
    char                            szDevName[DH_COMMON_STRING_64];            // ¨¦¨¨¡À?¡Àe??¡ê?¨º??¨²??¨¦¨¨????¨º?
    char                            szDevID[DH_COMMON_STRING_64];              // ¨¦¨¨¡À?¡À¨º¨º?¡ê?¨º??¨²??¨¦¨¨??¨º1¨®?
    char                            szUser[DH_COMMON_STRING_64];                  // ¦Ì???¨®??¡ì??
    char                            szPassword[DH_COMMON_STRING_64];              // ?¨¹??
    char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // ios?¡è¨º¨¦D??¡é¡ê?base64??o¨®¦Ì?¡Á?¡¤?¡ä?¡ê?D¨¨¨°a2¨¦¨®?TLS?¨®?¨¹¨º¡À¨®DD¡ì
    char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // ios?¨¹??¡ê?base64??o¨®¡Á?¡¤?¡ä?
    int                             nSubScribeMax;                             // ¡Á?¡ä¨®????¨¤¨¤D¨ª??¨ºy, ¡À¨ª¨º?pstuSubscribes¦Ì????¨®¨ºy¨¢?
    int                             nSubScribeNum;                             // ¨º¦Ì?¨º¦Ì?????¨¤¨¤D¨ª??¨ºy, ??¨¨?????¨®DD¡ì
    NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // ????¨¤¨¤D¨ª
} NET_MOBILE_PUSH_NOTIFY;

// Delete mobile push notification, CLIENT_DelMobilePushNotify's input param
typedef struct tagNET_MOBILE_PUSH_NOTIFY_DEL
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // ¨º??¨²?¨°Appple/ Android¡¤t???¡Â¡Á¡é2¨¢¡¤¦Ì??¦Ì?¡ê???¡ä?2?¨ª?
} NET_MOBILE_PUSH_NOTIFY_DEL;

// Mobile push notification config,  use RegisterID + AppID to subscribe
typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // ¨º??¨²?¨°Appple/ Android¡¤t???¡Â¡Á¡é2¨¢¡¤¦Ì??¦Ì?¡ê???¡ä?2?¨ª?
    char                            szAppID[MAX_APP_ID_LEN];                   // ¨º??¨²???a¨°????¨ª?¡ì??¡ê??¨¢2¨²¨¦¨²¨°???
    EM_MOBILE_SERVER_TYPE           emServerType;                              // ??¨¬¡§¨¤¨¤D¨ª
    EM_PUSH_GATEWAY_TYPE            emPushGatewayType;                         // ¨ª??¨ª¨ª?1?¨¤¨¤D¨ª, emServerType?aEM_MOBILE_SERVER_TYPE_SDKCLOUD¨º¡À¨®DD¡ì
    int                             nPeriodOfValidity;                         // ¨®DD¡ì¨º¡À??¡ê?¦Ì£¤???a??
    char                            szAuthServerAddr[MAX_URL_LEN];             // Android?¨¦?¡è¡¤t???¡Â¦Ì??¡¤
    int                             nAuthServerPort;                           // Android?¨¦?¡è¡¤t???¡Â???¨²
    char                            szPushServerAddr[MAX_URL_LEN];             // ¨ª??¨ª¡¤t???¡Â¦Ì??¡¤(¡ä¨®?a¡ä¨²¨¤¨ª¡ê?????¡¤t???¡Â¡ê?1???¨¨Y)
                                                                               // ¨®¨¦¡ä¨®?a¡¤t???¡Â¡ã¡ä1¨´¡¤?¡¤t???¡Â¨°a?¨®¡ê???¨®?¡Á?D?¦Ì??¨®?¨¹??¡¤¡§?¨´¡Áa¡¤¡é??1¨´¡¤?¡¤t???¡Â
    int                             nPushServerPort;                           // ¨ª??¨ª¡¤t???¡Â???¨²(¡ä¨®?a¡ä¨²¨¤¨ª)
    char                            szDevName[DH_COMMON_STRING_64];            // ¨¦¨¨¡À?¡Àe??¡ê?¨º??¨²??¨¦¨¨????¨º?
    char                            szDevID[DH_COMMON_STRING_64];              // ¨¦¨¨¡À?¡À¨º¨º?¡ê?¨º??¨²??¨¦¨¨??¨º1¨®?
    char                            szUser[DH_COMMON_STRING_64];                  // ¦Ì???¨®??¡ì??
    char                            szPassword[DH_COMMON_STRING_64];              // ?¨¹??
    char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // ios?¡è¨º¨¦D??¡é¡ê?base64??o¨®¦Ì?¡Á?¡¤?¡ä?¡ê?D¨¨¨°a2¨¦¨®?TLS?¨®?¨¹¨º¡À¨®DD¡ì
    char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // ios?¨¹??¡ê?base64??o¨®¡Á?¡¤?¡ä?
    int                             nSubScribeMax;                             // ¡Á?¡ä¨®????¨¤¨¤D¨ª??¨ºy, ¡À¨ª¨º?pstuSubscribes¦Ì????¨®¨ºy¨¢?
    int                             nSubScribeNum;                             // ¨º¦Ì?¨º¦Ì?????¨¤¨¤D¨ª??¨ºy, ??¨¨?????¨®DD¡ì
    NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // ????¨¤¨¤D¨ª
    NET_PUSH_SERVER_INFO            stuPushServerMain;                         // 
    NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // 
} NET_MOBILE_PUSH_NOTIFY_CFG;

// Delete mobile push notification config, CLIENT_DelMobilePushNotify's input param
typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG_DEL
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // ¨º??¨²?¨°Appple/ Android¡¤t???¡Â¡Á¡é2¨¢¡¤¦Ì??¦Ì?¡ê???¡ä?2?¨ª?
    char                            szAppID[MAX_APP_ID_LEN];                   // ¨º??¨²???a¨°????¨ª?¡ì??¡ê??¨¢2¨²¨¦¨²¨°???
} NET_MOBILE_PUSH_NOTIFY_CFG_DEL;

// NetSDK optimize type
typedef enum tagEmOptimizeType
{
    EM_OPT_TYPE_DEFAULT     = 0,    // default to do nothing
    EM_OPT_TYPE_MOBILE_V1   = 1,    // optimized for mobile
    EM_OPT_TYPE_P2P_NETPARAM_V1 = 2,    // the set for P2P network param£¬ pParam's type is  NET_PARAM*
}EM_OPTIMIZE_TYPE;

typedef struct tagNET_IN_MOTIONMATCH_PARAM
{
    DWORD                 dwSize;                   // structure size, dwSize needs to make valuation as sizeof(NET_IN_MOTIONMATCH_PARAM) 
    BOOL                  bFileName;                // if filename can be used as valid query condition, if the filename is valid, then it doesn¡¯t need to fill in file info (stRecordInfo) 
    char                  szFileName[MAX_PATH];     // file name 
    NET_RECORDFILE_INFO   stuRecordInfo;            // file info 
    int                   nRegionNum;               // number of vertex in rule detection area
    DH_POINT              stuRegion[DH_MAX_DETECT_REGION_NUM];    // rule detection area, x-coordinate 0~21, y-coordinate 0~17
} NET_IN_MOTIONMATCH_PARAM;

typedef struct tagNET_TIME_BEGIN_END
{
    NET_TIME              stuBegin;                 // begin
    NET_TIME              stuEnd;                   // end
} NET_TIME_BEGIN_END;

#define NET_SMART_SEARTCH_TIME_SECTION_MAX (128)

typedef struct tagNET_OUT_MOTIONMATCH_PARAM
{
    DWORD                 dwSize;                   // structure size, dwSize needs to make valuation as sizeof(NET_OUT_MOTIONMATCH_PARAM) 
    int                   nTimeNum;                 // queried time quantum number
    NET_TIME_BEGIN_END    stuTime[NET_SMART_SEARTCH_TIME_SECTION_MAX];   // time quantum
} NET_OUT_MOTIONMATCH_PARAM;

// CLIENT_SnapPictureToFile port input parameter
typedef struct tagNET_IN_SNAP_PIC_TO_FILE_PARAM 
{
    DWORD       dwSize;
    SNAP_PARAMS stuParam;               // snapshot parameter, mode field is only snapshot for once, fail to support timed or continuous snapshot; except mobile DVR, other devices only support snapshot frequency of one snapshot per second
    char        szFilePath[MAX_PATH];   // write in file address
}NET_IN_SNAP_PIC_TO_FILE_PARAM;

// CLIENT_SnapPictureToFile port output parameter
typedef struct tagNET_OUT_SNAP_PIC_TO_FILE_PARAM 
{
    DWORD       dwSize;
    char*       szPicBuf;               // picture content, user memory allocation
    DWORD       dwPicBufLen;            // picture content memory size, unit: byte
    DWORD       dwPicBufRetLen;         // returned picture size, unit:byte
}NET_OUT_SNAP_PIC_TO_FILE_PARAM;

//alarm event type DH_ALARM_BUS_SHARP_TURN (vehicle sharp turn event) corresponding data description info
typedef struct tagALARM_BUS_SHARP_TURN_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS info 
} ALARM_BUS_SHARP_TURN_INFO;

//alarm event type DH_ALARM_BUS_SCRAM (vehicle scram event) corresponding data description info 
typedef struct tagALARM_BUS_SCRAM_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS info 
} ALARM_BUS_SCRAM_INFO;

//alarm event type DH_ALARM_BUS_SHARP_ACCELERATE (vehicle sharp accelerate event) corresponding data description info
typedef struct tagALARM_BUS_SHARP_ACCELERATE_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS info 
} ALARM_BUS_SHARP_ACCELERATE_INFO;

//alarm event type DH_ALARM_BUS_SHARP_DECELERATE(vehicle sharp decelerate event) corresponding data description info 
typedef struct tagALARM_BUS_SHARP_DECELERATE_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS info 
} ALARM_BUS_SHARP_DECELERATE_INFO;


//access control card data operation type               
typedef enum tagNET_ACCESS_ACTION_TYPE        
{       
    NET_ACCESS_ACTION_TYPE_UNKNOWN  = 0,    // unknown               
    NET_ACCESS_ACTION_TYPE_INSERT   = 1,    // insert              
    NET_ACCESS_ACTION_TYPE_UPDATE   = 2,    // update              
    NET_ACCESS_ACTION_TYPE_REMOVE   = 3,    // remove               
}NET_ACCESS_ACTION_TYPE;   
        
//access control card data operation event        
typedef struct tagALARM_ACCESS_CARD_OPERATE_INFO       
{       
    DWORD                   dwSize;       
    NET_ACCESS_ACTION_TYPE  emActionType;                    // access control card data operation type               
    char                    szCardNo[DH_MAX_CARDINFO_LEN];   // access control card number               
    NET_THREE_STATUS_BOOL   emResult;                        // operation result, -1 is unknown, 0 is failure, 1 is success       
    int                     nChannelID;                      // ÃÅÍ¨µÀºÅ(»òÕßÃÅËø£¬ÃÅºÍÃÅËøÒ»Ò»¶ÔÓ¦), ´Ó0¿ªÊ¼
}ALARM_ACCESS_CARD_OPERATE_INFO;

// alarm event typeDH_EVENT_TAKENAWAYDETECTION (object move event) corresponding data description info  
typedef struct tagALARM_TAKENAWAY_DETECTION_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // event occurrence time
    int                 nEventID;                       // event ID 
    int                 nEventAction;                   // event action, 0 means pulse event, 1 means continuity event begins, 2 means continuity event ends

    int                 nOccurrenceCount;               // rule triggered occurrence times
    int                 nLevel;                         // event level, GB30147 requirement item, o hint, 1 general, 2 alarm
} ALARM_TAKENAWAY_DETECTION_INFO;

// alarm event type DH_EVENT_VIDEOABNORMALDETECTION (video abnormity event) corresponding data description info
typedef struct tagALARM_VIDEOABNORMAL_DETECTION_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // event occurrence time 
    int                 nEventID;                       // event ID
    int                 nEventAction;                   // event type, 0 means pulse event, 1 means continuity event begins, 2 means continuity event ends

    int                 nType;                          // detection type, 0-video loss, 1-video tampering, 2-image freeze, 3-over brightness, 4-over darkness, 5-scene change
                                                        // 6-stripe detection, 7-noise detection, 8- color cast detection, 9-video fuzziness detection, 10-contrast abnormity detection 
                                                        // 11-Video motion, 12-video flicker, 13-video color, 14- defocus detection, 15-overexposure detection
    int                 nValue;                         // detection value, the higher the value, the poorer the video quality
    int                 nOccurrenceCount;               // occurrence times of rule trigger
} ALARM_VIDEOABNORMAL_DETECTION_INFO;

typedef enum tagEM_NET_DEFENCE_AREA_TYPE
{
    EM_NET_DEFENCE_AREA_TYPE_UNKNOW,                    // unknown
    EM_NET_DEFENCE_AREA_TYPE_INTIME,                    // realtime protection area  
    EM_NET_DEFENCE_AREA_TYPE_DELAY,                     // delay protection area
    EM_NET_DEFENCE_AREA_TYPE_FULLDAY,                   // 24h protection area
} EM_NET_DEFENCE_AREA_TYPE;

// Alarm event type DH_EVENT_LOCALALARM (external alarm event) corresponding data description info
typedef struct tagALARM_LOCAL_ALARM_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // Event occurrence time 
    int                 nEventID;                       // Event ID
    int                 nEventAction;                   // Event action, 0 means pulse event, 1 means continuous event begin, 2 means continuous event end;

    int                 nSenseType;                     // sensor type
    int                 nDefenceAreaType;               // protection area type, refer to EM_NET_DEFENCE_AREA_TYPE 
} ALARM_LOCAL_ALARM_INFO;

// alarm event type DH_EVENT_MOTIONDETECT (video motion detection event) corresponding data description info
typedef struct tagALARM_MOTIONDETECT_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // event occurrence time
    int                 nEventID;                       // event ID
    int                 nEventAction;                   // event action, 0 means pulse event, 1 means continuous event begin, 2 means continuous event end;
} ALARM_MOTIONDETECT_INFO;

// alarm event type DH_ALARM_POLICE_CHECK (police sign in/out event) corresponding data description info
typedef struct tagALARM_POLICE_CHECK_INFO
{
    DWORD               dwSize;
    int                 nChannelID;                     // channel number
    double              PTS;                            // timestamp (unit is millisecond)
    NET_TIME_EX         UTC;                            // event occurrence time
    int                 nEventID;                       // Event ID
    int                 nEventAction;                   // Event action 

    char                szId[32];                       // sign in person ID number
    char                szName[32];                     // sign in person name, UTF8
    int                 nSignType;                      // type, refer to NET_DRIVER_CHECK_TYPE 
    NET_GPS_STATUS_INFO stuGPSStatusInfo;               // GPS info 
    char                szComment[1024];                // comment info 
} ALARM_POLICE_CHECK_INFO;

// alarm event type DH_ALARM_NEW_FILE (new file event) corresponding data description info
typedef struct tagALARM_NEW_FILE_INFO
{
    DWORD           dwSize;
    int             nChannel;                           // snapshot channel number
    int             nEventID;                           // event ID
    DWORD           dwEvent;                            // event type
    int             FileSize;                           // file size, unit is byte
    int             nIndex;                             // event source channel 
    DWORD           dwStorPoint;                        // storage point
    char            szFileName[DH_COMMON_STRING_128];   // file name
}ALARM_NEW_FILE_INFO;


// the status type of PTZ
typedef enum tagEM_PTZ_STATUS_TYPE
{
    EM_PTZ_STATUS_UNKNOW,                    // unknown
    EM_PTZ_STATUS_NORMAL,                    // nomal
    EM_PTZ_STATUS_PANOC_FAILED,              // PanOCFailed
    EM_PTZ_STATUS_TILEOC_FAILED,             // TileOCFailed
    EM_PTZ_STATUS_OC_FAILED                  // OCFailed
} EM_PTZ_STATUS_TYPE;


// the info of Ptz Diagnoses(DH_ALARM_PTZ_DIAGNOSES)
typedef struct tagALARM_PTZ_DIAGNOSES_INFO
{
	int 				nChannel;			// video channel
	NET_TIME_EX			UTC;				// the time when event happen
	EM_PTZ_STATUS_TYPE	emPtzStat;			// the status of PTZ
	BYTE                Reserved[512];
} ALARM_PTZ_DIAGNOSES_INFO;

// event type DH_ALARM_FLASH_LIGHT_FAULT (FlashLightFault event) corresponding data description info
typedef struct tagALARM_FLASH_LIGHT_FAULT_INFO
{
    double              PTS;                            // PTS(ms)
    NET_TIME_EX         UTC;                            // the event happen time
    int                 nEventAction;                   // Envet Action, 1-start,2-stop
    int                 nLightNum;                      // flash light number
    int                 nDevID[MAX_FLASH_LIGHT_NUM];    // the fault flash light ID
    int                 nLane;                          // lane number
    BYTE			    bReserved[512];				    // reserved
}ALARM_FLASH_LIGHT_FAULT_INFO;

// event DH_ALARM_STROBOSCOPIC_LIGTHT_FAULT (StroboscopicLightFault event) corresponding data description info
typedef struct tagALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO
{
    double              PTS;                                // PTS(ms)
    NET_TIME_EX         UTC;                                // the event happen time
    int                 nEventAction;                       // Envet Action, 1-start,2-stop
    int                 nLightNum;                          // stroboscopic light num 
    int                 nDevID[MAX_STROBOSCOPIC_LIGHT_NUM]; // the fault stroboscopic light ID
    int                 nLane;                              // lane number
    BYTE			    bReserved[512];				        // reserved
}ALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO;

// upper limit type
typedef enum tagEM_UPPER_LIMIT_TYPE
{
    EM_UPPER_LIMIT_TYPE_UNKNOWN,                             // unknow
    EM_UPPER_LIMIT_TYPE_ENTER_OVER,                          // "EnterOver"
    EM_UPPER_LIMIT_TYPE_EXIT_OVER,                           // "ExitOver"
    EM_UPPER_LIMIT_TYPE_INSIDE_OVER,                         // "InsideOver"
} EM_UPPER_LIMIT_TYPE;

// event type DH_ALARM_HUMAM_NUMBER_STATISTIC 
typedef struct tagALARM_NUMBER_STATISTIC_INFO 
{
    double              PTS;                            // PTC(ms)
    NET_TIME_EX         UTC;                            // event time
    int                 nEventAction;                   // Envet Action, 1-start,2-stop
    int                 nNumber;                        // the number of object which is in the area
    int                 nEnteredNumber;                 // entered object number
    int                 nExitedNumber;                  // exited object number
    EM_UPPER_LIMIT_TYPE emUpperLimitType;               // upper limit type(EnterOver, ExitOver, InsideOver)
    BYTE                reserved[512];                  // reserved
}ALARM_HUMAN_NUMBER_STATISTIC_INFO;

typedef struct tagALARM_VIDEOUNFOCUS_INFO
{
    int                 nEventAction;                   // event action, 0 means pulse event, 1 means continuous event begin, 2 means continuous event end
    BYTE                reserved[64];                   // reserved
}ALARM_VIDEOUNFOCUS_INFO;
// status
typedef enum tagEM_DEFENCEMODE
{
    EM_DEFENCEMODE_UNKNOWN,             // "unknown"   
    EM_DEFENCEMODE_ARMING,              // "Arming"    
    EM_DEFENCEMODE_DISARMING,           // "Disarming" 
}EM_DEFENCEMODE;

// event type DH_ALARM_DEFENCE_ARMMODECHANGE (Defence arming status change event)
typedef struct tagALARM_DEFENCE_ARMMODECHANGE_INFO 
{
    EM_DEFENCEMODE       emDefenceStatus;              //status
    int                  nDefenceID;                   //DefenceID
    NET_TIME_EX          stuTime;                      //the event happen time
    BYTE                 reserved[512];                //reserverd
}ALARM_DEFENCE_ARMMODECHANGE_INFO;

// status
typedef enum tagEM_SUBSYSTEMMODE
{
    EM_SUBSYSTEMMODE_UNKNOWN,             // "unknown"   
    EM_SUBSYSTEMMODE_ACTIVE,              // "active"    
    EM_SUBSYSTEMMODE_INACTIVE,            // "inactive"  
    EM_SUBSYSTEMMODE_UNDISTRIBUTED,       // "undistributed" 
    EM_SUBSYSTEMMODE_ALLARMING,           // "AllArming" 
    EM_SUBSYSTEMMODE_ALLDISARMING,        // "AllDisarming" 
    EM_SUBSYSTEMMODE_PARTARMING,          // "PartArming" 
}EM_SUBSYSTEMMODE;

// event type DH_ALARM_SUBSYSTEM_ARMMODECHANGE (Subsystem arming status change event)
typedef struct tagALARM_SUBSYSTEM_ARMMODECHANGE_INFO 
{
    EM_SUBSYSTEMMODE    emSubsystemMode;            //status (support report AllArming£¬AllDisarming£¬PartArming)
    NET_TIME_EX         UTC;                        //the event happen time
    char                szSubSystemname[64];        //subsystem name
    int                 nSubSystemID;               //SubSystemID
    BYTE                reserved[512];              //reserved
}ALARM_SUBSYSTEM_ARMMODECHANGE_INFO;

// infrared detection information event (Corresponding ALARM_RFID_INFO)
typedef struct tagALARM_RFID_INFO
{
    int                         nAction;                // 0:start 1:stop
    int                         nIndex;                 // channel ID
    NET_TIME_EX                 stuEventTime;           // event time
    int                         nValidCount;            // RFID  valid number of RFID 
    char                        szRfid[10][12];         // RFID array
}ALARM_RFID_INFO;

//event type DH_ALARM_SMOKE_DETECTION
typedef struct tagALARM_SMOKE_DETECTION_INFO
{
    int                 nAction;                        // 0:start 1:stop
    char                szName[128];                    // event name
    double              PTS;                            // PTC(ms)
    NET_TIME_EX         stuTime;                        // event time
    BYTE                reserved[128];                  // reserved               
}ALARM_SMOKE_DETECTION_INFO;

// TemperatureDifference Between Rule (DH_ALARM_BETWEENRULE_TEMP_DIFF)
typedef struct tagALARM_BETWEENRULE_DIFFTEMPER_INFO
{
    int                 nAction;                        // 0:start 1:stop
    int                 nOsdId;                         // config of TemperatureDifference OSD(OSDId)
    int                 nChannelID;                     // channel id
    NET_RADIOMETRY_ALARMCONTION     emAlarmContion;     // alarm condition
    int                 nRuleId1;                       // ThermometryRule1,refer to CFG_RADIOMETRY_RULE_INFO
    int                 nRuleId2;                       // ThermometryRule2,refer to CFG_RADIOMETRY_RULE_INFO
    float               fDiffValue;                     // Difference value between rules
    int                 nTemperatureUnit;               // TemperatureUnit,refer to CFG_TEMPERATURE_UNIT
    UINT                nPresetID;                      // Preset id
    BYTE                reserved[128];                  // reserved  
}ALARM_BETWEENRULE_DIFFTEMPER_INFO;

// hotspot warning(DH_ALARM_HOTSPOT_WARNING)
typedef struct tagALARM_HOTSPOT_WARNING_INFO
{
    int                 nAction;                        // 0:start 1:stop
    int                 nChannelID;                     // channel id
    DH_POINT            stuCoordinate;                   // hotspot point£¬ 0~8192
    float               fHotSpotValue;                  // hotspot value
    int                 nTemperatureUnit;               // temperature unit,refer to CFG_TEMPERATURE_UNIT
}ALARM_HOTSPOT_WARNING_INFO;

// coldspot warning(DH_ALARM_COLDSPOT_WARNING)
typedef struct tagALARM_COLDSPOT_WARNING_INFO
{
    int                 nAction;                        // 0:start 1:stop
    int                 nChannelID;                     // channel id
    DH_POINT            stuCoordinate;                   // coldspot point£¬ 0~8192
    float               fColdSpotValue;                  // coldspot value
    int                 nTemperatureUnit;               // temperature unit,refer to CFG_TEMPERATURE_UNIT
}ALARM_COLDSPOT_WARNING_INFO;

// flow meter info (DH_ALARM_FLOW_METER)
typedef struct tagALARM_FLOW_METER_INFO 
{
    DWORD           dwSize;
    float           fInstantRate;                       // Instant Rate m/s
    float           fInstantFlow;                       // Instant Flow m^3/h
    float           fTotalFlow;                         // Total Flow m^3
} ALARM_FLOW_METER_INFO;

// type of drop frame
typedef enum tagEM_BUF_DROP_FRAME_TYPE
{
    EM_BUF_DROP_FRAME_UNKOWN = 0,                       // frame type:unkonw
    EM_BUF_DROP_FRAME_DEVBUF,                           // frame type:main stream
    EM_BUF_DROP_FRAME_EXTBUF,                           // frame type:extra stream
    EM_BUF_DROP_FRAME_NETBUF,                           // frame type:net main stream 
    EM_BUF_DROP_FRAME_EXTRA1NETBUF                      // frame type:net extra1 stream
}EM_BUF_DROP_FRAME_TYPE;

// Video recond buffer drop frame event(DH_ALARM_BUF_DROP_FRAME)
typedef struct tagALARM_BUF_DROP_FRAME_INFO
{
    int                         nAction;                // 0:start 1:stop
    EM_BUF_DROP_FRAME_TYPE      emDropFrameType;        // type of drop frame
    BYTE                        reserved[1024];         // reserved
}ALARM_BUF_DROP_FRAME_INFO;


// Switch with master and slave (DH_ALARM_DCSSWITCH)
typedef struct tagALARM_DCSSWITCH_INFO
{
    int                         nAction;                // 0:start 1:stop
    char                        strMasterIP[32];        // Master device IP
    char                        strSlaveIP[32];         // Slave device IP
    NET_TIME_EX                 stuStartTime;           // the time when start switch
    BYTE                        reserved[1024];         // reserved
}ALARM_DCSSWITCH_INFO;

// Abnormal event when master broad'version and slave broad'version different (DH_ALARM_DOUBLE_DEV_VERSION_ABNORMAL)
typedef struct tagALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO
{
    int                         nAction;                // 0:start 1:stop
    char                        strMasterVer[64];       // master broad's version(when nAction is 0, this data is efficient)
    char                        strSlaveVer[64];        // slave broad's version(when nAction is 0, this data is efficient)
    BYTE                        reserved[1024];         // reserved
}ALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO;

// Radar connect state
typedef enum tagEM_RADAR_CONNECT_STATE
{
    EM_RADAR_CONNECT_STATE_UNKNOWN,     // unknown
    EM_RADAR_CONNECT_STATE_NORMAL,      // normal
    EM_RADAR_CONNECT_STATE_EXCEPTION,   // exception
}EM_RADAR_CONNECT_STATE;

// Radar connect state information event (DH_ALARM_RADAR_CONNECT_STATE)
typedef struct tagALARM_RADAR_CONNECT_STATE_INFO
{
    EM_RADAR_CONNECT_STATE      emRadarConnectState;    // Radar connect state
    BYTE                        reserved[1024];         // reserved
}ALARM_RADAR_CONNECT_STATE_INFO;

//CLIENT_SetMarkFileByTime input parameter
typedef enum tagEM_MARKFILE_MODE
{
	EM_MARK_FILE_BY_TIME_MODE,                              // add lock for record by time mode 
	EM_MARK_FILE_BY_NAME_MODE,                              // add lock for record by file mode 
}EM_MARKFILE_MODE;
typedef enum tagEM_MARKFILE_NAMEMADE_TYPE
{
	EM_MARKFILE_NAMEMADE_DEFAULT,							// default:need user pass record file name parameter szFilename
	EM_MARKFILE_NAMEMADE_JOINT,								// way of  file name split joint:pass the disk number ,pass the start cluster number,not need pass record file name
}EM_MARKFILE_NAMEMADE_TYPE;
//CLIENT_SetMarkFileByTimeEx input parameter
// Record file information
typedef struct tagNET_IN_SET_MARK_FILE
{
	DWORD               dwSize; 
	EM_MARKFILE_MODE	                    emLockMode;								// mode of lock for record,
	EM_MARKFILE_NAMEMADE_TYPE				emFileNameMadeType;						// way of create file name 
    int					nChannelID;								// channel ID
    char									szFilename[MAX_PATH];	                // file name
    unsigned int        nFramenum;								// the total number of file frames
    unsigned int        nSize;									// File length 
    NET_TIME            stuStartTime;							// Start time 
    NET_TIME            stuEndTime;								// End time 
    unsigned int        nDriveNo;								// HDD number
    unsigned int        nStartCluster;							// Initial cluster number
    BYTE                byRecordFileType;						// Recorded file type  0:general record;1:alarm record ;2:motion detection;3:card number record ;4:image 
    BYTE                byImportantRecID;						// 0:general record 1:Important record
    BYTE                byHint;									// Document Indexing
    BYTE                byRecType;								// 0-main stream record 1-sub1 stream record 2-sub2 stream record 3-sub3 stream record
} NET_IN_SET_MARK_FILE;
typedef struct tagNET_OUT_SET_MARK_FILE
{
    DWORD               dwSize; 
} NET_OUT_SET_MARK_FILE;
typedef struct tagNET_IN_SET_MARK_FILE_BY_TIME
{
    DWORD               dwSize;
    int                 nChannel;                             //the channel ID you want to lock, begin at 0, when the filed is -1,  it means all channels
    NET_TIME_EX         stuStartTime;                         //start time
    NET_TIME_EX         stuEndTime;                           //end time
    BOOL                bFlag;                                //action tag 	true : tag, false : clear
} NET_IN_SET_MARK_FILE_BY_TIME;

//CLIENT_SetMarkFileByTimeEx output parameter
typedef struct tagNET_OUT_SET_MARK_FILE_BY_TIME
{
    DWORD               dwSize; 
} NET_OUT_SET_MARK_FILE_BY_TIME;

//CLIENT_GetMarkInfo input parameter
typedef struct tagNET_IN_GET_MARK_INFO
{
    DWORD               dwSize;
} NET_IN_GET_MARK_INFO;

//CLIENT_GetMarkInfo output parameter 
typedef struct tagNET_OUT_GET_MARK_INFO
{
    DWORD               dwSize;
    int                 nTotalSpace;  //total capacity (unit M)
    int                 nMarkSpace;   //locked capacity of the video unit M 
} NET_OUT_GET_MARK_INFO;

//remove anti-submarine alarm input parameter 
typedef struct tagNET_IN_CLEAR_REPEAT_ENTER
{
    char         szCardNO[DH_MAX_CARDINFO_LEN];         // user card number
    BYTE         bReserved[1024];
}NET_IN_CLEAR_REPEAT_ENTER;

//remove anti-submarine alarm output parameter 
typedef struct tagNET_OUT_CLEAR_REPEAT_ENTER
{
    BYTE         bReserved[1024];
}NET_OUT_CLEAR_REPEAT_ENTER;

// alarm event type DH_ALARM_RECORD_LOSS (video loss event) corresponding data description info 
typedef struct tagALARM_RECORD_LOSS_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, 0:pulse, 1:start
    char                szIP[DH_MAX_IPADDR_LEN_EX];     // video loss device IP
    int                 nPort;                          // video loss device port 
    BYTE                byReserved[1024];               // reserve
} ALARM_RECORD_LOSS_INFO;

// alarm event type DH_ALARM_VIDEO_FRAME_LOSS (video frame loss event) corresponding data description info
typedef struct tagALARM_VIDEO_FRAME_LOSS_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, 0:Pulse,1:Start, 2: Stop 
    char                szIP[DH_MAX_IPADDR_LEN_EX];     // frame loss device IP 
    int                 nPort;                          // video loss device port 
    BYTE                byReserved[1024];               // reserve
} ALARM_VIDEO_FRAME_LOSS_INFO;

// alarm event type DH_ALARM_RECORD_VOLUME_FAILURE (disk volume abnormal) corresponding data description info 
typedef struct tagALARM_RECORD_VOLUME_FAILURE_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, 0:Pulse, 1: Start, 2: Stop
    BYTE                byReserved[1024];               // reserve
} ALARM_RECORD_VOLUME_FAILURE_INFO;

// event type DH_EVENT_SNAP_UPLOAD (picture uploading finish event) corresponding data description info 
typedef struct tagEVENT_SNAP_UPLOAD_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, 0: Pulse, 1: Start, 2: Stop
    BOOL                bSnapResult;                    // if the picture is uploaded successfully
    char                szFilePath[MAX_PATH];           // uploaded local picture name 
    BYTE                byReserved[1024];               // reserve 
}EVENT_SNAP_UPLOAD_INFO;

// alarm event type DH_ALARM_UPLOADPIC_FAILCOUNT (failed data number during uploading) corresponding data description info 
typedef struct tagALARM_UPLOADPIC_FAILCOUNT_INFO
{
    int                 nFailCount;                     // upload failure number
    BYTE                byReserved[1024];               // reserve
} ALARM_UPLOADPIC_FAILCOUNT_INFO;

// alarm event type DH_ALARM_HUMAN_INSIDE(Human inside) corresponding data description info
typedef struct tagALARM_HUMAN_INSIDE_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, -1: unknown, 0: start, 1: stop
    int                 nHumanNumber;                   // Human number inside
    NET_TIME            stuUtcTime;                     // event time
    BYTE                byReserved[1000];                // reserve  
} ALARM_HUMAN_INSIDE_INFO;

// alarm event type DH_ALARM_HUMAN_TUMBLE_INSIDE(someone tumbles inside) corresponding data description info
typedef struct tagALARM_HUMAN_TUMBLE_INSIDE_INFO
{
    int                 nChannelID;                     // channel number
    int                 nEventAction;                   // event action, -1: unknown, 0: start, 1: stop
    NET_TIME            stuUtcTime;                     // event time
    BYTE                byReserved[1000];                // reserve
} ALARM_HUMAN_TUMBLE_INSIDE_INFO;

// alarm event type DH_ALARM_DISABLE_LOCKIN(Lock entry trigger event) corresponding data description info
typedef struct tagALARM_DISABLE_LOCKIN_INFO
{
    int                 nChannelID;                     // channel number
    NET_TIME            stuUtcTime;                        // event time
    BYTE                byReserved[1000];                // reserve
} ALARM_DISABLE_LOCKIN_INFO;


// alarm event type DH_ALARM_DISABLE_LOCKOUT(Lock go out trigger)  corresponding data description info
typedef struct tagALARM_DISABLE_LOCKOUT_INFO
{
    int                 nChannelID;                     // channel number
    NET_TIME            stuUtcTime;                     // event time
    BYTE                byReserved[1000];               // reserve
} ALARM_DISABLE_LOCKOUT_INFO;

//CLIENT_GetOperatorName input parameter 
typedef struct tagNET_IN_GET_OPERATOR_NAME
{
    BYTE                byReserved[1024];               // reserve
} NET_IN_GET_OPERATOR_NAME;

//CLIENT_GetOperatorName output parameter 
typedef struct tagNET_OUT_GET_OPERATOR_NAME
{
    char                szOpearatorName[DH_COMMON_STRING_64]; //operator username 
    BYTE                byReserved[1024];                     // reserve 
} NET_OUT_GET_OPERATOR_NAME;

// CLIENT_GetSelfCheckInfo input param
typedef struct tagNET_IN_GET_SELTCHECK_INFO
{
    DWORD               dwSize;                  // caller must initializes it before using, should be sizeof (NET_IN_GET_SELTCHECK_INFO)
} NET_IN_GET_SELTCHECK_INFO;

//IVS event type EVENT_IVS_PTZ_PRESET(PTZ turn to preset enet)data description
typedef struct tagDEV_EVENT_ALARM_PTZ_PRESET_INFO
{
    int                 nChannelID;                                 // channel id
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                bReserved1[4];                              // keep align
    double              PTS;                                        // PTS
    NET_TIME_EX         UTC;                                        // event time
    int                 nEventID;                                   // event ID
    ///////////////////////////////up is common//////////////////////////////
    char                szPresetName[PTZ_PRESET_NAME_LEN];          // preset name
    PTZ_SPEED_UNIT      stuPos;                                     // preset ptz
    int                 nPresetID;                                  // preset id
    BYTE                bReserved[1024];                            // reserved
} DEV_EVENT_ALARM_PTZ_PRESET_INFO;

//IVS event type EVENT_IVS_RFID_INFO(event of infrared detect info)data description
typedef struct tagDEV_EVENT_ALARM_RFID_INFO
{
    int                 nChannelID;                                 // channel id
    char                szName[DH_EVENT_NAME_LEN];                  // event name
    char                bReserved1[4];                              // keep align
    double              PTS;                                        // PTS
    NET_TIME_EX         UTC;                                        // event time
    int                 nEventID;                                   // event ID
    ///////////////////////////////up is common//////////////////////////////
    int                 nAction;                                    // 0:start 1:stop
    int                 nValidCount;                                // the valid number of RFID identifier's array
    char                szRfid[10][12];                             // the array of RFID identifier
    BYTE                bReserved[1024];                            // reserved
} DEV_EVENT_ALARM_RFID_INFO;

// Initialization parameter
typedef struct tagNETSDK_INIT_PARAM
{
    int                 nThreadNum;         // specify netsdk's normal network process thread number, zero means using default value
    BYTE                bReserved[1024];    // reserved
}NETSDK_INIT_PARAM, *LPNETSDK_INIT_PARAM;

//////////////////////////////////////////////////////////////////////////
// RPC method name
//////////////////////////////////////////////////////////////////////////

#define RPC_METHOD_MONITORWALL_ADD      "monitorWallManager.addMonitorWall"     // add MonitorWall

/***********************************************************************
 ** Callback Function Definition 
 ***********************************************************************/

// Network disconnection callback function original shape 
typedef void (CALLBACK *fDisConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);

// network re-connection callback function original shape
typedef void (CALLBACK *fHaveReConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);

// The prototype of dynamic sub connection offline call function 
typedef void (CALLBACK *fSubDisConnect)(EM_INTERFACE_TYPE emInterfaceType, BOOL bOnline, LLONG lOperateHandle, LLONG lLoginID, LDWORD dwUser);

// monitor disconnect callback function
typedef void (CALLBACK *fRealPlayDisConnect)(LLONG lOperateHandle, EM_REALPLAY_DISCONNECT_EVENT_TYPE dwEventType, void* param, LDWORD dwUser);

// Real-time monitor data callback function original shape
typedef void (CALLBACK *fRealDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// Real-time monitor data callback function original shape---extensive
typedef void (CALLBACK *fRealDataCallBackEx)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser);

// OSD callback function original shape 
typedef void (CALLBACK *fDrawCallBack)(LLONG lLoginID, LLONG lPlayHandle, HDC hDC, LDWORD dwUser);

// Playback process by time callback function original shape
typedef void (CALLBACK *fTimeDownLoadPosCallBack) (LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, int index, NET_RECORDFILE_INFO recordfileinfo, LDWORD dwUser);

// Alarm message callback function original shape
typedef BOOL (CALLBACK *fMessCallBack)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);
// explanation of new parameter: 
// bAlarmAckFlag : TRUE,the event is affirmable event;FALSE,the event is not affirmable event
// nEventID is used by CLIENT_AlarmAck, when bAlarmAckFlag is TRUE, this data is efficient
// pBuf memory was managed by SDK 
typedef BOOL (CALLBACK *fMessCallBackEx1)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, BOOL bAlarmAckFlag, LONG nEventID, LDWORD dwUser);

// Listening server callback function original shape
typedef int (CALLBACK *fServiceCallBack)(LLONG lHandle, char *pIp, WORD wPort, LONG lCommand, void *pParam, DWORD dwParamLen, LDWORD dwUserData);

// Audio data of audio talk callback function original shape 
typedef void (CALLBACK *pfAudioDataCallBack)(LLONG lTalkHandle, char *pDataBuf, DWORD dwBufSize, BYTE byAudioFlag, LDWORD dwUser);

// Upgrade device callback function original shape
typedef void (CALLBACK *fUpgradeCallBack) (LLONG lLoginID, LLONG lUpgradechannel, int nTotalSize, int nSendSize, LDWORD dwUser);

// Transparent COM callback function original shape
typedef void (CALLBACK *fTransComCallBack) (LLONG lLoginID, LLONG lTransComChannel, char *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// Search device log data callback function original shape 
typedef void (CALLBACK *fLogDataCallBack)(LLONG lLoginID, char *pBuffer, DWORD dwBufSize, DWORD nTotalSize, BOOL bEnd, LDWORD dwUser);

// Snapshot callback function original shape 
// Encode Type 10: jpeg 0: number i frame of mpeg4 
typedef void (CALLBACK *fSnapRev)(LLONG lLoginID, BYTE *pBuf, UINT RevLen, UINT EncodeType, DWORD CmdSerial, LDWORD dwUser);

// GPS message subscription callback 
typedef void( CALLBACK *fGPSRev)(LLONG lLoginID, GPS_Info GpsInfo, LDWORD dwUserData);

// GPSGPS message subscription callback - extra
typedef void (CALLBACK *fGPSRevEx)(LLONG lLoginID, GPS_Info GpsInfo, ALARM_STATE_INFO stAlarmInfo, LDWORD dwUserData, void *reserved);

// GPS GPS subscription of temperature and humidity callback
typedef void (CALLBACK *fGPSTempHumidityRev)(LLONG lLoginID, GPS_TEMP_HUMIDITY_INFO GpsTHInfo, LDWORD dwUserData);

// Asynchronous data callback
typedef void (CALLBACK *fMessDataCallBack)(LLONG lCommand, LPNET_CALLBACK_DATA lpData, LDWORD dwUser);

// File Transfer callback
typedef void (CALLBACK *fTransFileCallBack)(LLONG lHandle, int nTransType, int nState, int nSendSize, int nTotalSize, LDWORD dwUser);

// intelligent analysis data callback;nSequence instruct the repeat picture's station,0 instruct the first time it appear, 2 instruct the last time it appear or it only appear once,1 instruct it will appear next time
// int nState = (int) reserved instruct current callback data's state, 0 means realtime data,1 means offline data,2 means send offline data over
typedef int  (CALLBACK *fAnalyzerDataCallBack)(LLONG lAnalyzerHandle, DWORD dwAlarmType, void* pAlarmInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);

// Asynchronism search device call
typedef void (CALLBACK *fSearchDevicesCB)(DEVICE_NET_INFO_EX *pDevNetInfo, void* pUserData);

// Asynchronism register device call
// typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);

// playback YUV callback function
typedef void (CALLBACK *fYUVDataCallBack)(LLONG lPlaybackHandle, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser, void *reserved);

/************************************************************************
 ** Interface Definition 
 ***********************************************************************/

// SDK Initialization 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Init(fDisConnect cbDisConnect, LDWORD dwUser);

// SDK Initialization, specify initialization parameter through struct NETSDK_INIT_PARAM,
// e.g., netsdk's normal network process thread number.
// equivalent to CLIENT_Init when lpInitParam is NULL
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitEx(fDisConnect cbDisConnect, LDWORD dwUser, LPNETSDK_INIT_PARAM lpInitParam = NULL);

// SDK exit and clear
CLIENT_NET_API void CALL_METHOD CLIENT_Cleanup();

//------------------------------------------------------------------------

// Set re-connection callback function after disconnection. Internal SDK  auto connect again after disconnection 
CLIENT_NET_API void CALL_METHOD CLIENT_SetAutoReconnect(fHaveReConnect cbAutoConnect, LDWORD dwUser);

// Dynamic sub-set link disconnected callback function, the current monitoring and playback equipment SVR is a short connection
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubconnCallBack(fSubDisConnect cbSubDisConnect, LDWORD dwUser);

// Return the function execution failure code
CLIENT_NET_API DWORD CALL_METHOD CLIENT_GetLastError(void);

// Set device connection timeout value and trial times 
CLIENT_NET_API void CALL_METHOD CLIENT_SetConnectTime(int nWaitTime, int nTryTimes);

// Set log in network environment 
CLIENT_NET_API void CALL_METHOD CLIENT_SetNetworkParam(NET_PARAM *pNetParam);

// Get SDK version information 
CLIENT_NET_API DWORD CALL_METHOD CLIENT_GetSDKVersion();

//------------------------------------------------------------------------

// Register to the device 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_Login(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, LPNET_DEVICEINFO lpDeviceInfo, int *error = 0);

// Expension interfacenSpecCap =0 is login under TCP mode, nSpecCap =2 is login with active registeration, nSpecCap =3 is login under multicast mode,
//			 nSpecCap =4 is login under UDP mode, nSpecCap =6 is login with main connection,nSpecCap =7 is SSL encription
//			 nSpecCap=9 is login in to remote device, enter void* pCapParam as remote device name
//          nSpecCap = 12 is login under LDAP mode
//          nSpecCap = 13 is login under AD mode
//           nSpecCap = 14 is Radius login 
//             nSpecCap = 15 is Socks5 login¡ê?now void* pCapParam fill in Socks5 server IP&&port&&ServerName&&ServerPassword string
//             nSpecCap = 16 is proxy login¡ê?now void* pCapParam fill in SOCKET value
//             nSpecCap = 19 is web privatepenestrating login
//             nSpecCap = 20 mobile phone client login
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginEx(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, int nSpecCap, void* pCapParam, LPNET_DEVICEINFO lpDeviceInfo, int *error = 0);

// Login extension interface
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginEx2(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, EM_LOGIN_SPAC_CAP_TYPE emSpecCap, void* pCapParam, LPNET_DEVICEINFO_Ex lpDeviceInfo, int *error = 0);

// Asynchronism login device 
// nSpecCap = 0 TCP login,nSpecCap = 6 only main connect login
// nSpecCap = 19 is private penestrating login
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartLogin(char *pchDVRIP, WORD wDVRPort, char *pchUserName, char *pchPassword, int nSpecCap, void* pCapParam, fHaveLogin cbLogin, LDWORD dwUser);

// Only when CLIENT_StartLogin () callback errors for 11 when asynchronous log in using the interface to continue
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartLoginEx(NET_IN_STARTLOGINEX* pInParam, NET_OUT_STARTLOGINEX* pOutParam);

// stop login
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLogin(LLONG lLoginID);

CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoginEx(LLONG lLoginID);

// Log out the device 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Logout(LLONG lLoginID);


//------------------------------------------------------------------------

// Begin real-time monitor 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlay(LLONG lLoginID, int nChannelID, HWND hWnd);

// Begin real-time monitor--extensive
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlayEx(LLONG lLoginID, int nChannelID, HWND hWnd, DH_RealPlayType rType = DH_RType_Realplay);

//start real-time monitor
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRealPlay(LLONG lLoginID, int nChannelID, HWND hWnd, DH_RealPlayType rType, fRealDataCallBackEx cbRealData, fRealPlayDisConnect cbDisconnect, LDWORD dwUser, DWORD dwWaitTime = 10000);

// Multiple-window preview 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MultiPlay(LLONG lLoginID, HWND hWnd);

// Stop multiple-window preview 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopMultiPlay(LLONG lMultiHandle);

// Snapshot;hPlayHandle is monitor or playback handle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePicture(LLONG hPlayHandle, const char *pchPicFileName);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePictureEx(LLONG hPlayHandle, const char *pchPicFileName, NET_CAPTURE_FORMATS eFormat);

// Set real-time monitor data callback 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBack(LLONG lRealHandle, fRealDataCallBack cbRealData, LDWORD dwUser);

// Set real-time monitor data callback--extensive 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBackEx(LLONG lRealHandle, fRealDataCallBackEx cbRealData, LDWORD dwUser, DWORD dwFlag);

// Set video fluency
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_AdjustFluency(LLONG lRealHandle, int nLevel);

// Save data as file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SaveRealData(LLONG lRealHandle, const char *pchFileName);

// Stop saving data as file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSaveRealData(LLONG lRealHandle);

// Set video property
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClientSetVideoEffect(LLONG lPlayHandle, unsigned char nBrightness, unsigned char nContrast, unsigned char nHue, unsigned char nSaturation);

// Get video property 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClientGetVideoEffect(LLONG lPlayHandle, unsigned char *nBrightness, unsigned char *nContrast, unsigned char *nHue, unsigned char *nSaturation);

// Set screen overlay callback 
CLIENT_NET_API void CALL_METHOD CLIENT_RigisterDrawFun(fDrawCallBack cbDraw, LDWORD dwUser);

// Open audio 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenSound(LLONG hPlayHandle);

// Set volume;lPlayHandle is monitor handle or playabck handle 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVolume(LLONG lPlayHandle, int nVolume);

// If use HD iamge internal adjustment strategy¡ê?enable by default. This strategy is used, when quick play x4 and higher, only play 1 frame, When disable, play every frame. 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayEnableLargePicAdjustment(LLONG lPlayHandle, BOOL bEnable);

// Stop audio 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseSound();

// Stop real-time preview 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealPlay(LLONG lRealHandle);

// stop real-time preview-extensive
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealPlayEx(LLONG lRealHandle);

//------------------------------------------------------------------------

// general PTZ control
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZControl(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, DWORD dwStep, BOOL dwStop);

// Private PTZ control 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControl(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, unsigned char param1, unsigned char param2, unsigned char param3, BOOL dwStop,void* param4=NULL);

//  private PTZ control extensive port. support 3D intelligent position
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControlEx(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, LONG lParam1, LONG lParam2, LONG lParam3, BOOL dwStop);

// private PTZ control expansion port ¡ê?support 3D quick positioning, Fish eye 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControlEx2(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, LONG lParam1, LONG lParam2, LONG lParam3, BOOL dwStop , void* param4 = NULL);

//------------------------------------------------------------------------
// query record state everyday in the month
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordStatus(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmMonth, char* pchCardid, LPNET_RECORD_STATUS pRecordStatus, int waittime=1000);

// Search whether there is recorded file in specified period
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordTime(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, BOOL *bResult, int waittime=1000);

// Search all recorded file sin the specified periods
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordFile(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, LPNET_RECORDFILE_INFO nriFileinfo, int maxlen, int *filecount, int waittime=1000, BOOL bTime = FALSE);

// Async search period all record files
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartQueryRecordFile(LLONG lLoginID, NET_IN_START_QUERY_RECORDFILE *pInParam, NET_OUT_START_QUERY_RECORDFILE *pOutParam);

// search first 16 records
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuickQueryRecordFile(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, LPNET_RECORDFILE_INFO nriFileinfo, int maxlen, int *filecount, int waittime=1000, BOOL bTime = FALSE);


// Query the first record time 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryFurthestRecordTime(LLONG lLoginID, int nRecordFileType, char *pchCardid, NET_FURTHEST_RECORD_TIME* pFurthrestTime, int nWaitTime);

// Begin searching recorded file
CLIENT_NET_API LLONG	CALL_METHOD CLIENT_FindFile(LLONG lLoginID, int nChannelId, int nRecordFileType, char* cardid, LPNET_TIME time_start, LPNET_TIME time_end, BOOL bTime, int waittime);

// Search recorded file 
CLIENT_NET_API int	CALL_METHOD CLIENT_FindNextFile(LLONG lFindHandle,LPNET_RECORDFILE_INFO lpFindData);

// Stop searching recorded file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindClose(LLONG lFindHandle);

// Playback in file 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// Playback in file--extensive
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileEx(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser);

// playback in file - disconnect callback
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartPlayBackByRecordFile(LLONG lLoginID,  LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, 
															 fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
															 fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, 
															 fRealPlayDisConnect fDisConnectCallBack, LDWORD dwDisUser, DWORD dwWaitTime = 10000);

//Playback in file--Drop frame playback (not enough bandwidth can be used)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FramCotrolPlayBackByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, 
																   fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
																   fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, unsigned int nCutFrameRate);

// Playback in time
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser);

// Playback in time--extensive
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeEx(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
													 fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
													 fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser);

// Playback by time, support playback by direction compare to the old version
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeEx2(LLONG lLoginID, int nChannelID, 
                        NET_IN_PLAY_BACK_BY_TIME_INFO *pstNetIn, NET_OUT_PLAY_BACK_BY_TIME_INFO *pstNetOut);

// playback in time--disconnect callback
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartPlayBackByTime(LLONG lLoginID, int nChannelID, 
													   LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
													   fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser,
													   fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, 
													   fRealPlayDisConnect fDisConnectCallBack, LDWORD dwDisUser, DWORD dwWaitTime = 10000);

//Playback in time--Drop frame playback (not enough bandwidth can be used)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FramCotrolPlayBackByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
															 fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
															 fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, unsigned int nCutFrameRate);

//playback by synopsis file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackBySynopsisFile(LLONG lLoginID, 
															LPNET_SYNOPSISFILE_INFO lpRecordFile, 
															HWND hWnd, 
															fDownLoadPosCallBack cbDownLoadPos,
															LDWORD dwPosUser, 
															fDataCallBack fDownLoadDataCallBack,
															LDWORD dwDataUser,
															LDWORD dwUser);

// multi-channel preview palyabck
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MultiPlayBack(LLONG lLoginID, NET_MULTI_PLAYBACK_PARAM *pParam);

// position record playback initial point
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SeekPlayBack(LLONG lPlayHandle, unsigned int offsettime, unsigned int offsetbyte);

// Pause or restore file playback 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PausePlayBack(LLONG lPlayHandle, BOOL bPause);

// Fast playback file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FastPlayBack(LLONG lPlayHandle);

// Slow playback file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SlowPlayBack(LLONG lPlayHandle);

// Step playback file 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StepPlayBack(LLONG lPlayHandle, BOOL bStop);

// Control playback direction--Forward or Backward playback
// bBackward FALSE:normal play TRUE:upend
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayBackControlDirection(LLONG lPlayHandle, BOOL bBackward);

// Set playback frame rate 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFramePlayBack(LLONG lPlayHandle, int framerate);

// Get playback frame rate
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFramePlayBack(LLONG lPlayHandle, int *fileframerate, int *playframerate);

// Restore ordinary playback
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NormalPlayBack(LLONG lPlayHandle);

// smart search play back
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SmartSearchPlayBack(LLONG lPlayHandle, LPIntelligentSearchPlay lpPlayBackParam);

// Get playback OSD time 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlayBackOsdTime(LLONG lPlayHandle, LPNET_TIME lpOsdTime, LPNET_TIME lpStartTime, LPNET_TIME lpEndTime);

// Stop file playback 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopPlayBack(LLONG lPlayHandle);

// Download recorded file 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByRecordFile(LLONG lLoginID,LPNET_RECORDFILE_INFO lpRecordFile, char *sSavedFileName, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// Download video files - extension
// sSavedFileName Is not null, video data written to the corresponding file path; fDownLoadDataCallBack Is not null, video data through the callback function returns 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByRecordFileEx(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, char *sSavedFileName, 
                                                           fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData, 
                                                           fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, void* pReserved = NULL);

// Download file by time 
// nRecordFileType corresonding to emum EM_QUERY_RECORD_TYPE
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByTime(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char *sSavedFileName, fTimeDownLoadPosCallBack cbTimeDownLoadPos, LDWORD dwUserData);

// Through the time to download the video - extension
// sSavedFileName Is not null, video data written to the corresponding file path; fDownLoadDataCallBack Is not null, video data through the callback function returns
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByTimeEx(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char *sSavedFileName, 
                                                     fTimeDownLoadPosCallBack cbTimeDownLoadPos, LDWORD dwUserData, 
                                                     fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, void* pReserved = NULL);

// Search record download process 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDownloadPos(LLONG lFileHandle, int *nTotalSize, int *nDownLoadSize);

// Stop record download 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDownload(LLONG lFileHandle);

//partial enlarged
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDisplayRegion(LLONG lPlayHandle,DWORD nRegionNum, DH_DISPLAYRREGION *pSrcRect, HWND hDestWnd, BOOL bEnable);

// start to search record file frame info
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindFrameInfo(LLONG lLoginID, NET_IN_FIND_FRAMEINFO_PRAM *pInParam, NET_OUT_FIND_FRAMEINFO_PRAM* pOutParam, int nWaitTime);

// search record file frame info, search by specified info item
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindNextFrameInfo(LLONG lFindHandle, NET_IN_FINDNEXT_FRAMEINFO_PRAM *pInParam, NET_OUT_FINDNEXT_FRAMEINFO_PRAM* pOutParam, int nWaitTime);

// end record file search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindFrameInfoClose(LLONG lFindHandle);
// pInParam, pOutParam memory managed by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FileStreamMotionMatch(LLONG lLoginID, const NET_IN_MOTIONMATCH_PARAM *pInParam, NET_OUT_MOTIONMATCH_PARAM* pOutParam, int nWaitTime);

//------------------------------------------------------------------------

// Set alarm callback function 
CLIENT_NET_API void CALL_METHOD CLIENT_SetDVRMessCallBack(fMessCallBack cbMessage,LDWORD dwUser);

CLIENT_NET_API void CALL_METHOD CLIENT_SetDVRMessCallBackEx1(fMessCallBackEx1 cbMessage,LDWORD dwUser);


// subscribe alarm 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartListen(LLONG lLoginID);

// subscribe alarm---extensive
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartListenEx(LLONG lLoginID);

// Stop subscribe alarm 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopListen(LLONG lLoginID);

// alarm reset
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AlarmReset(LLONG lLoginID, DWORD dwAlarmType, int nChannel, void* pReserved = NULL, int nWaitTime = 1000);

//------------------------------------------------------------------------

// actively registration function. enable service. nTimeout is invalid. 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ListenServer(char* ip, WORD port, int nTimeout, fServiceCallBack cbListen, LDWORD dwUserData);

// stop service
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopListenServer(LLONG lServerHandle);

// Respond the registration requestion from the device 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResponseDevReg(char *devSerial, char* ip, WORD port, BOOL bAccept);

//------------------------------------------------------------------------

// Alarm upload function. Enable service. dwTimeOut paramter is invalid 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartService(WORD wPort, char *pIp = NULL, fServiceCallBack pfscb = NULL, DWORD dwTimeOut = 0xffffffff, LDWORD dwUserData = 0);

// Stop service 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopService(LLONG lHandle);

//------------------------------------------------------------------------

// Set audio talk mode(client-end mode or server mode)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceMode(LLONG lLoginID, EM_USEDEV_MODE emType, void* pValue);

// Enable audio talk 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTalkEx(LLONG lLoginID, pfAudioDataCallBack pfcb, LDWORD dwUser);

// Begin PC record 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStart();

// Stop PC record 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStop();


// start PC record(to CLIENT_RecordStart()extend)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStartEx(LLONG lLoginID);

// end PC record(to CLIENT_RecordStop() extend)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStopEx(LLONG lLoginID);


// Send out audio data to the device 
CLIENT_NET_API LONG CALL_METHOD CLIENT_TalkSendData(LLONG lTalkHandle, char *pSendBuf, DWORD dwBufSize);

// Decode audio data 
CLIENT_NET_API void CALL_METHOD CLIENT_AudioDec(char *pAudioDataBuf, DWORD dwBufSize);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioDecEx(LLONG lTalkHandle, char *pAudioDataBuf, DWORD dwBufSize);

// Set audio talk volume
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAudioClientVolume(LLONG lTalkHandle, WORD wVolume);

// Stop audio talk 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTalkEx(LLONG lTalkHandle);

// add device into broadcast group 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioBroadcastAddDev(LLONG lLoginID);

// Remove device from the broadcast group 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioBroadcastDelDev(LLONG lLoginID);

// audio encode-initialization(specified standard format, private format)
CLIENT_NET_API int  CALL_METHOD CLIENT_InitAudioEncode(DH_AUDIO_FORMAT aft);

// Audio encode--data encode
CLIENT_NET_API int	CALL_METHOD	CLIENT_AudioEncode(LLONG lTalkHandle, BYTE *lpInBuf, DWORD *lpInLen, BYTE *lpOutBuf, DWORD *lpOutLen);

// audio encode--complete and then exit
CLIENT_NET_API int	CALL_METHOD	CLIENT_ReleaseAudioEncode();

//------------------------------------------------------------------------

// Search device log
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLog(LLONG lLoginID, char *pLogBuffer, int maxlen, int *nLogBufferlen, int waittime=3000);

// Search device log page by page.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceLog(LLONG lLoginID, QUERY_DEVICE_LOG_PARAM *pQueryParam, char *pLogBuffer, int nLogBufferLen, int *pRecLogNum, int waittime=3000);

// search device log item
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevLogCount(LLONG lLoginID, NET_IN_GETCOUNT_LOG_PARAM *pInParam, NET_OUT_GETCOUNT_LOG_PARAM* pOutParam , int waittime=3000);

// Search channel record status 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordState(LLONG lLoginID, char *pRSBuffer, int maxlen, int *nRSBufferlen, int waittime=1000);

// Search channel extra record status (the returned byte number was equal to the channel number, every byte instruct the respond channel's state,0-stop,1-manual,2-schedule)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryExtraRecordState(LLONG lLoginID, char *pRSBuffer, int maxlen, int *nRSBufferlen, void *pReserved, int waittime=1000);

// Search device status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevState(LLONG lLoginID, int nType, char *pBuf, int nBufLen, int *pRetLen, int waittime=1000);

// query remote device state,when nType = DH_DEVSTATE_ALARM_FRONTDISCONNECT,the number form 1.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRemotDevState(LLONG lLoginID, int nType, int nChannelID, char *pBuf, int nBufLen, int *pRetLen, int waittime=1000);

// Search system capacity information 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuerySystemInfo(LLONG lLoginID, int nSystemType, char *pSysInfoBuffer, int maxlen, int *nSysInfolen, int waittime=1000);

// New Search system capacity information(by Json)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNewSystemInfo(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime=1000);

// Get channel bit stream 
CLIENT_NET_API LONG CALL_METHOD CLIENT_GetStatiscFlux(LLONG lLoginID, LLONG lPlayHandle);

// Get PTZ information 
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetPtzOptAttr(LLONG lLoginID,DWORD dwProtocolIndex,LPVOID lpOutBuffer,DWORD dwBufLen,DWORD *lpBytesReturned,int waittime=500);

// device capacity type, corresponding to CLIENT_GetDevCaps port
#define NET_DEV_CAP_SEQPOWER            0x01                // power timing capacity, pInBuf=NET_IN_CAP_SEQPOWER*, pOutBuf=NET_OUT_CAP_SEQPOWER*
#define NET_ENCODE_CFG_CAPS             0x02                // device encode config corresponding to capacity, pInBuf=NET_IN_ENCODE_CFG_CAPS*, pOutBuf= NET_OUT_ENCODE_CFG_CAPS*
#define NET_VIDEOIN_FISHEYE_CAPS        0x03                // Fish eye capacity , pInBuf=NET_IN_VIDEOIN_FISHEYE_CAPS*, pOutBuf=NET_OUT_VIDEOIN_FISHEYE_CAPS*
#define NET_COMPOSITE_CAPS              0x04                // Get composited caps by pointed window number, pInBuf=NET_IN_COMPOSITE_CAPS*, pOutBuf=NET_OUT_COMPOSITE_CAPS*
#define NET_VIDEO_DETECT_CAPS           0x05                // Get video detect device caps,pInBuf=NET_IN_VIDEO_DETECT_CAPS* , pOutBuf=NET_OUT_VIDEO_DETECT_CAPS*
#define NET_THERMO_GRAPHY_CAPS          0x06                // ÈÈ³ÉÏñÉãÏñÍ·ÊôÐÔÄÜÁ¦£¬pInBuf=NET_IN_THERMO_GETCAPS*, pOutBuf=NET_OUT_THERMO_GETCAPS*
#define NET_RADIOMETRY_CAPS             0x07                // ÈÈ³ÉÏñ²âÎÂÈ«¾ÖÅäÖÃÄÜÁ¦£¬pInBuf=NET_IN_RADIOMETRY_GETCAPS*, pOutBuf=NET_OUT_RADIOMETRY_GETCAPS*
#define NET_POS_CAPS                    0x08                // POS»úÄÜÁ¦£¬pInBuf = NET_IN_POS_GETCAPS *, pOutBuf = NET_OUT_POS_GETCAPS *
#define NET_USER_MNG_CAPS               0x09                // ÓÃ»§¹ÜÀíÄÜÁ¦, pInBuf = NET_IN_USER_MNG_GETCAPS *, pOutBuf = NET_OUT_USER_MNG_GETCAPS *
#define NET_MEDIAMANAGER_CAPS           0x0a                // query capabilities of VideoInput£¬pInBuf=NET_IN_MEDIAMANAGER_GETCAPS*, pOutBuf=NET_OUT_MEDIAMANAGER_GETCAPS*
#define	NET_VIDEO_MOSAIC_CAPS			0x0b				// query capabilities of video mosaic, pInBuf=NET_IN_MEDIA_VIDEOMOSAIC_GETCAPS*, pOutBuf=NET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS*
#define NET_SNAP_CFG_CAPS               0x0c                // query capabilities of snap config, pInBuf=NET_IN_SNAP_CFG_CAPS*, pOutBuf= NET_OUT_SNAP_CFG_CAPS*

// get device capacity
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetDevCaps(LLONG lLoginID, int nType, void* pInBuf, void* pOutBuf, int nWaitTime);

// device info type¡ê?corresponding to CLIENT_QueryDevInfo port
#define NET_QUERY_DEV_STORAGE_NAMES                 0x01                // search device storage module name list , pInBuf=NET_IN_STORAGE_DEV_NAMES *, pOutBuf=NET_OUT_STORAGE_DEV_NAMES *
#define NET_QUERY_DEV_STORAGE_INFOS                 0x02                // search device storage info list, pInBuf=NET_IN_STORAGE_DEV_INFOS*, pOutBuf= NET_OUT_STORAGE_DEV_INFOS *
#define NET_QUERY_RECENCY_JNNCTION_CAR_INFO         0x03                // search recent ANPR vehicle info port, pInBuf=NET_IN_GET_RECENCY_JUNCTION_CAR_INFO*, pOutBuf=NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO*
#define NET_QUERY_LANES_STATE                       0x04                // search lane info ,pInBuf = NET_IN_GET_LANES_STATE , pOutBuf = NET_OUT_GET_LANES_STATE
#define NET_QUERY_DEV_FISHEYE_WININFO               0x05                // search Fish eye window info , pInBuf= NET_IN_FISHEYE_WININFO*, pOutBuf=NET_OUT_FISHEYE_WININFO *
#define NET_QUERY_DEV_REMOTE_DEVICE_INFO            0x06                // search remote device info , pInBuf= NET_IN_GET_DEVICE_INFO*, pOutBuf= NET_OUT_GET_DEVICE_INFO *
#define NET_QUERY_SYSTEM_INFO                       0x07                // search system info , pInBuf= NET_IN_SYSTEM_INFO*, pOutBuf= NET_OUT_SYSTEM_INFO*
#define NET_QUERY_REG_DEVICE_NET_INFO               0x08                // query active register device network connection , pInBuf=NET_IN_REGDEV_NET_INFO * , pOutBuf=NET_OUT_REGDEV_NET_INFO *
#define NET_QUERY_DEV_THERMO_GRAPHY_PRESET          0x09                // query thermal preset info , pInBuf= NET_IN_THERMO_GET_PRESET_INFO*, pOutBuf= NET_OUT_THERMO_GET_PRESET_INFO *
#define NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION       0x0a                // query thermal ROI info£¬pInBuf= NET_IN_THERMO_GET_OPTREGION*, pOutBuf= NET_OUT_THERMO_GET_OPTREGION *
#define NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO      0x0b                // query thermal external system info, pInBuf= NET_IN_THERMO_GET_EXTSYSINFO*, pOutBuf= NET_OUT_THERMO_GET_EXTSYSINFO *
#define NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER       0x0c                // query the parameter value of temperature measurement point, pInBuf= NET_IN_RADIOMETRY_GETPOINTTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETPOINTTEMPER *
#define NET_QUERY_DEV_RADIOMETRY_TEMPER             0x0d                // query parameter value of temperature measurement item, pInBuf= NET_IN_RADIOMETRY_GETTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETTEMPER *
#define NET_QUERY_GET_CAMERA_STATE                  0x0e                // query camera state, pInBuf= NET_IN_GET_CAMERA_STATEINFO*, pOutBuf= NET_OUT_GET_CAMERA_STATEINFO *
#define NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE   0x0f                // acquire remote communication audio coding mode  , pInBuf= NET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO*, pOutBuf= NET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO *
#define NET_QUERY_GET_COMM_PORT_INFO                0x10                // get comm port Info, pInBuf=NET_IN_GET_COMM_PORT_INFO* , pOutBuf=NET_OUT_GET_COMM_PORT_INFO* 
#define NET_QUERY_GET_LINKCHANNELS                  0x11                // query video linked channels for a single channel 
#define NET_QUERY_GET_VIDEOOUTPUTCHANNELS           0x12                // query video decode channel count statistics info, pInBuf=NET_IN_GET_VIDEOOUTPUTCHANNELS*, pOutBuf=NET_OUT_GET_VIDEOOUTPUTCHANNELS*
#define NET_QUERY_GET_VIDEOINFO                     0x13                // query video decode channel info, pInBuf=NET_IN_GET_VIDEOINFO*, pOutBuf=NET_OUT_GET_VIDEOINFO*
#define NET_QUERY_GET_ALLLINKCHANNELS               0x14                // query all linked video channel groups, pInBuf=NET_IN_GET_ALLLINKCHANNELS* , pOutBuf=NET_OUT_GET_ALLLINKCHANNELS*
#define NET_QUERY_VIDEOCHANNELSINFO                 0x15                // query video channel info, pInBuf=NET_IN_GET_VIDEOCHANNELSINFO* , pOutBuf=NET_OUT_GET_VIDEOCHANNELSINFO*
#define NET_QUERY_TRAFFICRADAR_VERSION              0x16                // query traffic radar version£¬pInBuf=NET_IN_TRAFFICRADAR_VERSION* , pOutBuf=NET_OUT_TRAFFICRADAR_VERSION*
#define NET_QUERY_WORKGROUP_NAMES                   0x17                // query all workgroups' names£¬pInBuf=NET_IN_WORKGROUP_NAMES* , pOutBuf=NET_OUT_WORKGROUP_NAMES*
#define NET_QUERY_WORKGROUP_INFO                    0x18                // query workgroup info£¬pInBuf=NET_IN_WORKGROUP_INFO* , pOutBuf=NET_OUT_WORKGROUP_INFO*
#define NET_QUERY_WLAN_ACCESSPOINT                  0x19                // query wlan access point info£¬pInBuf=NET_IN_WLAN_ACCESSPOINT* , pOutBuf=NET_OUT_WLAN_ACCESSPOINT*

// search device info
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_QueryDevInfo(LLONG lLoginID, int nQueryType, void* pInBuf, void* pOutBuf, void *pReserved = NULL , int nWaitTime = 1000);
//------------------------------------------------------------------------

// Reboot device 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RebootDev(LLONG lLoginID);

// Shut down devic e
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ShutDownDev(LLONG lLoginID);

// Device control 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDevice(LLONG lLoginID, CtrlType type, void *param, int waittime = 1000);

// Set channel record status 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDeviceEx(LLONG lLoginID, CtrlType emType, void* pInBuf, void* pOutBuf = NULL, int nWaitTime = 1000);

#define DH_POS_EXCHANGE_GOODS_MAX             4           //goods array number   
#define DH_POS_EXCHANGE_FUSSY_KEY_MAX		  4           //the key words'number of fuzzy pattern

// POS get exchange information   the key word type of Fuzzy pattern
typedef enum tagEM_NET_POS_EXCHANGE_FUSSY_KEY
{
    EM_NET_POS_EXCHANGE_KEY_NULL = 0,                      // not Fuzzy pattern
    EM_NET_POS_EXCHANGE_KEY_GOODS = 1,                     // key word = Goods(now only suport Goods when Fuzzy pattern)
} EM_NET_POS_EXCHANGE_FUSSY_KEY;
  
// Interface CLIENT_StartFind  command NET_FIND_POS_EXCHANGE in param       
typedef struct tagNET_IN_POSEXCHANGE_STARTFIND       
{       
    DWORD							dwSize;														//struct size       
    int								nChannel;													//channel number£¬0 - first channel£¬-1  -  all channel¡£       
    NET_TIME_EX						stuStartTime;												//start time       
    NET_TIME_EX				        stuEndTime;													//end time       
    char							szGoods[DH_POS_EXCHANGE_GOODS_MAX][DH_COMMON_STRING_32];    //goods       
    EM_NET_POS_EXCHANGE_FUSSY_KEY         szFuzzyPattern[DH_POS_EXCHANGE_FUSSY_KEY_MAX];			    //Fuzzy pattern       
    int                              nPosId;                                                            //Pos id, -1 means all pos
} NET_IN_POSEXCHANGE_STARTFIND;       
        
// Interface CLIENT_StartFind command NET_FIND_POS_EXCHANGE out param       
typedef struct tagNET_OUT_POSEXCHANGE_STARTFIND       
{       
    DWORD                dwSize;                         // struct size       
    unsigned int		 nToken;						 // ²éÑ¯ÁîÅÆ
    DWORD                dwTotalCount;                   // total count       
}NET_OUT_POSEXCHANGE_STARTFIND;       
        
// Interface CLIENT_DoFind command NET_FIND_POS_EXCHANGE in param       
typedef struct tagNET_IN_POSEXCHANGE_DOFIND       
{       
    DWORD                dwSize;                         // struct size       
    unsigned int		 nToken;						 // Search handle       
    unsigned int		 nBeginNumber;                   // begin number    0<=dwBeginNumber<=dwTotalCount-1       
    unsigned int         nCount;                         // count of get exchange information       
} NET_IN_POSEXCHANGE_DOFIND;       
        
// POS exchange information       
typedef struct tagNET_POSEXCHANGE_INFO       
{       
    NET_TIME            stuExchangeTime;                //exchange time       
}NET_POSEXCHANGE_INFO;       

// POS exchange info 
typedef struct tagNET_POSEXCHANGE_INFO_EX
{
    int                 nPosId;                         // Pos id
    char                cDetail[512];                   // exchange detail info
    int                 nDetailLen;                     // length of cDetail
    BYTE                reserved[1024];                 // reserved
} NET_POSEXCHANGE_INFO_EX;
        
// Interface CLIENT_DoFind command NET_FIND_POS_EXCHANGE out param       
typedef struct tagNET_OUT_POSEXCHANGE_DOFIND       
{       
    DWORD                       dwSize;                                             // struct size       
    DWORD                       dwFound;                                            // found number       
    NET_POSEXCHANGE_INFO        arrPOSExchangeInfo[DH_MAX_POS_EXCHANGE_INFO];       // pos exchange information array       
    NET_POSEXCHANGE_INFO_EX     stuInfoEx[DH_MAX_POS_EXCHANGE_INFO];                // exchange info detail
}NET_OUT_POSEXCHANGE_DOFIND;       
        
// Interface CLIENT_StopFind command NET_FIND_POS_EXCHANGE in param       
typedef struct tagNET_IN_POSEXCHANGE_STOPFIND       
{          
    DWORD               dwSize;                             // struct size       
    unsigned int        nToken;								// Search handle       
} NET_IN_POSEXCHANGE_STOPFIND;       
        
// Interface CLIENT_StopFind command NET_FIND_POS_EXCHANGE out param       
typedef struct tagNET_OUT_POSEXCHANGE_STOPFIND       
{          
    DWORD               dwSize;                             // struct size       
} NET_OUT_POSEXCHANGE_STOPFIND;       

typedef enum tagNET_FIND {
    NET_FIND_RADIOMETRY,                            // thermal temperature query, pInBuf= NET_IN_RADIOMETRY_*FIND*, pOutBuf= NET_OUT_RADIOMETRY_*FIND*    
	NET_FIND_POS_EXCHANGE,							// POS Exchange Info Find,pInBuf = NET_IN_POSEXCHANGE_*FIND*,pOutBuf= NET_OUT_POSEXCHANGE_*FIND*
} NET_FIND;
// start find information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime = 1000);
// find information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime = 1000);
// stop find information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime = 1000);
//set channel record status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupRecordState(LLONG lLoginID, char *pRSBuffer, int nRSBufferlen);

// set channel extra record status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupExtraRecordState(LLONG lLoginID, char *pRSBuffer, int nRSBufferlen, void* pReserved);

// Search IO status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryIOControlState(LLONG lLoginID, DH_IOTYPE emType, 
                                           void *pState, int maxlen, int *nIOCount, int waittime=1000);

// IO control 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_IOControl(LLONG lLoginID, DH_IOTYPE emType, void *pState, int maxlen);

// Compulsive I frame
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MakeKeyFrame(LLONG lLoginID, int nChannelID, int nSubChannel=0);

// public agency registration
typedef void (CALLBACK *fConnectMessCallBack)(LLONG lConnectHandle, NET_CLOUDSERVICE_CONNECT_RESULT* pConnectResult, void* pReserved, LDWORD dwUser);

CLIENT_NET_API LLONG CALL_METHOD CLIENT_ConnectCloudService(LLONG lLoginID, NET_CLOUDSERVICE_CONNECT_PARAM* pConnectParm, fConnectMessCallBack pConnectMessCB, LDWORD dwUser, void* pReserved);
//------------------------------------------------------------------------

// Search user information 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfo(LLONG lLoginID, USER_MANAGE_INFO *info, int waittime=1000);

// Search user information--extensive
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfoEx(LLONG lLoginID, USER_MANAGE_INFO_EX *info, int waittime=1000);

// Search device info--Max supports device of 64-ch
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfoNew(LLONG lLoginID, USER_MANAGE_INFO_NEW *info, void* pReserved, int waittime = 1000);
// Device operation user 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfo(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, int waittime=1000);

// Device operation user--extensive
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfoEx(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, int waittime=1000);

// User operates the device--Max supports device of 64-ch
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfoNew(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, void* pReserved, int waittime = 1000);

//------------------------------------------------------------------------

// Create transparent COM channel ,TransComType: high 2 bytes represent the serial number,low 2 bytes of serail type,type 0: serial,1:485
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CreateTransComChannel(LLONG lLoginID, int TransComType, unsigned int baudrate, unsigned int databits, unsigned int stopbits, unsigned int parity, fTransComCallBack cbTransCom, LDWORD dwUser);

// Transparent COM send out data 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendTransComData(LLONG lTransComChannel, char *pBuffer, DWORD dwBufSize);

// Release transparent COM channel 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DestroyTransComChannel(LLONG lTransComChannel);

// Query the status of a transparent serial port
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryTransComParams(LLONG lLoginID, int TransComType, DH_COMM_STATE* pCommState, int nWaitTime = 500);

//------------------------------------------------------------------------

// Begin upgrading device program 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgrade(LLONG lLoginID, char *pchFileName, fUpgradeCallBack cbUpgrade, LDWORD dwUser);

// Begin upgrading device program--extensive
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgradeEx(LLONG lLoginID, EM_UPGRADE_TYPE emType, char *pchFileName, fUpgradeCallBack cbUpgrade, LDWORD dwUser);

// Send out data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendUpgrade(LLONG lUpgradeID);

// Stop upgrading device program 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUpgrade(LLONG lUpgradeID);

//------------------------------------------------------------------------

// Search configuration information 
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetDevConfig(LLONG lLoginID, DWORD dwCommand, LONG lChannel, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned,int waittime=500);

// Set configuration information 
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetDevConfig(LLONG lLoginID, DWORD dwCommand, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, int waittime=500);

// New configuration interface, Search configuration information(using Json protocol, see configuration SDK)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNewDevConfig(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime=500);

// New configuration interface, Set configuration information(using Json protocol, see configuration SDK)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetNewDevConfig(LLONG lLoginID, char* szCommand, int nChannelID, char* szInBuffer, DWORD dwInBufferSize, int *error, int *restart, int waittime=500);

// Delete configuration interface(Json format)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteDevConfig(LLONG lLoginID, NET_IN_DELETECFG* pInParam, NET_OUT_DELETECFG* pOutParam, int waittime=500);

// Get the configuration member name interface(Json format)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMemberNames(LLONG lLoginID, NET_IN_MEMBERNAME* pInParam, NET_OUT_MEMBERNAME* pOutParam, int waittime=500);

// get net card info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNetStat(LLONG lLoginID , EM_NET_QUERY_TYPE emType , void *lpInParam , int nInParamLen , void *lpOutParam , int nOutParamLen , int *pError = NULL , int nWaitTime=1000);

//------------------------------------------------------------------------

// Search device channel name 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryChannelName(LLONG lLoginID, char *pChannelName, int maxlen, int *nChannelCount, int waittime=1000);

// Set device channel name
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetupChannelName(LLONG lLoginID,char *pbuf, int nbuflen);

// Set device channel character overlay 
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetupChannelOsdString(LLONG lLoginID, int nChannelNo, DH_CHANNEL_OSDSTRING* struOsdString, int nbuflen);

// Search device current time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceTime(LLONG lLoginID, LPNET_TIME pDeviceTime, int waittime=1000);

// Set device current time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupDeviceTime(LLONG lLoginID, LPNET_TIME pDeviceTime);

// Set device max bit stream
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMaxFlux(LLONG lLoginID, WORD wFlux);

//------------------------------------------------------------------------

// Import configuration file 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ImportConfigFile(LLONG lLoginID, char *szFileName, fDownLoadPosCallBack cbUploadPos, LDWORD dwUserData, DWORD param=0);

// Stop importing configuration file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopImportCfgFile(LLONG lImportHandle);

// Exporting configuration file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportConfigFile(LLONG lLoginID, DH_CONFIG_FILE_TYPE emConfigFileType, char *szSavedFilePath, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// top exporting configuration file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportCfgFile(LLONG lExportHandle);

//------------------------------------------------------------------------

// Search device IP in DDBS by device name or device serial number
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDVRIPByResolveSvr(char *pchDVRIP, WORD wDVRPort, BYTE *sDVRName, WORD wDVRNameLen, BYTE *sDVRSerialNumber, WORD wDVRSerialLen, char* sGetIP);

// Search IPC,NVS and etc in LAN 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevices(char* szBuf, int nBufLen, int* pRetLen, DWORD dwSearchTime, char* szLocalIp=NULL);

// asynchronism search IPC, NVS and etc in LAN
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSearchDevices(fSearchDevicesCB cbSearchDevices, void* pUserData, char* szLocalIp=NULL);

// stop asynchronism search IPC, NVS and etc in LAN
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSearchDevices(LLONG lSearchHandle);

// modify Device ip
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyDevice(DEVICE_NET_INFO_EX *pDevNetInfo, DWORD dwWaitTime, int *iError = NULL, char* szLocalIp = NULL, void *reserved = NULL);

// search device ip cross VLAN
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevicesByIPs(DEVICE_IP_SEARCH_INFO* pIpSearchInfo, fSearchDevicesCB cbSearchDevices, LDWORD dwUserData, char* szLocalIp, DWORD dwWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceSearchParam(const NET_DEVICE_SEARCH_PARAM* pstParam);
//------------------------------------------------------------------------

// Platform embedded interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlatFormInfo(LLONG lLoginID, DWORD dwCommand, int nSubCommand, int nParam, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned,int waittime=500);
// lpInBuffer managed by user
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlatFormInfo(LLONG lLoginID, DWORD dwCommand, int nSubCommand, int nParam, LPVOID lpInBuffer, DWORD dwInBufferSize, int waittime=500);

// control focus 
//	dwFocusCommand = 0 focus adjucy
//	dwFocusCommand = 1continuous focus adjustment
//	dwFocusCommand = 2 auto adjust ,adjust to the best position,nFocus and nZoominvalid
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FocusControl(LLONG lLoginID, int nChannelID, DWORD dwFocusCommand, double nFocus, double nZoom, void *reserved = NULL, int waittime=500);

///////////////////////////////Mobile DVR interface///////////////////////////////

// Set snapshot callback function 
CLIENT_NET_API void CALL_METHOD CLIENT_SetSnapRevCallBack(fSnapRev OnSnapRevMessage, LDWORD dwUser);

// Snapshot request
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPicture(LLONG lLoginID, SNAP_PARAMS par);

// Snapshot request--extensive
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureEx(LLONG lLoginID, SNAP_PARAMS *par, int *reserved = 0);

// Set GPS subscription callback function 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureToFile(LLONG lLoginID, const NET_IN_SNAP_PIC_TO_FILE_PARAM* pInParam, NET_OUT_SNAP_PIC_TO_FILE_PARAM* pOutParam, int nWaitTime);
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBack(fGPSRev OnGPSMessage, LDWORD dwUser);

// Set GPS subscription callback function - extensive
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBackEX(fGPSRevEx OnGPSMessage, LDWORD dwUser);

/**************************************************************************************
*   Funcname: CLIENT_SubcribeGPS
*   Purpose:GPS inforamtion subscribe
*   InputParam:   LLONG  :lLoginID    //login handle
*   InputParam:   BOOL   :bStart      //TRUE:subscribe  FALSE:cancle subscribe
*   InputParam:   LONG   :KeepTime    // subscribe time last (unit second) value:-1  means indefinite duration last


*   InputParam:   LONG   :InterTime   // GPS send rate in subscribe time
*   Return: BOOL
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SubcribeGPS (LLONG lLoginID, BOOL bStart, LONG KeepTime, LONG InterTime);

// Set GPS subscription of temperature and humidity callback function
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSTHCallBack(fGPSTempHumidityRev OnGPSMessage, LDWORD dwUser);

// GPS subscription of temperature and humidity
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SubcribeGPSTempHumidity (LLONG lLoginID, BOOL bStart,	int InterTime, void* Reserved);

//GPS log query
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryGPSLog(LLONG lLoginID,QUERY_GPS_LOG_PARAM *pQueryParam, char *pLogBuffer, int nLogBufferLen, int *pRecLogNum, BOOL *bContinue, int waittime);

// subscription task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AttachMission(LLONG lLoginID, NET_IN_ATTACH_MISSION_PARAM *pInParam, NET_OUT_ATTACH_MISSION_PARAM *pOutParam, int nWaitTime);

// cancen subscription
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMission(LLONG lAttachHandle);

// vehicle emergency alarm confirm
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BusConfirmEvent(LLONG lLoginID, const NET_IN_BUS_CONFIRM_EVENT* pInParam, NET_OUT_BUS_CONFIRM_EVENT* pOutParam, int nWaitTime = 3000);

// set device address information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDevicePosition(LLONG lLoginID, const NET_IN_SET_DEVICE_POSITION* pInParam, NET_OUT_SET_DEVICE_POSITION* pOutParam, int nWaitTime);

// get device address information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevicePosition(LLONG lLoginID, const NET_IN_GET_DEVICE_POSITION* pInParam, NET_OUT_GET_DEVICE_POSITION* pOutParam, int nWaitTime);
// snapshoot by time mode 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureByEvent(LLONG lLoginID, const NET_IN_SNAP_BY_EVENT* pInParam, NET_OUT_SNAP_BY_EVENT* pOutParam, int nWaitTime);
//////////////////////////////NVD interface//////////////////////////////

// Query decoder information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderInfo(LLONG lLoginID, LPDEV_DECODER_INFO lpDecInfo, int waittime=1000);

// Query decoder TV information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderTVInfo(LLONG lLoginID, int nMonitorID, LPDEV_DECODER_TV lpMonitorInfo, int waittime=1000);

// Query decoder channel information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecEncoderInfo(LLONG lLoginID, int nDecoderID, LPDEV_ENCODER_INFO lpEncoderInfo, int waittime=1000);

// Set decoder TV enable
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecTVOutEnable(LLONG lLoginID, BYTE *pDecTVOutEnable, int nBufLen, int waittime=1000);

// set decoder tip layout enable, channel number start at 0
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecLayOutEnable(LLONG lLoginID, BYTE bDecLayOutEnable, int nChannel, int waittime=1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDecLayOutEnable(LLONG lLoginID, BYTE *pDecLayOutEnable, int nChannel, int waittime=1000);
//------------------------------------------------------------------------

// Set up asynchronous callback function
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOperateCallBack(LLONG lLoginID, fMessDataCallBack cbMessData, LDWORD dwUser);

// Control decoder TV screen partition,Interface is asynchronous
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CtrlDecTVScreen(LLONG lLoginID, int nMonitorID, BOOL bEnable, int nSplitType, BYTE *pEncoderChannel, int nBufLen, void* userdata=NULL);

// Switch decoder TV screen,Interface is asynchronous
// According to nMonitorID(TV ID) nWndID(Screen ID) Convert to nDecoderID(decoder channel) formula:nEncoderID nMonitorID*nSplitNum(Partition number)+nWndID
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SwitchDecTVEncoder(LLONG lLoginID, int nDecoderID, LPDEV_ENCODER_INFO lpEncoderInfo, void* userdata=NULL);

//------------------------------------------------------------------------

// Add combination of screen
CLIENT_NET_API int CALL_METHOD CLIENT_AddTourCombin(LLONG lLoginID, int nMonitorID, int nSplitType, BYTE *pEncoderChannnel, int nBufLen, int waittime=1000);

// Delete combination of screen
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, int waittime=1000);

// Modify combination of screen
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, int nSplitType, BYTE *pEncoderChannel, int nBufLen, int waittime=1000);

// Query combination of screen,nCombinID: 0??32
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, LPDEC_COMBIN_INFO lpDecCombinInfo, int waittime=1000);

// Set up tour operation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecoderTour(LLONG lLoginID, int nMonitorID, LPDEC_TOUR_COMBIN lpDecTourInfo, int waittime=1000);

// Query tour operation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderTour(LLONG lLoginID, int nMonitorID, LPDEC_TOUR_COMBIN lpDecTourInfo, int waittime=1000);

// Query the current flux information of decoding channel
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecChannelFlux(LLONG lLoginID, int nDecoderID, LPDEV_DECCHANNEL_STATE lpChannelStateInfo, int waittime=1000);

// control decoder tour operation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CtrlDecoderTour(LLONG lLoginID, int nMonitorID, DEC_CTRL_TOUR_TYPE emActionParam, int waittime = 1000);
//------------------------------------------------------------------------

typedef void (CALLBACK *fDecPlayBackPosCallBack)(LLONG lLoginID, int nEncoderID, DWORD dwTotalSize, DWORD dwPlaySize, LDWORD dwUser);

// Set the playback progress callback function
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecPlaybackPos(LLONG lLoginID, fDecPlayBackPosCallBack cbPlaybackPos, LDWORD dwUser);

// Decoder TV screen playback,Interface is asynchronous
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DecTVPlayback(LLONG lLoginID, int nDecoderID, DEC_PLAYBACK_MODE emPlaybackMode, LPVOID lpInBuffer, DWORD dwInBufferSize, void* userdata=NULL);

// Control TV screen playback
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CtrlDecPlayback(LLONG lLoginID, int nDecoderID, DEC_CTRL_PLAYBACK_TYPE emCtrlType, int nValue, int waittime=1000);

///////////////////////////////intelligent device interface///////////////////////////////

// real load picture of intelligent analysis 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealLoadPicture(LLONG lLoginID, int nChannelID, DWORD dwAlarmType, fAnalyzerDataCallBack cbAnalyzerData, LDWORD dwUser);

// real load picture of intelligent analysis(expand interface: 'bNeedPicFile == true' instruct load picture file, 'bNeedPicFile == false' instruct not load picture file ) 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealLoadPictureEx(LLONG lLoginID, int nChannelID, 
													 DWORD dwAlarmType, 
													 BOOL bNeedPicFile, 
													 fAnalyzerDataCallBack cbAnalyzerData, 
													 LDWORD dwUser, 
													 void* Reserved);

// stop load picture of intelligent analysis
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadPic(LLONG lAnalyzerHandle);

// Confirm if picture upload is complete¡ê-picture
// This port better not be in the same thread with  CLIENT_RealLoadPictureEx/CLIENT_RealLoadPicture ??s call function¡ê?otherwise will cause jam¡ê?and must call in another thread
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapManagerConfirmUpload(LLONG lLoginID, const NET_IN_SNAP_MANAGER_CONFIRM_UPLOAD* pstInParam, NET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD* pstOutParam, int waittime=1000);

// Search according to the criteria
CLIENT_NET_API LLONG	CALL_METHOD CLIENT_FindFileEx(LLONG lLoginID, EM_FILE_QUERY_TYPE emType, void* pQueryCondition, void *reserved, int waittime=1000);	

// Search file:nFilecount:the searched amount. The return value is media file amount. The search in the specified time completed if return <nFilecount.
CLIENT_NET_API int	CALL_METHOD CLIENT_FindNextFileEx(LLONG lFindHandle, int nFilecount, void* pMediaFileInfo, int maxlen, void *reserved, int waittime=1000);

// End the file search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindCloseEx(LLONG lFindHandle);

// get matched search filter file total
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTotalFileCount(LLONG lFindHandle, int* pTotalCount, void *reserved, int waittime=1000);

// set search jump filter
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFindingJumpOption(LLONG lFindHandle, NET_FINDING_JUMP_OPTION_INFO* pOption, void *reserved, int waittime=1000);

// Download the specified intelligent analytics data-image
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadMediaFile(LLONG lLoginID,EM_FILE_QUERY_TYPE emType, void* lpMediaFileInfo, char *sSavedFileName, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData,  void *reserved);

// Stop downloading the data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDownloadMediaFile(LLONG lFileHandle);

// batch download file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownLoadMultiFile(LLONG lLoginID, NET_IN_DOWNLOAD_MULTI_FILE *pstInParam, NET_OUT_DOWNLOAD_MULTI_FILE *pstOutParam, int waittime=1000);

// stop download
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadMultiFile(LLONG lDownLoadHandle);

// download picture of intelligent analysis when being off line
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoadOffLineFile(LLONG lLoginID, int nChannelID, DWORD dwAlarmType, LPNET_TIME_EX lpStartTime, LPNET_TIME_EX lpEndTime, fAnalyzerDataCallBack cbAnalyzerData, LDWORD dwUser);

//Pause IVS data download(bPause=TRUE, it is to stop download , bPause=FALSE , it is to resume download.)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseLoadPic(LLONG lLoadHadle, BOOL bPause);

// traffic snap--snapshot by network
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TrafficSnapByNetwork(LLONG lLoginID, int nChannelID, NET_IN_SNAPSHOT* pstInParam, NET_OUT_SNAPSHOT* pstOutParam);
// start traffic flux state
// traffic control --forced the red light
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TrafficForceLightState(LLONG lLoginID, int nChannelID, NET_IN_FORCELIGHTSTATE* pstInParamg, NET_OUT_FORCELIGHTSTATE* pstOutParam, int waittime=1000);

//  balck/white list operation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateTrafficList(LLONG lLoginID ,  NET_IN_OPERATE_TRAFFIC_LIST_RECORD* pstInParam , NET_OUT_OPERATE_TRAFFIC_LIST_RECORD *pstOutParam = NULL ,  int waittime = 1000);

// start traffic flux state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTrafficFluxStat(LLONG lLoginID, NET_IN_TRAFFICFLUXSTAT* pstInParam,NET_OUT_TRAFFICFLUXSTAT* pstOutParam);

// stop traffic flux state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTrafficFluxStat(LLONG lFluxStatHandle);

// start find flux state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindFluxStat(LLONG lLoginID, NET_IN_TRAFFICSTARTFINDSTAT* pstInParam, NET_OUT_TRAFFICSTARTFINDSTAT* pstOutParam);

// do find flux state
CLIENT_NET_API int	CALL_METHOD CLIENT_DoFindFluxStat(LLONG lFindHandle, NET_IN_TRAFFICDOFINDSTAT* pstInParam,NET_OUT_TRAFFICDOFINDSTAT* pstOutParam);

// stop find flux state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFluxStat(LLONG lFindHandle);
// start find number state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindNumberStat(LLONG lLoginID, NET_IN_FINDNUMBERSTAT* pstInParam, NET_OUT_FINDNUMBERSTAT* pstOutParam);

// do find number state
CLIENT_NET_API int	CALL_METHOD CLIENT_DoFindNumberStat(LLONG lFindHandle, NET_IN_DOFINDNUMBERSTAT* pstInParam, NET_OUT_DOFINDNUMBERSTAT* pstOutParam);

// stop find number state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindNumberStat(LLONG lFindHandle);

// subscribe video statistical summary
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVideoStatSummary(LLONG lLoginID, const NET_IN_ATTACH_VIDEOSTAT_SUM* pInParam, NET_OUT_ATTACH_VIDEOSTAT_SUM* pOutParam, int nWaitTime);

// unsubscribe video statistical summary
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoStatSummary(LLONG lAttachHandle);

// Call of the analysis device method
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateVideoAnalyseDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime=1000);

// Access to video analysis object
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VideoAnalyseGetTemplateImage(LLONG lLoginID, const NET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE* pstInParam, NET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE* pstOutParam, int nWaitTime=1000);

// Set the video analysis object
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VideoAnalyseSetTemplateImage(LLONG lLoginID, const NET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE* pstInParam, NET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE* pstOutParam, int nWaitTime=1000);

// serial device method call
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCommDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime=1000);

// Intelligent track speed dome control port.
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlIntelliTracker(LLONG lLoginID, NET_IN_CONTROL_INTELLITRACKER* pstInParam, NET_OUT_CONTROL_INTELLITRACKER* pstOutParam);

// master-slave device method,look for CLIENT_OperateMasterSlaveDevice
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMasterSlaveDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime=1000);

// video splicing method call
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateVideoJoin(LLONG lLoginID, NET_VIDEOJOIN_OPERATE_TYPE emType, void* pstInParam, void* pstOutParam, int nWaitTime);

////////////////////////////////  Video analysis /////////////////////////////////
// Real-time get video analysis result 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartVideoDiagnosis(LLONG lLoginID, NET_IN_VIDEODIAGNOSIS *pstInParam, NET_OUT_VIDEODIAGNOSIS *pstOutParam);

// Stop video analysis result report
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopVideoDiagnosis(LLONG hDiagnosisHandle);

// Start video analysis result search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindDiagnosisResult(LLONG lLoginID, NET_IN_FIND_DIAGNOSIS* pstInParam, NET_OUT_FIND_DIAGNOSIS* pstOutParam);

// Get video analysis result info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindDiagnosisResult(LLONG hFindHandle,NET_IN_DIAGNOSIS_INFO* pstInParam, NET_OUT_DIAGNOSIS_INFO* pstOutParam);

// End video analysis result search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindDiagnosis(LLONG hFindHandle);

// enable real time disgnosis plan
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartRealTimeProject(LLONG lLoginID,NET_IN_START_RT_PROJECT_INFO* pstInParam, NET_OUT_START_RT_PROJECT_INFO* pstOutParam, int nWaitTime);

// stop real time diagnosis plan
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealTimeProject(LLONG lLoginID,NET_IN_STOP_RT_PROJECT_INFO* pstInParam, NET_OUT_STOP_RT_PROJECT_INFO* pstOutParam, int nWaitTime);

// get parking space status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetParkingSpaceStatus(LLONG lLoginID, NET_IN_GET_PARKINGSPACE_STATUS* pstInParam, NET_OUT_GET_PARKINGSPACE_STATUS* pstOutParam);

// attach parking space data
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachParkingSpaceData(LLONG lLoginID, NET_IN_ATTACH_PARKINGSPACE* pstInParam, NET_OUT_ATTACH_PARKINGSPACE* pstOutParam);

// detach parking space data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachParkingSpaceData(NET_IN_DETACH_PARKINGSPACE* pstInParam, NET_OUT_DETACH_PARKINGSPACE* pstOutParam);

// Subscribed to the car information
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCarPassInfo(LLONG lLoginID, NET_IN_ATTACH_CAR_PASS_INFO* pstInParam, NET_OUT_ATTACH_CAR_PASS_INFO* pstOutParam , int nWaitTime);

// Unsubscribe car information lCarPassInfoHandle is CLIENT_AttachCarPassInfo returns a handle 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCarPassInfo(LLONG lCarPassInfoHandle);

// order specific lane info 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachLanesState(LLONG lLoginID, NET_IN_ATTACH_LANES_STATE* pstInParam, NET_OUT_ATTACH_LANES_STATE* pstOutParam, int nWaitTime);

// cancel order of specific lane info lLanesStateHandle is CLIENT_AttachLanesStatereturn handle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachLanesState(LLONG lLanesStateHandle);

// get car port light status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCarPortLightStatus(LLONG lLoginID, NET_IN_GET_CARPORTLIGHT_STATUS* pstInParam, NET_OUT_GET_CARPORTLIGHT_STATUS* pstOutParam, int waittime=1000);

// ser car port light status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCarPortLightStatus(LLONG lLoginID, NET_IN_SET_CARPORTLIGHT_STATUS* pstInParam, NET_OUT_SET_CARPORTLIGHT_STATUS* pstOutParam, int waittime=1000);

// subscribe intelligent analysis porogress¡ê¡§for video analysis source is record file¡ê?
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AttachVideoAnalyseState(LLONG lLoginID, NET_IN_ATTACH_VIDEOANALYSE_STATE* pstInParam, NET_OUT_ATTACH_VIDEOANALYSE_STATE* pstOutParam, int nWaittime=1000);

// stop subscription
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoAnalyseState(LLONG lAttachHandle);

// subscribe front-end device talk state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachTalkState(LLONG lLoginID, NET_IN_ATTACH_TALK_STATE* pstInParam, NET_OUT_ATTACH_TALK_STATE* pstOutParam, int nWaitTime = 1000);

// cancel subscribing front-end device talk state, lAttachHandle is the returned handle of  CLIENT_AttachTalkState
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachTalkState(LLONG lAttachHandle);

////////////////////////////////synopsis video' interface////////////////////////////////

// add video synopsis task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddVideoSynopsisTask(LLONG lLoginID,	NET_IN_ADD_VIDEOSYNOPSIS* pstInParam, NET_OUT_ADD_VIDEOSYNOPSIS* pstOutParam);

// video Synopsis task pretreatment
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PreHandleVideoSynopsisTask(LLONG lLoginID,  const NET_IN_PRE_HANDLE_VIDEOSYNOPSIS* pstInParam, NET_OUT_PRE_HANDLE_VIDEOSYNOPSIS* pstOutParam);
// video Synopsis task handle 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RunVideoSynopsisTask(LLONG lLoginID, const NET_IN_RUN_VIDEOSYNOPSIS_TASK* pstInParam, NET_OUT_RUN_VIDEOSYNOPSIS_TASK* pstOutParam);
// pause video Synopsis task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseVideoSynopsisTask(LLONG lLoginID, NET_IN_PAUSE_VIDEOSYNOPSIS* pstInParam);

// remove video synopsis task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveVideoSynopsisTask(LLONG lLoginID, NET_IN_REMOVE_VIDEOSYNOPSIS* pstInParam);

// subscibe real load object data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RealLoadObjectData(LLONG lLoginID, NET_IN_REALLOAD_OBJECTDATA* pstInParam, NET_OUT_REALLOAD_OBJECTDATA* pstOutParam);

// stop load object data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadObjectData(LLONG lRealLoadHandle, NET_IN_STOPLOAD_OBJECTDATA* pstInParam);

// subscribe real synopsis progress state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RealLoadSynopsisState(LLONG lLoginID, NET_IN_REALLAOD_SYNOPSISSTATE* pstInParam, NET_OUT_REALLOAD_SYNOPSISSTATE* pstOutParam);

// stop subscribe real synopsis progress state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadSynopsisState(LLONG lRealLoadHandle, NET_IN_STOPLOAD_SYNOPSISSTATE* pstInParam);

// query real synopsis video state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryVideoSynopsisInfo(LLONG lLoginID, NET_IN_QUERY_VIDEOSYNOPSIS* pstInParam, NET_OUT_QUERY_VIDEOSYNOPSIS* pstuOutParam);

// according to the query criteria query synopsis file
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_FindSynopsisFile(LLONG lLoginID, NET_IN_FIND_SYNOPSISFILE *pstInParam, NET_OUT_FIND_SYNOPSISFILE *pstOutParam);	

// query synopsis file
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_FindNextSynopsisFile(LLONG lFindHandle, NET_IN_FINDNEXT_SYNOPSISFILE *pstInParam, NET_OUT_FINDNEXT_SYNOPSISFILE *pstOutParam);

// close query synopsis file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SynopsisFindClose(LLONG lFindHandle);

// download synosis file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownLoadSynosisFile(LLONG lLoginID, NET_IN_DOWNLOAD_SYNOPSISFILE *pstInParam, NET_OUT_DOWNLOAD_SYNOPSISFILE *pstOutParam);

// stop load synosis file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadSynosisFile(LLONG lDownLoadHandle);

// according to the path to the file request video service,generate the file information
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_SetFilePathInfo(LLONG lLoginID, NET_IN_SET_FILEPATHINFO* pstInParam);

// attach add file state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAddFileState(LLONG lLoginID, const NET_IN_ADDFILE_STATE* pstInParam, NET_OUT_ADDFILE_STATE *pstOutParam, int nWaitTime = 1000);

// cancel attach add file state,  CLIENT_AttacAddFileState return lAttachHandle
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DetachAddFileState(LLONG lAttachHandle);

/////////////////////////////////face recognition port/////////////////////////////////////////
// face recognition database info operation¡ê¡§including add and delete¡ê?
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionDB(LLONG lLoginID, const NET_IN_OPERATE_FACERECONGNITIONDB* pstInParam, NET_OUT_OPERATE_FACERECONGNITIONDB *pstOutParam, int nWaitTime = 1000);

// by filter search face recognition result 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindFaceRecognition(LLONG lLoginID, const NET_IN_STARTFIND_FACERECONGNITION* pstInParam, NET_OUT_STARTFIND_FACERECONGNITION *pstOutParam, int nWaitTime = 1000);

// search face recognition result:nFilecount: need search item,  return value is media file item  return value<nFilecount then corresponding period file search complete(search max of 20 records each time)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceRecognition(const NET_IN_DOFIND_FACERECONGNITION* pstInParam, NET_OUT_DOFIND_FACERECONGNITION *pstOutParam, int nWaitTime = 1000);

// end search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFaceRecognition(LLONG lFindHandle);

// face recognition(input one big graph¡ê?input big graph detected face picture)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetectFace(LLONG lLoginID, const NET_IN_DETECT_FACE* pstInParam, NET_OUT_DETECT_FACE *pstOutParam, int nWaitTime = 1000);

// face recognition staff group operation¡ê¡§including add, modify and delete¡ê?
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionGroup(LLONG lLoginID, const NET_IN_OPERATE_FACERECONGNITION_GROUP* pstInParam, NET_OUT_OPERATE_FACERECONGNITION_GROUP *pstOutParam, int nWaitTime = 1000);

// search face recognition staff group info 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindGroupInfo(LLONG lLoginID, const NET_IN_FIND_GROUP_INFO* pstInParam, NET_OUT_FIND_GROUP_INFO *pstOutParam, int nWaitTime = 1000);

// arm channel staff group info 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGroupInfoForChannel(LLONG lLoginID, const NET_IN_SET_GROUPINFO_FOR_CHANNEL* pstInParam, NET_OUT_SET_GROUPINFO_FOR_CHANNEL *pstOutParam, int nWaitTime = 1000);

// set picture information
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachFaceFindState(LLONG lLoginID, const NET_IN_FACE_FIND_STATE* pstInParam, NET_OUT_FACE_FIND_STATE *pstOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachFaceFindState(LLONG lAttachHandle);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionSetSearchImageInfo(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO *pstOutParam, int nWaitTime = 1000);
//////////////////////////////// burn the upload interface /////////////////////////////////

// open burning session, return to burning session handle
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartBurnSession(LLONG lLoginID, const NET_IN_START_BURN_SESSION* pstInParam, NET_OUT_START_BURN_SESSION *pstOutParam, int nWaitTime);

// close burning session
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBurnSession(LLONG lBurnSession);

// start burning
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartBurn(LLONG lBurnSession, const NET_IN_START_BURN* pstInParam, NET_OUT_START_BURN *pstOutParam, int nWaitTime);

// stop burning
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBurn(LLONG lBurnSession);

// pause/recover burning
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseBurn(LLONG lBurnSession, BOOL bPause);

// key mark
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnMarkTag(LLONG lBurnSession, const NET_IN_BURN_MARK_TAG* pstInParam, NET_OUT_BURN_MARK_TAG *pstOutParam, int nWaitTime);

// change disk
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnChangeDisk(LLONG lBurnSession, const NET_IN_BURN_CHANGE_DISK* pstInParam, NET_OUT_BURN_CHANGE_DISK *pstOutParam, int nWaitTime);

// get burning status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnGetState(LLONG lBurnSession, const NET_IN_BURN_GET_STATE* pstInParam, NET_OUT_BURN_GET_STATE *pstOutParam, int nWaitTime);

// attach burn state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnState(LLONG lLoginID, const NET_IN_ATTACH_STATE* pstInParam, NET_OUT_ATTACH_STATE *pstOutParam, int nWaitTime = 1000);

// cancel listening burning status¡ê?lAttachHandle is CLIENT_AttachBurnState return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnState(LLONG lAttachHandle);

// start burn upload
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadFileBurned(LLONG lLoginID, const NET_IN_FILEBURNED_START* pstInParam, NET_OUT_FILEBURNED_START *pstOutParam, int nWaitTime = 1000);

// send file burned,CLIENT_StartUploadFileBurned return lUploadHandle
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_SendFileBurned(LLONG lUploadHandle);

// stop upload 
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_StopUploadFileBurned(LLONG lUploadHandle);

// listening burning parity status
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnCheckState(LLONG lLoginID, const NET_IN_ATTACH_BURN_CHECK* pstInParam, NET_OUT_ATTACH_BURN_CHECK* pstOutParam, int nWaitTime = 1000);

// cancle attach burn state,CLIENT_DetachBurnCheckState return lAttachHandle
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnCheckState(LLONG lAttachHandle);

// subscribe burning case info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnCase(LLONG lLoginID, const NET_IN_ATTACH_BURN_CASE* pInParam, NET_OUT_ATTACH_BURN_CASE* pOutParam, int nWaitTime);

// cancel subscribe burning case info¡ê?lAttachHandle is CLIENT_AttachBurnCase return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnCase(LLONG lAttachHandle);

// subscribe burning device state
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnDevState(LLONG lLoginID, const NET_IN_ATTACH_BURN_DEV_STATE* pInParam, NET_OUT_ATTACH_BURN_DEV_STATE* pOutParam, int nWaitTime = 3000);

// cancel subscribe burning device state, lAttachHandle is CLIENT_AttachBurnDevState return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnDevState(LLONG lAttachHandle);

//////////////////////////////// logical device /////////////////////////////////////////

// attach camerastate
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCameraState(LLONG lLoginID, const NET_IN_CAMERASTATE* pstInParam, NET_OUT_CAMERASTATE *pstOutParam, int nWaitTime = 3000);

// detach camera state,CLIENT_AttachCameraState return lAttachHandle
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_DetachCameraState(LLONG lAttachHandle);

//get all valid display source
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixGetCameras(LLONG lLoginID, const DH_IN_MATRIX_GET_CAMERAS* pInParam, DH_OUT_MATRIX_GET_CAMERAS* pOutParam, int nWaitTime = 1000);

// add logical device
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCameras(LLONG lLoginID, const DH_IN_ADD_LOGIC_DEVICE_CAMERA* pInParam, DH_OUT_ADD_LOGIC_DEVICE_CAMERA* pOutParam, int nWaitTime = 1000);

// add logical device bydeviceinfo
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCamerasByDevice(LLONG lLoginID, const DH_IN_ADD_LOGIC_BYDEVICE_CAMERA* pInParam, DH_OUT_ADD_LOGIC_BYDEVICE_CAMERA* pOutParam, int nWaitTime = 1000);
////////////////////////////////  Matrix interface /////////////////////////////////

// Search product definition
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryProductionDefinition(LLONG lLoginID, DH_PRODUCTION_DEFNITION* pstuProdDef, int nWaitTime = 1000);

// Search matri sub card info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryMatrixCardInfo(LLONG lLoginID, DH_MATRIX_CARD_LIST* pstuCardList, int nWaitTime = 1000);

// Search system status
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_QuerySystemStatus(LLONG lLoginID, DH_SYSTEM_STATUS* pstuStatus, int nWaitTime = 1000);

// Search split mode
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitCaps(LLONG lLoginID, int nChannel, DH_SPLIT_CAPS* pstuCaps, int nWaitTime = 1000);

// Search/set display source 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitSource(LLONG lLoginID, int nChannel, int nWindow, DH_SPLIT_SOURCE* pstuSplitSrc, int nMaxCount, int* pnRetCount, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitSource(LLONG lLoginID, int nChannel, int nWindow, const DH_SPLIT_SOURCE* pstuSplitSrc, int nSrcCount, int nWaitTime = 1000);
// set display source, support output parameter
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitSourceEx(LLONG lLoginID, const NET_IN_SET_SPLIT_SOURCE* pInparam, NET_OUT_SET_SPLIT_SOURCE* pOutParam, int nWaitTime = 1000);

// Search/set split mode
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitMode(LLONG lLoginID, int nChannel, DH_SPLIT_MODE_INFO* pstuSplitInfo, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitMode(LLONG lLoginID, int nChannel, const DH_SPLIT_MODE_INFO* pstuSplitInfo, int nWaitTime = 1000);

// Search split group amount
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitGroupCount(LLONG lLoginID, int nChannel, DH_SPLIT_MODE emSplitMode, int* pnGroupCount, int nWaitTime = 1000);

// Search video output capability
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoOutCaps(LLONG lLoginID, int nChannel, DH_VIDEO_OUT_CAPS* pstuCaps, int nWaitTime = 1000);

// Set video output option
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVideoOutOption(LLONG lLoginID, int nChannel, const DH_VIDEO_OUT_OPT* pstuVideoOut, int nWaitTime = 1000);

// Search the current window of video input channel
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryVideoOutWindows(LLONG lLoginID, int nChannel, DH_VIDEO_OUT_WINDOW* pstuWnds, int nMaxWndCount, int* pnRetWndCount, int nWaitTime = 1000);

// set windown position
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_SetSplitWindowRect(LLONG lLoginID, const DH_IN_SPLIT_SET_RECT* pInParam, DH_OUT_SPLIT_SET_RECT* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL	CALL_METHOD	CLIENT_GetSplitWindowRect(LLONG lLoginID, const DH_IN_SPLIT_GET_RECT* pInParam, DH_OUT_SPLIT_GET_RECT* pOutParam, int nWaitTime = 1000);

// open or close window
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenSplitWindow(LLONG lLoginID, const DH_IN_SPLIT_OPEN_WINDOW* pInParam, DH_OUT_SPLIT_OPEN_WINDOW* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseSplitWindow(LLONG lLoginID, const DH_IN_SPLIT_CLOSE_WINDOW* pInParam, DH_OUT_SPLIT_CLOSE_WINDOW* pOutParam, int nWaitTime = 1000);

// set window order
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitTopWindow(LLONG lLoginID, const DH_IN_SPLIT_SET_TOP_WINDOW* pInParam, DH_OUT_SPLIT_SET_TOP_WINDOW* pOutParam, int nWaitTime = 1000);

// get windows info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitWindowsInfo(LLONG lLoginID, const DH_IN_SPLIT_GET_WINDOWS* pInParam, DH_OUT_SPLIT_GET_WINDOWS* pOutParam, int nWaitTime = 1000);

// load or save collection
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_LoadSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_LOAD_COLLECTION* pInParam, DH_OUT_SPLIT_LOAD_COLLECTION* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_SaveSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_SAVE_COLLECTION* pInParam, DH_OUT_SPLIT_SAVE_COLLECTION* pOutParam, int nWaitTime = 1000);

// get collection info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitCollections(LLONG lLoginID, const DH_IN_SPLIT_GET_COLLECTIONS* pInParam, DH_OUT_SPLIT_GET_COLLECTIONS* pOutParam, int nWaitTime = 1000);

// rename collection
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_RenameSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_RENAME_COLLECTION* pInParam, DH_OUT_SPLIT_RENAME_COLLECTION* pOutParam, int nWaitTime = 1000);

// delete collection
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_DELETE_COLLECTION* pInParam, DH_OUT_SPLIT_DELETE_COLLECTION* pOutParam, int nWaitTime = 1000);

// decode policy
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecodePolicy(LLONG lLoginID, const DH_IN_SET_DEC_POLICY* pInParam, DH_OUT_SET_DEC_POLICY* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDecodePolicy(LLONG lLoginID, const DH_IN_GET_DEC_POLICY* pInParam, DH_OUT_GET_DEC_POLICY* pOutParam, int nWaitTime = 1000);

// mode of audio output
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitAudioOuput(LLONG lLoginID, const DH_IN_SET_AUDIO_OUTPUT* pInParam, DH_OUT_SET_AUDIO_OUTPUT* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitAudioOuput(LLONG lLoginID, const DH_IN_GET_AUDIO_OUTPUT* pInParam, DH_OUT_GET_AUDIO_OUTPUT* pOutParam, int nWaitTime = 1000);

// set display source
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSetCameras(LLONG lLoginID, const DH_IN_MATRIX_SET_CAMERAS* pInParam, DH_OUT_MATRIX_SET_CAMERAS* pOutParam, int nWaitTime = 1000);

// get video in ability
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoInCaps(LLONG lLoginID, const DH_IN_GET_VIDEO_IN_CAPS* pInParam, DH_OUT_GET_VIDEO_IN_CAPS* pOutParam, int nWaitTime = 1000);

// get mode of video out
CLIENT_NET_API BOOL CALL_METHOD CLIENT_EnumVideoOutModes(LLONG lLoginID, const DH_IN_ENUM_VIDEO_OUT_MODES* pInParam, DH_OUT_ENUM_VIDEO_OUT_MODES* pOutParam, int nWaitTime = 1000);

// get or set splite output OSD info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitOSD(LLONG lLoginID, const DH_IN_SPLIT_GET_OSD* pInParam, DH_OUT_SPLIT_GET_OSD* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitOSD(LLONG lLoginID, const DH_IN_SPLIT_SET_OSD* pInParam, DH_OUT_SPLIT_SET_OSD* pOutParam, int nWaitTime = 1000);

// set window tour display source
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTourSource(LLONG lLoginID, const NET_IN_SET_TOUR_SOURCE* pInParam, NET_OUT_SET_TOUR_SOURCE* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTourSource(LLONG lLoginID, const NET_IN_GET_TOUR_SOURCE* pInParam, NET_OUT_GET_TOUR_SOURCE* pOutParam, int nWaitTime);

// order tour status 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachSplitTour(LLONG lLoginID, const NET_IN_ATTACH_SPLIT_TOUR* pInParam, NET_OUT_ATTACH_SPLIT_TOUR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachSplitTour(LLONG lAttachHandle);

// low matrix switch
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSwitch(LLONG lLoginID, const NET_IN_MATRIX_SWITCH* pInParam, NET_OUT_MATRIX_SWITCH* pOutParam, int nWaitTime);

// set display source, support multiple window at same time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SplitSetMultiSource(LLONG lLoginID, const NET_IN_SPLIT_SET_MULTI_SOURCE* pInParam, NET_OUT_SPLIT_SET_MULTI_SOURCE* pOutParam, int nWaitTime);

// video split operation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateSplit(LLONG lLoginID, NET_SPLIT_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);

// split window play operaton type 
typedef enum tagNET_PLAYER_OPERATE_TYPE
{
    NET_PLAYER_OPERATE_OPEN,                // open playuer
    NET_PLAYER_OPERATE_CLOSE,               // close player
    NET_PLAYER_OPERATE_START,               //  start play
    NET_PLAYER_OPERATE_STOP,                // stop play
    NET_PLAYER_OPERATE_PAUSE,               // pause/restore play
    NET_PLAYER_OPERATE_SEEK_TIME,           // go to specific time play
    NET_PLAYER_OPERATE_STEP_FRAME,          // single frame playback, need to be used after pause
    NET_PLAYER_OPERATE_GET_STATE,           // take current playback status 
    NET_PLAYER_OPERATE_GET_TIME,            // Get  current playback time
    NET_PLAYER_OPERATE_GET_SPEED,           // Get play speed
    NET_PLAYER_OPERATE_SET_SPEED,           // Set play speed
    NET_PLAYER_OPERATE_GET_VOLUME,          // Get volume
    NET_PLAYER_OPERATE_SET_VOLUME,          // Set volume
    NET_PLAYER_OPERATE_GET_PLAYLIST,        // Get file list
    NET_PLAYER_OPERATE_GET_PLAYLIST_TS,     // Get current file list all period info
}NET_PLAYER_OPERATE_TYPE;

// play criteria 
typedef struct tagNET_PLAYER_OPEN_CONDITION 
{
    DWORD               dwSize;
    char                szDevice[DH_DEV_ID_LEN];        // point remote device 
    int                 nChannel;                       // channel no.
    NET_TIME            stuStartTime;                   // start time
    NET_TIME            stuEndTime;                     // end time
    NET_STREAM_TYPE     emStreamType;                   // stream type 
    int                 nEventNum;                      // Event type number
    int                 nEvent[MAX_IVS_EVENT_NUM];      // Event type
}NET_PLAYER_OPEN_CONDITION;

//open player input parameter , corresponding to NET_PLAYER_OPERATE_OPEN
typedef struct tagNET_IN_PLAYER_OPEN 
{
  DWORD        dwSize;
  LLONG        lPlayerID;           // play example ID
  const char*     pszDevice;           // take record from local or remote end, as null represents to take record from local¡ê?
                            // if from remote device¡ê?need to maintain with NET_PLAYER_OPEN_CONDITION szDevice identical
  NET_PLAYER_OPEN_CONDITION stuCondition;       // search criteria 
}NET_IN_PLAYER_OPEN;

// open player  output parameter , corresponding to NET_PLAYER_OPERATE_OPEN
typedef struct tagNET_OUT_PLAYER_OPEN 
{
  DWORD        dwSize;
}NET_OUT_PLAYER_OPEN;

// close player input parameter , corresponding to NET_PLAYER_OPERATE_CLOSE
typedef struct tagNET_IN_PLAYER_CLOSE
{
  DWORD        dwSize;
  LLONG        lPlayerID;           // play example ID
}NET_IN_PLAYER_CLOSE;

// close player output parameter , corresponding to NET_PLAYER_OPERATE_CLOSE
typedef struct tagNET_OUT_PLAYER_CLOSE
{
  DWORD        dwSize;
}NET_OUT_PLAYER_CLOSE;

//  start  play input parameter , corresponding to NET_PLAYER_OPERATE_START
typedef struct tagNET_IN_PLAYER_START
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_START;

//  start  play  output parameter , corresponding to NET_PLAYER_OPERATE_START
typedef struct tagNET_OUT_PLAYER_START
{
  DWORD        dwSize;
}NET_OUT_PLAYER_START;

// stop play input parameter , corresponding to NET_PLAYER_OPERATE_STOP
typedef struct tagNET_IN_PLAYER_STOP
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_STOP;

// stop play  output parameter , corresponding to NET_PLAYER_OPERATE_STOP
typedef struct tagNET_OUT_PLAYER_STOP
{
  DWORD        dwSize;
}NET_OUT_PLAYER_STOP;

//  pause /recover  play input parameter , corresponding to NET_PLAYER_OPERATE_PAUSE
typedef struct tagNET_IN_PLAYER_PAUSE
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
  BOOL        bPause;             // pause or not, TRUE- pause  play , FALSE-recover  play 
}NET_IN_PLAYER_PAUSE;

//  pause /recover  play  output parameter , corresponding to NET_PLAYER_OPERATE_PAUSE
typedef struct tagNET_OUT_PLAYER_PAUSE
{
  DWORD        dwSize;
}NET_OUT_PLAYER_PAUSE;

// go to specific time play input parameter , corresponding to NET_PLAYER_OPERATE_SEEK_TIME
typedef struct tagNET_IN_PLAYER_SEEK_TIME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
  NET_TIME      stuTime;            // go to time
}NET_IN_PLAYER_SEEK_TIME;

// go to specific time play  output parameter , corresponding to NET_PLAYER_OPERATE_SEEK_TIME
typedef struct tagNET_OUT_PLAYER_SEEK_TIME
{
  DWORD        dwSize;
}NET_OUT_PLAYER_SEEK_TIME;

// single frame play input parameter , corresponding to NET_PLAYER_OPERATE_STEP_FRAME
typedef struct tagNET_IN_PLAYER_STEP_FRAME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
  BOOL        bForward;            //  positive direction, TRUE-positive direction, FALSE-negative direction
}NET_IN_PLAYER_STEP_FRAME;

// single frame play  output parameter , corresponding to NET_PLAYER_OPERATE_STEP_FRAME
typedef struct tagNET_OUT_PLAYER_STEP_FRAME
{
  DWORD        dwSize;
}NET_OUT_PLAYER_STEP_FRAME;

//  play status 
typedef enum tagNET_PLAYER_STATE 
{
  NET_PLAYER_STATE_UNKNOWN,        // unknown 
  NET_PLAYER_STATE_ERROR,         // error occur
  NET_PLAYER_STATE_READING,        // ready, may start palyabck
  NET_PLAYER_STATE_STANDBY,        //  current file playback stop, only can start playback from beginningart
  NET_PLAYER_STATE_RUNNING,        // running
  NET_PLAYER_STATE_PAUSED,        //  paused , may continue from pause point
  NET_PLAYER_STATE_CLOSED,        // closed, cannot play, must open and enter Reading status again
}NET_PLAYER_STATE;

// search  play status input parameter , corresponding to NET_PLAYER_OPERATE_GET_STATE
typedef struct tagNET_IN_PLAYER_GET_STATE
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_GET_STATE;

// search  play status  output parameter , corresponding to NET_PLAYER_OPERATE_GET_STATE
typedef struct tagNET_OUT_PLAYER_GET_STATE
{
  DWORD        dwSize;
  NET_PLAYER_STATE  emState;            // status 
}NET_OUT_PLAYER_GET_STATE;

// Get  current  playback timeinput parameter , corresponding to NET_PLAYER_OPERATE_GET_TIME
typedef struct tagNET_IN_PLAYER_GET_TIME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_GET_TIME;

// Get  current  playback time output parameter , corresponding to NET_PLAYER_OPERATE_GET_TIME
typedef struct tagNET_OUT_PLAYER_GET_TIME
{
  DWORD        dwSize;
  NET_TIME      stuTime;            //  current  play time
}NET_OUT_PLAYER_GET_TIME;

// Get  play speed input parameter , corresponding to NET_PLAYER_OPERATE_GET_SPEED
typedef struct tagNET_IN_PLAYER_GET_SPEED
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_GET_SPEED;

// Get  play speed output parameter , corresponding to NET_PLAYER_OPERATE_GET_SPEED
typedef struct tagNET_OUT_PLAYER_GET_SPEED
{
  DWORD        dwSize;
  float        fSpeed;             //  play speed, >0 positive direction  play , <0 direction  play 
                            // absolute value means speed, =1 nornal speed, >1 quick, <1 slow
}NET_OUT_PLAYER_GET_SPEED;

// set play speedinput parameter , corresponding to NET_PLAYER_OPERATE_SET_SPEED
typedef struct tagNET_IN_PLAYER_SET_SPEED
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
  float        fSpeed;             //  play speed, >0 positive direction  play , <0 direction  play 
                            // absolute value means speed, =1 normal speed, >1 quick, <1 slow
}NET_IN_PLAYER_SET_SPEED;

// set play speed output parameter , corresponding to NET_PLAYER_OPERATE_SET_SPEED
typedef struct tagNET_OUT_PLAYER_SET_SPPED
{
  DWORD        dwSize;
}NET_OUT_PLAYER_SET_SPEED;

// Get  play  volume input parameter , corresponding to NET_PLAYER_OPERATE_GET_VOLUME
typedef struct tagNET_IN_PLAYER_GET_VOLUME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
}NET_IN_PLAYER_GET_VOLUME;

// Get  play  volume  output parameter , corresponding to NET_PLAYER_OPERATE_GET_VOLUME
typedef struct tagNET_OUT_PLAYER_GET_VOLUME
{
  DWORD        dwSize;
  int         nVolume;            //  play  volume , 0~100
}NET_OUT_PLAYER_GET_VOLUME;

// set play  volume input parameter , corresponding to NET_PLAYER_OPERATE_SET_VOLUME
typedef struct tagNET_IN_PLAYER_SET_VOLUME
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
  int         nVolume;            //  play  volume , 0~100
}NET_IN_PLAYER_SET_VOLUME;

// set play  volume  output parameter , corresponding to NET_PLAYER_OPERATE_SET_VOLUME
typedef struct tagNET_OUT_PLAYER_SET_VOLUME
{
  DWORD        dwSize;
}NET_OUT_PLAYER_SET_VOLUME;

//  play listinfo 
typedef struct tagNET_PLAYER_PLAYLIST
{
  DWORD        dwSize;
  char        szFilePath[MAX_PATH];      // file path, select either Url
  char        szUrl[MAX_PATH];        // URL, and FilePath wither one
  DH_DEVICE_PROTOCOL emUrlProtocol;         // URL protocol type 
  NET_TIME      stuStartTime;          // start time
  NET_TIME      stuEndTime;           // end time
}NET_PLAYER_PLAYLIST;

// Get  current  play listinput parameter , corresponding to NET_PLAYER_OPERATE_GET_PLAYLIST
typedef struct tagNET_IN_PLAYER_GET_PLAYLIST
{
  DWORD        dwSize;
  LLONG        lPlayerID;           //  play example ID
  NET_TIME      stuStartTime;          // start time
  NET_TIME      stuEndTime;           // end time
  int         nLimit;             // search file quantity limit, 0 means no limit
}NET_IN_PLAYER_GET_PLAYLIST;

// Get  current  play list output parameter , corresponding to NET_PLAYER_OPERATE_GET_PLAYLIST
typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST
{
  DWORD        dwSize;
  NET_PLAYER_PLAYLIST* pstuPlayLists;         //  play list, user allocate memory
  int         nMaxPlayListCount;       // max play list quantity, user fill in
  int         nRetPlayListCount;       // return play list quantity
}NET_OUT_PLAYER_GET_PLAYLIST;

// Get current file list all time period info input parameter, corresponding  NET_PLAYER_OPERATE_GET_PLAYLIST_TS
typedef struct tagNET_IN_PLAYER_GET_PLAYLIST_TS
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // Play actual ID
}NET_IN_PLAYER_GET_PLAYLIST_TS;

typedef struct tagNET_PLAYLIST_TIMESECTION
{
    DWORD               dwSize;
    int                 nEvent;                         // Record event type,  currently have
                                                        // EVENT_ALARM_COMMON, EVENT_ALARM_VIDEOBLIND, EVENT_ALARM_VIDEOLOSS, 
                                                        // EVENT_ALARM_MOTIONDETECT, EVENT_ALARM_LOCALALARM
    LPDH_TSECT          pstuTSs;                        // Time period info
    DWORD               unMaxTS;                        // Time period max number
    DWORD               unRetTS;                        // Actual returned time period number
}NET_PLAYLIST_TIMESECTION;

// Get current file list all time period info output parameters, corresponding  NET_PLAYER_OPERATE_GET_PLAYLIST_TS
typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST_TS
{
    DWORD                    dwSize;
    DWORD                    dwEventNum;                // Record type quantity
    NET_PLAYLIST_TIMESECTION stuTS[MAX_IVS_EVENT_NUM];  // Current playback list time period info
}NET_OUT_PLAYER_GET_PLAYLIST_TS;

// split window  play operation
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateSplitPlayer(LLONG lLoginID, NET_PLAYER_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);

// NET_ACCESS_LOCK_VER input parameter 
typedef struct tagNET_ACCESS_LOCK_VER_IN
{
    int                 nChannel;                       // channel number 
    char                reserved[128];                  // reserve 
} NET_ACCESS_LOCK_VER_IN;

// NET_ACCESS_LOCK_VER output parameter 
typedef struct tagNET_ACCESS_LOCK_VER_OUT
{
    char                szVersion[32];                  // version 
    NET_TIME            stuTime;                        // time 
    char                reserved[512];                  // reserve 
} NET_ACCESS_LOCK_VER_OUT;

// door lock version number, CLIENT_QueryDevState query type
typedef struct tagNET_ACCESS_LOCK_VER
{
    DWORD                    dwSize;
    NET_ACCESS_LOCK_VER_IN   stuIn;                     // input parameter 
    NET_ACCESS_LOCK_VER_OUT  stuOut;                    // output parameter 
} NET_ACCESS_LOCK_VER;

//////////////////////////////////// TV wall control  //////////////////////////////////////

// power control 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PowerControl(LLONG lLoginID, const DH_IN_WM_POWER_CTRL* pInParam, DH_OUT_WM_POWER_CTRL* pOutParam, int nWaitTime = 1000);

// get or set mode of display 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDisplayMode(LLONG lLoginID, const DH_IN_WM_SET_DISPLAY_MODE* pInParam, DH_OUT_WM_SET_DISPLAY_MODE* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDisplayMode(LLONG lLoginID, const DH_IN_WM_GET_DISPLAY_MODE* pInParam, DH_OUT_WM_GET_DISPLAY_MODE* pOutParam, int nWaitTime = 1000);

// load or save plan
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_LoadMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_LOAD_COLLECTION* pInParam, DH_OUT_WM_LOAD_COLLECTION* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_SaveMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_SAVE_COLLECTION* pInParam, DH_OUT_WM_SAVE_COLLECTION* pOutParam, int nWaitTime = 1000);

// get plan of monitor wall
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMonitorWallCollections(LLONG lLoginID, const DH_IN_WM_GET_COLLECTIONS* pInParam, DH_OUT_WM_GET_COLLECTIONS* pOutParam, int nWaitTime = 1000);

// rename monitor wall's plan
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_RenameMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_RENAME_COLLECTION* pInParam, DH_OUT_WM_RENAME_COLLECTION* pOutParam, int nWaitTime = 1000);

// get or set scene of monitor wall 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetScene(LLONG lLoginID, const DH_IN_MONITORWALL_GET_SCENE* pInParam, DH_OUT_MONITORWALL_GET_SCENE* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetScene(LLONG lLoginID, const DH_IN_MONITORWALL_SET_SCENE* pInParam, DH_OUT_MONITORWALL_SET_SCENE* pOutParam, int nWaitTime = 1000);

// get attribute caps of monitor wall
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetAttributeCaps(LLONG lLoginID, const DH_IN_MONITORWALL_GET_ARRT_CAPS* pInParam, DH_OUT_MONITORWALL_GET_ARRT_CAPS* pOutParam, int nWaitTime = 1000);

// auto adjust of monitor wall
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallAutoAdjust(LLONG lLoginID, const DH_IN_MONITORWALL_AUTO_ADJUST* pInParam, DH_OUT_MONITORWALL_AUTO_ADJUST* pOutParam, int nWaitTime = 1000);

// set attribute of monitor wall 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetAttribute(LLONG lLoginID, const DH_IN_MONITORWALL_SET_ATTR* pInParam, DH_OUT_MONITORWALL_SET_ATTR* pOutParam, int nWaitTime = 1000);

// set mode of backlight
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetBackLight(LLONG lLoginID, const DH_IN_MONITORWALL_SET_BACK_LIGHT* pInParam, DH_OUT_MONITORWALL_SET_BACK_LIGHT* pOutParam, int nWaitTime = 1000);

// search/set screen on/off plan
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetPowerSchedule(LLONG lLoginID, const NET_IN_MW_GET_POWER_SCHEDULE* pInParam, NET_OUT_MW_GET_POWER_SCHEDULE* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetPowerSchedule(LLONG lLoginID, const NET_IN_MW_SET_POWER_SCHEDULE* pInParam, NET_OUT_MW_SET_POWER_SCHEDULE* pOutParam, int nWaitTime);

// search/set screen control parameter
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetScrnCtrlParam(LLONG lLoginID, const NET_IN_MW_GET_SCRN_CTRL_PARAM* pInParam, NET_OUT_MW_GET_SCRN_CTRL_PARAM* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetScrnCtrlParam(LLONG lLoginID, const NET_IN_MW_SET_SCRN_CTRL_PARAM* pInParam, NET_OUT_MW_SET_SCRN_CTRL_PARAM* pOutParam, int nWaitTime);

// search/set screen and window background color
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetBackgroudColor(LLONG lLoginID, const NET_IN_MW_GET_BACKGROUDND_COLOR* pInParam, NET_OUT_MW_GET_BACKGROUDND_COLOR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetBackgroudColor(LLONG lLoginID, const NET_IN_MW_SET_BACKGROUD_COLOR* pInParam, NET_OUT_MW_SET_BACKGROUD_COLOR* pOutParam, int nWaitTime);

// order scheme tour status 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MonitorWallAttachTour(LLONG lLoginID, const NET_IN_WM_ATTACH_TOUR* pInParam, NET_OUT_WM_ATTACH_TOUR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallDetachTour(LLONG lAttachHandle);

// operate Monitor Wall
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMonitorWall(LLONG lLoginID, NET_MONITORWALL_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);

// switch Monitor Wall display sigal
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSwitchDisplaySignal(LLONG lLoginID, const NET_IN_MW_SWITCH_DISPLAY_SIGNAL* pInParam, NET_OUT_MW_SWITCH_DISPLAY_SIGNAL* pOutParam, int nWaitTime);

///////////////////////////////// directory management /////////////////////////////////////////

// add nodes
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationAddNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_ADD_NODES* pInParam, DH_OUT_ORGANIZATION_ADD_NODES* pOutParam, int nWaitTime = 1000);

// delete nodes
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationDeleteNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_DELETE_NODES* pInParam, DH_OUT_ORGANIZATION_DELETE_NODES* pOutParam, int nWaitTime = 1000);

// get info of nodes
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationGetNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_GET_NODES* pInParam, DH_OUT_ORGANIZATION_GET_NODES* pOutParam, int nWaitTime = 1000);

//set node
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationSetNode(LLONG lLoginID, const DH_IN_ORGANIZATION_SET_NODE* pInParam, DH_OUT_ORGANIZATION_SET_NODE* pOutParam, int nWaitTime = 1000);


//////////////////////////////// network caught /////////////////////////////////

// start caught
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSniffer(LLONG lLoginID, const DH_IN_START_SNIFFER* pInParam, DH_OUT_START_SNIFFER* pOutParam, int nWaitTime = 1000);

// stop caught
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSniffer(LLONG lLoginID, LLONG lSnifferID);

// get caught state
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSnifferInfo(LLONG lLoginID, const DH_IN_GET_SNIFFER_INFO* pInParam, DH_OUT_GET_SNIFFER_INFO* pOutParam, int nWaitTime = 1000);

//////////////////////////////// Play Library Related Port /////////////////////////////////

//Snapshot JPEG
CLIENT_NET_API BOOL CALL_METHOD  CLIENT_GetPicJPEG(LLONG lPlayHandle, BYTE* pJpegBuf, DWORD dwBufSize,DWORD *pJpegSize,int quality);


//////////////////////////////// manage remote file /////////////////////////////////

// create file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CreateRemoteFile(LLONG lLoginID, const DH_IN_CREATE_REMOTE_FILE* pInParam, DH_OUT_CREATE_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// remove file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveRemoteFiles(LLONG lLoginID, const DH_IN_REMOVE_REMOTE_FILES* pInParam, DH_OUT_REMOVE_REMOTE_FILES* pOutParam, int nWaitTime = 1000);

// rename
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenameRemoteFile(LLONG lLoginID, const DH_IN_RENAME_REMOTE_FILE* pInParam, DH_OUT_RENAME_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// display files and subdirectories in a directory
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ListRemoteFile(LLONG lLoginID, const DH_IN_LIST_REMOTE_FILE* pInParam, DH_OUT_LIST_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// sybcgribize fule upload
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UploadRemoteFile(LLONG lLoginID, const DH_IN_UPLOAD_REMOTE_FILE* pInParam, DH_OUT_UPLOAD_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// CLIENT_StartUploadRemoteFile callback function, lUploadFileHandle is CLIENT_StartUploadRemoteFile return value
typedef void (CALLBACK *fUploadFileCallBack) (LLONG lUploadFileHandle, int nTotalSize, int nSendSize, LDWORD dwUser);
// start upload remote file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadRemoteFile(LLONG lLoginID, const DH_IN_UPLOAD_REMOTE_FILE* pInParam, DH_OUT_UPLOAD_REMOTE_FILE* pOutParam, fUploadFileCallBack cbUploadFile, LDWORD dwUser);

// stop upload remote file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUploadRemoteFile(LLONG lUploadFileID);

// remote project, play audio file on device end
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayAudioFile(LLONG lLoginID, const NET_IN_PLAY_AUDIO_FILE* pInParam, NET_OUT_PLAY_AUDIO_FILE* pOutParam, int nWaitTime = 1000);

// file download, only for small file
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownloadRemoteFile(LLONG lLoginID, const DH_IN_DOWNLOAD_REMOTE_FILE* pInParam, DH_OUT_DOWNLOAD_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// set file property
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFileAttribute(LLONG lLoginID, const DH_IN_SET_FILEATTRIBUTE* pInParam, DH_OUT_SET_FILEATTRIBUTE* pOutParam, int nWaitTime = 1000);

////////////////////////////////// manage storage device ////////////////////////////////////////

// Get ISCSI target list
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_GetISCSITargets(LLONG lLoginID, const DH_IN_ISCSI_TARGETS* pInParam, DH_OUT_ISCSI_TARGETS* pOutParam, int nWaitTime = 1000);

CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetBitmap(LLONG lLoginID , const DH_IN_BITMAP* pInParam, DH_OUT_BITMAP* pOutParam, int nWaitTime = 1000);

// Get storage device name list
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_GetStorageDeviceNames(LLONG lLoginID, DH_STORAGE_DEVICE_NAME* pstuNames, int nMaxCount, int* pnRetCount, int nWaitTime = 1000);

// Get storage device info
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_GetStorageDeviceInfo(LLONG lLoginID, const char* pszDevName, DH_STORAGE_DEVICE* pDevice, int nWaitTime = 1000);

// subscribe record file update info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordInfo(LLONG lLoginID, const NET_IN_ATTACH_RECORD_INFO* pInParam, NET_OUT_ATTACH_RECORD_INFO* pOutParam, int nWaitTime = 1000);

// cancel subscribe record file update info¡ê?lAttachHandle is CLIENT_AttachRecordInfo return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordInfo(LLONG lAttachHandle);

// subscribe writing in remote torage info status
CLIENT_NET_API LLONG CALL_METHOD CLIENT_NetStorageAttachWriteInfo(LLONG lLoginID, const NET_IN_STORAGE_ATTACH_WRITE_INFO* pInParam, NET_OUT_STORAGE_ATTACH_WRITE_INFO* pOutParam, int nWaitTime);

// cancel writing in remote device info¡ê?lAttachHandle is CLIENT_NetStorageAttachWriteInfo¦Ì? return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NetStorageDetachWriteInfo(LLONG lAttachHandle);

// search remote storage wiring in info status
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NetStorageGetWriteInfo(LLONG lLoginID, const NET_IN_STORAGE_GET_WRITE_INFO* pInParam, NET_OUT_STORAGE_GET_WRITE_INFO* pOutParam, int nWaitTime);

// RAID operation, different operation type corresponding different structures 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateRaid(LLONG lLoginID, NET_RAID_OPERATE_TYPE emType, void* pInBuf, void* pOutBuf, int nWaitTime);

/////////////////////////////////// cascade device ///////////////////////////////////////

// search cascade video
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSearch(LLONG lLoginID, const DH_IN_MATRIX_SEARCH* pInParam, DH_OUT_MATRIX_SEARCH* pOutParam, int nWaitTime = 1000);

// get cascade tree
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMatrixTree(LLONG lLoginID, const DH_IN_GET_MATRIX_TREE* pInParam, DH_OUT_GET_MATRIX_TREE* pOutParam, int nWaitTime = 1000);

// get superior cascade device list info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSuperiorMatrixList(LLONG lLoginID, const DH_IN_GET_SUPERIOR_MATRIX_LIST* pInParam, DH_OUT_GET_SUPERIOR_MATRIX_LIST* pOutParam, int nWaitTime = 1000);

/************************************************************************/
/*							backup record comes back
/************************************************************************/

// start record backup restore
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRecordBackupRestore(LLONG lLoginID);

// stop record backup restore
CLIENT_NET_API void CALL_METHOD CLIENT_StopRecordBackupRestore(LLONG lRestoreID);

// add record backup restore task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_ADD_REC_BAK_RST_TASK* pInParam, int nWaitTime = 1000);

// remove record backup restore task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_REMOVE_REC_BAK_RST_TASK* pInParam, int nWaitTime = 1000);

// get record backup restore task
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_QUERY_REC_BAK_RST_TASK* pInParam, DH_OUT_QUERY_REC_BAK_RST_TASK* pOutParam, int nWaitTime = 1000);

//////////////////////////////// Encode Manager  ////////////////////////////////
// judicial burn in plan parameter coding
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEncodePlan(LLONG lLoginID, const DH_IN_GET_ENCODE_PLAN* pInParam, DH_OUT_GET_ENCODE_PLAN* pOutParam, int nWaitTime = 1000);

/************************************************************************/
/*                           database record operation                         */
/************************************************************************/
// by search filter search record
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindRecord(LLONG lLoginID, NET_IN_FIND_RECORD_PARAM* pInParam, NET_OUT_FIND_RECORD_PARAM* pOutParam, int waittime=1000);    

// search record :nFilecount: need search items,  return value as media file items  return value<nFilecountas corresponding period file search complete
CLIENT_NET_API int    CALL_METHOD CLIENT_FindNextRecord(NET_IN_FIND_NEXT_RECORD_PARAM* pInParam, NET_OUT_FIND_NEXT_RECORD_PARAM* pOutParam, int waittime=1000);

// search record items
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_QueryRecordCount(NET_IN_QUEYT_RECORD_COUNT_PARAM* pInParam, NET_OUT_QUEYT_RECORD_COUNT_PARAM* pOutParam, int waittime=1000);

// end record search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindRecordClose(LLONG lFindHandle);

/************************************************************************/
/*                            PTZ metadata port subcribe
/************************************************************************/
// subscribe PTZ metadata port
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPTZStatusProc(LLONG lLoginID, NET_IN_PTZ_STATUS_PROC *pstuInPtzStatusProc,  NET_OUT_PTZ_STATUS_PROC *pstuOutPtzStatusProc, int nWaitTime = 3000);

// stop subscribe PTZ metadata port¡ê?lAttachHandle is CLIENT_AttachPTZStatusProc return value
CLIENT_NET_API BOOL    CALL_METHOD    CLIENT_DetachPTZStatusProc(LLONG lAttachHandle);

/************************************************************************/
/*                            PTZ visual domain subcribe
/************************************************************************/
// subscribe PTZ visual domain
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachViewRangeState(LLONG lLoginID, NET_IN_VIEW_RANGE_STATE *pstuInViewRange, NET_OUT_VIEW_RANGE_STATE *pstuOutViewRange, int nWaitTime = 3000);

// stop subscribe PTZ visual domain¡ê?lAttachHandle is CLIENT_AttachViewRangeState return value
CLIENT_NET_API BOOL    CALL_METHOD    CLIENT_DetachViewRangeState(LLONG lAttachHandle);

/************************************************************************/
/*                            BUS order                                   */
/************************************************************************/
// order Bus status
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBusState(LLONG lLoginID, NET_IN_BUS_ATTACH *pstuInBus, NET_OUT_BUS_ATTACH *pstuOutBus, int nWaitTime = 3000);

// stop order Bus status¡ê?lAttachHandle is CLIENT_AttachBusState return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBusState(LLONG lAttachHandle);

/************************************************************************/
/*                            analog alarm channel data subcribe
/************************************************************************/

// subscribe analog alarm channel data
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAnalogAlarmData(LLONG lLoginID, const NET_IN_ANALOGALARM_DATA* pInParam, NET_OUT_ANALOGALARM_DATA* pOutParam, int nWaitTime);

// stop subscribe analog alarm channel data
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAnalogAlarmData(LLONG lAttachHandle);

/************************************************************************/
/*               record  change port order              */
/************************************************************************/

// order record  change port 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordUpdater(LLONG lLoginID, const NET_IN_RECORDUPDATER_DATA* pInParam, NET_OUT_RECORDUPDATER_DATA* pOutParam, int nWaitTime);

// stoporder record  change port 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordUpdater(LLONG lAttachHandle);

////////////////////////////Special Version Interface///////////////////////////////
// open log function
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LogOpen(LOG_SET_PRINT_INFO *pstLogPrintInfo);

// close log function
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LogClose();

// Search device log--extensive
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLogEx(LLONG lLoginID, DH_LOG_QUERY_TYPE logType, char *pLogBuffer, int maxlen, int *nLogBufferlen, void* reserved, int waittime=3000);

// Start query log(support BSC only)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartQueryLog(LLONG lLoginID, const NET_IN_START_QUERYLOG* pInParam, NET_OUT_START_QUERYLOG* pOutParam, int nWaitTime);

// Query next log(support BSC only)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNextLog(LLONG lLogID, NET_IN_QUERYNEXTLOG* pInParam, NET_OUT_QUERYNEXTLOG* pOutParam, int nWaitTime);

// Stop query log(support BSC only)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopQueryLog(LLONG lLogID);

// Active registered redirect function,establish directed connections
CLIENT_NET_API LONG CALL_METHOD CLIENT_ControlConnectServer(LLONG lLoginID, char* RegServerIP, WORD RegServerPort, int TimeOut=3000);

// Establish active registered connection
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlRegisterServer(LLONG lLoginID, LONG ConnectionID, int waittime=1000);

// Disconnected directional connection
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDisconnectRegServer(LLONG lLoginID, LONG ConnectionID);

// Query active registered server information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryControlRegServerInfo(LLONG lLoginID, LPDEV_SERVER_AUTOREGISTER lpRegServerInfo, int waittime=2000);

// Upload file
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FileTransmit(LLONG lLoginID, int nTransType, char* szInBuf, int nInBufLen, fTransFileCallBack cbTransFile, LDWORD dwUserData, int waittime);

// web info trasmit
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_TransmitInfoForWeb(LLONG lLoginID, char* szInBuffer, DWORD dwInBufferSize, char* szOutBuffer, DWORD dwOutBufferSize, void* pExtData, int waittime=500);


// watermark verify for picture *nResult = 0-means no verify *nResult = 1-means has verify
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_WatermarkVerifyForPicture(char* szFilePath, int* nResult, void* pReserved);

// multi realplay
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_MultiRealPlay(LLONG lLoginID, DHDEV_IN_MULTIPLAY_PARAM* pInBuf, int nInBufLen, DHDEV_OUT_MULTIPLAY_PARAM* pOutBuf, int nOutBufLen, int* pRetLen);
 
// stop multi realplay
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_StopMultiRealPlay(LLONG* lRealHandles, int nNumOfHandles);

// when hwnd != null,set playback yuv data callback 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlaybackYUVCallBack(LLONG lPlayHandle, fYUVDataCallBack cYUVData, LDWORD dwUser);

// get web configuration
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNewDevConfigForWeb(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime=500);

// set configuration for web
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetNewDevConfigForWeb(LLONG lLoginID, char* szCommand, int nChannelID, char* szInBuffer, DWORD dwInBufferSize, int *error, int *restart, int waittime=500);

// set play strategy parameter, only valid for real time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayMethod(LLONG lRealHandle, int nStartTime, int nSlowTime, int nFastTime, int nFailedTime);

// close device auto registration link
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseRegConnect(LLONG lHandle, char *pIp, WORD wPort, void *pParam);

// by file playback input parameter-proxy use
typedef struct tagNET_IN_PLAYBACK_BYFILE_PROXY 
{
    DWORD                   dwSize;
    LPNET_RECORDFILE_INFO   lpRecordFile;                   // record file info
    HWND                    hWnd;                           // window handle
    fDownLoadPosCallBack    cbDownLoadPos;                  // playback progress call
    LDWORD                  dwPosUser;                      // progress call user data
    fDataCallBack           fDownLoadDataCallBack;          // playback data call
    LDWORD                  dwDataUser;                     // data call user data
    char                    szDstIP[DH_COMMON_STRING_128];  // device IP
}NET_IN_PLAYBACK_BYFILE_PROXY;

// by file playback output parameter ¡§Cproxy use
typedef struct tagNET_OUT_PLAYBACK_BYFILE_PROXY 
{
    DWORD                   dwSize;
}NET_OUT_PLAYBACK_BYFILE_PROXY;

// by time playback input parameter-proxy use
typedef struct tagNET_IN_PLAYBACK_BYTIME_PROXY 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // channel no.
    LPNET_TIME              lpStartTime;                    // start time
    LPNET_TIME              lpStopTime;                     // end time
    HWND                    hWnd;                           // window handlw
    fDownLoadPosCallBack    cbDownLoadPos;                  // playback progress call
    LDWORD                  dwPosUser;                      // progress call user data
    fDataCallBack           fDownLoadDataCallBack;          // playback data call
    LDWORD                  dwDataUser;                     // data call user data
    char                    szDstIP[DH_COMMON_STRING_128];  // device IP
}NET_IN_PLAYBACK_BYTIME_PROXY;

// by time playback output parameter-proxy use
typedef struct tagNET_OUT_PLAYBACK_BYTIME_PROXY 
{
    DWORD                   dwSize;
}NET_OUT_PLAYBACK_BYTIME_PROXY;

// by file playback?aattached device IP, proxy use only
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileProxy(LLONG lLoginID, NET_IN_PLAYBACK_BYFILE_PROXY* pInParam, NET_OUT_PLAYBACK_BYFILE_PROXY* pOutParam);

// by time playback?aattached device IP, proxy use only
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeProxy(LLONG lLoginID, NET_IN_PLAYBACK_BYTIME_PROXY* pInParam, NET_OUT_PLAYBACK_BYTIME_PROXY* pOutParam);

// Import configuration file (JSON) pSendBuf: To send data, the user allocates memory, nSendBufLen: The length of the sent, reserved: retention parameter
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ImportConfigFileJson(LLONG lLoginID, char *pSendBuf, int nSendBufLen, void* reserved=NULL, int nWaitTime=3000);
// Export the configuration file (JSON) pOutBuffer: Receive buffer, The user allocates memory, maxlen: Receive buffer length, nRetlen: The actual length derived, reserved: retention parameter
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ExportConfigFileJson(LLONG lLoginID, char *pOutBuffer, int maxlen, int *nRetlen, void* reserved=NULL, int nWaitTime=3000);

CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSecurityKey(LLONG lPlayHandle, char* szKey, DWORD nKeyLen);

// RPC capacity search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRpcMethod(LLONG lLoginID, const char* pszMethod, BOOL* pResult, int nWaitTime);

//////////////////////////////////////////////////////////////////////////
// Public transport business relevant interface
//////////////////////////////////////////////////////////////////////////

// check bus route
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CheckBusLine(LLONG lLoginID, const NET_IN_CHECK_BUS_LINE* pstInParam, NET_OUT_CHECK_BUS_LINE* pstOutParam, int nWaitTime = 5000);

// send bus route info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchBusLineInfo(LLONG lLoginID, const NET_IN_DISPATCH_BUS_LINE_INFO* pstInParam, NET_OUT_DISPATCH_BUS_LINE_INFO* pstOutParam, int nWaitTime = 5000);

// vehicle operation dispatch 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BusSchedule(LLONG lLoginID, const NET_IN_BUS_SCHEDULE_INFO* pstInParam, NET_OUT_BUS_SCHEDULE_INFO* pstOutParam, int nWaitTime = 5000);

// Issued by the vehicle scheduling plan
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchWorkPlan(LLONG lLoginID, const NET_IN_BUS_DISPATCH_WORK_PLAN* pstInParam, NET_OUT_BUS_DISPATCH_WORK_PLAN* pstOutParam, int nWaitTime);

//////////////////////////////////////////////////////////////////////////

// add feedback type after task
typedef enum tagNET_MISSION_FEEDBACK_TYPE
{
    NET_MISSION_FEEDBACK_NO = 0,                        // no feedback needed
    NET_MISSION_FEEDBACK_YES,                           // need feedback, shall replay DH_ALARM_MISSION_CONFIRM task confirmed event
}NET_MISSION_FEEDBACK_TYPE;

// message type (mobile)
typedef enum tagNET_MISSION_MESSAGE_TYPE
{
    NET_MISSION_MESSAGE_TEXT = 0 ,      //text info 
    NET_MISSION_MESSAGE_AD ,            //ad info 
    NET_MISSION_MESSAGE_BROAD ,         //broadcast info
    NET_MISSION_MESSAGE_DRIVER ,        //driver info
    NET_MISSION_MESSAGE_DISPATCH ,      //dispatch command
    NET_MISSION_MESSAGE_TRANSPARENT ,   //transparent data   
    NET_MISSION_MESSAGE_URGENT,         // emergency
    NET_MISSION_MESSAGE_MAX ,
}NET_MISSION_MESSAGE_TYPE;

// CLIENT_AddMission()port input parameter
typedef struct tagNET_IN_ADD_MISSION 
{
    DWORD           dwSize;
    char            szTitle[DH_COMMON_STRING_256];      // task name
    char            szMissionID[DH_COMMON_STRING_256];  // task ID
    char            szComment[DH_COMMON_STRING_256];    // replay content
    NET_MISSION_FEEDBACK_TYPE   emFeedBack;             // feedback type after adding
    NET_MISSION_MESSAGE_TYPE    emMessageType;          // message type 
}NET_IN_ADD_MISSION;

// CLIENT_AddMission() port output parameter
typedef struct tagNET_OUT_ADD_MISSION 
{
    DWORD           dwSize;
}NET_OUT_ADD_MISSION;

CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddMission(LLONG lLoginID, const NET_IN_ADD_MISSION* pstInParam, NET_OUT_ADD_MISSION* pstOutParam, int nWaitTime = 3000);

// CLIENT_ParkingControlStartFind port input parameter
typedef struct tagNET_IN_PARKING_CONTROL_START_FIND_PARAM
{
    DWORD                     dwSize;          // structure size
    BOOL                      bSearchCount;    // Search if record call is valid
    DWORD                     dwSearchCount;   // Search record item, value range is 1~100
    BOOL                      bBegin;          // Search if start time is valid
    NET_TIME                  stuBegin;        // Search start time
    BOOL                      bEnd;            // Search if end time is valid
    NET_TIME                  stuEnd;          // Search end time
    BOOL                      bCardType;       // If card type is valid
    NET_ECK_IC_CARD_USER_TYPE emCardType;      // Card type
    BOOL                      bFlag;           // If car pass mark is valid
    NET_ECK_CAR_PASS_FLAG     emFlag;          // Car pass mark
} NET_IN_PARKING_CONTROL_START_FIND_PARAM;

// CLIENT_ParkingControlStartFind port output parameter
typedef struct tagNET_OUT_PARKING_CONTROL_START_FIND_PARAM
{
    DWORD                     dwSize;          // structure size
    DWORD                     dwTotalCount;    // Result number match the search criteria
} NET_OUT_PARKING_CONTROL_START_FIND_PARAM;

// CLIENT_ParkingControlDoFind port input parameter
typedef struct tagNET_IN_PARKING_CONTROL_DO_FIND_PARAM
{
    DWORD                     dwSize;          // structure size
    DWORD                     dwFileCount;     // Currently record item number to search
} NET_IN_PARKING_CONTROL_DO_FIND_PARAM;

// Car pass record info
typedef struct tagNET_CAR_PASS_ITEM
{
    DWORD                      dwSize; 
    NET_TIME                   stuTime;          // Car pass time
    DWORD                      dwCardNo;         // Card no.
    NET_ECK_IC_CARD_USER_TYPE  emCardType;       // Card type
    NET_ECK_CAR_PASS_FLAG      emFlag;           // Car pass record type
} NET_CAR_PASS_ITEM;

// CLIENT_ParkingControlDoFind port output parameter
typedef struct tagNET_OUT_PARKING_CONTROL_DO_FIND_PARAM
{
    DWORD                     dwSize;          // structure size
    NET_CAR_PASS_ITEM        *pstuRecordList;  // Record list, user allocate memory
    int                       nMaxRecordNum;   // List record number
    int                       nRetRecordNum;   // Searched record items, current searched item number is lower than designated item number, search end
} NET_OUT_PARKING_CONTROL_DO_FIND_PARAM;

// Start car pass record search
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlStartFind(LLONG lLoginID, NET_IN_PARKING_CONTROL_START_FIND_PARAM* pInParam, NET_OUT_PARKING_CONTROL_START_FIND_PARAM* pOutParam, int waittime);

// Get car pass record
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDoFind(LLONG lFindeHandle, NET_IN_PARKING_CONTROL_DO_FIND_PARAM* pInParam, NET_OUT_PARKING_CONTROL_DO_FIND_PARAM* pOutParam, int waittime);

// End car pass record search
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlStopFind(LLONG lFindHandle);

// Order car pass record data call function origin
typedef void (CALLBACK *fParkingControlRecordCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CAR_PASS_ITEM *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_ParkingControlAttachRecord() port input parameter
typedef struct tagNET_IN_PARKING_CONTROL_PARAM
{
    DWORD                           dwSize;
    fParkingControlRecordCallBack   cbCallBack;                 // Data call function
    LDWORD                          dwUser;                     // User custom parameter
} NET_IN_PARKING_CONTROL_PARAM;

// CLIENT_ParkingControlDetachRecord() port output parameter
typedef struct tagNET_OUT_PARKING_CONTROL_PARAM
{
    DWORD    dwSize;
} NET_OUT_PARKING_CONTROL_PARAM;

// Car pass record order
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlAttachRecord(LLONG lLoginID, const NET_IN_PARKING_CONTROL_PARAM* pInParam, NET_OUT_PARKING_CONTROL_PARAM* pOutParam, int nWaitTime);

// Cancel car pass record order
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDetachRecord(LLONG lAttachHandle);

// Vehicle detector status
typedef enum tagNET_CAR_DETECTOR_STATE
{
    NET_CAR_DETECTOR_STATE_UNKNOWN = -1,
    NET_CAR_DETECTOR_STATE_OFFLINE = 0,                   // Offline
    NET_CAR_DETECTOR_STATE_ONLINE,                        // Online
    NET_CAR_DETECTOR_STATE_LOOPOFFLINE,                   // Senser coil offline
} NET_CAR_DETECTOR_STATE;

// Sub device general status
typedef enum tagNET_AUXILIARY_DEV_STATE
{
    NET_AUXILIARY_DEV_STATE_UNKNOWN = -1,
    NET_AUXILIARY_DEV_STATE_OFFLINE = 0,                   // offline
    NET_AUXILIARY_DEV_STATE_ONLINE,                        // online
} NET_AUXILIARY_DEV_STATE;

// Device IC card quantity condition
typedef enum tagNET_IC_CARD_STATUS
{
    NET_IC_CARD_STATUS_UNKNOWN = -1,
    NET_IC_CARD_STATUS_NORMAL = 0,                         // Normal
    NET_IC_CARD_STATUS_NOCARD,                             // No card
    NET_IC_CARD_STATUS_LOWCARD,                            // Few
    NET_IC_CARD_STATUS_FULLCARDS,                          // Full
} NET_IC_CARD_STATUS;

// auxiliary work mode type
typedef enum tagNET_AUXILIARY_WORK_MODE
{
    NET_AUXILIARY_WORK_MODE_UNKNOWN = 0,
    NET_AUXILIARY_WORK_MODE_OFFLINE,                       // working offline
    NET_AUXILIARY_WORK_MODE_ONLINE,                        // working online
} NET_AUXILIARY_WORK_MODE;

// Alarm event type DH_ALARM_AUXILIARY_DEV_STATE(sub device status event)corresponding data description info
typedef struct tagALARM_AUXILIARY_DEV_STATE
{
    DWORD                   dwSize;
    NET_CAR_DETECTOR_STATE  emDetector;                   // Vehicle detector status
    NET_AUXILIARY_DEV_STATE emLed;                        // LED status lattice screen status
    NET_AUXILIARY_DEV_STATE emICDetectBoard;              // Panel swiping card board
    NET_AUXILIARY_DEV_STATE emICSenderBoard;              // Issuing card swiping cardboard
    NET_IC_CARD_STATUS      emICCardStatus;               // Device IC card quantity condition
    NET_AUXILIARY_WORK_MODE emWorkMode;                   // working mode
} ALARM_AUXILIARY_DEV_STATE;

// Parking issuing card swiping card type
typedef enum tagNET_PARKING_CARD_TYPE
{
    NET_PARKING_CARD_TYPE_UNKNOWN,
    NET_PARKING_CARD_TYPE_SEND,                             // Issue card
    NET_PARKING_CARD_TYPE_DETECT,                           // Swipe card
} NET_PARKING_CARD_TYPE;

// Alarm event type DH_ALARM_PARKING_CARD(parking swipe card event)corresponding data description info
typedef struct tagALARM_PARKING_CARD
{
    DWORD                   dwSize;
    NET_PARKING_CARD_TYPE   emType;                       // Type
    DWORD                   dwCardNo;                     // Card no.
    char                    szPlate[DH_COMMON_STRING_16]; // Plate
} ALARM_PARKING_CARD;

// The type of alarm source device
typedef enum tagEM_ALARM_TRANSMIT_DEV_SRC_TYPE
{
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_UNKNOWN,             // Unknown    
	EM_ALARM_TRANSMIT_DEV_SRC_TYPE_DIGIT,               // Digit   
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_ANALOG,              // Analog 
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_SMARTLOCK,           // SmartLock
}EM_ALARM_TRANSMIT_DEV_SRC_TYPE;

// alarm transmit alarm type
typedef enum tagEM_ALARM_TRANSMIT_ALARM_TYPE
{
    EM_ALARM_TRANSMIT_ALARM_TYPE_UNKNOWN,               // unknown
    EM_ALARM_TRANSMIT_ALARM_TYPE_PREVENTREMOVE,         // PreventRemove
    EM_ALARM_TRANSMIT_ALARM_TYPE_LOWERPOWER,            // LowerPower
    EM_ALARM_TRANSMIT_ALARM_TYPE_KEY,                   // Key
    EM_ALARM_TRANSMIT_ALARM_TYPE_DURESS,                // Duress
}EM_ALARM_TRANSMIT_ALARM_TYPE;

// Alarm transmission event (Corresponding structure ALARM_PROFILE_ALARM_TRANSMIT_INFO)
typedef struct tagALARM_PROFILE_ALARM_TRANSMIT_INFO
{
    DWORD                           dwSize;
    int					            nChannelID;								// channel number
    int					            nAction;								// 0:Start 1:Stop
    NET_TIME                        stuTime;                                // time-to-event
    NET_SENSE_METHOD                emSenseMethod;                          // Sensor Type
    char                            szUserID[DH_COMMON_STRING_128];         // Alarm users, to distinguish    
	EM_ALARM_TRANSMIT_DEV_SRC_TYPE  emDevSrcType;                           // The type of alarm source device 
    EM_ALARM_TRANSMIT_ALARM_TYPE    emAlarmType;                            // alarm transmit alarm type
}ALARM_PROFILE_ALARM_TRANSMIT_INFO;

// order monitor spot info 
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SCADAAttachInfo(LLONG lLoginID, const NET_IN_SCADA_ATTACH_INFO* pInParam, NET_OUT_SCADA_ATTACH_INFO* pOutParam, int nWaitTime);

// cancel monitor spot info order
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADADetachInfo(LLONG lAttachHandle);

// scada get threshold
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADAGetThreshold(LLONG lLoginID, const NET_IN_SCADA_GET_THRESHOLD* pInParam, NET_OUT_SCADA_GET_THRESHOLD* pOutParam, int nWaitTime);

// scada set threshold
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADASetThreshold(LLONG lLoginID, const NET_IN_SCADA_SET_THRESHOLD* pInParam, NET_OUT_SCADA_SET_THRESHOLD* pOutParam, int nWaitTime);

// scada start find history info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindSCADA(LLONG lLoginID, const NET_IN_SCADA_START_FIND* pInParam, NET_OUT_SCADA_START_FIND* pOutParam, int nWaitTime);

// scada do find history info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindSCADA(LLONG lFindHandle, const NET_IN_SCADA_DO_FIND* pInParam, NET_OUT_SCADA_DO_FIND* pOutParam, int nWaitTime);

// scada stop find history info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindSCADA(LLONG lFindHandle);

// scada attach alarm event
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SCADAAlarmAttachInfo(LLONG lLoginID, const NET_IN_SCADA_ALARM_ATTACH_INFO* pInParam, NET_OUT_SCADA_ALARM_ATTACH_INFO* pOutParam, int nWaitTime = 3000);

// scada detach alarm event
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADAAlarmDetachInfo(LLONG lAttachHandle);

// scada set point info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADASetInfo(LLONG lLoginID, const NET_IN_SCADA_POINT_SET_INFO_LIST* pInParam, NET_OUT_SCADA_POINT_SET_INFO_LIST* pOutParam, int nWaitTime = 3000);

//////////////////////////////////////////////////////////////////////////

// Order wireless code info port
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachLowRateWPAN(LLONG lLoginID, const NET_IN_ATTACH_LOWRATEWPAN* pstInParam, NET_OUT_ATTACH_LOWRATEWPAN* pstOutParam, int nWaitTime = 3000);

// Cancel order wireless info port¡ê?lAttachHandle is CLIENT_AttachLowRateWPAN return value
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachLowRateWPAN(LLONG lAttachHandle);

//Get play library port used to decode and display in preview, close resource type of gotten port,it will affect normal operaton
CLIENT_NET_API LONG CALL_METHOD CLIENT_GetRealPlayPort(LLONG lRealPlayHandle);

// Get play library port used to decode and display in preview, close resource type of gotten port,it will affect normal operaton
CLIENT_NET_API LONG CALL_METHOD  CLIENT_GetPlayBackPort(LLONG lPlayBackHandle);

// Parking Spaces of the intelligent parking systems 
typedef enum tagNET_ECK_PARK_STATE
{
    NET_ECK_PARK_STATE_UNKOWN,
    NET_ECK_PARK_STATE_PARK,                     // Parking cars
    NET_ECK_PARK_STATE_NOPARK,                   // No car parking Spaces
} NET_ECK_PARK_STATE;

// Parking information
typedef struct tagNET_PARK_INFO_ITEM
{
    DWORD                      dwSize; 
    char                       szParkNo[DH_COMMON_STRING_32];   // Parking number
    NET_ECK_PARK_STATE         emState;                         // Parking state
    DWORD                      dwScreenIndex;                   // GuideScreen index according to parking number
    DWORD                      dwFreeParkNum;                   // Free count of parking space
} NET_PARK_INFO_ITEM;

// Subscribe to the parking information callback function prototypes
typedef void (CALLBACK *fParkInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_PARK_INFO_ITEM *pInfo, int nBufLen, LDWORD dwUser);

// Parking space detector type
typedef enum tagNET_ECK_PARK_DETECTOR_TYPE
{
    NET_ECK_PARK_DETECTOR_TYPE_SONIC,                     // ultrasonic detector
    NET_ECK_PARK_DETECTOR_TYPE_CAMERA,                    // The camera detector
    NET_ECK_PARK_DETECTOR_TYPE_ALL,
} NET_ECK_PARK_DETECTOR_TYPE;

// Parking space detector information query condition

typedef struct tagNET_PARK_INFO_FILTER
{
    DWORD                      dwSize; 
    DWORD                      dwNum;                                  // Parking space detector type number
    NET_ECK_PARK_DETECTOR_TYPE emType[NET_ECK_PARK_DETECTOR_TYPE_ALL]; // Parking space detector type 
} NET_PARK_INFO_FILTER;

// CLIENT_ParkingControlAttachParkInfo()Interface input parameters
typedef struct tagNET_IN_PARK_INFO_PARAM
{
    DWORD                           dwSize;
    NET_PARK_INFO_FILTER            stuFilter;
    fParkInfoCallBack               cbCallBack;                 // Data callback function
    LDWORD                          dwUser;                     // User defined parameters 
} NET_IN_PARK_INFO_PARAM;

// CLIENT_ParkingControlAttachParkInfo()Interface output parameters
 typedef struct tagNET_OUT_PARK_INFO_PARAM
{
    DWORD    dwSize;
} NET_OUT_PARK_INFO_PARAM;

// Parking state subscription
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlAttachParkInfo(LLONG lLoginID, const NET_IN_PARK_INFO_PARAM* pInParam, NET_OUT_PARK_INFO_PARAM* pOutParam, int nWaitTime);

// Cancel the parking state subscription
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDetachParkInfo(LLONG lAttachHandle);

// Subscribe to the video phone status information
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVTPCallState(LLONG lLoginID, const NET_IN_VTP_CALL_STATE_ATTACH* pInParam, NET_OUT_VTP_CALL_STATE_ATTACH* pOutParam, int nWaitTime);

// Unsubscribe video phone status information
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVTPCallState(LLONG lCallStateHandle);

// set mobile push notification, use RegisterID to identify the config info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobilePushNotify(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// delete mobile push notification, use RegisterID to identify the config info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePushNotify(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);

// set mobile push notification config, use RegisterID+AppID to identify the info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobilePushNotifyCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// delete mobile push notification config, use RegisterID+AppID to identify the info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePushNotifyCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);

////////////////////////////////////////////////////////////////////////////////
// Net applications, operation type
typedef enum tagEM_RPC_NETAPP_TYPE
{
    EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT,      //  get statistics of net resource, pstuIn: NET_IN_NETAPP_GET_NET_RESOURCE_STAT*¡ê?pstuOut: NET_OUT_NETAPP_GET_NET_RESOURCE_STAT*
}EM_RPC_NETAPP_TYPE;

// EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT, input param
typedef struct tagNET_IN_NETAPP_GET_NET_RESOURCE_STAT
{
    DWORD               dwSize;
}NET_IN_NETAPP_GET_NET_RESOURCE_STAT;

// EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT, output param
typedef struct tagNET_OUT_NETAPP_GET_NET_RESOURCE_STAT
{
    DWORD               dwSize;
    int                 nIPChanneIn;             // IP channel in bandwidth, unit: kbps
    int                 nNetRemain;              // Net remain bandwidth, unit: kbps
    int                 nNetCapability;          // Net total bandwidth, unit: Mbps
    int                 nRemotePreview;          // Remote preview bandwidth, unit: kbps
    int                 nRemotePlayAndDownload;  // Remote playback and download bandwidth, unit: kbps
    int                 nRemoteSendRemain;       // Remote send remain bandwidth, unit: kbps
    int                 nRemoteSendCapability;   // Remote send total bandwidth, unit: Mbps
}NET_OUT_NETAPP_GET_NET_RESOURCE_STAT;

// network application component, company internal customized port 
// used to acquire network source data of front-end device
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RPC_NetApp(LLONG lLoginID, EM_RPC_NETAPP_TYPE emType, const void* pstuIn, void* pstuOut, int nWaitTime = 1000);

// Set optimize mode
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOptimizeMode(EM_OPTIMIZE_TYPE emType, void *pParam);

// panoramic PTZ operation type 
typedef enum tagEM_NET_WIDE_VIEW_CTRL
{
    EM_NET_WIDE_VIEW_CTRL_START,                      // begin to generate panoramic view, startGenerateWideView, structure NET_IN_WIDE_VIEW_GENERATE_START and NET_OUT_WIDE_VIEW_GENERATE_START
    EM_NET_WIDE_VIEW_CTRL_STOP,                       // stop generating panoramic view, stopGenerateWideView, structure NET_IN_WIDE_VIEW_GENERATE_STOP and NET_OUT_WIDE_VIEW_GENERATE_STOP
    EM_NET_WIDE_VIEW_CTRL_PROGRESS,                   // acquire current progress generated by panoramic view, getWideViewProgress, structure NET_IN_WIDE_VIEW_PROGRESS and NET_OUT_WIDE_VIEW_PROGRESS
    EM_NET_WIDE_VIEW_CTRL_IMAGEINFO,                  // acquire panoramic view info, getImageInfo, structure NET_IN_WIDE_VIEW_IMAGE and NET_OUT_WIDE_VIEW_IMAGE
    EM_NET_WIDE_VIEW_CTRL_WV_COORD,                   // switch from PTZ coordinate to panoramic view coordinate, getWideViewCoordinates, structure NET_IN_WIDE_VIEW_WV and NET_OUT_WIDE_VIEW_WV
    EM_NET_WIDE_VIEW_CTRL_PTZ_COORD,                  // switch from panoramic view to PTZ absolute coordinate, getPtzCoordinates, structure NET_IN_WIDE_VIEW_PTZ ºÍ NET_OUT_WIDE_VIEW_PTZ 
} EM_NET_WIDE_VIEW_CTRL;

// begin to generate panoramic view input parameter 
typedef struct tagNET_IN_WIDE_VIEW_GENERATE_START
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
} NET_IN_WIDE_VIEW_GENERATE_START;

// begin to generate panoramic view output parameter 
typedef struct tagNET_OUT_WIDE_VIEW_GENERATE_START
{
    DWORD                    dwSize;
} NET_OUT_WIDE_VIEW_GENERATE_START;

//  stop generating panoramic view input parameter 
typedef struct tagNET_IN_WIDE_VIEW_GENERATE_STOP
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
} NET_IN_WIDE_VIEW_GENERATE_STOP;

//  stop generating panoramic view output parameter 
typedef struct tagNET_OUT_WIDE_VIEW_GENERATE_STOP
{
    DWORD                    dwSize;
} NET_OUT_WIDE_VIEW_GENERATE_STOP;

//  acquire current progress input parameter generated by panoramic view
typedef struct tagNET_IN_WIDE_VIEW_PROGRESS
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
} NET_IN_WIDE_VIEW_PROGRESS;

//  acquire current progress output parameter generated by panoramic view 
typedef struct tagNET_OUT_WIDE_VIEW_PROGRESS
{
    DWORD                    dwSize;
    int                      nProgress;               // current progress generated by panoramic view, range 0-100 
} NET_OUT_WIDE_VIEW_PROGRESS;

//  acquire panoramic view info input parameter 
typedef struct tagNET_IN_WIDE_VIEW_IMAGE
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
} NET_IN_WIDE_VIEW_IMAGE;

//  panoramic view info 
typedef struct tagNET_WIDE_VIEW_IMAGE_INFO
{
    char                     szImageUrl[MAX_PATH];    // channel number 
} NET_WIDE_VIEW_IMAGE_INFO;

// acquire panoramic view info output parameter
typedef struct tagNET_OUT_WIDE_VIEW_IMAGE
{
    DWORD                    dwSize;
    NET_WIDE_VIEW_IMAGE_INFO stuImageInfo;             // panoramic view info 
} NET_OUT_WIDE_VIEW_IMAGE;

#define NET_WIDE_VIEW_COORDINATES_MAX (64)

//  switch from PTZ coordinate to panoramic view coordinate input parameter 
typedef struct tagNET_IN_WIDE_VIEW_WV
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
    int                      nNum;                    // effective PTZ coordinate number 
    PTZ_SPEED_UNIT           stuPTZ[NET_WIDE_VIEW_COORDINATES_MAX];   // PTZ direction and zoom rate 
} NET_IN_WIDE_VIEW_WV;

//  switch from PTZ coordinate to panoramic view coordinate output parameter 
typedef struct tagNET_OUT_WIDE_VIEW_WV
{
    DWORD                    dwSize;
    NET_RECT                 stuRect[NET_WIDE_VIEW_COORDINATES_MAX];  // panoramic view coordinate 
} NET_OUT_WIDE_VIEW_WV;

//  switch from panoramic view to PTZ absolute coordinate input parameter 
typedef struct tagNET_IN_WIDE_VIEW_PTZ
{
    DWORD                    dwSize;
    int                      nChannel;                // channel number 
    int                      nNum;                    // effective panoramic coordinate number 
    NET_RECT                 stuRect[NET_WIDE_VIEW_COORDINATES_MAX];  // panoramic view coordinate 
} NET_IN_WIDE_VIEW_PTZ;

//  switch from panoramic view to PTZ absolute coordinate output parameter 
typedef struct tagNET_OUT_WIDE_VIEW_PTZ
{
    DWORD                    dwSize;
    PTZ_SPEED_UNIT           stuPTZ[NET_WIDE_VIEW_COORDINATES_MAX];   // PTZ direction and zoom rate 
} NET_OUT_WIDE_VIEW_PTZ;

// panoramic PTZ relevant operation port, operation type refers to EM_NET_WIDE_VIEW_CTRL
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WideViewCtrl(LLONG lLoginID, EM_NET_WIDE_VIEW_CTRL emCtrlType, const void *pstuInParam, void *pstuOutParam, int nWaitTime = 1000);

CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMarkFile(LLONG lLoginID,const NET_IN_SET_MARK_FILE* pInParam, NET_OUT_SET_MARK_FILE* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT );
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMarkFileByTime(LLONG lLoginID, const NET_IN_SET_MARK_FILE_BY_TIME* pInParam, NET_OUT_SET_MARK_FILE_BY_TIME* pOutParam, int nWaitTime = 1000);

//record according to time stamp &&C5

//acquire sign video info 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMarkInfo(LLONG lLoginID, const NET_IN_GET_MARK_INFO* pInParam, NET_OUT_GET_MARK_INFO* pOutParam, int nWaitTime = 1000);

// record stream type 
typedef enum tagEM_NET_AUDIO_REC_STREAM
{
    EM_NET_AUDIO_REC_STREAM_UNKNOWN,
    EM_NET_AUDIO_REC_STREAM_MAIN,                    // Main
    EM_NET_AUDIO_REC_STREAM_EXTRA1,                  // Extra1
    EM_NET_AUDIO_REC_STREAM_EXTRA2,                  // Extra2
    EM_NET_AUDIO_REC_STREAM_EXTRA3,                  // Extra3
    EM_NET_AUDIO_REC_STREAM_TALKBACK,                // Talkback
} EM_NET_AUDIO_REC_STREAM;

// enable/disable audio record and acquire record name input parameter, corresponding command DH_CTRL_AUDIO_REC_START_NAMEºÍDH_CTRL_AUDIO_REC_STOP_NAME 
typedef struct tagNET_IN_AUDIO_REC_MNG_NAME
{
    DWORD                    dwSize;                 // structure size 
    int                      nChannel;               // audio channel number 
    EM_NET_AUDIO_REC_STREAM  emStream;               // code stream type 
} NET_IN_AUDIO_REC_MNG_NAME;

// enable /disable audio record and acquire record name output parameter, corresponding command DH_CTRL_AUDIO_REC_START_NAMEºÍDH_CTRL_AUDIO_REC_STOP_NAME 
typedef struct tagNET_OUT_AUDIO_REC_MNG_NAME
{
    DWORD                    dwSize;                 // structure size 
    char                     szFileName[MAX_PATH];   // recording file name 
} NET_OUT_AUDIO_REC_MNG_NAME;

// enable record type 
typedef enum tagEM_NET_REC_EVENT
{
    EM_NET_REC_EVENT_UNKNOWN,                       // unknown 
    EM_NET_REC_EVENT_ALARM,                         // Alarm
} EM_NET_REC_EVENT;

// enable/disable designated channel video input parameter, able to designate record type 
typedef struct tagNET_IN_REC_MNG_CTRL_MPT300
{
    DWORD                    dwSize;                 // the structure size
    int                      nChannel;               // channel number 
    EM_NET_REC_EVENT         emType;                 // record type, it is valid when nAction is 0 
    int                      nAction;                // 0:enable, 1:disable 
} NET_IN_REC_MNG_CTRL_MPT300;

// enable/disable designated channel record output parameter 
typedef struct tagNET_OUT_REC_MNG_CTRL_MPT300
{
    DWORD                    dwSize;                 // the structure size 
} NET_OUT_REC_MNG_CTRL_MPT300;

// realtime snapshot (manual snapshot) input parameter, corresponding command DH_CTRL_SNAP_MNG_SNAP_SHOT 
typedef struct tagNET_IN_SNAP_MNG_SHOT
{
    DWORD                    dwSize;                 // the structure size 
    int                      nChannel;               // channel number 
    int                      nTime;                  // continuous snapshot times, 0 means stopping snapshot, positive number means the number of continuous snapshot 
} NET_IN_SNAP_MNG_SHOT;

// realtime snapshot (manual snapshot) output parameter, corresponding command DH_CTRL_SNAP_MNG_SNAP_SHOT 
typedef struct tagNET_OUT_SNAP_MNG_SHOT
{
    DWORD                    dwSize;                 // the structure size
} NET_OUT_SNAP_MNG_SHOT;

// and close database/resume database input parameter, corresponding command DH_CTRL_LOG_STOP and DH_CTRL_LOG_RESUME
typedef struct tagNET_IN_LOG_MNG_CTRL
{
    DWORD                    dwSize;                 // the structure size 
} NET_IN_LOG_MNG_CTRL;

// and close database/resume database output parameter, corresponding command DH_CTRL_LOG_STOP and DH_CTRL_LOG_RESUME
typedef struct tagNET_OUT_LOG_MNG_CTRL
{
    DWORD                    dwSize;                 // the structure size 
} NET_OUT_LOG_MNG_CTRL;

// direct unvarnished transmission input parameter 
typedef struct tagNET_IN_TRANSMIT_DIRECTLY
{
    DWORD                    dwSize;                  // the structure size 
    char                    *szInBuffer;              // data transmitted to device 
    DWORD                    dwInBufferSize;          // data size transmitted to device
    NET_TRANSMIT_EXT_INFO    stExtData;               // data expansion transmitted to device, binary data 
} NET_IN_TRANSMIT_DIRECTLY;

// direct unvarnished output parameter 
typedef struct tagNET_OUT_TRANSMIT_DIRECTLY
{
    DWORD                    dwSize;                  // the structure size 
    char                    *szOutBuffer;             // device returned data 
    DWORD                    dwOutBufferSize;         // device returned data buffering size 
    DWORD                    dwRetBufferSize;         // actual returned data size 
} NET_OUT_TRANSMIT_DIRECTLY;

//remove anti-submarine alarm 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClearRepeatEnter(LLONG lLoginID, const NET_IN_CLEAR_REPEAT_ENTER* pInParam, NET_OUT_CLEAR_REPEAT_ENTER* pOutParam, int nWaitTime = 1000);

//remove anti-submarine alarm 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOperatorName(LLONG lLoginID, const NET_IN_GET_OPERATOR_NAME* pInParam, NET_OUT_GET_OPERATOR_NAME* pOutParam, int nWaitTime = 1000);

// POS connection type
typedef enum tagEM_CONN_TYPE
{
    EM_CONN_TYPE_UNKNOWN,                            // unknown
    EM_CONN_TYPE_NET,                                // tcp/ip
    EM_CONN_TYPE_RS232,                              // RS232
    EM_CONN_TYPE_RS485,                              // RS485
} EM_CONN_TYPE;

// POS protocol type
typedef enum tagEM_CONN_PROT
{
    EM_CONN_PROT_UNKNOWN,                            // unknown
    EM_CONN_PROT_NONE,                               // custom
    EM_CONN_PROT_POS,                                // POS
} EM_CONN_PROT;

// POS status type
typedef enum tagEM_POS_STATUS
{
    EM_POS_STATUS_OTHER = -1,                        // other error
    EM_POS_STATUS_NO,                                // no error
    EM_POS_STATUS_PROT_FORMAT,                       // protocol format error
    EM_POS_STATUS_NET_ADDR_CONFLICT,                 // net address conflict
    EM_POS_STATUS_RS232_ADDR_CONFLICT,               // rs232 address conflict
    EM_POS_STATUS_RS485_ADDR_CONFLICT,               // rs485 address conflict
    EM_POS_STATUS_LINK_CHANNEL_CONFLICT,             // linked channel conflict
    EM_POS_STATUS_NOT_EXIST,                         // POS does not exist
    EM_POS_STATUS_NUM_LIMIT,                         // POS number is out of limit
    EM_POS_STATUS_NAME_CONFLICT,                     // POS name conflict
} EM_POS_STATUS;

// POS tcp/ip connection attribute
typedef struct tagNET_POS_NET_ATT
{
    char                     szSrcIp[DH_MAX_IPADDR_LEN_EX];              // POS ip addr
    int                      nSrcPort;                                   // POS port
    char                     szDstIp[DH_MAX_IPADDR_LEN_EX];              // NVR ip addr
    int                      nDstPort;                                   // NVR port
} NET_POS_NET_ATT;

// POS COM connection attribute, RS232, RS485
typedef struct tagNET_POS_COM_ATT
{
    int                      nCommChannel;                               // comm channel (sub index of CFG_CMD_COMM)
    int                      nAddress;                                   // RS485 address
    DH_COMM_PROP             stuAttr;                                    // RS485 attr
} NET_POS_COM_ATT;

// POS custom protocol
typedef struct tagNET_POS_CUSTOM_PROT
{
    char                     szStartStr[DH_COMMON_STRING_32];            // start string
    BOOL                     bAnyCharater;                               // whether use szStartStr as prefix, TRUE: use any string as prefix£¬FALSE: use szStartStr as prefix
    char                     szEndStr[DH_COMMON_STRING_32];              // end string
    char                     szLineDelimiter[DH_COMMON_STRING_32];       // line delimiter
    int                      nMoreLine;                                  // count of POS trade info lines
    char                     szIgnoreStr[DH_COMMON_STRING_32];           // string to ignore
    BOOL                     bCaseSensitive;                             // whether case sensitive
    BYTE                     reserved[1024];                             // reserved
} NET_POS_CUSTOM_PROT;

// POS info
typedef struct tagNET_POS_INFO
{
    BOOL                     bEnable;                // enable
    DWORD                    dwPosId;                // POS ID, invalid wheth adding POS
    char                     szName[64];             // POS name
    EM_CONN_TYPE             emConnType;             // connection type
    NET_POS_NET_ATT          stuNetAtt;              // net connection attr, valid if emConnType is EM_CONN_TYPE_NET
    NET_POS_COM_ATT          stuComAtt;              // comm attr, valid if emConnType is EM_CONN_TYPE_RS232 or EM_CONN_TYPE_RS485
    EM_CONN_PROT             emConnProt;             // connection protocol type
    NET_POS_CUSTOM_PROT      stuCustom;              // valid if emConnProt is EM_CONN_PROT_NONE
    int                      nTimeOut;               // time out for recv msg, unit: sec
    int                      nLinkChannel[32];       // linked channel
    int                      nLinkChannelNum;        // valid count in nLinkChannel
    int                      nPlayBackTime;          // POS msg assocated video playback time, unit: sec
    BYTE                     reserved[1024];         // reserved
} NET_POS_INFO;

// Ôö¼Ó/ÐÞ¸ÄÒ»¸öPosÉè±¸Èë²Î, ¶ÔÓ¦ÃüÁîDH_CTRL_POS_ADD/DH_CTRL_POS_MODIFY
typedef struct tagNET_IN_POS_ADD
{
    DWORD                    dwSize;                 // struct size
    NET_POS_INFO             stuPosInfo;             // POS info
} NET_IN_POS_ADD;

// Ôö¼Ó/ÐÞ¸ÄÒ»¸öPosÉè±¸³ö²Î, ¶ÔÓ¦ÃüÁîDH_CTRL_POS_ADD/DH_CTRL_POS_MODIFY
typedef struct tagNET_OUT_POS_ADD
{
    DWORD                    dwSize;                 // ¸Ã½á¹¹Ìå´óÐ¡
    DWORD                    dwPosId;                // PosµÄIDºÅ, Éè±¸ÖÐÎ¨Ò», DH_CTRL_POS_MODIFYÎÞÐ§
    EM_POS_STATUS            emStatus;               // ²Ù×÷×´Ì¬
} NET_OUT_POS_ADD;

// É¾³ýÒ»¸öPosÉè±¸Èë²Î, ¶ÔÓ¦ÃüÁîDH_CTRL_POS_REMOVE
typedef struct tagNET_IN_POS_REMOVE
{
    DWORD                    dwSize;                 // ¸Ã½á¹¹Ìå´óÐ¡
    DWORD                    dwPosId;                // PosµÄIDºÅ
} NET_IN_POS_REMOVE;

// É¾³ýÒ»¸öPosÉè±¸³ö²Î, ¶ÔÓ¦ÃüÁîDH_CTRL_POS_REMOVE
typedef struct tagNET_OUT_POS_REMOVE
{
    DWORD                    dwSize;                 // ¸Ã½á¹¹Ìå´óÐ¡
    EM_POS_STATUS            emStatus;               // ²Ù×÷×´Ì¬
} NET_OUT_POS_REMOVE;

// ÅúÁ¿É¾³ýPosÉè±¸Èë²Î, ¶ÔÓ¦ÃüÁîDH_CTRL_POS_REMOVE_MULTI
typedef struct tagNET_IN_POS_REMOVE_MULTI
{
    DWORD                    dwSize;                 // ¸Ã½á¹¹Ìå´óÐ¡
    DWORD                    dwPosId[16];            // PosµÄIDºÅ, -1±íÊ¾È«²¿
    int                      nPosNum;                // dwPosId¸öÊý
} NET_IN_POS_REMOVE_MULTI;

// ÅúÁ¿É¾³ýPosÉè±¸³ö²Î, ¶ÔÓ¦ÃüÁîDH_CTRL_POS_REMOVE_MULTI
typedef struct tagNET_OUT_POS_REMOVE_MULTI
{
    DWORD                    dwSize;                 // ¸Ã½á¹¹Ìå´óÐ¡
    EM_POS_STATUS            emStatus;               // ²Ù×÷×´Ì¬, Èç¹ûÊ§°Ü·µ»ØµÚÒ»¸öÉ¾³ýÊ§°ÜÊ±µÄ´íÎó×´Ì¬
    DWORD                    dwPosIdFailed[16];      // Ê§°ÜµÄPosµÄIDºÅ
    int                      nPosNum;                // dwPosIdFailed¸öÊý
} NET_OUT_POS_REMOVE_MULTI;

// »ñÈ¡È«²¿PosÉè±¸, ¶ÔÓ¦ÃüÁîDH_DEVSTATE_GET_ALL_POS
typedef struct tagNET_POS_ALL_INFO
{
    DWORD                    dwSize;                 // ¸Ã½á¹¹Ìå´óÐ¡
    NET_POS_INFO             stuPos[256];            // posÐÅÏ¢
    int                      nPosNum;                // pos¸öÊý
} NET_POS_ALL_INFO;

// ÊÂ¼þÀàÐÍ DH_ALARM_POS_MANAGE (POS¹ÜÀíÊÂ¼þÊÂ¼þ)¶ÔÓ¦µÄÊý¾ÝÃèÊöÐÅÏ¢
typedef struct tagALARM_POS_MANAGE_INFO
{
    int                      nEventAction;                   // ÊÂ¼þ¶¯×÷, 0:Pulse, 1:Start, 2:Stop
    int                      nType;                          // ²Ù×÷ÀàÐÍ, 0:add, 1:remove, 2:modify
    DWORD                    dwPosId;                        // PosµÄIDºÅ
    char                     szName[DH_COMMON_STRING_64];    // Pos×Ô¶¨ÒåÃû³Æ
    int                      nLinkChannel[32];               // Ã¿Ì¨POS½Ó¹ØÁªµÄÍ¨µÀ
    int                      nLinkChannelNum;                // nLinkChannelÓÐÐ§ÊýÁ¿
    EM_CONN_PROT             emConnProt;                     // Á¬½ÓÐ­Òé
    BYTE                     reserved[1024];                 // Ô¤Áô
} ALARM_POS_MANAGE_INFO;

// info of event type DH_ALARM_LOCK_BREAK (lock break event)
typedef struct tagALARM_LOCK_BREAK_INFO
{
    int                      nDoor;                          // door channel, start from 0
    int                      nAction;                        // 0:start, 1:stop
    NET_TIME_EX              UTC;                            // event time
    BYTE                     reserved[1024];                 // revered
}ALARM_LOCK_BREAK_INFO;

// POS trade info
typedef struct tagNET_POS_TRADE_INFO
{
    DWORD                    dwPosId;                        // POS ID
    NET_TIME                 stuTime;                        // trading time
    BYTE                    *pbyComment;                     // trading content
    DWORD                    dwCommentLen;                   // pbyComment length
    BYTE                     reserved[1024];                 // revered
} NET_POS_TRADE_INFO;

// POS trade info callback prototype
typedef void (CALLBACK *fPosTradeCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_POS_TRADE_INFO *pInfo, int nBufLen, LDWORD dwUser);

// input param of attaching POS trade info
typedef struct tagNET_IN_POS_TRADE_ATTACH 
{
    DWORD                       dwSize;                 // struct size
    fPosTradeCallBack           cbCallState;            // trade info callback
    LDWORD                      dwUser;                 // callback user's param
} NET_IN_POS_TRADE_ATTACH;

// output param of attaching POS trade info
typedef struct tagNET_OUT_POS_TRADE_ATTACH 
{
    DWORD                       dwSize;                 // struct size
} NET_OUT_POS_TRADE_ATTACH;

// input param of CLIENT_GetDevCaps according to NET_POS_CAPS 
typedef struct tagNET_IN_POS_GETCAPS
{
    DWORD               dwSize;
} NET_IN_POS_GETCAPS;

// output param of CLIENT_GetDevCaps according to NET_POS_CAPS 
typedef struct tagNET_OUT_POS_GETCAPS
{
    DWORD               dwSize;
    EM_CONN_TYPE        emConnType[10];                    // connection type
    int                 nConnTypeNum;                      // connection type count in emConnType
    EM_CONN_PROT        emConnProt[10];                    // connect protocol type
    int                 nConnProtNum;                      // connect protocol count in emConnProt
    int                 nMaxPos;                           // max POS count supported
} NET_OUT_POS_GETCAPS;

// attach POS trade info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPosTrade(LLONG lLoginID, const NET_IN_POS_TRADE_ATTACH* pInParam, NET_OUT_POS_TRADE_ATTACH* pOutParam, int nWaitTime);

// detach POS trade info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPosTrade(LLONG lAttachHandle);

// CLIENT_GetDevCaps ½Ó¿Ú NET_USER_MNG_CAPS ÃüÁîÈë²Î
typedef struct tagNET_IN_USER_MNG_GETCAPS
{
    DWORD               dwSize;
} NET_IN_USER_MNG_GETCAPS;

// CLIENT_GetDevCaps ½Ó¿Ú NET_USER_MNG_CAPS ÃüÁî³ö²Î
typedef struct tagNET_OUT_USER_MNG_GETCAPS
{
    DWORD               dwSize;
    BOOL                bAccountLimitation;                // ÕË»§ÏÞÖÆ£¬¿ÉÒÔ¾«È·¿ØÖÆÃ¿¸öÓÃ»§ÔÊÐíÍ¬Ê±½øÐÐµÄÇëÇó
    BOOL                bIndividualAccessFilter;           // ºÚ°×Ãûµ¥ÊÇ·ñÖ§³ÖÕë¶Ôµ¥¸öIPµÄ¹ýÂË
    DWORD               dwMaxPageSize;                     // ·ÖÒ³²éÑ¯Ê±µ¥´Î²éÑ¯µÄ×î´óÓÃ»§ÐÅÏ¢ÌõÊý
} NET_OUT_USER_MNG_GETCAPS;

// ÎÞÏßÒ£¿ØÆ÷¹¤×÷Ä£Ê½
typedef enum tagEM_WIRELESS_CTRL_WORK_MODE
{
    EM_WIRELESS_CTRL_WORK_MODE_UNKNOWN,                     // Î´Öª
    EM_WIRELESS_CTRL_WORK_MODE_NORMAL,                      // ÆÕÍ¨Ä£Ê½
    EM_WIRELESS_CTRL_WORK_MODE_POLLING,                     // Ñ²¼ìÄ£Ê½
} EM_WIRELESS_CTRL_WORK_MODE;

// ÊÂ¼þÀàÐÍ DH_ALARM_REMOTE_CTRL_STATUS (ÎÞÏßÒ£¿ØÆ÷×´Ì¬ÊÂ¼þ)¶ÔÓ¦µÄÊý¾ÝÃèÊöÐÅÏ¢
typedef struct tagALARM_REMOTE_CTRL_STATUS
{
    NET_TIME_EX              UTC;                            // ÊÂ¼þ·¢ÉúµÄÊ±¼ä
    DWORD                    dwID;                           // Ò£¿ØÆ÷ID
    char                     szName[32];                     // Ãû³Æ
    char                     szUser[32];                     // ÓÃ»§Ãû£¬Ö¸ÎÞÏßÉè±¸¹ØÁªµ½±¨¾¯Ö÷»úµÄÄ³¸öÓÃ»§Ãû£¬²Ù×÷È¨ÏÞ¸úËæÕâ¸öÓÃ»§
    EM_WIRELESS_CTRL_WORK_MODE emMode;                       // ¹¤×÷Ä£Ê½
    BYTE                     reserved[1024];                 // Ô¤Áô
} ALARM_REMOTE_CTRL_STATUS;

typedef enum tagEM_PASSENGER_CARD_CHECK_TYPE
{
    EM_PASSENGER_CARD_CHECK_TYPE_UNKOWN = 0,                // Unkown
    EM_PASSENGER_CARD_CHECK_TYPE_SIGNIN,                    // Signin
    EM_PASSENGER_CARD_CHECK_TYPE_SIGNOUT,                   // Signout
    EM_PASSENGER_CARD_CHECK_TYPE_NORMAL,                    // Normal
}EM_PASSENGER_CARD_CHECK_TYPE;

// The description information of event type DH_ALARM_PASSENGER_CARD_CHECK corresponding data block
typedef struct tagALARM_PASSENGER_CARD_CHECK
{
    BOOL                     bEventConfirm;                  // Need confirm or not
    char                     szCardNum[DH_MAX_BUSCARD_NUM];  // Buscard number
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS information
    NET_TIME_EX              UTC;                            // Time of card check
    int                      nTime;                          // UTC time. unit:second 
    EM_PASSENGER_CARD_CHECK_TYPE    emType;                  // Type of card check
    char                     szMac[DH_MAX_POS_MAC_NUM];      // POS Mac code(default "0000")
    BYTE                     reserved[1012];                 // reserved
} ALARM_PASSENGER_CARD_CHECK;

// The description information of event type DH_ALARM_BUS_TIRED_DRIVE_CHECK corresponding data block
typedef struct tagALARM_TIRED_DRIVE_CHECK_INFO
{
    BOOL                     bEventConfirm;                  // Need confirm or not
    int                      nAction;                        // 0:Start, 1:Stop
    int                      nDriveTime;                     // Drive time     unit:minutes
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS information
    NET_TIME_EX              UTC;                            // Time of the event happens
    int                      nTime;                          // Time of the event happens  UTC time. unit:second
    BYTE                     reserved[1024];                 // reserved
} ALARM_TIRED_DRIVE_CHECK_INFO;


// ÊÂ¼þÀàÐÍ DH_ALARM_SOUND (ÉùÒôÊÂ¼þ)¶ÔÓ¦µÄÊý¾ÝÃèÊöÐÅÏ¢
typedef struct tagALARM_SOUND
{
    int                      nChannel;                       // Í¨µÀºÅ
    NET_TIME_EX              UTC;                            // Ë¢¿¨Ê±¼ä
    BYTE                     reserved[1024];                 // Ô¤Áô
} ALARM_SOUND;

// ´¥·¢ÓÐÉù±¨¾¯Èë²Î, ¶ÔÓ¦ÃüÁî DH_CTRL_SET_SOUND_ALARM
typedef struct tagNET_IN_SOUND_ALARM
{
    DWORD                    dwSize;                 // ¸Ã½á¹¹Ìå´óÐ¡
} NET_IN_SOUND_ALARM;

// ´¥·¢ÓÐÉù±¨¾¯³ö²Î, ¶ÔÓ¦ÃüÁî DH_CTRL_SET_SOUND_ALARM
typedef struct tagNET_OUT_SOUND_ALARM
{
    DWORD                    dwSize;                 // ¸Ã½á¹¹Ìå´óÐ¡
} NET_OUT_SOUND_ALARM;

// the output channesl which should to be silenced
typedef struct tagNET_SILENCE_CHANNEL
{
	int				nMatrix;			//the index of matrix
	int				nOutChannel;		// the counts of  output channels which should to be  silenced
	int				nOutPutChannel[DH_MAX_AUDIO_MATRIX_OUTPUT];	// the output channels which should to be  silenced
	BYTE			bReserved[512];	
}NET_SILENCE_CHANNEL;

//Audio matrix silence input parameter
typedef struct tagNET_IN_AUDIO_MATRIX_SILENCE
{
	DWORD					dwSize;				// the data is sizeof(NET_IN_AUDIO_MATRIX_SILENCE)
	BOOL					bEnable;			// enbale(true:close voice     false:open voice)
	int						nListCount;			// the counts of  output channels lists which should to be  silenced
	NET_SILENCE_CHANNEL*	pstSlienceChannel;	// the output channels lists which should to be silenced
} NET_IN_AUDIO_MATRIX_SILENCE;





//Audio matrix silence output parameter
typedef struct tagNET_OUT_AUDIO_MATRIX_SILENCE
{
	DWORD					dwSize;		//the data is sizeof(NET_OUT_AUDIO_MATRIX_SILENCE)
} NET_OUT_AUDIO_MATRIX_SILENCE;

// target type
typedef enum tagEM_TARGET_TYPE
{
    EM_TARGET_TYPE_CLIENT,              // "client"
    EM_TARGET_TYPE_FTP_SERVER,          // "FTPServer"
}EM_TARGET_TYPE;

// fliter info
typedef struct tagNET_MANUAL_UPLOAD_FILTER_INFO
{
    EM_TARGET_TYPE           emTargetType;                      //target type, "Client" , "FTPServer"
    char                     szClientIP[DH_MAX_IPADDR_LEN];     //client IP address
    NET_TIME                 stuStartTime;                      //snap picture start time
    NET_TIME                 stuEndTime;                        //snap picture end time
}NET_MANUAL_UPLOAD_FILTER_INFO;

// event type DH_CTRL_MANUAL_UPLOAD_PICTURE, description of input parameter
typedef struct tagNET_IN_MANUAL_UPLOAD_PICTURE
{
    DWORD                                 dwSize;             // structure size
    NET_MANUAL_UPLOAD_FILTER_INFO         stuFilter;          // manual upload filter       
}NET_IN_MANUAL_UPLOAD_PICTURE;

// event type DH_CTRL_MANUAL_UPLOAD_PICTURE, description of output parameter
typedef struct tagNET_OUT_MANUAL_UPLOAD_PICTURE
{
    DWORD					dwSize;		                    // structure size
}NET_OUT_MANUAL_UPLOAD_PICTURE;

// description of reboot network decoding device input parameter, corresponding command DH_CTRL_REBOOT_NET_DECODING_DEV
typedef struct tagNET_IN_REBOOT_NET_DECODING_DEV
{
    DWORD               dwSize;                                 // structure size, need to be assigned sizeof(NET_IN_REBOOT_NET_DECODING_DEV)
    char				szDeviceID[DH_COMMON_STRING_64];	    // device ID
    int                 nRebootDelayTime;                       // reboot delay time, unit: second
}NET_IN_REBOOT_NET_DECODING_DEV;

//  description of input parameter,corresponding command NET_DEFENCE_MODESET
typedef struct tagNET_IN_SET_DEFENCEMODE
{
    DWORD                   dwSize;
    char                    szPassword[DH_COMMON_STRING_64];           // login password
    int                     nChannel;                                  // channel id
    EM_DEFENCEMODE          emDefenceMode;                             // work status
}NET_IN_SET_DEFENCEMODE;

// description of output parameter,corresponding command NET_DEFENCE_MODESET
typedef struct tagNET_OUT_SET_DEFENCEMODE 
{
    DWORD                   dwSize;
}NET_OUT_SET_DEFENCEMODE;

// description of input parameter,corresponding command NET_SUBSYSTEM_MODESET
typedef struct tagNET_IN_SET_SUBSYSTEMMODE 
{
    DWORD                   dwSize;
    int                     nChannel;                                  // subsystem id
    char                    szPassword[DH_COMMON_STRING_64];           // login password
    EM_DEFENCEMODE          emDefenceMode;                             // work status
}NET_IN_SET_SUBSYSTEMMODE;

// description of output parameter,corresponding command NET_SUBSYSTEM_MODESET
typedef struct tagNET_OUT_SET_SUBSYSTEMMODE
{
    DWORD               dwSize;
    DWORD               dwSourceNum;                        // alarm source input arming failed subsystem number 
    int                 nSource[ARM_DISARM_ZONE_MAX];       // alarm source input failed subsystem no.,subsystem no. start from 0
    DWORD               dwLinkNum;                          // link alarm arming failed subsystem number 
    int                 nLink[ARM_DISARM_ZONE_MAX];         // link alarm failed subsystem no., subsystem no. start from 0
}NET_OUT_SET_SUBSYSTEMMODE;

// description of input parameter,corresponding command NET_DEFENCE_MODEGET
typedef struct tagNET_IN_GET_DEFENCEMODE
{
    DWORD                    dwSize;
    int                      nDefenceNum;                            // Zone valid number
    int                      anDefence[DH_MAX_ALARMIN];              // Zone number to search
}NET_IN_GET_DEFENCEMODE;

// description of output parameter,corresponding command NET_DEFENCE_MODEGET
typedef struct tagNET_OUT_GET_DEFENCEMODE
{
    DWORD                    dwSize;
    int                      nDefenceNum;                            // Zone valid number
    EM_DEFENCEMODE           anDefenceState[DH_MAX_ALARMIN];         // Zone status info
}NET_OUT_GET_DEFENCEMODE;

// description of input parameter,corresponding command NET_SUBSYSTEM_MODEGET
typedef struct tagNET_IN_GET_SUBSYSTEMMODE
{
    DWORD                    dwSize;
}NET_IN_GET_SUBSYSTEMMODE;

// description of output parameter,corresponding command  NET_SUBSYSTEM_MODEGET
typedef struct tagNET_OUT_GET_SUBSYSTEMMODE
{
    DWORD                    dwSize;
    int                      nSubSystemNum;                            //subsystem valid number
    EM_SUBSYSTEMMODE         anSubSystemState[DH_MAX_ALARM_SUBSYSTEM_NUM];         // ???????
}NET_OUT_GET_SUBSYSTEMMODE;


// description of reboot network decoding device ouput parameter, corresponding command DH_CTRL_REBOOT_NET_DECODING_DEV
typedef struct tagNET_OUT_REBOOT_NET_DECODING_DEV
{
    DWORD					dwSize;		                    // structure size, need to be assigned sizeof(NET_OUT_REBOOT_NET_DECODING_DEV)
}NET_OUT_REBOOT_NET_DECODING_DEV;

// event type DH_ALARM_DRIVE_AFTER_WORK (not work time event) data description
// ParkingControl set IC Sender input parameter, corresponding command DH_CTRL_SET_IC_SENDER
typedef struct tagNET_IN_SET_IC_SENDER
{
	DWORD					dwSize;				// the data is sizeof(NET_IN_SET_IC_SENDER)
	BOOL					bEnable;			// enbale(true: send IC card is allowed, false: forbidden)
}NET_IN_SET_IC_SENDER;
// ParkingControl set IC Sender input parameter, corresponding command DH_CTRL_SET_IC_SENDER
typedef struct tagNET_OUT_SET_IC_SENDER
{
	DWORD					dwSize;				// the data is sizeof(NET_OUT_SET_IC_SENDER)
}NET_OUT_SET_IC_SENDER;
typedef struct tagALARM_DVRIVE_AFTER_WORK
{
    BOOL                     bEventConfirm;                  // need confirm or not
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS
    NET_TIME_EX              stuUtc;                         // check time
    DWORD                    dwUtc;                          // check time, value equal to stuUtc£¬format different£¬used to confirm
    BYTE                     reserved[1024];                 // reserved
} ALARM_DVRIVE_AFTER_WORK;

// event type DH_ALARM_UPLOAD_PIC_FAILED (break rules data upload failed) data description
typedef struct tagALARM_UPLOAD_PIC_FAILED_INFO
{
    int                      nAction;                        // 0:upload failed, 1:upload success after failed
    BYTE                     reserved[1024];                 // reserved
} ALARM_UPLOAD_PIC_FAILED_INFO;

// get city and road code info, CLIENT_QueryDevState, DH_DEVSTATE_GET_ROAD_LIST
typedef struct tagNET_ROAD_LIST_INFO
{
    DWORD                    dwSize;                 // structure size
    char                     szCity[32];             // city
    char                     szRoadList[2048][256];  // road code
    int                      nRoadNum;               // number of road code, first dimension of szRoadList
} NET_ROAD_LIST_INFO;

// ÎÞÏßÉè±¸ÀàÐÍ
typedef enum tagEM_WIRELESS_DEV_TYPE
{
    EM_WIRELESS_DEV_TYPE_UNKNOWN,                            // Î´Öª
    EM_WIRELESS_DEV_TYPE_STATION,                            // "Station":Õ¾µã
    EM_WIRELESS_DEV_TYPE_AP,                                 // "AccessPoint":ÎÞÏß½ÓÈëµã
} EM_WIRELESS_DEV_TYPE;

// ÎÞÏßÉè±¸ÈÏÖ¤·½Ê½
typedef enum tagEM_WIRELESS_AUTHENTICATION
{
    EM_WIRELESS_AUTHENTICATION_UNKNOWN,                             // UnKnown
    EM_WIRELESS_AUTHENTICATION_OPEN,                                // OPEN
    EM_WIRELESS_AUTHENTICATION_SHARED,                              // SHARED
    EM_WIRELESS_AUTHENTICATION_WPA,                                 // WPA
    EM_WIRELESS_AUTHENTICATION_WPAPSK,                              // WPA-PSK
    EM_WIRELESS_AUTHENTICATION_WPA2,                                // WPA2
    EM_WIRELESS_AUTHENTICATION_WPA2PSK,                             // WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPANONE,                             // WPA-NONE
    EM_WIRELESS_AUTHENTICATION_WPAPSK_WPA2PSK,                      // WPA-PSK|WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPA_WPA2,                            // WPA|WPA2
    EM_WIRELESS_AUTHENTICATION_WPA_WPAPSK,                          // WPA | WPA-PSK
    EM_WIRELESS_AUTHENTICATION_WPA2_WPA2PSK,                        // WPA2|WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPA_WPAPSK_WPA2_WPA2PSK,             // WPA|WPA-PSK|WPA2|WPA2-PSK
} EM_WIRELESS_AUTHENTICATION;

// ÎÞÏßÊý¾Ý¼ÓÃÜ·½Ê½·½Ê½
typedef enum tagEM_WIRELESS_DATA_ENCRYPT
{
    EM_WIRELESS_DATA_ENCRYPT_UNKNOWN,                            // UnKnown
    EM_WIRELESS_DATA_ENCRYPT_NONE,                               // NONE
    EM_WIRELESS_DATA_ENCRYPT_WEP,                                // WEP
    EM_WIRELESS_DATA_ENCRYPT_TKIP,                               // TKIP
    EM_WIRELESS_DATA_ENCRYPT_AES,                                // AES(CCMP)
    EM_WIRELESS_DATA_ENCRYPT_TKIP_AES,                           // TKIP+AES
} EM_WIRELESS_DATA_ENCRYPT;

// wifi device info
typedef struct tagNET_WIFI_DEV_INFO
{
    char                     szMac[DH_MACADDR_LEN];          // mac address of wifi device
    int                      nLinkQuality;                   // link quality, 0~100
    NET_TIME_EX              stuEnerTime;                    // first searched time
    NET_TIME_EX              stuLeaveTime;                   // leave time
    int                      nSearchedCount;                 // searched count
    char                     szSSID[24];                     // SSID
    NET_TIME_EX              UTC;                            // event time
    EM_WIRELESS_DEV_TYPE     emDevType;                      // WIFI dev type
    int                      nChannel;                       // Wifi channel
    EM_WIRELESS_AUTHENTICATION emAuth;                       // authentication
    EM_WIRELESS_DATA_ENCRYPT emEncrypt;                      // data encrypt
    char                     szAPMac[DH_MACADDR_LEN];        // AP Mac
    int                      nAPChannel;                     // AP channel
    char                     szAPSSID[24];                   // AP SSID
    EM_WIRELESS_DATA_ENCRYPT emAPEncrypt;                    // AP data encrypt
    BYTE                     reserved[424];                  // reserved
} NET_WIFI_DEV_INFO;

// event type DH_ALARM_WIFI_SEARCH (search WIFI device) data description
typedef struct tagALARM_WIFI_SEARCH_INFO
{
    int                      nWifiNum;                       // WIFI number, indicate valid object in stuWifi
    NET_WIFI_DEV_INFO        stuWifi[1024];                  // wifi device info
    BYTE                     reserved[1024];                 // reserved
} ALARM_WIFI_SEARCH_INFO;

//wirelesstype
typedef enum tagNET_WIRELESSDEV_LOWPOWER_TYPE
{
    NET_WIRELESSDEV_UNKNOWN = 0,                                // unknowndevice
    NET_WIRELESSDEV_CONTROL = 1,                                // wirelesscontrol
    NET_WIRELESSDEV_DEFENCE = 2,                                // wirelessdefence
    NET_WIRELESSDEV_KEYBOARD = 3,                               // wirelessKeyBoard
    NET_WIRELESSDEV_MAGNETOMER = 4,                             // wirelessMagnetomer
} NET_WIRELESSDEV_LOWPOWER_TYPE;

//report event of lowpower wireless
typedef struct tagALARM_WIRELESSDEV_LOWPOWER_INFO
{
    NET_THREE_STATUS_BOOL         emResult;                   // lowpower event:true lowpower,false narmal£¬unknown Unknown
    NET_TIME                      stuTime;                   // event time
    int                           nId;                       // wirelessdevice ID
    NET_WIRELESSDEV_LOWPOWER_TYPE emType;                    // wirelessdevice type
    BYTE                          reserved[1024];            // reserved
} ALARM_WIRELESSDEV_LOWPOWER_INFO;

// event type DH_ALARM_BUS_PAD_SHUTDOWN(PAD shut down event) data description
typedef struct tagALARM_BUS_PAD_SHUTDOWN_INFO
{
    int                nDelayTime;                      // delay time for shut down, unit: sec
    BOOL               bConfirm;                        // need confirme to shut down, TRUE: yes, FALSE: no
    NET_TIME_EX        stuUtcTime;                      // event time
    DWORD              dwUtc;                           // event time, for confirm
    BYTE               byReserved[512];                 // revervsed
} ALARM_BUS_PAD_SHUTDOWN_INFO;

// get heatmap infomation, input arguments
typedef struct tagNET_IN_QUERY_HEAT_MAP
{
    int                      nChannel;                       // channel id
    NET_TIME_EX              stuBegin;                       // begin time
    NET_TIME_EX              stuEnd;                         // end time
    BYTE                     reserved[1024];                 // reserved
} NET_IN_QUERY_HEAT_MAP;

// get heatmap information, output arguments
typedef struct tagNET_OUT_QUERY_HEAT_MAP
{
    int                      nWidth;                         // picture width
    int                      nHeight;                        // picture height
    char *                   pBufData;                       // heatmap picture data, user alloc this memory
    int                      nBufLen;                        // pBufData max len
    int                      nBufRet;                        // data len
    int                      nAverage;                       // average info
    BYTE                     reserved[1020];                 // reserved
} NET_OUT_QUERY_HEAT_MAP;

// get heatmap information, type DH_DEVSTATE_GET_HEAT_MAP
typedef struct tagNET_QUERY_HEAT_MAP
{
    DWORD                    dwSize;                         // size of this structure
    NET_IN_QUERY_HEAT_MAP    stuIn;                          // heatmap search condition
    NET_OUT_QUERY_HEAT_MAP   stuOut;                         // heatmap search result
} NET_QUERY_HEAT_MAP;

//DoorWork mode
typedef enum tagNET_DOORWORK_MODE
{
    NET_DOORWORK_MODE_UNKNOWN = 0,                                // ??
    NET_DOORWORK_MODE_NORMAL = 1,                                 // ????
    NET_DOORWORK_MODE_SHUTLOCK = 2,                               // ??
    NET_DOORWORK_MODE_UNUSED = 3,                                 // ??
    NET_DOORWORK_MODE_OPENDOORCONTINUE = 4,                       // ????
} NET_DOORWORK_MODE;

// Get DoorWork mode£¬type DH_DEVSTATE_GET_ACCESSCONTROLMODE
typedef struct tagNET_GET_DOORWORK_MODE
{
    DWORD                    dwSize;
    int                      nChannel;              // ChannelID
    NET_DOORWORK_MODE   emControlMode;              // DoorWork mode      
}NET_GET_DOORWORK_MODE;

// VTÊÂ¼þÀàÐÍ
typedef enum tagEM_AUDIO_CB_FLAG
{
    EM_AUDIO_CB_FLAG_UNKNOWN,
    EM_AUDIO_CB_FLAG_NEWCALL,                   // ÓÐºô½Ð½øÀ´
    EM_AUDIO_CB_FLAG_REMOTE_HANGUP,             // ¶Ô·½¹Ò¶Ï
    EM_AUDIO_CB_FLAG_DISCONNECT,                // ¶ÏÏß
    EM_AUDIO_CB_FLAG_RING,                      // ¶Ô¶ËÏìÁå
} EM_AUDIO_CB_FLAG;

// VT»Øµ÷º¯Êý
typedef int (CALLBACK *pfVtEventCallBack)(LLONG instId, LLONG ulRegisterId, LLONG ulSessionId, int nEvent, char *pDataBuf, DWORD dwBufSize, LDWORD dwUser);

// ºô½ÐÊÂ¼þ´¦Àí¶¯×÷EM_AUDIO_CB_FLAG_NEWCALL
typedef enum tagEM_NEWCALL_ACTION
{
    EM_NEWCALL_ACTION_UNKNOWN,                  // ÎÞ²Ù×÷
    EM_NEWCALL_ACTION_REFUSE,                   // ¾Ü½Ó
    EM_NEWCALL_ACTION_ACCEPT,                   // ½ÓÈë
} EM_NEWCALL_ACTION;

typedef enum tagEM_VT_PARAM_VALID
{
    EM_VT_PARAM_VALID_EVENT_CB     = 0x0001,
    EM_VT_PARAM_VALID_USER_DATA    = 0x0002,
    EM_VT_PARAM_VALID_MID_NUM      = 0x0004,
    EM_VT_PARAM_VALID_ACTION       = 0x0008,
    EM_VT_PARAM_VALID_WAITTIME     = 0x0010,
    EM_VT_PARAM_VALID_VIDEOWND     = 0x0020,
    EM_VT_PARAM_VALID_CSMODE       = 0x0040,
    EM_VT_PARAM_VALID_AUDIO_ENCODE = 0x0080,
    EM_VT_PARAM_VALID_LOCAL_IP     = 0x0100,
} EM_VT_PARAM_VALID;

// VT¶Ô½²²ÎÊý
typedef struct tagNET_VT_TALK_PARAM
{
    DWORD               dwSize;                  // ½á¹¹Ìå´óÐ¡
    int                 nValidFlag;              // °´Î»±êÊ¶ºóÃæµÄ×Ö¶ÎÊÇ·ñÓÐÐ§, EM_VT_PARAM_VALIDµÄ×éºÏ
    pfVtEventCallBack   pfEventCb;               // ÊÂ¼þ»Øµ÷º¯Êý, EM_VT_PARAM_VALID_EVENT_CB
    LDWORD              dwUser;                  // ÊÂ¼þ»Øµ÷º¯Êý×Ô¶¨ÒåÊý¾Ý, EM_VT_PARAM_VALID_USER_DATA
    char                szPeerMidNum[16];        // ±»½ÐÖÐºÅ, 8Î», EM_VT_PARAM_VALID_MID_NUM
    EM_NEWCALL_ACTION   emAction;                // ¶Ôºô½ÐµÄ²Ù×÷, 0:ÎÞ²Ù×÷, 1:¾Ü½Ó, 2:½ÓÈë, EM_VT_PARAM_VALID_ACTION
    int                 nWaitTime;               // ³¬Ê±Ê±¼ä, µ¥Î»ms, EM_VT_PARAM_VALID_WAITTIME
    HWND                hVideoWnd;               // ¿ÉÊÓ¶Ô½²ÊÓÆµÏÔÊ¾´°¿Ú, EM_VT_PARAM_VALID_VIDEOWND
    BOOL                bClient;                 // ¿Í»§¶Ë/·þÎñÆ÷Ä£Ê½, TRUE:¿Í»§¶Ë, FALSE:·þÎñÆ÷, EM_VT_PARAM_VALID_CSMODE
    DHDEV_TALKDECODE_INFO stAudioEncode;         // ÓïÒô±àÂëÐÅÏ¢, EM_VT_PARAM_VALID_AUDIO_ENCODE
} NET_VT_TALK_PARAM;

// VTCµÇÂ¼VTO
CLIENT_NET_API LLONG CALL_METHOD CLIENT_VT_RegisterVto(const char *pszIp, int nPort = 13801);

// VTCµÇ³öVTO
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VT_UnRegisterVto(LLONG ulLongId);

/////////////////////////////////// UAV interfaces ///////////////////////////////////////

// UAV fly info
typedef struct tagNET_UAV_FLY_INFO 
{
    float               fAltitude;                          // Altitude, with respect to horizon, Unit: meter
    float               fDistance;                          // Distance, with respect to remote controller, Unit: meter
    float               fHorizontalSpeed;                   // Horizontal Speed, Unit: m/s
    float               fVerticalSpeed;                     // Vertical Speed, Unit: m/s
    int                 nRCLinkQuality;                     // remote controller link quality, range£º0~100
    char                reserved[512];
} NET_UAV_FLY_INFO;

// callback for UAV info, lAttachHandle is the return value of CLIENT_AttachUavFly
typedef void (CALLBACK *fUavFlyCallBack) (LLONG lAttachHandle, NET_UAV_FLY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachUavFly input
typedef struct tagNET_IN_ATTACH_UAV_FLY 
{
    DWORD               dwSize;
    fUavFlyCallBack     cbUavFly;                           // fly info callback
    DWORD               dwUser;                             // user data                   
} NET_IN_ATTACH_UAV_FLY;

// CLIENT_AttachUavFly output
typedef struct tagNET_OUT_ATTACH_UAV_FLY 
{
    DWORD                dwSize;
} NET_OUT_ATTACH_UAV_FLY;

// subscribe UAV fly info
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachUavFly(LLONG lLoginID, const NET_IN_ATTACH_UAV_FLY* pInParam, NET_OUT_ATTACH_UAV_FLY* pOutParam, int nWaitTime);

// unsubscribe UAV fly info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachUavFly(LLONG lAttachHandle);

////////////////////////////////////////////////////////////////////////////////

// Get device self check info
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSelfCheckInfo(LLONG lLoginID, const NET_IN_GET_SELTCHECK_INFO* pInParam, NET_SELFCHECK_INFO* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

/////////////////////////////////Laser and EIS interface/////////////////////////////////

// open or close laser input
typedef struct tagLASER_IN_INFO
{
	DWORD		dwSize;				
	UINT		nChannelID;			// channel ID
} LASER_IN_INFO;

// open or close laser output
typedef struct tagLaser_OUT_INFO 
{
	DWORD		dwSize;			
} LASER_OUT_INFO;

// open or close EIS input
typedef struct tagEIS_IN_INFO 
{
	DWORD		dwSize;				
	UINT		nChannelID;			// channel ID
} EIS_IN_INFO;

// open or close EIS output
typedef struct tagEIS_OUT_INFO 
{
	DWORD		dwSize;			
} EIS_OUT_INFO;


// open laser interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartLaser(LLONG lLoginID,const LASER_IN_INFO* pLaserDataIn, LASER_OUT_INFO* pLaserDataOut,int nWaitTime = 1000);

// close laser interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLaser(LLONG lLoginID,const LASER_IN_INFO* pLaserDataIn, LASER_OUT_INFO* pLaserDataOut,int nWaitTime = 1000);

// open EIS interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartEIS(LLONG lLoginID,const EIS_IN_INFO* pEISDataIn, EIS_OUT_INFO* pEISDataOut,int nWaitTime = 1000);

// close EIS interface
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopEIS(LLONG lLoginID,const EIS_IN_INFO* pEISDataIn, EIS_OUT_INFO* pEISDataOut,int nWaitTime = 1000);


///////////////////////////////////deprecated///////////////////////////////////

// Search system server setup. This interface is invalid now please use  CLIENT_GetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryConfig(LLONG lLoginID, int nConfigType, char *pConfigbuf, int maxlen, int *nConfigbuflen, int waittime=1000);

// Set system server setup. This interface is invalid now please use  CLIENT_SetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupConfig(LLONG lLoginID, int nConfigType, char *pConfigbuf, int nConfigbuflen, int waittime=1000);

// This interface is invalid now. 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Reset(LLONG lLoginID, BOOL bReset);

// Search COM protocol. This interface is invalid now please use  CLIENT_GetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryComProtocol(LLONG lLoginID, int nProtocolType, char *pProtocolBuffer, int maxlen, int *nProtocollen, int waittime=1000);

// Begin audio talk. This interface is invalid now. Please use  CLIENT_StartTalkEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartTalk(LLONG lRealHandle, BOOL bCustomSend=false);

// Stop audio talk. This interface is invalid now , please use  CLIENT_StopTalkEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTalk(LLONG lRealHandle);

// Send out self-defined audio talk data. This interface is invalid now, please use  CLIENT_TalkSendData
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendTalkData_Custom(LLONG lRealHandle, char *pBuffer, DWORD dwBufSize);

// Set real-time preview buffer size
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayerBufNumber(LLONG lRealHandle, DWORD dwBufNum);

// Download file by time
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFileByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, char *sSavedFileName);

// Network playback control 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayBackControl(LLONG lPlayHandle, DWORD dwControlCode, DWORD dwInValue, DWORD *lpOutValue);

// Search device working status .This interface is invalid now, please use  CLIENT_QueryDevState
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDEVWorkState(LLONG lLoginID, LPNET_DEV_WORKSTATE lpWorkState, int waittime=1000);

// Asynchronism search device log 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLogCallback(LLONG lLoginID, fLogDataCallBack cbLogData, LDWORD dwUser);

// open or close record for mpt300
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecMngCtrlMpt300(LLONG lLoginID, const NET_IN_REC_MNG_CTRL_MPT300 *pstRecIn, NET_OUT_REC_MNG_CTRL_MPT300 *pstRecOut, int nWaitTime);

// Transmit Info Directly
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TransmitInfoDirectly(LLONG lLoginID, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, int nWaittime = 1000);

// call back for Transmit Info Directly
typedef void (CALLBACK *fTransmitInfoDirectlyCallBack)(LLONG lLoginID, LLONG lStartHandle, const char *pszOutBuf, DWORD dwBufLen, LDWORD dwUser);

// start Transmit Info Directly
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTransmitInfoDirectly(LLONG lLoginID, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, fTransmitInfoDirectlyCallBack cbDirectly, LDWORD dwUser, int nWaitTime = 1000);

// stop Transmit Info Directly
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTransmitInfoDirectly(LLONG lStartHandle, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, int nWaitTime = 1000);

// Set Defence Arm Mode 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDefenceArmMode(LLONG lLoginID, NET_IN_SET_DEFENCEMODE* pInBuf, NET_OUT_SET_DEFENCEMODE* pOutBuf = NULL, int nWaitTime = 1000);

// Get Defence Arm Mode
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDefenceArmMode(LLONG lLoginID, NET_IN_GET_DEFENCEMODE* pInBuf, NET_OUT_GET_DEFENCEMODE* pOutBuf, int nWaitTime = 1000);

// Set SubSystem Arm Mode
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSubSystemArmMode(LLONG lLoginID, NET_IN_SET_SUBSYSTEMMODE* pInBuf, NET_OUT_SET_SUBSYSTEMMODE* pOutBuf = NULL, int nWaitTime = 1000);

// Get SubSystem Arm Mode
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSubSystemArmMode(LLONG lLoginID, NET_IN_GET_SUBSYSTEMMODE* pInBuf, NET_OUT_GET_SUBSYSTEMMODE* pOutBuf, int nWaitTime = 1000);

// batch insert access control cards
// nInsertCount: number of cards to insert, no more than 20
// pInsertCards: cards to insert, NET_RECORDSET_ACCESS_CTL_CARD buffer allocated and filled by user, amount to nInsertCount
// nRecNo: record number after inserted (-1 for failed), int buffer allocated by user, coresponding to pInsertCards one by one, amount to nInsertCount
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InsertAccessControlCards(LLONG lLoginID, int nInsertCount, const NET_RECORDSET_ACCESS_CTL_CARD* pInsertCards, int* pRecNo, void* reserved = NULL, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

#ifdef __cplusplus
}
#endif
#endif // DHNETSDK_H



